{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/robots.txt","path":"robots.txt","modified":1,"renderable":0},{"_id":"themes/matery/source/css/gitment.css","path":"css/gitment.css","modified":1,"renderable":1},{"_id":"themes/matery/source/css/my-gitalk.css","path":"css/my-gitalk.css","modified":1,"renderable":1},{"_id":"themes/matery/source/css/matery.css","path":"css/matery.css","modified":1,"renderable":1},{"_id":"themes/matery/source/css/my.css","path":"css/my.css","modified":1,"renderable":1},{"_id":"themes/matery/source/js/click_show_text.js","path":"js/click_show_text.js","modified":1,"renderable":1},{"_id":"themes/matery/source/js/matery.js","path":"js/matery.js","modified":1,"renderable":1},{"_id":"themes/matery/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/loading.svg","path":"medias/loading.svg","modified":1,"renderable":1},{"_id":"themes/matery/source/favicon.png","path":"favicon.png","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/animate/animate.min.css","path":"libs/animate/animate.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/aos/aos.css","path":"libs/aos/aos.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/aos/aos.js","path":"libs/aos/aos.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.css","path":"libs/aplayer/APlayer.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/clipboard.min.js","path":"libs/codeBlock/clipboard.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/codeBlockFuction.js","path":"libs/codeBlock/codeBlockFuction.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/codeCopy.js","path":"libs/codeBlock/codeCopy.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/codeShrink.js","path":"libs/codeBlock/codeShrink.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/codeLang.js","path":"libs/codeBlock/codeLang.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/cryptojs/crypto-js.min.js","path":"libs/cryptojs/crypto-js.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.css","path":"libs/dplayer/DPlayer.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/gitalk/gitalk.css","path":"libs/gitalk/gitalk.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/gitment/gitment-default.css","path":"libs/gitment/gitment-default.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","path":"libs/jqcloud/jqcloud-1.0.4.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/jqcloud/jqcloud.css","path":"libs/jqcloud/jqcloud.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/masonry/masonry.pkgd.min.js","path":"libs/masonry/masonry.pkgd.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/others/busuanzi.pure.mini.js","path":"libs/others/busuanzi.pure.mini.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/others/clicklove.js","path":"libs/others/clicklove.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/others/explosion.min.js","path":"libs/others/explosion.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/others/fireworks.js","path":"libs/others/fireworks.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/others/snow.js","path":"libs/others/snow.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/others/text.js","path":"libs/others/text.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/scrollprogress/scrollProgress.min.js","path":"libs/scrollprogress/scrollProgress.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/tocbot/tocbot.css","path":"libs/tocbot/tocbot.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/tocbot/tocbot.min.js","path":"libs/tocbot/tocbot.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/9.jpg","path":"medias/featureimages/9.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.js","path":"libs/aplayer/APlayer.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/gitment/gitment.js","path":"libs/gitment/gitment.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/jquery/jquery-2.2.0.min.js","path":"libs/jquery/jquery-2.2.0.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.js","path":"libs/dplayer/DPlayer.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/csdn.ico","path":"medias/avatars/csdn.ico","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/valine/Valine.min.js","path":"libs/valine/Valine.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/14.jpg","path":"medias/featureimages/14.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/15.jpg","path":"medias/featureimages/15.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/21.jpg","path":"medias/featureimages/21.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/27.jpg","path":"medias/featureimages/27.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/35.jpg","path":"medias/featureimages/35.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/36.jpg","path":"medias/featureimages/36.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/38.jpg","path":"medias/featureimages/38.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/37.jpg","path":"medias/featureimages/37.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/47.jpg","path":"medias/featureimages/47.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/css/lightgallery.min.css","path":"libs/lightGallery/css/lightgallery.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.eot","path":"libs/lightGallery/fonts/lg.eot","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.svg","path":"libs/lightGallery/fonts/lg.svg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.ttf","path":"libs/lightGallery/fonts/lg.ttf","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.woff","path":"libs/lightGallery/fonts/lg.woff","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/video-play.png","path":"libs/lightGallery/img/video-play.png","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/youtube-play.png","path":"libs/lightGallery/img/youtube-play.png","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/loading.gif","path":"libs/lightGallery/img/loading.gif","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/vimeo-play.png","path":"libs/lightGallery/img/vimeo-play.png","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/css/share.min.css","path":"libs/share/css/share.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.eot","path":"libs/share/fonts/iconfont.eot","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.svg","path":"libs/share/fonts/iconfont.svg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.ttf","path":"libs/share/fonts/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.woff","path":"libs/share/fonts/iconfont.woff","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/js/jquery.share.min.js","path":"libs/share/js/jquery.share.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/materialize/materialize.min.css","path":"libs/materialize/materialize.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/js/social-share.min.js","path":"libs/share/js/social-share.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/materialize/materialize.min.js","path":"libs/materialize/materialize.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/valine/av-min.js","path":"libs/valine/av-min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/10.jpg","path":"medias/featureimages/10.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/11.jpg","path":"medias/featureimages/11.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/16.jpg","path":"medias/featureimages/16.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/2.jpg","path":"medias/featureimages/2.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/20.jpg","path":"medias/featureimages/20.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/23.jpg","path":"medias/featureimages/23.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/24.jpg","path":"medias/featureimages/24.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/28.jpg","path":"medias/featureimages/28.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/29.jpg","path":"medias/featureimages/29.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/30.jpg","path":"medias/featureimages/30.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/31.jpg","path":"medias/featureimages/31.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/33.jpg","path":"medias/featureimages/33.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/39.jpg","path":"medias/featureimages/39.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/41.jpg","path":"medias/featureimages/41.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/43.jpg","path":"medias/featureimages/43.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/46.jpg","path":"medias/featureimages/46.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/music/avatars/不见就散-周深.jpg","path":"medias/music/avatars/不见就散-周深.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/music/avatars/平凡之路-朴树.jpg","path":"medias/music/avatars/平凡之路-朴树.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/8.jpg","path":"medias/featureimages/8.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/logo.png","path":"medias/logo.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/reward/wechat.jpg","path":"medias/reward/wechat.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/css/font-awesome.min.css","path":"libs/awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff","path":"libs/awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff2","path":"libs/awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/js/lightgallery-all.min.js","path":"libs/lightGallery/js/lightgallery-all.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/5.jpg","path":"medias/banner/5.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/0.jpg","path":"medias/featureimages/0.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/1.jpg","path":"medias/featureimages/1.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/18.jpg","path":"medias/featureimages/18.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/25.jpg","path":"medias/featureimages/25.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/3.jpg","path":"medias/featureimages/3.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/32.jpg","path":"medias/featureimages/32.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/34.jpg","path":"medias/featureimages/34.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/45.jpg","path":"medias/featureimages/45.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/6.jpg","path":"medias/featureimages/6.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/5.jpg","path":"medias/featureimages/5.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/7.jpg","path":"medias/featureimages/7.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/reward/alipay.jpg","path":"medias/reward/alipay.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/26.jpg","path":"medias/featureimages/26.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/4.jpg","path":"medias/featureimages/4.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/44.jpg","path":"medias/featureimages/44.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/48.jpg","path":"medias/featureimages/48.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/FontAwesome.otf","path":"libs/awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/1.jpg","path":"medias/banner/1.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/2.jpg","path":"medias/banner/2.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/6.jpg","path":"medias/banner/6.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/12.jpg","path":"medias/featureimages/12.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/13.jpg","path":"medias/featureimages/13.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/22.jpg","path":"medias/featureimages/22.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/40.jpg","path":"medias/featureimages/40.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/42.jpg","path":"medias/featureimages/42.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.eot","path":"libs/awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.ttf","path":"libs/awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/0.jpg","path":"medias/banner/0.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/myzhihu.png","path":"medias/avatars/myzhihu.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/4.jpg","path":"medias/banner/4.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/17.jpg","path":"medias/featureimages/17.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/music/avatars/每天爱你多一些.jpg","path":"medias/music/avatars/每天爱你多一些.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.svg","path":"libs/awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/gitalk/gitalk.min.js","path":"libs/gitalk/gitalk.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/echarts/echarts.min.js","path":"libs/echarts/echarts.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/49.jpg","path":"medias/featureimages/49.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/3.jpg","path":"medias/banner/3.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/music/每天爱你多一些-张学友.mp3","path":"medias/music/每天爱你多一些-张学友.mp3","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/music/不见就散-周深.mp3","path":"medias/music/不见就散-周深.mp3","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/music/平凡之路-朴树.mp3","path":"medias/music/平凡之路-朴树.mp3","modified":1,"renderable":1}],"Cache":[{"_id":"source/404.md","hash":"9e6f55d7c01343e1ffd36d55860587fd269d6cb6","modified":1680600250127},{"_id":"source/CNAME","hash":"4740c94df1240b26efd774d065f3ae8ef5c24b7c","modified":1680600250127},{"_id":"source/robots.txt","hash":"96afc2fc25d1e9121f5eae9eaef811cd1ac04208","modified":1680600250283},{"_id":"themes/matery/.gitignore","hash":"eaa3d84cb77d92a21b111fd1e37f53edc1ff9de0","modified":1680600250283},{"_id":"themes/matery/LICENSE","hash":"7df059597099bb7dcf25d2a9aedfaf4465f72d8d","modified":1680600250283},{"_id":"themes/matery/_config.yml","hash":"0f5f3711a37d386a7bedbb26d2488c0cc0dc85a2","modified":1680609937082},{"_id":"source/_data/musics.json","hash":"4f57cba90894eeb98f7036f25151f650b7bed983","modified":1683459352537},{"_id":"source/about/index.md","hash":"608f3e2b6521dc4572dac46918a78e5ec2c0080e","modified":1680600250283},{"_id":"source/archives/index.md","hash":"28ffe1788b7ec6b5e8096d3bdba6060afd5024b3","modified":1680600250283},{"_id":"source/categories/index.md","hash":"ea9413cff6268ec0cab02a3fd9628c90e9f9c08d","modified":1680600250283},{"_id":"source/contact/index.md","hash":"58bfae891c6b8ff355438057252e3db365773fae","modified":1680600250283},{"_id":"source/gallery/index.md","hash":"7c4ac1cca330c5c90058ab93eab50a5b8333faed","modified":1680600250283},{"_id":"source/tags/index.md","hash":"aed5e51001f4c51a4b3ffbd18c2320da8004901f","modified":1680600250283},{"_id":"themes/matery/languages/default.yml","hash":"b7ac861f0ae6ed431e5b6aac26c81813d290736a","modified":1680600250283},{"_id":"themes/matery/languages/zh-CN.yml","hash":"7d71e43508d65185914b6c12c965aa50f74216c9","modified":1680600250283},{"_id":"themes/matery/layout/404.ejs","hash":"40c4af57aef2b77611042782e9f3b395f217408f","modified":1680600250283},{"_id":"themes/matery/layout/about.ejs","hash":"8d3355f15ab3b4667243af81aa593d41f2f39557","modified":1680600250283},{"_id":"themes/matery/layout/archive.ejs","hash":"b09487edc56298e20e8d0c29b9b1131f3eb28fd2","modified":1680600250283},{"_id":"themes/matery/layout/categories.ejs","hash":"8e54665cc25d7c333da7d9f312987190be6215da","modified":1680600250283},{"_id":"themes/matery/layout/category.ejs","hash":"8fa32a94aa3ba36d788e8f8f5906074e391f1739","modified":1680600250283},{"_id":"themes/matery/layout/contact.ejs","hash":"7b0f365624f9fdc2fe242930c8de62535c00ae3f","modified":1680600250283},{"_id":"themes/matery/layout/gallery.ejs","hash":"783010507ecd34f354de0a8db17b872ed3ca32e6","modified":1680600250283},{"_id":"themes/matery/layout/index.ejs","hash":"b1a8a07b1da8ab939cf9d30d3b35a5bcaf22a6e1","modified":1680600250283},{"_id":"themes/matery/layout/layout.ejs","hash":"de38cd533d70e281aa4337b4c51f27f46246b612","modified":1680600250283},{"_id":"themes/matery/layout/post.ejs","hash":"23fcd2d9bcf4256260e830339f0b2976a145705e","modified":1680600250283},{"_id":"themes/matery/layout/tag.ejs","hash":"b4ec6952112384961061c923847f19c5afba8d7a","modified":1680600250283},{"_id":"themes/matery/layout/tags.ejs","hash":"cf9517aa6a0111355121f44615d6923e312283c7","modified":1680600250283},{"_id":"themes/matery/layout/_partial/back-top.ejs","hash":"8c91d2088c9bb323246b054d4940bde6cead6828","modified":1680600250283},{"_id":"themes/matery/layout/_partial/bg-cover-content.ejs","hash":"dbe4391fba348972b1882951b6f453af09273ee4","modified":1680600250283},{"_id":"themes/matery/layout/_partial/bg-cover.ejs","hash":"02191109712f61c0e487b8f0b8466597181a9004","modified":1680600250283},{"_id":"themes/matery/layout/_partial/disqus.ejs","hash":"a0f53d1a9b579d52e52ccad8c6e330bf3b89547e","modified":1680600250283},{"_id":"themes/matery/layout/_partial/footer.ejs","hash":"12872c3ba85e7117f5278b1aca5f0b6d32322004","modified":1680600250283},{"_id":"themes/matery/layout/_partial/gitalk.ejs","hash":"c07893e507971db87a3d3509cbd1c0440ab1b691","modified":1680600250283},{"_id":"themes/matery/layout/_partial/github-link.ejs","hash":"3aeb581bd78ab8e15b858e4c44c03bcf92f20b9e","modified":1680600250283},{"_id":"themes/matery/layout/_partial/gitment.ejs","hash":"0abfb51dc80ad063fb2118bee28de6bb8d99ed4e","modified":1680600250283},{"_id":"themes/matery/layout/_partial/google-analytics.ejs","hash":"5f4992205617da5f8cc5863c62b5ec46e414e2fb","modified":1680600250283},{"_id":"themes/matery/layout/_partial/head.ejs","hash":"8436ad05aefa9992d839a50020cd82826aa1cecc","modified":1680600250283},{"_id":"themes/matery/layout/_partial/header.ejs","hash":"e253c813b3ee5ed924700a95133741802e58adc5","modified":1680600250283},{"_id":"themes/matery/layout/_partial/index-cover.ejs","hash":"294e51ad32426fb84da8daaee7c2155071dbd6b1","modified":1680600250283},{"_id":"themes/matery/layout/_partial/livere.ejs","hash":"9c3401b42ea7f26410a5593bae93ada7e57b43be","modified":1680600250283},{"_id":"themes/matery/layout/_partial/mobile-nav.ejs","hash":"2ab4becf3da0204cbcacc5a0f3a35c8de9be8b48","modified":1680600250283},{"_id":"themes/matery/layout/_partial/navigation.ejs","hash":"afd67678d902c6e6364387b0cdfa3c2393ace92c","modified":1680600250283},{"_id":"themes/matery/layout/_partial/paging.ejs","hash":"68a24cad2b2049c4dc3a250aa30bf4256f9e50cb","modified":1680600250283},{"_id":"themes/matery/layout/_partial/post-cover.ejs","hash":"8f90dba37cb824a037fe86f6b60b73056673cee0","modified":1680600250283},{"_id":"themes/matery/layout/_partial/post-detail-toc.ejs","hash":"d4114c22126704cc1754d6d28cb00aec020b428b","modified":1680600250283},{"_id":"themes/matery/layout/_partial/post-detail.ejs","hash":"80991b987adc765fff991e0d352920cf9e009c19","modified":1680600250283},{"_id":"themes/matery/layout/_partial/post-statis.ejs","hash":"2b2fe8e8e94e65c52a4dbd454168e9b9df6baf10","modified":1680600250283},{"_id":"themes/matery/layout/_partial/prev-next.ejs","hash":"078cee6adc13ab4a88845d694454ac5dff77ee27","modified":1680600250283},{"_id":"themes/matery/layout/_partial/reprint-statement.ejs","hash":"3d61d4acde8d27a63072145130d2661df8c05df7","modified":1680600250283},{"_id":"themes/matery/layout/_partial/reward.ejs","hash":"3dff4f6a73973b0b32f40604244255f3c2a5bb78","modified":1680600250283},{"_id":"themes/matery/layout/_partial/search.ejs","hash":"942609b9240d5c8c09b24562fc8fb31eabe1cae4","modified":1680600250283},{"_id":"themes/matery/layout/_partial/share.ejs","hash":"34f8e4250bb66012026aa50686a7c89a0414ca1b","modified":1680600250283},{"_id":"themes/matery/layout/_partial/social-link.ejs","hash":"cd435a1e20a809d11f3bcbeb9bcd7f646ea84500","modified":1680600250283},{"_id":"themes/matery/layout/_partial/valine.ejs","hash":"e07fe01051488cd06d1c41622dd9268cd1e70d56","modified":1680600250283},{"_id":"themes/matery/layout/_widget/category-cloud.ejs","hash":"a5a10d6fa66a389d0253d7a52e0a646af6e8e9be","modified":1680600250283},{"_id":"themes/matery/layout/_widget/category-radar.ejs","hash":"f5561dd7d53d68897a33090bf677719213459b19","modified":1680600250283},{"_id":"themes/matery/layout/_widget/dream.ejs","hash":"96c43b244a9abf1f501ed61bad22cd315e2a863d","modified":1680600250283},{"_id":"themes/matery/layout/_widget/gallery-wordcloud.ejs","hash":"1d275459a54618f5d6b66ad5d1ca10babe19def1","modified":1680607235218},{"_id":"themes/matery/layout/_widget/music.ejs","hash":"8eafddbd73fed80e85c66d49837c1a241b087258","modified":1680600250283},{"_id":"themes/matery/layout/_widget/my-gallery.ejs","hash":"f81eb2891bea326908057029e2a063001371ba9b","modified":1680600250283},{"_id":"themes/matery/layout/_widget/my-projects.ejs","hash":"b9bf70ec5d97b0e14bb1b4f60f92db7680be5949","modified":1680600250283},{"_id":"themes/matery/layout/_widget/my-skills.ejs","hash":"bb8609e8739c7625e5ebfc1998acfac259386273","modified":1680600250283},{"_id":"themes/matery/layout/_widget/post-calendar.ejs","hash":"0b0a3eb6af29bf0d55d535958c44b01c0f18d10d","modified":1680600250283},{"_id":"themes/matery/layout/_widget/post-charts.ejs","hash":"af0604623db37ef800bb7ad48028d18d99efbbc3","modified":1680600250283},{"_id":"themes/matery/layout/_widget/recommend.ejs","hash":"72ee5ed55e68101a9c560788659674c48e15f568","modified":1680600250283},{"_id":"themes/matery/layout/_widget/tag-cloud.ejs","hash":"846065817dd5ec7dec636f276c9c34cca02df0ac","modified":1680600250283},{"_id":"themes/matery/layout/_widget/tag-wordcloud.ejs","hash":"3a991d7292e0cf98e0eb7d899d0aba5a3ad8cf03","modified":1680606634931},{"_id":"themes/matery/layout/_widget/video.ejs","hash":"bda810cc135b52f834f1c1ccf52defccacace714","modified":1680600250283},{"_id":"themes/matery/source/css/gitment.css","hash":"2bd15cc17dca35ac3ecc0acf167a23a1dd362acd","modified":1680600250283},{"_id":"themes/matery/source/css/my-gitalk.css","hash":"eeda46a83d0db1cc239a9cd27d544faf663f9883","modified":1680600250283},{"_id":"themes/matery/source/css/matery.css","hash":"9177986b225313e4a986a9ff35085104e5886b2a","modified":1680603183877},{"_id":"themes/matery/source/css/my.css","hash":"405d61aa393c79aeb2033ef227fc7beb7b20eff6","modified":1680600250283},{"_id":"themes/matery/source/js/click_show_text.js","hash":"613c5e7851df10317da8ac50ec91b26a3e2ef372","modified":1680600250283},{"_id":"themes/matery/source/js/matery.js","hash":"c5a9c4fae16126cae80719e7435705840718b628","modified":1680600250283},{"_id":"themes/matery/source/js/search.js","hash":"499e11786efbb04815b54a1de317cc8606a37555","modified":1680600250283},{"_id":"themes/matery/source/medias/loading.svg","hash":"6c54fec96e2dfe43c027a2e4bcc7c80f00d0e873","modified":1680600250319},{"_id":"source/_posts/2022/01/IMX6ull-移植-lVGL总结.md","hash":"a60ec6d2c9e98fc893328b3eb0148a6422b0bd96","modified":1680600250127},{"_id":"source/_posts/2022/01/Linux-input子系统.md","hash":"d541c50f9195e4e20284fda91a0148fbf6b7d8df","modified":1680605772224},{"_id":"source/_posts/2022/01/linux线程.md","hash":"8c28ed3937f800f167489e0f8b3fb61e345d43d6","modified":1680605855503},{"_id":"source/_posts/2022/01/python使用百度翻译的API.md","hash":"a97eed7f4ed97279a8636228fdf207d32dec1559","modified":1680604573093},{"_id":"source/_posts/2022/01/中华通史-上古史-夏.md","hash":"2d0c995df8736de1b78924ea6c719c48fff6e120","modified":1680600250135},{"_id":"source/_posts/2022/01/菜鸟应该如何开始设计一个项目的嵌入式软件架构.md","hash":"b8b83de4d18babe4cb8b05da359f4acac6802943","modified":1680600250139},{"_id":"source/_posts/2022/01/超详细解析python爬取外网图片.md","hash":"6782dbb4489bbd5972a7e171e4c2becc0c80b3d6","modified":1680600250143},{"_id":"source/_posts/2023/04/EMC-EMI.md","hash":"c7d0a8134efce8288bc0d73d52292419fcce0531","modified":1680608189800},{"_id":"source/_posts/2023/04/ten-ge-li.md","hash":"6856ea5efa315450ce639f95405f29c6e169df2a","modified":1682664342210},{"_id":"source/_posts/2023/04/上海.md","hash":"77d9e88489af29489de707c483aa14eefeb70b31","modified":1680600250147},{"_id":"source/_posts/2023/04/业务功能-业务流程-业务规则分析.md","hash":"17de7f7dc4a9a9429b844bf2515714b651a1e25c","modified":1681710777687},{"_id":"source/_posts/2023/04/北京.md","hash":"5e636d1e364565a8239cba60d9aaf5c24e501f05","modified":1681712114815},{"_id":"source/_posts/2023/04/新疆.md","hash":"74e0ad91d963df84545d9a4de38ab86a72260c8b","modified":1680608747620},{"_id":"source/_posts/2023/04/深圳梧桐山-毛棉杜鹃.md","hash":"a179332d78a29d62c865678a23940f4e9e582c6f","modified":1680600250267},{"_id":"source/_posts/2023/04/衡山.md","hash":"2f19376e18ad6f7016d06cea817acf8061b67e08","modified":1680600250275},{"_id":"source/_posts/2023/05/单链表-报警模块.md","hash":"482404f8addabe3305e1c8167626780552b5efaf","modified":1683458068601},{"_id":"source/_posts/2023/05/PIN-GPIO.md","hash":"da48474cda114246751a17bb119abc0cda432fbf","modified":1684661841376},{"_id":"source/_posts/2023/05/提升EMC的软件编程策略.md","hash":"a5a527ec88e706ff5e0bd68821dfd43061f708ba","modified":1683871580020},{"_id":"source/_posts/2023/06/linux内核-tool目录.md","hash":"93fcf2588fda047566b4255967e21290885687af","modified":1687914379407},{"_id":"source/_posts/2023/06/ttymxx-UART.md","hash":"42bfbf36113e8e8ae94b059366f346906d21a0af","modified":1687918784448},{"_id":"source/_posts/2023/06/url.md","hash":"ce974b395b1fb5d3e63523d5484aefcff1670df4","modified":1687224812336},{"_id":"source/_posts/2023/07/linux-platform.md","hash":"859f1223f7ae9adaa245d9349020b998285b8eba","modified":1688613996733},{"_id":"source/_posts/2023/07/嵌入式软件框架方案.md","hash":"121f668602f9992a8ab1ce97f54b795c6f140938","modified":1689558631576},{"_id":"themes/matery/source/favicon.png","hash":"8d9bbc4559b4a7d594474fc59789436dd4c28adc","modified":1680600250283},{"_id":"themes/matery/source/libs/animate/animate.min.css","hash":"97afa151569f046b2e01f27c1871646e9cd87caf","modified":1680600250283},{"_id":"themes/matery/source/libs/aos/aos.css","hash":"191a3705a8f63e589a50a0ff2f2c5559f1a1b6b2","modified":1680600250283},{"_id":"themes/matery/source/libs/aos/aos.js","hash":"02bfb40b0c4b6e9b0b4081218357145cbb327d74","modified":1680600250283},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1680600250283},{"_id":"themes/matery/source/libs/codeBlock/clipboard.min.js","hash":"9cd57c67fbd3e3067f80793ef8445f5ff7783563","modified":1680600250291},{"_id":"themes/matery/source/libs/codeBlock/codeBlockFuction.js","hash":"c7ab06d27a525b15b1eb69027135269e9b9132fb","modified":1680600250291},{"_id":"themes/matery/source/libs/codeBlock/codeCopy.js","hash":"b74a381adf6ef8404d6a0452c2b9f44b47219c80","modified":1680600250291},{"_id":"themes/matery/source/libs/codeBlock/codeShrink.js","hash":"215910dc8f63fd50b97957e5fcdc8480aa2728cb","modified":1680600250291},{"_id":"themes/matery/source/libs/codeBlock/codeLang.js","hash":"ea8b51e4d75e7b2cd63e4d5bcb8db2cf7f23f5db","modified":1680600250291},{"_id":"themes/matery/source/libs/cryptojs/crypto-js.min.js","hash":"5989527a378b55011a59522f41eeb3981518325c","modified":1680600250291},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.css","hash":"f7d19655f873b813ffba5d1a17145c91f82631b8","modified":1680600250291},{"_id":"themes/matery/source/libs/gitalk/gitalk.css","hash":"3aac1db83b0135c521187254ff302d125cc30706","modified":1680600250291},{"_id":"themes/matery/source/libs/gitment/gitment-default.css","hash":"2903c59ee06b965bef32e937bd69f5b0b2190717","modified":1680600250295},{"_id":"themes/matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"257eaae3020599e4939f50d5008a743827f25b8c","modified":1680600250295},{"_id":"themes/matery/source/libs/jqcloud/jqcloud.css","hash":"20d9f11a19d95c70e27cb922e0d6dccbec4eae89","modified":1680600250295},{"_id":"themes/matery/source/libs/masonry/masonry.pkgd.min.js","hash":"ff940b4ea68368ca0e4d5560cbb79fb147dfc3c5","modified":1680600250295},{"_id":"themes/matery/source/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1680600250295},{"_id":"themes/matery/source/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1680600250299},{"_id":"themes/matery/source/libs/others/explosion.min.js","hash":"417b68e2cf2c6de2119c57626f4412105a8457f5","modified":1680600250299},{"_id":"themes/matery/source/libs/others/fireworks.js","hash":"53981959bc6def4a85bbbb41b07e4b1474a2124d","modified":1680600250299},{"_id":"themes/matery/source/libs/others/snow.js","hash":"7f3b1ad2f64d4473210a2c3218893649c73c980e","modified":1680600250299},{"_id":"themes/matery/source/libs/others/text.js","hash":"1791782cde0d1e4197f2ed58ecb7dd6aefddd169","modified":1680600250299},{"_id":"themes/matery/source/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1680600250299},{"_id":"themes/matery/source/libs/tocbot/tocbot.css","hash":"15601837bf8557c2fd111e4450ed4c8495fd11a0","modified":1680600250299},{"_id":"themes/matery/source/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1680600250299},{"_id":"themes/matery/source/medias/featureimages/9.jpg","hash":"2e1ac235e6a6d80dbed651f993f319c1ed4b5925","modified":1680600250319},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1680600250287},{"_id":"themes/matery/source/libs/gitment/gitment.js","hash":"28c02c45ce568e084cd1041dc493f83f9c6c88c6","modified":1680600250295},{"_id":"themes/matery/source/libs/jquery/jquery-2.2.0.min.js","hash":"5d7e5bbfa540f0e53bd599e4305e1a4e815b5dd1","modified":1680600250295},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.js","hash":"c3bad7b265574fab0ae4d45867422ea1cb9d6599","modified":1680600250291},{"_id":"themes/matery/source/medias/avatars/csdn.ico","hash":"fff55f10e98084a888ac0b346ccdf0dbaad2ccb1","modified":1680600250299},{"_id":"themes/matery/source/libs/valine/Valine.min.js","hash":"4e34802ccbb59f1daa58a62241ff57f923e50600","modified":1680600250299},{"_id":"themes/matery/source/medias/featureimages/14.jpg","hash":"164bda04d4ef6ae75f149c2e822d0d0f0b79e15c","modified":1680600250307},{"_id":"themes/matery/source/medias/featureimages/15.jpg","hash":"867c9882842f84290ba173292d551a626106a45d","modified":1680600250307},{"_id":"themes/matery/source/medias/featureimages/21.jpg","hash":"9ad4b78782e69f0ace50f76daa7a4bd687738332","modified":1680600250311},{"_id":"themes/matery/source/medias/featureimages/27.jpg","hash":"ea65367dab59059c343cd0a211f41ca4bd0dc2c9","modified":1680600250311},{"_id":"themes/matery/source/medias/featureimages/35.jpg","hash":"2f001a7d045a952ba059eb3575664347ebbf4d1f","modified":1680600250315},{"_id":"themes/matery/source/medias/featureimages/36.jpg","hash":"a71a869c98c68123e94706fa970333235990f0ab","modified":1680600250315},{"_id":"themes/matery/source/medias/featureimages/38.jpg","hash":"fc728ac4c69d06e911bbc4d6cba9c9ef1b158b9f","modified":1680600250315},{"_id":"themes/matery/source/medias/featureimages/37.jpg","hash":"515fd43e0acddf316a5753ea1cdc259c9571eec6","modified":1680600250315},{"_id":"themes/matery/source/medias/featureimages/47.jpg","hash":"ee4de6373759e67d96c0fe7237620ccdd190f188","modified":1680600250319},{"_id":"source/_posts/2022/01/IMX6ull-移植-lVGL总结/2909691-20220928153140065-1807119912.png","hash":"81814544b47e2371c6174d2d78a40c6dc1ec97ee","modified":1680600250131},{"_id":"source/_posts/2022/01/Linux-input子系统/2909691-20220819102740731-2036281828.png","hash":"620ca1c5e896674be2123b19c639bc542af82caf","modified":1680600250135},{"_id":"source/_posts/2022/01/IMX6ull-移植-lVGL总结/2909691-20220928153451220-1274979267.png","hash":"38e44ea1bf27b199f03e40d3fbb31ca92a9560b1","modified":1680600250131},{"_id":"source/_posts/2022/01/Linux-input子系统/2909691-20220819094250974-180404869.webp","hash":"f2c6a92fb8d6c71167d08db4814ac8978264f149","modified":1680600250135},{"_id":"source/_posts/2022/01/linux线程/2909691-20221018201940242-320806714.png","hash":"e303ca7352b7cb92f2f9a6e68a42a53f40f0a5e0","modified":1680600250135},{"_id":"source/_posts/2022/01/linux线程/2909691-20221018202536805-171723429.png","hash":"19ee436b75c2365a5d9b0fe3692a743a6e49c952","modified":1680600250135},{"_id":"source/_posts/2022/01/Linux-input子系统/input_logical.png","hash":"745413f59d688e5a390a23fc26d5cbba1bee74bf","modified":1680605599224},{"_id":"source/_posts/2022/01/linux线程/2909691-20221018204634847-2097816257.png","hash":"11e873440e4adc189ebe3f537f9ef2e5e95e30ba","modified":1680600250135},{"_id":"source/_posts/2022/01/python使用百度翻译的API/20200302120105912.png","hash":"60d73aec104782b1e3626b0ae5b695e6b2f44134","modified":1680600250135},{"_id":"source/_posts/2022/01/python使用百度翻译的API/20200302115943813.png","hash":"d732381420174bf2f792dc34b3f5b3b56bfc2fe8","modified":1680600250135},{"_id":"source/_posts/2022/01/菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329195920218.jpg","hash":"20699b111e09083edc68e80f86e2238c4c5b703d","modified":1680600250139},{"_id":"source/_posts/2022/01/菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329200632579.png","hash":"cd08c7532ef0acf9b9406d0794195926408d8b0a","modified":1680600250139},{"_id":"source/_posts/2022/01/菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329193127889.jpg","hash":"7a0511fab61dec9617ff13e3e30955a7b37f0930","modified":1680600250139},{"_id":"source/_posts/2022/01/菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329202548677.png","hash":"af1c46bdb03c03fa55002639807e158ac3ab6868","modified":1680600250143},{"_id":"source/_posts/2022/01/菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329202358795.png","hash":"cdfc62f3ea8e38679c1a804d2aad822b1bcc1a36","modified":1680600250143},{"_id":"source/_posts/2022/01/菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329203335481.png","hash":"d8ae5f3ea833f6f627c8d7006a0a886753a3b908","modified":1680600250143},{"_id":"source/_posts/2023/04/EMC-EMI/2023-04-04_19-32-29.png","hash":"5cf52b16fc4970dd256fb8ab707a8988e6fea828","modified":1680608014940},{"_id":"source/_posts/2023/04/EMC-EMI/2023-04-04_19-33-48.png","hash":"e5f260152656763228b8ef179d47a2ad485802f9","modified":1680608092912},{"_id":"source/_posts/2023/04/业务功能-业务流程-业务规则分析/分析起步.png","hash":"f597a655cc0aff1ed6aaf5a19380957ba362fde6","modified":1681709952620},{"_id":"source/_posts/2023/04/业务功能-业务流程-业务规则分析/模板.png","hash":"e67a71845dfd7a98e4959b97df24d50a8da41177","modified":1681709450286},{"_id":"source/_posts/2023/04/新疆/2d25bdf0ce35910c874badcedff928002.JPG","hash":"dfb9275edaa0886abb505911f112165b5aea21e1","modified":1680600250203},{"_id":"source/_posts/2023/06/linux内核-tool目录/tool目录.png","hash":"e0941cce6adf15e087d9484b4e126716ae2549f6","modified":1686100827716},{"_id":"source/_posts/2023/07/linux-platform/device-driver.png","hash":"d1a74b75fbd655681620df04a09a2a81e07060e2","modified":1688612432152},{"_id":"source/_posts/2023/07/嵌入式软件框架方案/22c7469876239933b38a12a32e9c6f16.png","hash":"e0ac3751ad221d95718ae7ff26ebf073bb9594f1","modified":1689558406944},{"_id":"source/_posts/2023/07/嵌入式软件框架方案/60a0b6815e87242adbc049d64b96e01b.png","hash":"d57950b2bab69769bd372eb0ab86a71f7cb28d27","modified":1689558406953},{"_id":"source/_posts/2023/07/嵌入式软件框架方案/780552b6b4ceacfe274a8c687b74a569.png","hash":"579c26e4342cdae2ba4404f04781a4b4839e4dc7","modified":1689558406948},{"_id":"source/_posts/2023/07/嵌入式软件框架方案/dc4e3ddfdab5a0456af40df7d0a9238b.png","hash":"782eae366eeb181d32de302b4d0f4416a6fefbfc","modified":1689558406936},{"_id":"source/_posts/2023/07/嵌入式软件框架方案/e7176066eab77c0cf6e147aed0046ea7.png","hash":"63576e1bd997584873acae29976472105d199fdb","modified":1689558406959},{"_id":"themes/matery/source/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1680600250295},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1680600250295},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.svg","hash":"9a732790adc004b22022cc60fd5f77ec4c8e3e5a","modified":1680600250295},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1680600250295},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1680600250295},{"_id":"themes/matery/source/libs/lightGallery/img/video-play.png","hash":"fbfdbe06aebf7d0c00da175a4810cf888d128f11","modified":1680600250295},{"_id":"themes/matery/source/libs/lightGallery/img/youtube-play.png","hash":"39150b45ec5fc03155b7ebeaa44f1829281788e2","modified":1680600250295},{"_id":"themes/matery/source/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1680600250295},{"_id":"themes/matery/source/libs/lightGallery/img/vimeo-play.png","hash":"1142b47de219dddfba2e712cd3189dec0c8b7bee","modified":1680600250295},{"_id":"themes/matery/source/libs/share/css/share.min.css","hash":"8a778a86f3ce9a042df6be63a9f1039631e351a5","modified":1680600250299},{"_id":"themes/matery/source/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1680600250299},{"_id":"themes/matery/source/libs/share/fonts/iconfont.svg","hash":"f0a1b849868a6bf351ff98dc3924a4e7254eb88b","modified":1680600250299},{"_id":"themes/matery/source/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1680600250299},{"_id":"themes/matery/source/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1680600250299},{"_id":"themes/matery/source/libs/share/js/jquery.share.min.js","hash":"16ce82901ca0e302cf47a35fb10f59009a5e7eb9","modified":1680600250299},{"_id":"themes/matery/source/libs/materialize/materialize.min.css","hash":"4d46df5f22cbc24eefa76228c7ee308dc3585594","modified":1680600250295},{"_id":"themes/matery/source/libs/share/js/social-share.min.js","hash":"4df722bafde2c5d8faaace0d1f894798385a8793","modified":1680600250299},{"_id":"themes/matery/source/libs/materialize/materialize.min.js","hash":"c8b4c65651921d888cf5f27430dfe2ad190d35bf","modified":1680600250295},{"_id":"themes/matery/source/libs/valine/av-min.js","hash":"2577e72b52b736d99649f9e95be8976d58563333","modified":1680600250299},{"_id":"themes/matery/source/medias/featureimages/10.jpg","hash":"53f3eb05edab87ee07c889f26fc550e9b5e5cb91","modified":1680600250307},{"_id":"themes/matery/source/medias/featureimages/11.jpg","hash":"4e4ed3d6f8466b3362cbaaa04dc31b8859d3e202","modified":1680600250307},{"_id":"themes/matery/source/medias/featureimages/16.jpg","hash":"87100d52e5077c77f9e74856a1c5330d81708ae3","modified":1680600250307},{"_id":"themes/matery/source/medias/featureimages/2.jpg","hash":"8567da47271a81b74ca341d170e057bb42f42bf5","modified":1680600250311},{"_id":"themes/matery/source/medias/featureimages/20.jpg","hash":"e854df6ea24c22c999216db611dfd3785b76b834","modified":1680600250311},{"_id":"themes/matery/source/medias/featureimages/23.jpg","hash":"c2f1f9387db7dd99d3c0e4df42a160d482dde5bd","modified":1680600250311},{"_id":"themes/matery/source/medias/featureimages/24.jpg","hash":"33fc0af42186fa2c0e41712d5e45c716dd47bce6","modified":1680600250311},{"_id":"themes/matery/source/medias/featureimages/28.jpg","hash":"565fb296d8e4e2e520d6f15985f1de33d7bd98c8","modified":1680600250311},{"_id":"themes/matery/source/medias/featureimages/29.jpg","hash":"a8ff01c7f29be6d703040fad7889f5afba1eb844","modified":1680600250311},{"_id":"themes/matery/source/medias/featureimages/30.jpg","hash":"6dfe6d277ec3ef36e8c958a71712702a5be3e4d8","modified":1680600250311},{"_id":"themes/matery/source/medias/featureimages/31.jpg","hash":"50eedc29287470f333612e6f71d88c3121357257","modified":1680600250311},{"_id":"themes/matery/source/medias/featureimages/33.jpg","hash":"851fadf999b21c4e42d7a5e4114a10abd21f81cd","modified":1680600250311},{"_id":"themes/matery/source/medias/featureimages/39.jpg","hash":"2b914a3b098aa874f68b4fcda7c85613140c6420","modified":1680600250315},{"_id":"themes/matery/source/medias/featureimages/41.jpg","hash":"51ccac5c36201f1c04f66e5d54babbb21cf5dc5f","modified":1680600250315},{"_id":"themes/matery/source/medias/featureimages/43.jpg","hash":"76bf6095d8e92aa5d6a4e2dff4c2d710c61da07e","modified":1680600250315},{"_id":"themes/matery/source/medias/featureimages/46.jpg","hash":"1e73f8ed0bd91c4443c4f7e57d2ea5cf94d419c6","modified":1680600250315},{"_id":"themes/matery/source/medias/music/avatars/不见就散-周深.jpg","hash":"c0611b3db7a0acb91c8d1972e6ffe99545289bc8","modified":1680600250323},{"_id":"themes/matery/source/medias/music/avatars/平凡之路-朴树.jpg","hash":"70d026f8ff9df7a5427e75e58c4b8bc6c637d85f","modified":1680600250323},{"_id":"themes/matery/source/medias/featureimages/8.jpg","hash":"b04f9b49261b2486260e64e6543da45689e272de","modified":1680600250319},{"_id":"themes/matery/source/medias/logo.png","hash":"8d9bbc4559b4a7d594474fc59789436dd4c28adc","modified":1680600250323},{"_id":"themes/matery/source/medias/reward/wechat.jpg","hash":"010a7b4eaf2113af7660fab39f7b7d2dc2fb314e","modified":1680600250387},{"_id":"source/_posts/2022/01/IMX6ull-移植-lVGL总结/2909691-20220928151916481-1456634923.png","hash":"1a6e87f307777f98d725943978c00efb4090c0ba","modified":1680600250127},{"_id":"source/_posts/2022/01/IMX6ull-移植-lVGL总结/2909691-20220928152957065-501054685.png","hash":"02e70dd300ead042177d527aebf566eb8ebec4fc","modified":1680600250131},{"_id":"source/_posts/2022/01/python使用百度翻译的API/20200302113654396.png","hash":"0eb46311fe5eee6803493cec10c082d2acef996b","modified":1680600250135},{"_id":"source/_posts/2022/01/中华通史-上古史-夏/20210703105831609.png","hash":"6f74b0d301ff93d020a051b598c1843023c8a60f","modified":1680600250139},{"_id":"source/_posts/2022/01/中华通史-上古史-夏/20210703105920999.png","hash":"e6a74917abe403a8adca2103d264f2b532765b96","modified":1680600250139},{"_id":"source/_posts/2022/01/菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329201646615.png","hash":"33a6c6a068648814992c82eaeab0d798cd05258e","modified":1680600250143},{"_id":"source/_posts/2022/01/菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329203021908.png","hash":"0648ca9586b7a83463ad4f12efc003231171b681","modified":1680600250143},{"_id":"source/_posts/2022/01/菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329203626594.png","hash":"3e9af02ca14cc9e5098b1b148583dee50e0a28b8","modified":1680600250143},{"_id":"source/_posts/2023/04/EMC-EMI/2023-04-04_19-28-04.png","hash":"e95e091152fa0c866d73f5014c48cf5a62f54719","modified":1680607768844},{"_id":"source/_posts/2023/04/EMC-EMI/2023-04-04_19-33-05.png","hash":"7477c974bab91a2621066e5f826da10bf3f970c9","modified":1680608050459},{"_id":"source/_posts/2023/04/业务功能-业务流程-业务规则分析/主干流程.png","hash":"f4a5350223b0e86788af65ad517ef1302feed1e7","modified":1681710030693},{"_id":"source/_posts/2023/04/衡山/20230403161331.jpg","hash":"a452aeceed392945bd8cf528b00b0f6475a6f7cd","modified":1680600250275},{"_id":"source/_posts/2023/04/衡山/20230403161404.jpg","hash":"1c641d5779759d0d48bd33a9e4c2020b7c51cde7","modified":1680600250279},{"_id":"source/_posts/2023/04/衡山/20230403161412.jpg","hash":"525c7afb118f1c0052078119b3ca24df7d5101f4","modified":1680600250279},{"_id":"source/_posts/2023/05/PIN-GPIO/Pinctrl.png","hash":"9bdf584dbb8e6fb33546aa917b3bd76790337d3b","modified":1684661521218},{"_id":"source/_posts/2023/05/PIN-GPIO/imx6ull pinctrl.png","hash":"28d5e0d8c17c46bff684820293b1028d8e8752b5","modified":1684657106048},{"_id":"source/_posts/2023/05/PIN-GPIO/iomuxc.png","hash":"d0d101818eb5c21c45e6ed4a033de957e1cb9795","modified":1684657681843},{"_id":"source/_posts/2023/05/PIN-GPIO/pinctrl_system.png","hash":"8a57a4a6e04e1171f13fcedb6d0fac2fe58fbd5f","modified":1684654812332},{"_id":"source/_posts/2023/05/PIN-GPIO/probe.png","hash":"9d21cfe994d9a48e7442f91f0fb6e59fea403795","modified":1684658187650},{"_id":"source/_posts/2023/06/linux内核-tool目录/menuconfig.png","hash":"d9715c99899d7d2ec1557e648f00a36d55032858","modified":1686105224443},{"_id":"source/_posts/2023/07/嵌入式软件框架方案/2dd308b3411c41658cce041f8c230853.png","hash":"4c66e0a781c7319210351bef8458dce004c1d3df","modified":1689558406938},{"_id":"source/_posts/2023/07/嵌入式软件框架方案/32643a6fbe010dcc95af301416619164.png","hash":"cdbf520cd2419b7cdc97569c1d38e81ea6c2186e","modified":1689558406943},{"_id":"source/_posts/2023/07/嵌入式软件框架方案/6aadad4da134377249d84bab5dbdfa8d.png","hash":"74983111bde7189cb23f4ee194c3d6e3e0ddde3f","modified":1689558406940},{"_id":"themes/matery/source/libs/awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1680600250287},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1680600250291},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1680600250291},{"_id":"themes/matery/source/libs/lightGallery/js/lightgallery-all.min.js","hash":"9f5ef4bc8a0a3c746ca4f3c3e6d64493b1a977d8","modified":1680600250295},{"_id":"themes/matery/source/medias/banner/5.jpg","hash":"38272cddbb09c70c7785aed877f6c9b45a61262a","modified":1680600250303},{"_id":"themes/matery/source/medias/featureimages/0.jpg","hash":"4e9f83cbe1575a44fe9315f937e7505ed05b6920","modified":1680600250307},{"_id":"themes/matery/source/medias/featureimages/1.jpg","hash":"aaf5863bed7563a86a6da15cef0b5d44740e449c","modified":1680600250307},{"_id":"themes/matery/source/medias/featureimages/18.jpg","hash":"b8108799fbf3eadf0462fba04034a277a462018b","modified":1680600250311},{"_id":"themes/matery/source/medias/featureimages/25.jpg","hash":"97930cf52f9e68ccf24d26b383704ca4724dae34","modified":1680600250311},{"_id":"themes/matery/source/medias/featureimages/3.jpg","hash":"4cabac02df559a5eb1b9abc8a0359fe6573a738b","modified":1680600250311},{"_id":"themes/matery/source/medias/featureimages/32.jpg","hash":"e440f9bdcdff7c181904b26b2774c48632e4d24a","modified":1680600250311},{"_id":"themes/matery/source/medias/featureimages/34.jpg","hash":"6fca10e13cae2a089909ea266fa6be510e57a2bd","modified":1680600250315},{"_id":"themes/matery/source/medias/featureimages/45.jpg","hash":"5c22e8d627f763ebae1d080025aee103383a8460","modified":1680600250315},{"_id":"themes/matery/source/medias/featureimages/6.jpg","hash":"e0eb036bf77aacc91dffea2d75f590f9f1b2b961","modified":1680600250319},{"_id":"themes/matery/source/medias/featureimages/5.jpg","hash":"38272cddbb09c70c7785aed877f6c9b45a61262a","modified":1680600250319},{"_id":"themes/matery/source/medias/featureimages/7.jpg","hash":"26833abcdd65e10c48e8d0553cb3543d3e0ca4d8","modified":1680600250319},{"_id":"themes/matery/source/medias/reward/alipay.jpg","hash":"bf966a223684650a6c5f1bc5df6d571493e922f3","modified":1680600250387},{"_id":"source/_posts/2022/01/IMX6ull-移植-lVGL总结/2909691-20220928152209724-1097250473.png","hash":"05d498f7f30591101a53a8c5c95924ff1a84001d","modified":1680600250131},{"_id":"source/_posts/2022/01/IMX6ull-移植-lVGL总结/2909691-20220928152945955-899676295.png","hash":"9714cee9d41e446e660bc06e1908adad5edd6258","modified":1680600250131},{"_id":"source/_posts/2022/01/IMX6ull-移植-lVGL总结/2909691-20220928153305849-1048335725.png","hash":"aeee98d5b5d62bc471f881b6482100864635f667","modified":1680600250131},{"_id":"source/_posts/2022/01/Linux-input子系统/2909691-20220819093409715-1604400596.png","hash":"55b9667906c85b6e35a8306dec17b969ece62590","modified":1680600250135},{"_id":"source/_posts/2022/01/python使用百度翻译的API/20200302113313981.png","hash":"a3bc848fc823b39cb9304360dabc4113a61ebb40","modified":1680600250135},{"_id":"source/_posts/2023/04/业务功能-业务流程-业务规则分析/业务规则上.png","hash":"106e7b83de735bd1506057f05bded3f5b3f5fd1f","modified":1681710341285},{"_id":"source/_posts/2023/04/北京/IMG_6716.JPG","hash":"99ff60c734012614ac5407d15ead6311fc76c8fb","modified":1681711548911},{"_id":"source/_posts/2023/04/新疆/1b706b934fc955412e3ed163fd0b7cbc2.JPG","hash":"197d9abf8cb2a83ba7f92192e339ebdef533f956","modified":1680600250203},{"_id":"source/_posts/2023/04/新疆/89c05a76a9273811c585c395890c9f522.JPG","hash":"acd08647f23bdbabb1f68cc061086d71df0dccd8","modified":1680600250211},{"_id":"source/_posts/2023/04/衡山/20230403161419.jpg","hash":"d52eba8c569ccd38a42589d5feccbad599bdb78e","modified":1680600250279},{"_id":"source/_posts/2023/05/PIN-GPIO/gpio.png","hash":"bad8a6af0e809665e3d511cf24ab38f173abf2d0","modified":1684654303930},{"_id":"source/_posts/2023/06/ttymxx-UART/cat-proc-devices.png","hash":"d7b01cb33a859dca9532928d23f626d7e9406c71","modified":1687916694055},{"_id":"source/_posts/2023/06/ttymxx-UART/ls-dev.png","hash":"b568d5d4f2dd4c06497e8bf3fd2c9c114cb807b7","modified":1687916266176},{"_id":"themes/matery/source/medias/featureimages/26.jpg","hash":"9c2eaf5aff8abdc4e215af96002c8525be9ddd06","modified":1680600250311},{"_id":"themes/matery/source/medias/featureimages/4.jpg","hash":"d7139f883aad272d619ce181ebcd86672a2a7bdc","modified":1680600250315},{"_id":"themes/matery/source/medias/featureimages/44.jpg","hash":"6bca5b340c7e16350e3040da2416f6184ccd64a4","modified":1680600250315},{"_id":"themes/matery/source/medias/featureimages/48.jpg","hash":"13754e6efc8f6db46088d736ed2c290b0d9bfb33","modified":1680600250319},{"_id":"source/_posts/2022/01/python使用百度翻译的API/20200302112847600.png","hash":"7826ff6dbdf5ff34629750ce22b0e94cccadef69","modified":1680600250135},{"_id":"source/_posts/2022/01/中华通史-上古史-夏/20210703111602157.png","hash":"eed4aad178595cbb24f9d33be2b6b893d29ebe07","modified":1680600250139},{"_id":"source/_posts/2023/04/EMC-EMI/2023-04-04_19-34-25.png","hash":"7dcff810f530ee4d40ee76651268a3c473f7d5ed","modified":1680608130721},{"_id":"source/_posts/2023/04/业务功能-业务流程-业务规则分析/探索分支.png","hash":"3cf5793d9bf2b409bd939c0e485c6e23c7f3d28a","modified":1681710086969},{"_id":"source/_posts/2023/04/北京/IMG_6717.JPG","hash":"9bfb74c92dc7ea4217d2dd03624ef50acf2e5d38","modified":1681711549661},{"_id":"source/_posts/2023/04/深圳梧桐山-毛棉杜鹃/2b135a37c965e856f04d4a5faf8d2f2b2.JPG","hash":"f4165d53241b101e85fad7128831f04d684ad00a","modified":1680600250267},{"_id":"source/_posts/2023/06/ttymxx-UART/cat-ttymxc2.png","hash":"5847a4ae7a6b9dc2e40b772d68e265417b69cebc","modified":1687917272871},{"_id":"themes/matery/source/libs/awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1680600250287},{"_id":"themes/matery/source/medias/banner/1.jpg","hash":"cd3fc47d2042a3277e4b375ad084365abdc28f5d","modified":1680600250299},{"_id":"themes/matery/source/medias/banner/2.jpg","hash":"c2980f75f2c047d0957e3c8227b3f8d84e67f752","modified":1680600250303},{"_id":"themes/matery/source/medias/banner/6.jpg","hash":"5be9274e63d6ac02607e3d659fd32532291385fa","modified":1680600250307},{"_id":"themes/matery/source/medias/featureimages/12.jpg","hash":"29f884076a7fbed6900a1a05c41ffd3ce122a123","modified":1680600250307},{"_id":"themes/matery/source/medias/featureimages/13.jpg","hash":"1eed284202ae51c4f3051d943b3d97a7602a9fc6","modified":1680600250307},{"_id":"themes/matery/source/medias/featureimages/22.jpg","hash":"2beb56f529f0ce49f36a84d55890b7c0de3d7705","modified":1680600250311},{"_id":"themes/matery/source/medias/featureimages/40.jpg","hash":"7a69b037ce05312d9322fe3f11c4d645b88645aa","modified":1680600250315},{"_id":"themes/matery/source/medias/featureimages/42.jpg","hash":"c05648a22e1f083d13f40e76fed535f027fae0b6","modified":1680600250315},{"_id":"source/_posts/2022/01/中华通史-上古史-夏/20210703105815619.png","hash":"ed38e99ca771a664503c1fc241b65609b190a652","modified":1680600250139},{"_id":"source/_posts/2023/04/业务功能-业务流程-业务规则分析/业务规则.png","hash":"9096eaf502a8c77966e2ddba42aeca3d42a30c59","modified":1681710520050},{"_id":"source/_posts/2023/04/新疆/5d0b74a8910a3abba7e860149b9d40e12.JPG","hash":"ec0e0cd928032ca04d666abf09e657b401f8c286","modified":1680600250203},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1680600250287},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1680600250291},{"_id":"themes/matery/source/medias/banner/0.jpg","hash":"73bae0e6812c46509b91e3155bd12ce8640b245a","modified":1680600250299},{"_id":"themes/matery/source/medias/avatars/myzhihu.png","hash":"4a9aec7e236615e3b698adfd3b36bc34ec05e5c7","modified":1680600250299},{"_id":"themes/matery/source/medias/banner/4.jpg","hash":"4d6f31f86966584360bcdbfecb6f6a2ec94f944d","modified":1680600250303},{"_id":"themes/matery/source/medias/featureimages/17.jpg","hash":"4cbd4926b13132903c465685a127c577b56b2b8b","modified":1680600250307},{"_id":"source/_posts/2022/01/IMX6ull-移植-lVGL总结/2909691-20220928152922659-1842915282.png","hash":"3e599491c205ce9c2473c7cb88ae34ffe5ed810c","modified":1680600250131},{"_id":"source/_posts/2022/01/python使用百度翻译的API/20200302112753932.png","hash":"6f7c69b14491228187f0b0d593687015b1751112","modified":1680600250135},{"_id":"source/_posts/2023/04/EMC-EMI/2023-04-04_19-30-08.png","hash":"4affe9d70ae0f96d3e097dedefeb4d8c2255f202","modified":1680607876130},{"_id":"source/_posts/2023/04/EMC-EMI/2023-04-04_19-31-27.png","hash":"a548cc6c623a27b9b1ef07bf747c2f5846a1b8ad","modified":1680607952947},{"_id":"source/_posts/2023/04/新疆/76d386e1b8eeeb85abab758cefc855e0.JPG","hash":"b5263a0698617a32ddcab1602d590abea3061540","modified":1680600250207},{"_id":"source/_posts/2023/04/衡山/20230403161440.jpg","hash":"de330e0d5f878351e1c4e01fd03e6646f47b7cd7","modified":1680600250283},{"_id":"source/_posts/2023/07/嵌入式软件框架方案/c7546c50623e8a8aa6ab33ead8fac6cb.png","hash":"a7316beb6a20159dfeb953c21713feeac78ac6ac","modified":1689558406958},{"_id":"source/_posts/2023/04/EMC-EMI/2023-04-04_19-32-59.png","hash":"f87f697280797d30f0e2f288829d1ef1e01679c5","modified":1680608044638},{"_id":"source/_posts/2023/04/业务功能-业务流程-业务规则分析/穷尽分支.png","hash":"7af9f4b00d74e30e5821ba95a050baa41c7e37f9","modified":1681710270939},{"_id":"source/_posts/2023/04/北京/DSC01699.JPG","hash":"88fd74c50d76197f25fcea4f145b0b7315afa381","modified":1681711543267},{"_id":"source/_posts/2023/05/PIN-GPIO/pinctrl struct.png","hash":"8fb5c14e3e7b5a3819fd16cc07cead5aef72dae1","modified":1684655547450},{"_id":"source/_posts/2023/06/ttymxx-UART/ttymxc.png","hash":"37188802f04a32b89f1bebec4b86cdf8df87472b","modified":1687917013010},{"_id":"themes/matery/source/medias/music/avatars/每天爱你多一些.jpg","hash":"2beb56f529f0ce49f36a84d55890b7c0de3d7705","modified":1680600250323},{"_id":"source/_posts/2023/04/新疆/95d557eb4ef2235d74a45743be1b05842.JPG","hash":"4b854a6ecb431a313e93f8d48df7fd0044aa372c","modified":1680600250211},{"_id":"source/_posts/2023/07/嵌入式软件框架方案/e852708ffd1c78efd87949efa7b31592.png","hash":"278cedda4410f27e589063fce68238de6ca46b43","modified":1689558406935},{"_id":"source/_posts/2023/04/EMC-EMI/2023-04-04_19-35-03.png","hash":"75a164a1aefb14493fd964ec6f1af67dad08dfad","modified":1680608169299},{"_id":"source/_posts/2023/04/北京/DSC01645.JPG","hash":"37aae358c05c3ebe858be7fde41a6d991c53ffac","modified":1681711540475},{"_id":"source/_posts/2023/04/新疆/88a98ae85a4705294439aca39ae07d672.JPG","hash":"efaf4595479444c71cb33287f510e15a97023d5e","modified":1680600250207},{"_id":"source/_posts/2023/04/新疆/a2a9265c2707c16b5a1ca704a4d0856d.JPG","hash":"32140a32efde0712248d80606354ef18c8bdca95","modified":1680600250263},{"_id":"source/_posts/2023/04/新疆/a51d80549e7edc0d1ba69a885aa946ff2.JPG","hash":"d035b1f8fc6fa4742360fa30519dc3c349c5eb9d","modified":1680600250267},{"_id":"source/_posts/2023/04/深圳梧桐山-毛棉杜鹃/0a32e20ee914cca207bd5e0446eca332.JPG","hash":"d8487b0b07b39733ff17269e2ab21b35290fc7d5","modified":1680600250267},{"_id":"source/_posts/2022/01/超详细解析python爬取外网图片/20200302110709393.png","hash":"2ad2b400e4ac4b25e38c950980367bb6b7276066","modified":1680600250143},{"_id":"source/_posts/2022/01/菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329201443609.png","hash":"58a7a16ec9b08da3d87fb952be7b90fa42d40b8a","modified":1680600250143},{"_id":"source/_posts/2023/04/业务功能-业务流程-业务规则分析/业务规则下.png","hash":"b2d1bd226e043c5a49cf997d195eab5828624e2e","modified":1681710361537},{"_id":"source/_posts/2023/04/北京/DSC01821.JPG","hash":"427acd97f61076e72289f67d92116b5264d532b6","modified":1681711546935},{"_id":"source/_posts/2023/04/深圳梧桐山-毛棉杜鹃/7d011510a39a8f6e23429fa828448a7c2.JPG","hash":"e39b53d9c09ac1a17144d8bc8190636d516184fb","modified":1680600250271},{"_id":"source/_posts/2023/04/衡山/20230403161427.jpg","hash":"edede76d7524dbff86198f9ed27af324e846a990","modified":1680600250279},{"_id":"source/_posts/2023/04/衡山/20230403161434.jpg","hash":"eb3aa00bd533848c1fcdc5b8978baa825c332a99","modified":1680600250283},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1680600250287},{"_id":"source/_posts/2023/04/深圳梧桐山-毛棉杜鹃/6f19a8a8bff80c030eeba535032db0f6.JPG","hash":"247ba6417dab25febabd897888b92c780012a972","modified":1680600250271},{"_id":"themes/matery/source/libs/gitalk/gitalk.min.js","hash":"564fc7c731d05fa70d71ef853a2c8cc7725739e2","modified":1680600250295},{"_id":"themes/matery/source/libs/echarts/echarts.min.js","hash":"9496f386a0da4601cad22c479cc5543913a4d67f","modified":1680600250291},{"_id":"themes/matery/source/medias/featureimages/49.jpg","hash":"90ad50712c339a89402a363288dcd355e98d0fbb","modified":1680600250319},{"_id":"source/_posts/2023/04/北京/DSC01755.JPG","hash":"45e044a7a2e818bc76bc695a2349c0220d2a6f43","modified":1681711545856},{"_id":"source/_posts/2023/04/深圳梧桐山-毛棉杜鹃/f4e3370968454b29062472df853b648e.JPG","hash":"9527a20734ba33ad970d1c09e9c5af69148a9e36","modified":1680600250275},{"_id":"source/_posts/2023/04/北京/DSC01697.JPG","hash":"e2bdc7040260ef7a9fafaf623a3f980e69faec27","modified":1681711542292},{"_id":"source/_posts/2023/04/北京/DSC01827.JPG","hash":"93f303dcf1cb66fc7c46f1912cb33edc4fcc7c0c","modified":1681711548086},{"_id":"source/_posts/2023/04/北京/DSC01687.JPG","hash":"0ca6df7cba2538cc3df7566e7652696abcbff8cf","modified":1681711541315},{"_id":"source/_posts/2023/04/北京/DSC01722.JPG","hash":"a50dcaff1db6ca1e6c7c746a580a96edf3695b61","modified":1681711544739},{"_id":"source/_posts/2023/04/深圳梧桐山-毛棉杜鹃/d2a7004a2e039c3f37d5fef10c7cc28a2.JPG","hash":"21997245573176ef723eae80b8337f1710d4a552","modified":1680600250275},{"_id":"source/_posts/2022/01/超详细解析python爬取外网图片/20200302111109517.png","hash":"3c1684024bc31494b116961152500c0109172a72","modified":1680600250147},{"_id":"source/_posts/2023/04/新疆/BBND3773.PNG","hash":"9d51e64746eaf562e333c0c58b1665c87b7e3c94","modified":1680600250231},{"_id":"source/_posts/2023/04/新疆/6d0c92b575f36108df2062fda3b1e4ba2.PNG","hash":"b1520fdd30b641aad9016617c32119cd8ed82a27","modified":1680600250207},{"_id":"source/_posts/2023/04/新疆/KNLN1045.PNG","hash":"9b81832789db7ed79eceb15cfd62958fe3c81f1e","modified":1680600250243},{"_id":"source/_posts/2023/04/ten-ge-li/6.jpg","hash":"7b0cbe85e3ac8f3bb07b151342332b577bf62c3b","modified":1682660527000},{"_id":"source/_posts/2023/04/新疆/254bc46a6128338402204fa78f54b3e12.PNG","hash":"e41e37de90a7768a13e2c5094c4b930aa03a47eb","modified":1680600250203},{"_id":"themes/matery/source/medias/banner/3.jpg","hash":"42a57b512acce7f09f122b6b8c4f85c3803cd438","modified":1680600250303},{"_id":"source/_posts/2023/04/新疆/50f3a54d039eb642be22bc25607e11ca2.PNG","hash":"81d8346d84e26f93cfdc42b386fcbe5346f645ea","modified":1680600250203},{"_id":"source/_posts/2023/04/ten-ge-li/5.jpg","hash":"8f369783db3afe07144f07bc27ab714853c3cfbb","modified":1682660526000},{"_id":"themes/matery/source/medias/music/每天爱你多一些-张学友.mp3","hash":"c4c9d37ac5b8012f0650fc6e1d414160bb6cbd5e","modified":1683458741119},{"_id":"source/_posts/2023/04/ten-ge-li/4.jpg","hash":"65423da6e9df83013372da9c0144723480560524","modified":1682660524000},{"_id":"themes/matery/source/medias/music/不见就散-周深.mp3","hash":"c96c5ad02f4138acc75321d0651d776939a8410b","modified":1683458806103},{"_id":"source/_posts/2023/04/ten-ge-li/1.jpg","hash":"aa5cc837537f2d220f140380d8aa4deb88ebc328","modified":1682660518000},{"_id":"source/_posts/2023/04/新疆/MOVG5083.JPG","hash":"d735c13bacae84426c35f79b31f0d76e56b5dbcb","modified":1680600250247},{"_id":"source/_posts/2023/04/ten-ge-li/3.jpg","hash":"ebdd58409be4f13114b49aca45a14587d6d33f7f","modified":1682660522000},{"_id":"source/_posts/2023/04/新疆/YJUM1401.JPG","hash":"2298f67966321b94c232d69b82a5d0c3725c250b","modified":1680600250263},{"_id":"source/_posts/2023/07/linux-platform/platform.png","hash":"8bbaa84862913279d587bda57cb8cbe1f203a548","modified":1688614085237},{"_id":"source/_posts/2023/04/新疆/ANKG1449.JPG","hash":"5baaa1ab9105091d0118f76229cef42117d346d3","modified":1680600250219},{"_id":"source/_posts/2023/04/新疆/XRBQ0574.JPG","hash":"0a22babef32c3458bf6d3b132fc86fdb92df4ac1","modified":1680600250255},{"_id":"source/_posts/2023/04/ten-ge-li/2.jpg","hash":"a67afd08d4cfc6ad6f1df81d6b9f6799ddaf2b5d","modified":1682660520000},{"_id":"source/_posts/2023/04/上海/20230403160809.jpg","hash":"c00d70be19d150a3e7852ba2bf0eb43d79b5af8e","modified":1680600250163},{"_id":"source/_posts/2023/04/新疆/IGAX1811.JPG","hash":"b28a4910831f07c5d9a24e7a89f1a13a89c4e499","modified":1680600250243},{"_id":"source/_posts/2023/04/ten-ge-li/IMG_6912.JPG","hash":"cf10a567bf3ebbe495dbefef9766d64f40838583","modified":1682663942634},{"_id":"source/_posts/2023/04/新疆/AZQE3071.JPG","hash":"ec500582aece897e57480cf258033db9afa09b4d","modified":1680600250227},{"_id":"source/_posts/2023/04/新疆/AQSR2937.JPG","hash":"803cbcd9795224d0fe0f955a183097d5841e7e4a","modified":1680600250223},{"_id":"source/_posts/2023/04/新疆/BBOD4958.JPG","hash":"d91a8e27fa87b395cf945e442e26b5afa5958529","modified":1680600250235},{"_id":"source/_posts/2023/04/ten-ge-li/IMG_6899.JPG","hash":"a83cb2a77b6e0783769e8db226b18ee12b684015","modified":1682663940654},{"_id":"source/_posts/2023/04/上海/20230403160820.jpg","hash":"67c97c223cf033355d5f224595e474000472c8ee","modified":1680600250199},{"_id":"themes/matery/source/medias/music/平凡之路-朴树.mp3","hash":"fab92512ec9c0cdc2ea41889f440084c86786e05","modified":1683458887868},{"_id":"source/_posts/2023/04/上海/20230403160752.jpg","hash":"1dd95e72274267e787dd795d8f25325365be8976","modified":1680600250159},{"_id":"source/_posts/2023/04/ten-ge-li/IMG_7069.JPG","hash":"54e10986b7f644c3f58d7231c4083ba7bf6b5934","modified":1682663953716},{"_id":"source/_posts/2023/04/上海/20230403160815.jpg","hash":"4791996fab30c9e1b0a57b5362fa19252382924a","modified":1680600250187},{"_id":"public/baidu_urls.txt","hash":"132cae2da7a77fa185dbffad7ea0b9a7f8379544","modified":1689561615728},{"_id":"public/atom.xml","hash":"c1f78dded019c634fc801501d77a656a0e9ae2b0","modified":1689561615770},{"_id":"public/baidusitemap.xml","hash":"6edbaee42d52841ae46a1deb982789dd1d078235","modified":1689561615771},{"_id":"public/search.xml","hash":"990800df782232cdf01e32a967d2962d4c6554cf","modified":1689561616651},{"_id":"public/sitemap.xml","hash":"f4c78e9965f8f5ce7fbeabaac17b926119a88a10","modified":1689561616791},{"_id":"public/404.html","hash":"a6dc9f97870901c56a1774edf7f9925b2566a959","modified":1689561616827},{"_id":"public/categories/index.html","hash":"7f84da7e31d7956329a2eb07c6d86720fd5a58c9","modified":1689561616827},{"_id":"public/about/index.html","hash":"ef94fcdc932d9d297d8046a534d65462fc215f1c","modified":1689561616827},{"_id":"public/archives/index.html","hash":"f0962d19831c2db338dd75f44584e3a187d8bd5f","modified":1689561616827},{"_id":"public/gallery/index.html","hash":"0fadf177122a93dbe33a8cc86ee4798b9a992950","modified":1689561616827},{"_id":"public/contact/index.html","hash":"23e862ef92dd848a15be0c83e1862c0032d1d1df","modified":1689561616827},{"_id":"public/tags/index.html","hash":"5292b663dee2b31e1b757f014135df1d7ee307ee","modified":1689561616827},{"_id":"public/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an.html","hash":"25fa6f90f127784c791b3924aa02e5b2e1b4900e","modified":1689561616828},{"_id":"public/2023/07/linux-platform.html","hash":"5f74d4cb35cc3c262d2f7a12943ba8d30f1cec1a","modified":1689561616828},{"_id":"public/2023/06/ttymxx-uart.html","hash":"9a74778ad7229a6cf1600758b5a99b92a7d0f15e","modified":1689561616828},{"_id":"public/2023/06/url.html","hash":"ef21e48f367d80c3c99a04f9eef1acab381f185c","modified":1689561616828},{"_id":"public/2023/06/linux-nei-he-tool-mu-lu.html","hash":"8d1a47402c219d0a5cb9a6dd9cdd3c3b2cccebad","modified":1689561616828},{"_id":"public/2023/05/pin-gpio.html","hash":"ac91d780091776c8af2b44c7072a2a53899dee02","modified":1689561616828},{"_id":"public/2023/05/ti-sheng-emc-de-ruan-jian-bian-cheng-ce-lue.html","hash":"e5082c4801589c423dffdc1166909e54ec2353a0","modified":1689561616828},{"_id":"public/2023/05/dan-lian-biao-bao-jing-mo-kuai.html","hash":"ce4082b03e6e2998b868fba6ca43bac80c9cef8b","modified":1689561616828},{"_id":"public/2023/04/ten-ge-li.html","hash":"b25c2e17b6ad4370b45f119067da6afd4935c9ab","modified":1689561616828},{"_id":"public/2023/04/bei-jing.html","hash":"fc8f26668897999109ff5b9f8cd7a811db482a9e","modified":1689561616828},{"_id":"public/2023/04/ye-wu-gong-neng-ye-wu-liu-cheng-ye-wu-gui-ze-fen-xi.html","hash":"91dadf7b5231665ef8eeb12222b428804f8c3552","modified":1689561616828},{"_id":"public/2023/04/emc-emi.html","hash":"5b0d0119eafc594f11aececb95639b2fbd05d70e","modified":1689561616828},{"_id":"public/2023/04/heng-shan.html","hash":"080fb5418cf71c86da83b77c612737e9380d7a66","modified":1689561616828},{"_id":"public/2023/04/shen-zhen-wu-tong-shan-mao-mian-du-juan.html","hash":"035619290a0bffc613b3310d41d3f08de1d7ae5e","modified":1689561616828},{"_id":"public/2023/04/shang-hai.html","hash":"f48821dfa17db95c70968f3aba75be278fecaa72","modified":1689561616828},{"_id":"public/2023/04/xin-jiang.html","hash":"cc7b011ff60b4d67841241973eb405b696c87bf9","modified":1689561616828},{"_id":"public/2022/01/linux-input-zi-xi-tong.html","hash":"786ba90d677f3425582c7f77ce06276d92b65769","modified":1689561616828},{"_id":"public/2022/01/linux-xian-cheng.html","hash":"e2f4176ed4434700eb32eb3cb663ee3190488b27","modified":1689561616828},{"_id":"public/2022/01/imx6ull-yi-zhi-lvgl-zong-jie.html","hash":"ca822b1437f564d09d2e882e14255d0fa5d97f57","modified":1689561616828},{"_id":"public/2022/01/zhong-hua-tong-shi-shang-gu-shi-xia.html","hash":"2df11c1ab472e595fc90a9e1f82cf7a931035c5d","modified":1689561616828},{"_id":"public/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou.html","hash":"d3c607877716ef80b752087e5f62a47f15b70ffd","modified":1689561616829},{"_id":"public/2022/01/python-shi-yong-bai-du-fan-yi-de-api.html","hash":"de6e1fe1b6abd3ed11950759ab66bcf7ddb22712","modified":1689561616829},{"_id":"public/2022/01/chao-xiang-xi-jie-xi-python-pa-qu-wai-wang-tu-pian.html","hash":"f17c1d3b16ca888b2f46e9b07cd7a900189aa2a2","modified":1689561616829},{"_id":"public/archives/page/2/index.html","hash":"8ceb7fa5e2f677e6a9dabf2d4079dd403c2d456c","modified":1689561616829},{"_id":"public/archives/2022/index.html","hash":"a69656f6866e6924b5a9b04ae85a90507701becc","modified":1689561616829},{"_id":"public/archives/2022/01/index.html","hash":"14bad386737e342cf1c621d76bf9b3171abd87e1","modified":1689561616829},{"_id":"public/archives/2023/index.html","hash":"4f53a9a87784128db1251aaaa9a26bf2907931dd","modified":1689561616829},{"_id":"public/archives/2023/page/2/index.html","hash":"4e6b0c7ef3626c7dcc4e64685f8af765d9a929e3","modified":1689561616829},{"_id":"public/archives/2023/04/index.html","hash":"79be3060872454c77d58225dabb02706262acada","modified":1689561616829},{"_id":"public/archives/2023/05/index.html","hash":"8e703450d05d6065b953e208f435e630aceb4baa","modified":1689561616829},{"_id":"public/archives/2023/06/index.html","hash":"df6ab37ac485a38dae2bf406d3b2f60ee82896e4","modified":1689561616829},{"_id":"public/archives/2023/07/index.html","hash":"ab315a652d5ab00c83390a14b1ace4f0ae1e1319","modified":1689561616829},{"_id":"public/categories/linux/index.html","hash":"d8de4f9f677c4f500d612beeb96a05defd3494c7","modified":1689561616829},{"_id":"public/categories/python/index.html","hash":"aa1166f3044407bc4a7f6afec938515d14a9f14d","modified":1689561616829},{"_id":"public/categories/history/index.html","hash":"1f27c2c1483f246b6a89acc588bc8f37b2e2995b","modified":1689561616829},{"_id":"public/categories/Embedded-system/index.html","hash":"3a04bd34e6a2522807e87d52faf4014d87feb54a","modified":1689561616829},{"_id":"public/categories/硬件/index.html","hash":"fe2f2e4a798fe8f56b866629b578835d9550e7e5","modified":1689561616829},{"_id":"public/categories/gallery/index.html","hash":"5f01bc32763233c8a0b80dc510a728bbfad629c3","modified":1689561616829},{"_id":"public/categories/study/index.html","hash":"9fa0862065bdc8f1ef5526788e3a6a96fa078bf7","modified":1689561616830},{"_id":"public/index.html","hash":"adaeefec33f6411a5f0d58db218f03a0dd1e00be","modified":1689561616830},{"_id":"public/page/2/index.html","hash":"4716e238d7eb7ffacd06a4a712c71ac092325d14","modified":1689561616830},{"_id":"public/tags/linux/index.html","hash":"caf5cd2eb51efa88cf43da8fe1c8e5c6b2dc3ed3","modified":1689561616830},{"_id":"public/tags/input/index.html","hash":"4f31a263135a2afbd946eb082bf4f58e3305de4b","modified":1689561616830},{"_id":"public/tags/imx6ull/index.html","hash":"1b6e70b44eef18c956d489ccb67b6f139a4f7180","modified":1689561616830},{"_id":"public/tags/python/index.html","hash":"545f3977607073c8499434bcd90e10b4fa28a390","modified":1689561616830},{"_id":"public/tags/thread/index.html","hash":"eede834467e34722655b88ef745f128542723954","modified":1689561616830},{"_id":"public/tags/history/index.html","hash":"a602f96b9ad313419add16d2604cd3ca77b3c865","modified":1689561616830},{"_id":"public/tags/Embedded-system/index.html","hash":"66043901ae70866bc9d258d96d2fc6a9da834836","modified":1689561616830},{"_id":"public/tags/EMC-EMI/index.html","hash":"425bcb191a8eb3b1aefadf2d54be83f3c6228ba7","modified":1689561616830},{"_id":"public/tags/gallery-腾格里/index.html","hash":"827de0a33769539aea072fbe9770092afbfed224","modified":1689561616830},{"_id":"public/tags/gallery-上海/index.html","hash":"9510c69ffcd505a10ea96c7ca699429caf1a9559","modified":1689561616830},{"_id":"public/tags/gallery-北京/index.html","hash":"b2e8ecea878ea3e591d6dd6ce1f644540821e160","modified":1689561616830},{"_id":"public/tags/gallery-新疆/index.html","hash":"4f16f3501caea8620c080c82b45861641223aff0","modified":1689561616830},{"_id":"public/tags/gallery-深圳梧桐山-毛棉杜鹃/index.html","hash":"1fe2b95c93a78b8088ce0cf6e276082b04641399","modified":1689561616830},{"_id":"public/tags/gallery-衡山/index.html","hash":"35b7a19ff1093b23c9ae45296d6cafb9ae47b69e","modified":1689561616830},{"_id":"public/tags/模块/index.html","hash":"aec88b1ff560ed210cb233dae8c0c16dc0885cd3","modified":1689561616830},{"_id":"public/tags/PIN-GPIO/index.html","hash":"b24acea40d176eb966f92178ab65c03400db925c","modified":1689561616830},{"_id":"public/tags/tool目录/index.html","hash":"30458f0b4f75b43e6828493f1418e6c3b41d3ad0","modified":1689561616830},{"_id":"public/tags/study/index.html","hash":"8256dfa9de95067d3ff7fcf1b7ec9a89f726ecba","modified":1689561616830},{"_id":"public/tags/platform/index.html","hash":"9d5dd6662d178a0cd5cf7a5ad6246ecf062b9ba1","modified":1689561616830},{"_id":"public/CNAME","hash":"4740c94df1240b26efd774d065f3ae8ef5c24b7c","modified":1689561616853},{"_id":"public/robots.txt","hash":"96afc2fc25d1e9121f5eae9eaef811cd1ac04208","modified":1689561616854},{"_id":"public/medias/loading.svg","hash":"6c54fec96e2dfe43c027a2e4bcc7c80f00d0e873","modified":1689561616854},{"_id":"public/medias/featureimages/9.jpg","hash":"2e1ac235e6a6d80dbed651f993f319c1ed4b5925","modified":1689561616854},{"_id":"public/medias/avatars/csdn.ico","hash":"fff55f10e98084a888ac0b346ccdf0dbaad2ccb1","modified":1689561616854},{"_id":"public/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1689561616854},{"_id":"public/libs/lightGallery/fonts/lg.svg","hash":"9a732790adc004b22022cc60fd5f77ec4c8e3e5a","modified":1689561616854},{"_id":"public/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1689561616854},{"_id":"public/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1689561616854},{"_id":"public/libs/lightGallery/img/video-play.png","hash":"fbfdbe06aebf7d0c00da175a4810cf888d128f11","modified":1689561616854},{"_id":"public/libs/lightGallery/img/youtube-play.png","hash":"39150b45ec5fc03155b7ebeaa44f1829281788e2","modified":1689561616854},{"_id":"public/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1689561616854},{"_id":"public/libs/lightGallery/img/vimeo-play.png","hash":"1142b47de219dddfba2e712cd3189dec0c8b7bee","modified":1689561616854},{"_id":"public/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1689561616854},{"_id":"public/libs/share/fonts/iconfont.svg","hash":"f0a1b849868a6bf351ff98dc3924a4e7254eb88b","modified":1689561616854},{"_id":"public/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1689561616854},{"_id":"public/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1689561616854},{"_id":"public/medias/music/avatars/不见就散-周深.jpg","hash":"c0611b3db7a0acb91c8d1972e6ffe99545289bc8","modified":1689561616854},{"_id":"public/medias/music/avatars/平凡之路-朴树.jpg","hash":"70d026f8ff9df7a5427e75e58c4b8bc6c637d85f","modified":1689561616854},{"_id":"public/2022/01/linux-xian-cheng/2909691-20221018201940242-320806714.png","hash":"e303ca7352b7cb92f2f9a6e68a42a53f40f0a5e0","modified":1689561616854},{"_id":"public/2022/01/linux-xian-cheng/2909691-20221018202536805-171723429.png","hash":"19ee436b75c2365a5d9b0fe3692a743a6e49c952","modified":1689561616854},{"_id":"public/2022/01/linux-input-zi-xi-tong/2909691-20220819102740731-2036281828.png","hash":"620ca1c5e896674be2123b19c639bc542af82caf","modified":1689561616854},{"_id":"public/2022/01/linux-xian-cheng/2909691-20221018204634847-2097816257.png","hash":"11e873440e4adc189ebe3f537f9ef2e5e95e30ba","modified":1689561616854},{"_id":"public/2022/01/linux-input-zi-xi-tong/2909691-20220819094250974-180404869.webp","hash":"f2c6a92fb8d6c71167d08db4814ac8978264f149","modified":1689561616854},{"_id":"public/2022/01/linux-input-zi-xi-tong/input_logical.png","hash":"745413f59d688e5a390a23fc26d5cbba1bee74bf","modified":1689561616854},{"_id":"public/2022/01/python-shi-yong-bai-du-fan-yi-de-api/20200302120105912.png","hash":"60d73aec104782b1e3626b0ae5b695e6b2f44134","modified":1689561616855},{"_id":"public/2022/01/python-shi-yong-bai-du-fan-yi-de-api/20200302115943813.png","hash":"d732381420174bf2f792dc34b3f5b3b56bfc2fe8","modified":1689561616855},{"_id":"public/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928153140065-1807119912.png","hash":"81814544b47e2371c6174d2d78a40c6dc1ec97ee","modified":1689561616855},{"_id":"public/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928153451220-1274979267.png","hash":"38e44ea1bf27b199f03e40d3fbb31ca92a9560b1","modified":1689561616855},{"_id":"public/2023/04/emc-emi/2023-04-04_19-32-29.png","hash":"5cf52b16fc4970dd256fb8ab707a8988e6fea828","modified":1689561616855},{"_id":"public/2023/04/emc-emi/2023-04-04_19-33-48.png","hash":"e5f260152656763228b8ef179d47a2ad485802f9","modified":1689561616855},{"_id":"public/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329193127889.jpg","hash":"7a0511fab61dec9617ff13e3e30955a7b37f0930","modified":1689561616855},{"_id":"public/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329195920218.jpg","hash":"20699b111e09083edc68e80f86e2238c4c5b703d","modified":1689561616855},{"_id":"public/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329200632579.png","hash":"cd08c7532ef0acf9b9406d0794195926408d8b0a","modified":1689561616855},{"_id":"public/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329202358795.png","hash":"cdfc62f3ea8e38679c1a804d2aad822b1bcc1a36","modified":1689561616855},{"_id":"public/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329202548677.png","hash":"af1c46bdb03c03fa55002639807e158ac3ab6868","modified":1689561616855},{"_id":"public/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329203335481.png","hash":"d8ae5f3ea833f6f627c8d7006a0a886753a3b908","modified":1689561616855},{"_id":"public/2023/06/linux-nei-he-tool-mu-lu/tool目录.png","hash":"e0941cce6adf15e087d9484b4e126716ae2549f6","modified":1689561616855},{"_id":"public/2023/07/linux-platform/device-driver.png","hash":"d1a74b75fbd655681620df04a09a2a81e07060e2","modified":1689561616855},{"_id":"public/2023/04/ye-wu-gong-neng-ye-wu-liu-cheng-ye-wu-gui-ze-fen-xi/模板.png","hash":"e67a71845dfd7a98e4959b97df24d50a8da41177","modified":1689561616855},{"_id":"public/2023/04/ye-wu-gong-neng-ye-wu-liu-cheng-ye-wu-gui-ze-fen-xi/分析起步.png","hash":"f597a655cc0aff1ed6aaf5a19380957ba362fde6","modified":1689561616855},{"_id":"public/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/22c7469876239933b38a12a32e9c6f16.png","hash":"e0ac3751ad221d95718ae7ff26ebf073bb9594f1","modified":1689561616855},{"_id":"public/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/60a0b6815e87242adbc049d64b96e01b.png","hash":"d57950b2bab69769bd372eb0ab86a71f7cb28d27","modified":1689561616855},{"_id":"public/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/780552b6b4ceacfe274a8c687b74a569.png","hash":"579c26e4342cdae2ba4404f04781a4b4839e4dc7","modified":1689561616855},{"_id":"public/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/e7176066eab77c0cf6e147aed0046ea7.png","hash":"63576e1bd997584873acae29976472105d199fdb","modified":1689561616855},{"_id":"public/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/dc4e3ddfdab5a0456af40df7d0a9238b.png","hash":"782eae366eeb181d32de302b4d0f4416a6fefbfc","modified":1689561616855},{"_id":"public/2023/04/xin-jiang/2d25bdf0ce35910c874badcedff928002.JPG","hash":"dfb9275edaa0886abb505911f112165b5aea21e1","modified":1689561616855},{"_id":"public/css/prism-tomorrow.css","hash":"3b99487dfc9b4e51e9105a93743b92a761840e34","modified":1689561616856},{"_id":"public/medias/featureimages/14.jpg","hash":"164bda04d4ef6ae75f149c2e822d0d0f0b79e15c","modified":1689561616873},{"_id":"public/medias/featureimages/15.jpg","hash":"867c9882842f84290ba173292d551a626106a45d","modified":1689561616875},{"_id":"public/medias/featureimages/21.jpg","hash":"9ad4b78782e69f0ace50f76daa7a4bd687738332","modified":1689561616876},{"_id":"public/medias/featureimages/27.jpg","hash":"ea65367dab59059c343cd0a211f41ca4bd0dc2c9","modified":1689561616876},{"_id":"public/medias/featureimages/35.jpg","hash":"2f001a7d045a952ba059eb3575664347ebbf4d1f","modified":1689561616876},{"_id":"public/medias/featureimages/36.jpg","hash":"a71a869c98c68123e94706fa970333235990f0ab","modified":1689561616876},{"_id":"public/medias/featureimages/38.jpg","hash":"fc728ac4c69d06e911bbc4d6cba9c9ef1b158b9f","modified":1689561616877},{"_id":"public/medias/featureimages/37.jpg","hash":"515fd43e0acddf316a5753ea1cdc259c9571eec6","modified":1689561616877},{"_id":"public/medias/featureimages/47.jpg","hash":"ee4de6373759e67d96c0fe7237620ccdd190f188","modified":1689561616877},{"_id":"public/libs/awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1689561616877},{"_id":"public/libs/awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1689561616877},{"_id":"public/2022/01/zhong-hua-tong-shi-shang-gu-shi-xia/20210703105831609.png","hash":"6f74b0d301ff93d020a051b598c1843023c8a60f","modified":1689561616877},{"_id":"public/2022/01/zhong-hua-tong-shi-shang-gu-shi-xia/20210703105920999.png","hash":"e6a74917abe403a8adca2103d264f2b532765b96","modified":1689561616877},{"_id":"public/2022/01/python-shi-yong-bai-du-fan-yi-de-api/20200302113654396.png","hash":"0eb46311fe5eee6803493cec10c082d2acef996b","modified":1689561616877},{"_id":"public/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928151916481-1456634923.png","hash":"1a6e87f307777f98d725943978c00efb4090c0ba","modified":1689561616877},{"_id":"public/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928152957065-501054685.png","hash":"02e70dd300ead042177d527aebf566eb8ebec4fc","modified":1689561616877},{"_id":"public/2023/04/emc-emi/2023-04-04_19-28-04.png","hash":"e95e091152fa0c866d73f5014c48cf5a62f54719","modified":1689561616877},{"_id":"public/2023/04/emc-emi/2023-04-04_19-33-05.png","hash":"7477c974bab91a2621066e5f826da10bf3f970c9","modified":1689561616877},{"_id":"public/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329201646615.png","hash":"33a6c6a068648814992c82eaeab0d798cd05258e","modified":1689561616877},{"_id":"public/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329203021908.png","hash":"0648ca9586b7a83463ad4f12efc003231171b681","modified":1689561616877},{"_id":"public/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329203626594.png","hash":"3e9af02ca14cc9e5098b1b148583dee50e0a28b8","modified":1689561616877},{"_id":"public/2023/06/linux-nei-he-tool-mu-lu/menuconfig.png","hash":"d9715c99899d7d2ec1557e648f00a36d55032858","modified":1689561616877},{"_id":"public/2023/04/heng-shan/20230403161331.jpg","hash":"a452aeceed392945bd8cf528b00b0f6475a6f7cd","modified":1689561616877},{"_id":"public/2023/04/heng-shan/20230403161404.jpg","hash":"1c641d5779759d0d48bd33a9e4c2020b7c51cde7","modified":1689561616877},{"_id":"public/2023/04/heng-shan/20230403161412.jpg","hash":"525c7afb118f1c0052078119b3ca24df7d5101f4","modified":1689561616878},{"_id":"public/2023/05/pin-gpio/Pinctrl.png","hash":"9bdf584dbb8e6fb33546aa917b3bd76790337d3b","modified":1689561616878},{"_id":"public/2023/05/pin-gpio/imx6ull pinctrl.png","hash":"28d5e0d8c17c46bff684820293b1028d8e8752b5","modified":1689561616878},{"_id":"public/2023/05/pin-gpio/iomuxc.png","hash":"d0d101818eb5c21c45e6ed4a033de957e1cb9795","modified":1689561616878},{"_id":"public/2023/05/pin-gpio/pinctrl_system.png","hash":"8a57a4a6e04e1171f13fcedb6d0fac2fe58fbd5f","modified":1689561616878},{"_id":"public/2023/05/pin-gpio/probe.png","hash":"9d21cfe994d9a48e7442f91f0fb6e59fea403795","modified":1689561616878},{"_id":"public/2023/04/ye-wu-gong-neng-ye-wu-liu-cheng-ye-wu-gui-ze-fen-xi/主干流程.png","hash":"f4a5350223b0e86788af65ad517ef1302feed1e7","modified":1689561616878},{"_id":"public/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/2dd308b3411c41658cce041f8c230853.png","hash":"4c66e0a781c7319210351bef8458dce004c1d3df","modified":1689561616878},{"_id":"public/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/32643a6fbe010dcc95af301416619164.png","hash":"cdbf520cd2419b7cdc97569c1d38e81ea6c2186e","modified":1689561616878},{"_id":"public/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/6aadad4da134377249d84bab5dbdfa8d.png","hash":"74983111bde7189cb23f4ee194c3d6e3e0ddde3f","modified":1689561616878},{"_id":"public/css/gitment.css","hash":"2bd15cc17dca35ac3ecc0acf167a23a1dd362acd","modified":1689561616896},{"_id":"public/css/my-gitalk.css","hash":"eeda46a83d0db1cc239a9cd27d544faf663f9883","modified":1689561616896},{"_id":"public/js/click_show_text.js","hash":"613c5e7851df10317da8ac50ec91b26a3e2ef372","modified":1689561616901},{"_id":"public/js/matery.js","hash":"c5a9c4fae16126cae80719e7435705840718b628","modified":1689561616901},{"_id":"public/js/search.js","hash":"499e11786efbb04815b54a1de317cc8606a37555","modified":1689561616901},{"_id":"public/css/my.css","hash":"405d61aa393c79aeb2033ef227fc7beb7b20eff6","modified":1689561616901},{"_id":"public/libs/aos/aos.js","hash":"02bfb40b0c4b6e9b0b4081218357145cbb327d74","modified":1689561616901},{"_id":"public/libs/aplayer/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1689561616901},{"_id":"public/libs/codeBlock/codeBlockFuction.js","hash":"c7ab06d27a525b15b1eb69027135269e9b9132fb","modified":1689561616901},{"_id":"public/libs/codeBlock/codeCopy.js","hash":"b74a381adf6ef8404d6a0452c2b9f44b47219c80","modified":1689561616901},{"_id":"public/libs/codeBlock/codeShrink.js","hash":"215910dc8f63fd50b97957e5fcdc8480aa2728cb","modified":1689561616901},{"_id":"public/libs/codeBlock/codeLang.js","hash":"ea8b51e4d75e7b2cd63e4d5bcb8db2cf7f23f5db","modified":1689561616901},{"_id":"public/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"257eaae3020599e4939f50d5008a743827f25b8c","modified":1689561616903},{"_id":"public/libs/jqcloud/jqcloud.css","hash":"20d9f11a19d95c70e27cb922e0d6dccbec4eae89","modified":1689561616903},{"_id":"public/libs/others/explosion.min.js","hash":"417b68e2cf2c6de2119c57626f4412105a8457f5","modified":1689561616903},{"_id":"public/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1689561616903},{"_id":"public/libs/others/text.js","hash":"1791782cde0d1e4197f2ed58ecb7dd6aefddd169","modified":1689561616903},{"_id":"public/libs/others/fireworks.js","hash":"53981959bc6def4a85bbbb41b07e4b1474a2124d","modified":1689561616903},{"_id":"public/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1689561616905},{"_id":"public/libs/tocbot/tocbot.css","hash":"15601837bf8557c2fd111e4450ed4c8495fd11a0","modified":1689561616906},{"_id":"public/libs/others/snow.js","hash":"7f3b1ad2f64d4473210a2c3218893649c73c980e","modified":1689561616906},{"_id":"public/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1689561616906},{"_id":"public/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1689561616906},{"_id":"public/libs/share/css/share.min.css","hash":"8a778a86f3ce9a042df6be63a9f1039631e351a5","modified":1689561616906},{"_id":"public/css/matery.css","hash":"9177986b225313e4a986a9ff35085104e5886b2a","modified":1689561616906},{"_id":"public/libs/animate/animate.min.css","hash":"97afa151569f046b2e01f27c1871646e9cd87caf","modified":1689561616906},{"_id":"public/libs/aos/aos.css","hash":"191a3705a8f63e589a50a0ff2f2c5559f1a1b6b2","modified":1689561616906},{"_id":"public/libs/codeBlock/clipboard.min.js","hash":"9cd57c67fbd3e3067f80793ef8445f5ff7783563","modified":1689561616906},{"_id":"public/libs/cryptojs/crypto-js.min.js","hash":"5989527a378b55011a59522f41eeb3981518325c","modified":1689561616906},{"_id":"public/libs/dplayer/DPlayer.min.css","hash":"f7d19655f873b813ffba5d1a17145c91f82631b8","modified":1689561616906},{"_id":"public/libs/gitalk/gitalk.css","hash":"3aac1db83b0135c521187254ff302d125cc30706","modified":1689561616906},{"_id":"public/libs/gitment/gitment-default.css","hash":"2903c59ee06b965bef32e937bd69f5b0b2190717","modified":1689561616906},{"_id":"public/libs/masonry/masonry.pkgd.min.js","hash":"ff940b4ea68368ca0e4d5560cbb79fb147dfc3c5","modified":1689561616906},{"_id":"public/libs/aplayer/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1689561616906},{"_id":"public/libs/gitment/gitment.js","hash":"28c02c45ce568e084cd1041dc493f83f9c6c88c6","modified":1689561616906},{"_id":"public/libs/jquery/jquery-2.2.0.min.js","hash":"5d7e5bbfa540f0e53bd599e4305e1a4e815b5dd1","modified":1689561616907},{"_id":"public/libs/dplayer/DPlayer.min.js","hash":"c3bad7b265574fab0ae4d45867422ea1cb9d6599","modified":1689561616907},{"_id":"public/libs/valine/Valine.min.js","hash":"4e34802ccbb59f1daa58a62241ff57f923e50600","modified":1689561616907},{"_id":"public/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1689561616908},{"_id":"public/libs/share/js/social-share.min.js","hash":"4df722bafde2c5d8faaace0d1f894798385a8793","modified":1689561616908},{"_id":"public/libs/materialize/materialize.min.css","hash":"4d46df5f22cbc24eefa76228c7ee308dc3585594","modified":1689561616908},{"_id":"public/libs/share/js/jquery.share.min.js","hash":"16ce82901ca0e302cf47a35fb10f59009a5e7eb9","modified":1689561616908},{"_id":"public/libs/materialize/materialize.min.js","hash":"c8b4c65651921d888cf5f27430dfe2ad190d35bf","modified":1689561616908},{"_id":"public/libs/valine/av-min.js","hash":"2577e72b52b736d99649f9e95be8976d58563333","modified":1689561616908},{"_id":"public/libs/awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1689561616908},{"_id":"public/libs/lightGallery/js/lightgallery-all.min.js","hash":"9f5ef4bc8a0a3c746ca4f3c3e6d64493b1a977d8","modified":1689561616908},{"_id":"public/medias/featureimages/10.jpg","hash":"53f3eb05edab87ee07c889f26fc550e9b5e5cb91","modified":1689561616908},{"_id":"public/medias/featureimages/11.jpg","hash":"4e4ed3d6f8466b3362cbaaa04dc31b8859d3e202","modified":1689561616908},{"_id":"public/medias/featureimages/16.jpg","hash":"87100d52e5077c77f9e74856a1c5330d81708ae3","modified":1689561616909},{"_id":"public/medias/featureimages/23.jpg","hash":"c2f1f9387db7dd99d3c0e4df42a160d482dde5bd","modified":1689561616909},{"_id":"public/medias/featureimages/24.jpg","hash":"33fc0af42186fa2c0e41712d5e45c716dd47bce6","modified":1689561616909},{"_id":"public/medias/featureimages/28.jpg","hash":"565fb296d8e4e2e520d6f15985f1de33d7bd98c8","modified":1689561616910},{"_id":"public/medias/featureimages/29.jpg","hash":"a8ff01c7f29be6d703040fad7889f5afba1eb844","modified":1689561616910},{"_id":"public/medias/featureimages/31.jpg","hash":"50eedc29287470f333612e6f71d88c3121357257","modified":1689561616910},{"_id":"public/medias/featureimages/30.jpg","hash":"6dfe6d277ec3ef36e8c958a71712702a5be3e4d8","modified":1689561616910},{"_id":"public/medias/featureimages/33.jpg","hash":"851fadf999b21c4e42d7a5e4114a10abd21f81cd","modified":1689561616910},{"_id":"public/medias/featureimages/43.jpg","hash":"76bf6095d8e92aa5d6a4e2dff4c2d710c61da07e","modified":1689561616910},{"_id":"public/medias/featureimages/8.jpg","hash":"b04f9b49261b2486260e64e6543da45689e272de","modified":1689561616911},{"_id":"public/medias/reward/wechat.jpg","hash":"010a7b4eaf2113af7660fab39f7b7d2dc2fb314e","modified":1689561616911},{"_id":"public/medias/featureimages/0.jpg","hash":"4e9f83cbe1575a44fe9315f937e7505ed05b6920","modified":1689561616911},{"_id":"public/medias/featureimages/1.jpg","hash":"aaf5863bed7563a86a6da15cef0b5d44740e449c","modified":1689561616911},{"_id":"public/medias/featureimages/6.jpg","hash":"e0eb036bf77aacc91dffea2d75f590f9f1b2b961","modified":1689561616911},{"_id":"public/libs/awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1689561616911},{"_id":"public/libs/awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1689561616911},{"_id":"public/libs/awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1689561616911},{"_id":"public/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928152209724-1097250473.png","hash":"05d498f7f30591101a53a8c5c95924ff1a84001d","modified":1689561616911},{"_id":"public/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928152945955-899676295.png","hash":"9714cee9d41e446e660bc06e1908adad5edd6258","modified":1689561616911},{"_id":"public/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928153305849-1048335725.png","hash":"aeee98d5b5d62bc471f881b6482100864635f667","modified":1689561616911},{"_id":"public/2022/01/linux-input-zi-xi-tong/2909691-20220819093409715-1604400596.png","hash":"55b9667906c85b6e35a8306dec17b969ece62590","modified":1689561616912},{"_id":"public/2023/04/bei-jing/IMG_6716.JPG","hash":"99ff60c734012614ac5407d15ead6311fc76c8fb","modified":1689561616912},{"_id":"public/2022/01/python-shi-yong-bai-du-fan-yi-de-api/20200302113313981.png","hash":"a3bc848fc823b39cb9304360dabc4113a61ebb40","modified":1689561616912},{"_id":"public/2023/04/xin-jiang/1b706b934fc955412e3ed163fd0b7cbc2.JPG","hash":"197d9abf8cb2a83ba7f92192e339ebdef533f956","modified":1689561616912},{"_id":"public/2023/04/xin-jiang/89c05a76a9273811c585c395890c9f522.JPG","hash":"acd08647f23bdbabb1f68cc061086d71df0dccd8","modified":1689561616912},{"_id":"public/2023/04/heng-shan/20230403161419.jpg","hash":"d52eba8c569ccd38a42589d5feccbad599bdb78e","modified":1689561616912},{"_id":"public/2023/05/pin-gpio/gpio.png","hash":"bad8a6af0e809665e3d511cf24ab38f173abf2d0","modified":1689561616912},{"_id":"public/2022/01/zhong-hua-tong-shi-shang-gu-shi-xia/20210703111602157.png","hash":"eed4aad178595cbb24f9d33be2b6b893d29ebe07","modified":1689561616912},{"_id":"public/2023/04/emc-emi/2023-04-04_19-34-25.png","hash":"7dcff810f530ee4d40ee76651268a3c473f7d5ed","modified":1689561616913},{"_id":"public/2023/04/ye-wu-gong-neng-ye-wu-liu-cheng-ye-wu-gui-ze-fen-xi/探索分支.png","hash":"3cf5793d9bf2b409bd939c0e485c6e23c7f3d28a","modified":1689561616913},{"_id":"public/2022/01/zhong-hua-tong-shi-shang-gu-shi-xia/20210703105815619.png","hash":"ed38e99ca771a664503c1fc241b65609b190a652","modified":1689561616913},{"_id":"public/2023/06/ttymxx-uart/cat-proc-devices.png","hash":"d7b01cb33a859dca9532928d23f626d7e9406c71","modified":1689561616913},{"_id":"public/2023/04/ye-wu-gong-neng-ye-wu-liu-cheng-ye-wu-gui-ze-fen-xi/业务规则上.png","hash":"106e7b83de735bd1506057f05bded3f5b3f5fd1f","modified":1689561616913},{"_id":"public/libs/gitalk/gitalk.min.js","hash":"564fc7c731d05fa70d71ef853a2c8cc7725739e2","modified":1689561616926},{"_id":"public/libs/echarts/echarts.min.js","hash":"9496f386a0da4601cad22c479cc5543913a4d67f","modified":1689561616926},{"_id":"public/medias/featureimages/2.jpg","hash":"8567da47271a81b74ca341d170e057bb42f42bf5","modified":1689561616926},{"_id":"public/medias/featureimages/20.jpg","hash":"e854df6ea24c22c999216db611dfd3785b76b834","modified":1689561616927},{"_id":"public/medias/banner/5.jpg","hash":"38272cddbb09c70c7785aed877f6c9b45a61262a","modified":1689561616927},{"_id":"public/medias/featureimages/18.jpg","hash":"b8108799fbf3eadf0462fba04034a277a462018b","modified":1689561616927},{"_id":"public/medias/featureimages/3.jpg","hash":"4cabac02df559a5eb1b9abc8a0359fe6573a738b","modified":1689561616927},{"_id":"public/medias/featureimages/32.jpg","hash":"e440f9bdcdff7c181904b26b2774c48632e4d24a","modified":1689561616927},{"_id":"public/medias/featureimages/34.jpg","hash":"6fca10e13cae2a089909ea266fa6be510e57a2bd","modified":1689561616927},{"_id":"public/medias/featureimages/45.jpg","hash":"5c22e8d627f763ebae1d080025aee103383a8460","modified":1689561616927},{"_id":"public/medias/featureimages/5.jpg","hash":"38272cddbb09c70c7785aed877f6c9b45a61262a","modified":1689561616927},{"_id":"public/medias/featureimages/7.jpg","hash":"26833abcdd65e10c48e8d0553cb3543d3e0ca4d8","modified":1689561616927},{"_id":"public/medias/reward/alipay.jpg","hash":"bf966a223684650a6c5f1bc5df6d571493e922f3","modified":1689561616927},{"_id":"public/medias/featureimages/26.jpg","hash":"9c2eaf5aff8abdc4e215af96002c8525be9ddd06","modified":1689561616928},{"_id":"public/medias/featureimages/4.jpg","hash":"d7139f883aad272d619ce181ebcd86672a2a7bdc","modified":1689561616928},{"_id":"public/medias/featureimages/48.jpg","hash":"13754e6efc8f6db46088d736ed2c290b0d9bfb33","modified":1689561616928},{"_id":"public/medias/featureimages/44.jpg","hash":"6bca5b340c7e16350e3040da2416f6184ccd64a4","modified":1689561616928},{"_id":"public/medias/featureimages/13.jpg","hash":"1eed284202ae51c4f3051d943b3d97a7602a9fc6","modified":1689561616928},{"_id":"public/medias/featureimages/22.jpg","hash":"2beb56f529f0ce49f36a84d55890b7c0de3d7705","modified":1689561616928},{"_id":"public/medias/featureimages/42.jpg","hash":"c05648a22e1f083d13f40e76fed535f027fae0b6","modified":1689561616928},{"_id":"public/medias/music/avatars/每天爱你多一些.jpg","hash":"2beb56f529f0ce49f36a84d55890b7c0de3d7705","modified":1689561616928},{"_id":"public/2022/01/python-shi-yong-bai-du-fan-yi-de-api/20200302112847600.png","hash":"7826ff6dbdf5ff34629750ce22b0e94cccadef69","modified":1689561616929},{"_id":"public/2023/04/bei-jing/IMG_6717.JPG","hash":"9bfb74c92dc7ea4217d2dd03624ef50acf2e5d38","modified":1689561616929},{"_id":"public/2023/04/shen-zhen-wu-tong-shan-mao-mian-du-juan/2b135a37c965e856f04d4a5faf8d2f2b2.JPG","hash":"f4165d53241b101e85fad7128831f04d684ad00a","modified":1689561616929},{"_id":"public/2023/06/ttymxx-uart/cat-ttymxc2.png","hash":"5847a4ae7a6b9dc2e40b772d68e265417b69cebc","modified":1689561616929},{"_id":"public/2022/01/python-shi-yong-bai-du-fan-yi-de-api/20200302112753932.png","hash":"6f7c69b14491228187f0b0d593687015b1751112","modified":1689561616929},{"_id":"public/2023/06/ttymxx-uart/ls-dev.png","hash":"b568d5d4f2dd4c06497e8bf3fd2c9c114cb807b7","modified":1689561616929},{"_id":"public/favicon.png","hash":"8d9bbc4559b4a7d594474fc59789436dd4c28adc","modified":1689561616941},{"_id":"public/medias/featureimages/39.jpg","hash":"2b914a3b098aa874f68b4fcda7c85613140c6420","modified":1689561616941},{"_id":"public/medias/featureimages/41.jpg","hash":"51ccac5c36201f1c04f66e5d54babbb21cf5dc5f","modified":1689561616941},{"_id":"public/medias/featureimages/46.jpg","hash":"1e73f8ed0bd91c4443c4f7e57d2ea5cf94d419c6","modified":1689561616941},{"_id":"public/medias/featureimages/12.jpg","hash":"29f884076a7fbed6900a1a05c41ffd3ce122a123","modified":1689561616941},{"_id":"public/medias/featureimages/17.jpg","hash":"4cbd4926b13132903c465685a127c577b56b2b8b","modified":1689561616942},{"_id":"public/2023/04/ye-wu-gong-neng-ye-wu-liu-cheng-ye-wu-gui-ze-fen-xi/业务规则.png","hash":"9096eaf502a8c77966e2ddba42aeca3d42a30c59","modified":1689561616942},{"_id":"public/medias/featureimages/25.jpg","hash":"97930cf52f9e68ccf24d26b383704ca4724dae34","modified":1689561616954},{"_id":"public/medias/banner/1.jpg","hash":"cd3fc47d2042a3277e4b375ad084365abdc28f5d","modified":1689561616954},{"_id":"public/medias/banner/2.jpg","hash":"c2980f75f2c047d0957e3c8227b3f8d84e67f752","modified":1689561616954},{"_id":"public/2022/01/chao-xiang-xi-jie-xi-python-pa-qu-wai-wang-tu-pian/20200302110709393.png","hash":"2ad2b400e4ac4b25e38c950980367bb6b7276066","modified":1689561616954},{"_id":"public/2023/04/xin-jiang/5d0b74a8910a3abba7e860149b9d40e12.JPG","hash":"ec0e0cd928032ca04d666abf09e657b401f8c286","modified":1689561616955},{"_id":"public/2023/04/heng-shan/20230403161440.jpg","hash":"de330e0d5f878351e1c4e01fd03e6646f47b7cd7","modified":1689561616955},{"_id":"public/2023/05/pin-gpio/pinctrl struct.png","hash":"8fb5c14e3e7b5a3819fd16cc07cead5aef72dae1","modified":1689561616955},{"_id":"public/2023/04/ye-wu-gong-neng-ye-wu-liu-cheng-ye-wu-gui-ze-fen-xi/穷尽分支.png","hash":"7af9f4b00d74e30e5821ba95a050baa41c7e37f9","modified":1689561616955},{"_id":"public/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/c7546c50623e8a8aa6ab33ead8fac6cb.png","hash":"a7316beb6a20159dfeb953c21713feeac78ac6ac","modified":1689561616955},{"_id":"public/medias/featureimages/40.jpg","hash":"7a69b037ce05312d9322fe3f11c4d645b88645aa","modified":1689561616962},{"_id":"public/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928152922659-1842915282.png","hash":"3e599491c205ce9c2473c7cb88ae34ffe5ed810c","modified":1689561616962},{"_id":"public/2023/04/emc-emi/2023-04-04_19-30-08.png","hash":"4affe9d70ae0f96d3e097dedefeb4d8c2255f202","modified":1689561616962},{"_id":"public/2023/04/emc-emi/2023-04-04_19-31-27.png","hash":"a548cc6c623a27b9b1ef07bf747c2f5846a1b8ad","modified":1689561616962},{"_id":"public/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329201443609.png","hash":"58a7a16ec9b08da3d87fb952be7b90fa42d40b8a","modified":1689561616962},{"_id":"public/2023/06/ttymxx-uart/ttymxc.png","hash":"37188802f04a32b89f1bebec4b86cdf8df87472b","modified":1689561616962},{"_id":"public/2023/04/bei-jing/DSC01699.JPG","hash":"88fd74c50d76197f25fcea4f145b0b7315afa381","modified":1689561616963},{"_id":"public/2023/04/xin-jiang/76d386e1b8eeeb85abab758cefc855e0.JPG","hash":"b5263a0698617a32ddcab1602d590abea3061540","modified":1689561616963},{"_id":"public/2023/04/xin-jiang/95d557eb4ef2235d74a45743be1b05842.JPG","hash":"4b854a6ecb431a313e93f8d48df7fd0044aa372c","modified":1689561616963},{"_id":"public/medias/banner/6.jpg","hash":"5be9274e63d6ac02607e3d659fd32532291385fa","modified":1689561616973},{"_id":"public/medias/banner/4.jpg","hash":"4d6f31f86966584360bcdbfecb6f6a2ec94f944d","modified":1689561616973},{"_id":"public/libs/awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1689561616973},{"_id":"public/2023/04/emc-emi/2023-04-04_19-32-59.png","hash":"f87f697280797d30f0e2f288829d1ef1e01679c5","modified":1689561616974},{"_id":"public/medias/logo.png","hash":"8d9bbc4559b4a7d594474fc59789436dd4c28adc","modified":1689561616982},{"_id":"public/medias/avatars/myzhihu.png","hash":"4a9aec7e236615e3b698adfd3b36bc34ec05e5c7","modified":1689561616982},{"_id":"public/2023/04/shen-zhen-wu-tong-shan-mao-mian-du-juan/7d011510a39a8f6e23429fa828448a7c2.JPG","hash":"e39b53d9c09ac1a17144d8bc8190636d516184fb","modified":1689561616983},{"_id":"public/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/e852708ffd1c78efd87949efa7b31592.png","hash":"278cedda4410f27e589063fce68238de6ca46b43","modified":1689561616983},{"_id":"public/2023/04/xin-jiang/88a98ae85a4705294439aca39ae07d672.JPG","hash":"efaf4595479444c71cb33287f510e15a97023d5e","modified":1689561616983},{"_id":"public/2023/04/xin-jiang/a2a9265c2707c16b5a1ca704a4d0856d.JPG","hash":"32140a32efde0712248d80606354ef18c8bdca95","modified":1689561616983},{"_id":"public/2023/04/xin-jiang/a51d80549e7edc0d1ba69a885aa946ff2.JPG","hash":"d035b1f8fc6fa4742360fa30519dc3c349c5eb9d","modified":1689561616983},{"_id":"public/2023/04/shen-zhen-wu-tong-shan-mao-mian-du-juan/0a32e20ee914cca207bd5e0446eca332.JPG","hash":"d8487b0b07b39733ff17269e2ab21b35290fc7d5","modified":1689561616990},{"_id":"public/2023/04/bei-jing/DSC01645.JPG","hash":"37aae358c05c3ebe858be7fde41a6d991c53ffac","modified":1689561616990},{"_id":"public/2023/04/bei-jing/DSC01821.JPG","hash":"427acd97f61076e72289f67d92116b5264d532b6","modified":1689561616990},{"_id":"public/medias/banner/0.jpg","hash":"73bae0e6812c46509b91e3155bd12ce8640b245a","modified":1689561616992},{"_id":"public/2023/04/emc-emi/2023-04-04_19-35-03.png","hash":"75a164a1aefb14493fd964ec6f1af67dad08dfad","modified":1689561617019},{"_id":"public/2023/04/heng-shan/20230403161427.jpg","hash":"edede76d7524dbff86198f9ed27af324e846a990","modified":1689561617019},{"_id":"public/2023/04/heng-shan/20230403161434.jpg","hash":"eb3aa00bd533848c1fcdc5b8978baa825c332a99","modified":1689561617020},{"_id":"public/2023/04/ye-wu-gong-neng-ye-wu-liu-cheng-ye-wu-gui-ze-fen-xi/业务规则下.png","hash":"b2d1bd226e043c5a49cf997d195eab5828624e2e","modified":1689561617037},{"_id":"public/medias/featureimages/49.jpg","hash":"90ad50712c339a89402a363288dcd355e98d0fbb","modified":1689561617042},{"_id":"public/2023/04/shen-zhen-wu-tong-shan-mao-mian-du-juan/6f19a8a8bff80c030eeba535032db0f6.JPG","hash":"247ba6417dab25febabd897888b92c780012a972","modified":1689561617042},{"_id":"public/2023/04/shen-zhen-wu-tong-shan-mao-mian-du-juan/f4e3370968454b29062472df853b648e.JPG","hash":"9527a20734ba33ad970d1c09e9c5af69148a9e36","modified":1689561617042},{"_id":"public/2023/04/bei-jing/DSC01755.JPG","hash":"45e044a7a2e818bc76bc695a2349c0220d2a6f43","modified":1689561617042},{"_id":"public/2023/04/bei-jing/DSC01827.JPG","hash":"93f303dcf1cb66fc7c46f1912cb33edc4fcc7c0c","modified":1689561617051},{"_id":"public/2023/04/shen-zhen-wu-tong-shan-mao-mian-du-juan/d2a7004a2e039c3f37d5fef10c7cc28a2.JPG","hash":"21997245573176ef723eae80b8337f1710d4a552","modified":1689561617055},{"_id":"public/2023/04/bei-jing/DSC01722.JPG","hash":"a50dcaff1db6ca1e6c7c746a580a96edf3695b61","modified":1689561617055},{"_id":"public/2023/04/bei-jing/DSC01687.JPG","hash":"0ca6df7cba2538cc3df7566e7652696abcbff8cf","modified":1689561617059},{"_id":"public/2023/04/bei-jing/DSC01697.JPG","hash":"e2bdc7040260ef7a9fafaf623a3f980e69faec27","modified":1689561617059},{"_id":"public/2023/04/xin-jiang/BBND3773.PNG","hash":"9d51e64746eaf562e333c0c58b1665c87b7e3c94","modified":1689561617065},{"_id":"public/2022/01/chao-xiang-xi-jie-xi-python-pa-qu-wai-wang-tu-pian/20200302111109517.png","hash":"3c1684024bc31494b116961152500c0109172a72","modified":1689561617071},{"_id":"public/2023/04/xin-jiang/6d0c92b575f36108df2062fda3b1e4ba2.PNG","hash":"b1520fdd30b641aad9016617c32119cd8ed82a27","modified":1689561617071},{"_id":"public/2023/04/xin-jiang/KNLN1045.PNG","hash":"9b81832789db7ed79eceb15cfd62958fe3c81f1e","modified":1689561617074},{"_id":"public/2023/04/ten-ge-li/6.jpg","hash":"7b0cbe85e3ac8f3bb07b151342332b577bf62c3b","modified":1689561617079},{"_id":"public/2023/04/xin-jiang/254bc46a6128338402204fa78f54b3e12.PNG","hash":"e41e37de90a7768a13e2c5094c4b930aa03a47eb","modified":1689561617084},{"_id":"public/2023/04/xin-jiang/50f3a54d039eb642be22bc25607e11ca2.PNG","hash":"81d8346d84e26f93cfdc42b386fcbe5346f645ea","modified":1689561617087},{"_id":"public/medias/banner/3.jpg","hash":"42a57b512acce7f09f122b6b8c4f85c3803cd438","modified":1689561617095},{"_id":"public/2023/04/ten-ge-li/5.jpg","hash":"8f369783db3afe07144f07bc27ab714853c3cfbb","modified":1689561617098},{"_id":"public/medias/music/不见就散-周深.mp3","hash":"c96c5ad02f4138acc75321d0651d776939a8410b","modified":1689561617111},{"_id":"public/2023/04/ten-ge-li/1.jpg","hash":"aa5cc837537f2d220f140380d8aa4deb88ebc328","modified":1689561617111},{"_id":"public/2023/04/ten-ge-li/4.jpg","hash":"65423da6e9df83013372da9c0144723480560524","modified":1689561617113},{"_id":"public/medias/music/每天爱你多一些-张学友.mp3","hash":"c4c9d37ac5b8012f0650fc6e1d414160bb6cbd5e","modified":1689561617132},{"_id":"public/2023/04/xin-jiang/MOVG5083.JPG","hash":"d735c13bacae84426c35f79b31f0d76e56b5dbcb","modified":1689561617138},{"_id":"public/2023/04/ten-ge-li/3.jpg","hash":"ebdd58409be4f13114b49aca45a14587d6d33f7f","modified":1689561617148},{"_id":"public/2023/07/linux-platform/platform.png","hash":"8bbaa84862913279d587bda57cb8cbe1f203a548","modified":1689561617151},{"_id":"public/2023/04/xin-jiang/YJUM1401.JPG","hash":"2298f67966321b94c232d69b82a5d0c3725c250b","modified":1689561617157},{"_id":"public/2023/04/xin-jiang/XRBQ0574.JPG","hash":"0a22babef32c3458bf6d3b132fc86fdb92df4ac1","modified":1689561617162},{"_id":"public/2023/04/ten-ge-li/2.jpg","hash":"a67afd08d4cfc6ad6f1df81d6b9f6799ddaf2b5d","modified":1689561617165},{"_id":"public/2023/04/xin-jiang/ANKG1449.JPG","hash":"5baaa1ab9105091d0118f76229cef42117d346d3","modified":1689561617165},{"_id":"public/2023/04/shang-hai/20230403160809.jpg","hash":"c00d70be19d150a3e7852ba2bf0eb43d79b5af8e","modified":1689561617169},{"_id":"public/2023/04/xin-jiang/IGAX1811.JPG","hash":"b28a4910831f07c5d9a24e7a89f1a13a89c4e499","modified":1689561617171},{"_id":"public/2023/04/ten-ge-li/IMG_6912.JPG","hash":"cf10a567bf3ebbe495dbefef9766d64f40838583","modified":1689561617185},{"_id":"public/2023/04/xin-jiang/AZQE3071.JPG","hash":"ec500582aece897e57480cf258033db9afa09b4d","modified":1689561617187},{"_id":"public/2023/04/xin-jiang/AQSR2937.JPG","hash":"803cbcd9795224d0fe0f955a183097d5841e7e4a","modified":1689561617187},{"_id":"public/2023/04/xin-jiang/BBOD4958.JPG","hash":"d91a8e27fa87b395cf945e442e26b5afa5958529","modified":1689561617212},{"_id":"public/2023/04/ten-ge-li/IMG_6899.JPG","hash":"a83cb2a77b6e0783769e8db226b18ee12b684015","modified":1689561617223},{"_id":"public/2023/04/shang-hai/20230403160820.jpg","hash":"67c97c223cf033355d5f224595e474000472c8ee","modified":1689561617236},{"_id":"public/medias/music/平凡之路-朴树.mp3","hash":"fab92512ec9c0cdc2ea41889f440084c86786e05","modified":1689561617245},{"_id":"public/2023/04/shang-hai/20230403160752.jpg","hash":"1dd95e72274267e787dd795d8f25325365be8976","modified":1689561617248},{"_id":"public/2023/04/ten-ge-li/IMG_7069.JPG","hash":"54e10986b7f644c3f58d7231c4083ba7bf6b5934","modified":1689561617252},{"_id":"public/2023/04/shang-hai/20230403160815.jpg","hash":"4791996fab30c9e1b0a57b5362fa19252382924a","modified":1689561617256}],"Category":[{"name":"linux","_id":"clk69d1ct0009jsrj4ao2gxrz"},{"name":"python","_id":"clk69d1d3000jjsrjv0k2d4j4"},{"name":"history","_id":"clk69d1d7000rjsrjot4rwcwg"},{"name":"Embedded system","_id":"clk69d1dc000vjsrjz9pk2tsw"},{"name":"硬件","_id":"clk69d1di0013jsrj9x2cvxop"},{"name":"gallery","_id":"clk69d1di0019jsrjafpvi4d6"},{"name":"study","_id":"clk69d1et002kjsrjmnt4gqxo"}],"Data":[{"_id":"musics","data":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}],"Page":[{"title":"404","date":"2019-07-19T08:41:10.000Z","type":"404","layout":"404","description":"你来到了没有知识的荒原 :(","_content":"","source":"404.md","raw":"---\ntitle: 404\ndate: 2019-07-19 16:41:10\ntype: \"404\"\nlayout: \"404\"\ndescription: \"你来到了没有知识的荒原 :(\"\n---\n","updated":"2023-04-04T09:24:10.127Z","path":"404.html","comments":1,"_id":"clk69d18l0000jsrjid8jw1nv","content":"","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":""},{"title":"categories","date":"2020-01-01T08:39:20.000Z","type":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2020-01-01 16:39:20\ntype: \"categories\"\nlayout: \"categories\"\n---","updated":"2023-04-04T09:24:10.283Z","path":"categories/index.html","comments":1,"_id":"clk69d1ac0001jsrjj718ry7v","content":"","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":""},{"title":"about","date":"2020-01-01T08:41:10.000Z","type":"about","layout":"about","_content":"\n\n# 教育经历\n\n* <b>本科 自动化</b>\n\n2020/09 - 现在\n<b>努力小白</b>\n\n\n\n# 联系方式\n\n* <b>电子邮箱</b>\n845343253@qq.com\n* <b>地址</b>\n太阳系地球中国境内\n* <b>微信</b>\n17675443156\n* <b>QQ</b>\n845343253","source":"about/index.md","raw":"---\ntitle: about\ndate: 2020-01-01 16:41:10\ntype: \"about\"\nlayout: \"about\"\n---\n\n\n# 教育经历\n\n* <b>本科 自动化</b>\n\n2020/09 - 现在\n<b>努力小白</b>\n\n\n\n# 联系方式\n\n* <b>电子邮箱</b>\n845343253@qq.com\n* <b>地址</b>\n太阳系地球中国境内\n* <b>微信</b>\n17675443156\n* <b>QQ</b>\n845343253","updated":"2023-04-04T09:24:10.283Z","path":"about/index.html","comments":1,"_id":"clk69d1ad0002jsrjtr8ef59a","content":"<h1 id=\"教育经历\"><a href=\"#教育经历\" class=\"headerlink\" title=\"教育经历\"></a>教育经历</h1><ul>\n<li><b>本科 自动化</b></li>\n</ul>\n<p>2020/09 - 现在<br><b>努力小白</b></p>\n<h1 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h1><ul>\n<li><b>电子邮箱</b><br><a href=\"mailto:845343253@qq.com\" target=\"_blank\" rel=\"noopener\">845343253@qq.com</a></li>\n<li><b>地址</b><br>太阳系地球中国境内</li>\n<li><b>微信</b><br>17675443156</li>\n<li><b>QQ</b><br>845343253</li>\n</ul>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<h1 id=\"教育经历\"><a href=\"#教育经历\" class=\"headerlink\" title=\"教育经历\"></a>教育经历</h1><ul>\n<li><b>本科 自动化</b></li>\n</ul>\n<p>2020/09 - 现在<br><b>努力小白</b></p>\n<h1 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h1><ul>\n<li><b>电子邮箱</b><br><a href=\"mailto:845343253@qq.com\" target=\"_blank\" rel=\"noopener\">845343253@qq.com</a></li>\n<li><b>地址</b><br>太阳系地球中国境内</li>\n<li><b>微信</b><br>17675443156</li>\n<li><b>QQ</b><br>845343253</li>\n</ul>\n"},{"title":"archives","date":"2020-01-01T08:39:20.000Z","type":"archives","layout":"archives","_content":"","source":"archives/index.md","raw":"---\ntitle: archives\ndate: 2020-01-01 16:39:20\ntype: \"archives\"\nlayout: \"archives\"\n---","updated":"2023-04-04T09:24:10.283Z","path":"archives/index.html","comments":1,"_id":"clk69d1ad0003jsrjd2y1xjm2","content":"","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":""},{"title":"gallery","date":"2019-11-30T08:00:17.000Z","type":"gallery","layout":"gallery","_content":"","source":"gallery/index.md","raw":"---\ntitle: gallery\ndate: 2019-11-30 16:00:17\ntype: \"gallery\"\nlayout: \"gallery\"\n---\n","updated":"2023-04-04T09:24:10.283Z","path":"gallery/index.html","comments":1,"_id":"clk69d1ae0004jsrj7m10zrtu","content":"","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":""},{"title":"contact","date":"2020-01-01T09:17:02.000Z","type":"contact","layout":"contact","_content":"\n# 欢迎留言\n大家有任何问题，都可以在评论区给我留言，或者加我联系方式：\n* QQ：**845343253**\n* 微信：**17675443156**\n\n# 友链交换\n想要交换友链的小伙伴，欢迎在评论区留言，留言格式：\n* **名称：**你的博客名称\n* **地址：**你的博客地址\n* **简介：**一句话简介\n* **头像：**你的头像地址","source":"contact/index.md","raw":"---\ntitle: contact\ndate: 2020-01-01 17:17:02\ntype: \"contact\"\nlayout: \"contact\"\n---\n\n# 欢迎留言\n大家有任何问题，都可以在评论区给我留言，或者加我联系方式：\n* QQ：**845343253**\n* 微信：**17675443156**\n\n# 友链交换\n想要交换友链的小伙伴，欢迎在评论区留言，留言格式：\n* **名称：**你的博客名称\n* **地址：**你的博客地址\n* **简介：**一句话简介\n* **头像：**你的头像地址","updated":"2023-04-04T09:24:10.283Z","path":"contact/index.html","comments":1,"_id":"clk69d1af0005jsrjdik824hy","content":"<h1 id=\"欢迎留言\"><a href=\"#欢迎留言\" class=\"headerlink\" title=\"欢迎留言\"></a>欢迎留言</h1><p>大家有任何问题，都可以在评论区给我留言，或者加我联系方式：</p>\n<ul>\n<li>QQ：<strong>845343253</strong></li>\n<li>微信：<strong>17675443156</strong></li>\n</ul>\n<h1 id=\"友链交换\"><a href=\"#友链交换\" class=\"headerlink\" title=\"友链交换\"></a>友链交换</h1><p>想要交换友链的小伙伴，欢迎在评论区留言，留言格式：</p>\n<ul>\n<li><strong>名称：</strong>你的博客名称</li>\n<li><strong>地址：</strong>你的博客地址</li>\n<li><strong>简介：</strong>一句话简介</li>\n<li><strong>头像：</strong>你的头像地址</li>\n</ul>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<h1 id=\"欢迎留言\"><a href=\"#欢迎留言\" class=\"headerlink\" title=\"欢迎留言\"></a>欢迎留言</h1><p>大家有任何问题，都可以在评论区给我留言，或者加我联系方式：</p>\n<ul>\n<li>QQ：<strong>845343253</strong></li>\n<li>微信：<strong>17675443156</strong></li>\n</ul>\n<h1 id=\"友链交换\"><a href=\"#友链交换\" class=\"headerlink\" title=\"友链交换\"></a>友链交换</h1><p>想要交换友链的小伙伴，欢迎在评论区留言，留言格式：</p>\n<ul>\n<li><strong>名称：</strong>你的博客名称</li>\n<li><strong>地址：</strong>你的博客地址</li>\n<li><strong>简介：</strong>一句话简介</li>\n<li><strong>头像：</strong>你的头像地址</li>\n</ul>\n"},{"title":"tags","date":"2020-01-01T08:40:27.000Z","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2020-01-01 16:40:27\ntype: \"tags\"\nlayout: \"tags\"\n---","updated":"2023-04-04T09:24:10.283Z","path":"tags/index.html","comments":1,"_id":"clk69d1af0006jsrj8528fwqc","content":"","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":""}],"Post":[{"title":"Linux input子系统","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2022-01-01T13:12:46.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"<div>\n<div>\n<ul>\n<li>\n<h5>Input driver ：主要实现对硬件设备的读写访问，中断设置，并把硬件产生的事件转换为核心层定义的规范提交给事件处理层。</h5>\n</li>\n<li>\n<h5>Input core ：承上启下。为设备驱动层提供了规范和接口；通知事件处理层对事件进行处理；</h5>\n</li>\n<li>\n<h5>Event handler ：提供用户编程的接口（设备节点），并处理驱动层提交的数据处理。</h5>\n</li>\n</ul>\n<p><img src=\"Linux-input子系统/2909691-20220819093409715-1604400596.png\" alt=\"\" /></p>\n<h1>1输入子系统框架分析</h1>\n<div>\n<div>\n<h2>1.1设备驱动层（Input driver）</h2>\n<ul>\n<li>device是纯硬件操作层，包含不同的硬件接口处理，如gpio等</li>\n<li>对于每种不同的具体硬件操作，都对应着不同的input_dev结构体</li>\n<li>该结构体内部也包含着一个h_list，指向handle</li>\n</ul>\n</div>\n</div>\n<div>\n<div>\n<div>\n<div>\n<h2>1.2.系统核心层（Input core）</h2>\n<ul>\n<li>申请主设备号;</li>\n<li>提供input_register_device跟input_register_handler函数分别用于注册device跟handler;</li>\n<li>提供input_register_handle函数用于注册一个事件处理，代表一个成功配对的input_dev和input_handler;</li>\n</ul>\n</div>\n</div>\n<h2>1.3.事件处理层（Event handler）</h2>\n<ul>\n<li>不涉及硬件方面的具体操作，handler层是纯软件层，包含不同的解决方案，如键盘，鼠标，游戏手柄等；</li>\n<li>对于不同的解决方案，都包含一个名为input_handler的结构体，该结构体内含的主要成员如下：</li>\n</ul>\n<table>\n<thead>\n<tr><th>成员</th><th>功能</th></tr>\n</thead>\n<tbody>\n<tr>\n<td>.id_table</td>\n<td>一个存放该handler所支持的设备id的表（其实内部存放的是EV_xxx事件,用于判断device是否支持该事件）</td>\n</tr>\n<tr>\n<td>.fops</td>\n<td>该handler的file_operation</td>\n</tr>\n<tr>\n<td>.connect</td>\n<td>连接该handler跟所支持device的函数</td>\n</tr>\n<tr>\n<td>.disconnect</td>\n<td>断开该连接</td>\n</tr>\n<tr>\n<td>.event</td>\n<td>事件处理函数，让device调用</td>\n</tr>\n<tr>\n<td>h_list</td>\n<td>是一个链表，该链表保存着该handler到所支持的所有device的中间站：handle结构体的指针</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1>2.两条链表连接dev和handler</h1>\n<pre>\n\t<code class=\"yaml\">\n#file pwd: drivers/input/input.c\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@suse.cz>\");\nMODULE_DESCRIPTION(\"Input core\");\nMODULE_LICENSE(\"GPL\");\n#define INPUT_MAX_CHAR_DEVICES        1024\n#define INPUT_FIRST_DYNAMIC_DEV        256\nstatic DEFINE_IDA(input_ida);\nstatic LIST_HEAD(input_dev_list);\nstatic LIST_HEAD(input_handler_list);\n  </code>\n</pre> \n在input.c文件中两个全局链表input_handler_list和<span style=\"color: #000000;\">input_dev_list</span>，通过handle相互关联：</div>\n<div><img src=\"Linux-input子系统/2909691-20220819094250974-180404869.webp\" alt=\"\" />\n<p>&nbsp;</p>\n<h1>3.输入子系统代码分析</h1>\n<p>文件路径：driver/input/input.c （核心层）</p>\n<pre>\n\t<code class=\"yaml\">\nstatic int __init input_init(void)\n{\n    int err;\n    err = class_register(&input_class);  //在/sys/class下创建逻辑（input）类，在类下面挂载input设备\n    if (err) {\n        pr_err(\"unable to register input_dev class\\n\");\n        return err;\n    }\n    err = input_proc_init();　　//在/proc下面建立相关的虚拟文件，proc下创建的文件可以看作是虚拟文件对内核读写的一种操作\n    if (err)\n        goto fail1;\n    err = register_chrdev_region(MKDEV(INPUT_MAJOR, 0),//在/dev下创建input设备号\n                     INPUT_MAX_CHAR_DEVICES, \"input\");\n    if (err) {\n        pr_err(\"unable to register char major %d\", INPUT_MAJOR);\n        goto fail2;\n    }\n    return 0;\n fail2:    input_proc_exit();\n fail1:    class_unregister(&input_class);\n    return err;\n}\nstatic void __exit input_exit(void)\n{\n    input_proc_exit();\n    unregister_chrdev_region(MKDEV(INPUT_MAJOR, 0),\n                 INPUT_MAX_CHAR_DEVICES);\n    class_unregister(&input_class);\n}\nsubsys_initcall(input_init);\nmodule_exit(input_exit);\n  </code>\n</pre> \n<p>现在基本框架已经建成，如何往input系统里面注册dev和hanlder呢？</p>\n<h2>3.1注册dev</h2>\n<pre>\n\t<code class=\"yaml\">\n/**\n * struct input_dev - represents an input device\n * @name: name of the device\n * @phys: physical path to the device in the system hierarchy\n * @uniq: unique identification code for the device (if device has it)\n * @id: id of the device (struct input_id)\n * @propbit: bitmap of device properties and quirks\n * @evbit: bitmap of types of events supported by the device (EV_KEY,\n *    EV_REL, etc.)\n * @keybit: bitmap of keys/buttons this device has\n * @relbit: bitmap of relative axes for the device\n * @absbit: bitmap of absolute axes for the device\n * @mscbit: bitmap of miscellaneous events supported by the device\n * @ledbit: bitmap of leds present on the device\n * @sndbit: bitmap of sound effects supported by the device\n * @ffbit: bitmap of force feedback effects supported by the device\n * @swbit: bitmap of switches present on the device\n * @hint_events_per_packet: average number of events generated by the\n *    device in a packet (between EV_SYN/SYN_REPORT events). Used by\n *    event handlers to estimate size of the buffer needed to hold\n *    events.\n * @keycodemax: size of keycode table\n * @keycodesize: size of elements in keycode table\n * @keycode: map of scancodes to keycodes for this device\n * @getkeycode: optional legacy method to retrieve current keymap.\n * @setkeycode: optional method to alter current keymap, used to implement\n *    sparse keymaps. If not supplied default mechanism will be used.\n *    The method is being called while holding event_lock and thus must\n *    not sleep\n * @ff: force feedback structure associated with the device if device\n *    supports force feedback effects\n * @repeat_key: stores key code of the last key pressed; used to implement\n *    software autorepeat\n * @timer: timer for software autorepeat\n * @rep: current values for autorepeat parameters (delay, rate)\n * @mt: pointer to multitouch state\n * @absinfo: array of &struct input_absinfo elements holding information\n *    about absolute axes (current value, min, max, flat, fuzz,\n *    resolution)\n * @key: reflects current state of device's keys/buttons\n * @led: reflects current state of device's LEDs\n * @snd: reflects current state of sound effects\n * @sw: reflects current state of device's switches\n * @open: this method is called when the very first user calls\n *    input_open_device(). The driver must prepare the device\n *    to start generating events (start polling thread,\n *    request an IRQ, submit URB, etc.)\n * @close: this method is called when the very last user calls\n *    input_close_device().\n * @flush: purges the device. Most commonly used to get rid of force\n *    feedback effects loaded into the device when disconnecting\n *    from it\n * @event: event handler for events sent _to_ the device, like EV_LED\n *    or EV_SND. The device is expected to carry out the requested\n *    action (turn on a LED, play sound, etc.) The call is protected\n *    by @event_lock and must not sleep\n * @grab: input handle that currently has the device grabbed (via\n *    EVIOCGRAB ioctl). When a handle grabs a device it becomes sole\n *    recipient for all input events coming from the device\n * @event_lock: this spinlock is is taken when input core receives\n *    and processes a new event for the device (in input_event()).\n *    Code that accesses and/or modifies parameters of a device\n *    (such as keymap or absmin, absmax, absfuzz, etc.) after device\n *    has been registered with input core must take this lock.\n * @mutex: serializes calls to open(), close() and flush() methods\n * @users: stores number of users (input handlers) that opened this\n *    device. It is used by input_open_device() and input_close_device()\n *    to make sure that dev->open() is only called when the first\n *    user opens device and dev->close() is called when the very\n *    last user closes the device\n * @going_away: marks devices that are in a middle of unregistering and\n *    causes input_open_device*() fail with -ENODEV.\n * @dev: driver model's view of this device\n * @h_list: list of input handles associated with the device. When\n *    accessing the list dev->mutex must be held\n * @node: used to place the device onto input_dev_list\n * @num_vals: number of values queued in the current frame\n * @max_vals: maximum number of values queued in a frame\n * @vals: array of values queued in the current frame\n * @devres_managed: indicates that devices is managed with devres framework\n *    and needs not be explicitly unregistered or freed.\n */\nstruct input_dev {\n    const char *name;\n    const char *phys;\n    const char *uniq;\n    struct input_id id;\n    unsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];\n    unsigned long evbit[BITS_TO_LONGS(EV_CNT)];\n    unsigned long keybit[BITS_TO_LONGS(KEY_CNT)];\n    unsigned long relbit[BITS_TO_LONGS(REL_CNT)];\n    unsigned long absbit[BITS_TO_LONGS(ABS_CNT)];\n    unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)];\n    unsigned long ledbit[BITS_TO_LONGS(LED_CNT)];\n    unsigned long sndbit[BITS_TO_LONGS(SND_CNT)];\n    unsigned long ffbit[BITS_TO_LONGS(FF_CNT)];\n    unsigned long swbit[BITS_TO_LONGS(SW_CNT)];\n    unsigned int hint_events_per_packet;\n    unsigned int keycodemax;\n    unsigned int keycodesize;\n    void *keycode;\n    int (*setkeycode)(struct input_dev *dev,\n              const struct input_keymap_entry *ke,\n              unsigned int *old_keycode);\n    int (*getkeycode)(struct input_dev *dev,\n              struct input_keymap_entry *ke);\n    struct ff_device *ff;\n    unsigned int repeat_key;\n    struct timer_list timer;\n    int rep[REP_CNT];\n    struct input_mt *mt;\n    struct input_absinfo *absinfo;\n    unsigned long key[BITS_TO_LONGS(KEY_CNT)];\n    unsigned long led[BITS_TO_LONGS(LED_CNT)];\n    unsigned long snd[BITS_TO_LONGS(SND_CNT)];\n    unsigned long sw[BITS_TO_LONGS(SW_CNT)];\n    int (*open)(struct input_dev *dev);\n    void (*close)(struct input_dev *dev);\n    int (*flush)(struct input_dev *dev, struct file *file);\n    int (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value);\n    struct input_handle __rcu *grab;\n    spinlock_t event_lock;\n    struct mutex mutex;\n    unsigned int users;\n    bool going_away;\n    struct device dev;\n    struct list_head    h_list;\n    struct list_head    node;\n    unsigned int num_vals;\n    unsigned int max_vals;\n    struct input_value *vals;\n    bool devres_managed;\n};\n#define to_input_dev(d) container_of(d, struct input_dev, dev)\n  </code>\n</pre> \n<p>&nbsp;</p>\n<div>\n<div>&nbsp;</div><pre>\n\t<code class=\"yaml\">\n/**\n * input_register_device - register device with input core\n * @dev: device to be registered\n *\n * This function registers device with input core. The device must be\n * allocated with input_allocate_device() and all it's capabilities\n * set up before registering.\n * If function fails the device must be freed with input_free_device().\n * Once device has been successfully registered it can be unregistered\n * with input_unregister_device(); input_free_device() should not be\n * called in this case.\n *\n * Note that this function is also used to register managed input devices\n * (ones allocated with devm_input_allocate_device()). Such managed input\n * devices need not be explicitly unregistered or freed, their tear down\n * is controlled by the devres infrastructure. It is also worth noting\n * that tear down of managed input devices is internally a 2-step process:\n * registered managed input device is first unregistered, but stays in\n * memory and can still handle input_event() calls (although events will\n * not be delivered anywhere). The freeing of managed input device will\n * happen later, when devres stack is unwound to the point where device\n * allocation was made.\n */\nint input_register_device(struct input_dev *dev)\n{\n    struct input_devres *devres = NULL;\n     /* 输入事件的处理接口指针，用于和设备的事件类型进行匹配 */\n    struct input_handler *handler;\n    unsigned int packet_size;\n    const char *path;\n    int error;\n    if (dev->devres_managed) {\n        devres = devres_alloc(devm_input_device_unregister,\n                      sizeof(struct input_devres), GFP_KERNEL);\n        if (!devres)\n            return -ENOMEM;\n        devres->input = dev;\n    }\n    /* Every input device generates EV_SYN/SYN_REPORT events. */\n    __set_bit(EV_SYN, dev->evbit);\n    /* KEY_RESERVED is not supposed to be transmitted to userspace. */\n    __clear_bit(KEY_RESERVED, dev->keybit);\n    /* Make sure that bitmasks not mentioned in dev->evbit are clean. */\n    input_cleanse_bitmasks(dev);\n    packet_size = input_estimate_events_per_packet(dev);\n    if (dev->hint_events_per_packet < packet_size)\n        dev->hint_events_per_packet = packet_size;\n    dev->max_vals = dev->hint_events_per_packet + 2;\n    dev->vals = kcalloc(dev->max_vals, sizeof(*dev->vals), GFP_KERNEL);\n    if (!dev->vals) {\n        error = -ENOMEM;\n        goto err_devres_free;\n    }\n    /*\n     * If delay and period are pre-set by the driver, then autorepeating\n     * is handled by the driver itself and we don't do it in input.c.\n     */\n    if (!dev->rep[REP_DELAY] && !dev->rep[REP_PERIOD]) {\n        dev->timer.data = (long) dev;\n        dev->timer.function = input_repeat_key;\n        dev->rep[REP_DELAY] = 250;\n        dev->rep[REP_PERIOD] = 33;\n    }\n    if (!dev->getkeycode)\n        dev->getkeycode = input_default_getkeycode;\n    if (!dev->setkeycode)\n        dev->setkeycode = input_default_setkeycode;\n    error = device_add(&dev->dev);\n    if (error)\n        goto err_free_vals;\n    path = kobject_get_path(&dev->dev.kobj, GFP_KERNEL);\n    pr_info(\"%s as %s\\n\",\n        dev->name ? dev->name : \"Unspecified device\",\n        path ? path : \"N/A\");\n    kfree(path);\n    error = mutex_lock_interruptible(&input_mutex);\n    if (error)\n        goto err_device_del;\n    /* 重要:把设备挂到全局的input子系统设备链表input_dev_list上 */\n    list_add_tail(&dev->node, &input_dev_list);\n    /* 核心重点，input设备在增加到input_dev_list链表上之后，会查找\n     * input_handler_list事件处理链表上的handler进行匹配，这里的匹配\n     * 方式与设备模型的device和driver匹配过程很相似*/\n    list_for_each_entry(handler, &input_handler_list, node)\n        input_attach_handler(dev, handler);/*遍历input_handler_list，通过input_match_device试图与每一个handler进行匹配 匹配上了就使用connect连接*/\n    /*\n    static int input_attach_handler(struct input_dev *dev, struct input_handler *handler)\n    {\n        const struct input_device_id *id;\n        int error;\n\n        id = input_match_device(handler, dev);\n        if (!id)\n            return -ENODEV;\n        error = handler->connect(handler, dev, id);\n        if (error && error != -ENODEV)\n            pr_err(\"failed to attach handler %s to device %s, error: %d\\n\",\n                   handler->name, kobject_name(&dev->dev.kobj), error);\n        return error;\n    }\n    */\n    input_wakeup_procfs_readers();\n    mutex_unlock(&input_mutex);\n    if (dev->devres_managed) {\n        dev_dbg(dev->dev.parent, \"%s: registering %s with devres.\\n\",\n            __func__, dev_name(&dev->dev));\n        devres_add(dev->dev.parent, devres);\n    }\n    return 0;\nerr_device_del:\n    device_del(&dev->dev);\nerr_free_vals:\n    kfree(dev->vals);\n    dev->vals = NULL;\nerr_devres_free:\n    devres_free(devres);\n    return error;\n}\nEXPORT_SYMBOL(input_register_device);\n  </code>\n</pre> \n<h2>3.2注册handler</h2>\n<p>一般handler不需要我们自己写 内核里面已经有了很多的hanlder基本够用</p>\n下面以Evdev为例，来分析事件处理层。<br />\nvim drivers/input/evdev.c</div>\n<div>\n<pre>\n\t<code class=\"yaml\">\nstatic const struct input_device_id evdev_ids[] = {\n    { .driver_info = 1 },    /* Matches all devices */\n    { },            /* Terminating zero entry */\n};\nMODULE_DEVICE_TABLE(input, evdev_ids);\nstatic struct input_handler evdev_handler = {\n    .event        = evdev_event,\n    .events        = evdev_events,\n    .connect    = evdev_connect,\n    .disconnect    = evdev_disconnect,\n    .legacy_minors    = true,\n    .minor        = EVDEV_MINOR_BASE,\n    .name        = \"evdev\",\n    .id_table    = evdev_ids,\n};\nstatic int __init evdev_init(void)\n{\n    return input_register_handler(&evdev_handler);\n}\nstatic void __exit evdev_exit(void)\n{\n    input_unregister_handler(&evdev_handler);\n}\nmodule_init(evdev_init);\nmodule_exit(evdev_exit);\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>\");\nMODULE_DESCRIPTION(\"Input driver event char devices\");\nMODULE_LICENSE(\"GPL\");  \n  </code>\n</pre>  \n<p>注册的handler可以在proc/bus/input/danlder中查看到</p>\n</div>\n<p><img src=\"Linux-input子系统/2909691-20220819102740731-2036281828.png\" alt=\"\" /></p><pre>\n\t<code class=\"yaml\">\n/**\n* input_register_handler - register a new input handler\n* @handler: handler to be registered\n*\n* This function registers a new input handler (interface) for input\n* devices in the system and attaches it to all input devices that\n* are compatible with the handler.\n*/\nint input_register_handler(struct input_handler *handler)\n{\n     struct input_dev *dev;\n     int error;\n     error = mutex_lock_interruptible(&input_mutex);\n     if (error)\n         return error;\n \n     INIT_LIST_HEAD(&handler->h_list);\n 　　/* `重要`:把设备处理器挂到全局的input子系统设备链表input_handler_list上 */ \n     list_add_tail(&handler->node, &input_handler_list);\n 　　/*遍历input_dev_list，试图与每一个input_dev进行匹配*/\n     list_for_each_entry(dev, &input_dev_list, node)\n         input_attach_handler(dev, handler);　　　　/*static int input_attach_handler(struct input_dev *dev, struct input_handler *handler)\n{\n    const struct input_device_id *id;\n    int error;\n    ........\n    ........\n    input_wakeup_procfs_readers();\n    mutex_unlock(&input_mutex);\n    return 0;\n}\nEXPORT_SYMBOL(input_register_handler);\n  </code>\n</pre>  \n<p>这个过程和注册dev及其相似</p>\n<h2>3.3 handler的connect函数</h2><pre>\n\t<code class=\"yaml\">\nstatic int evdev_connect(struct input_handler *handler, struct input_dev *dev,\n             const struct input_device_id *id)\n{\n    struct evdev *evdev;\n    int minor;\n    int dev_no;\n    int error;\n    /*申请一个新的次设备号*/\n    minor = input_get_new_minor(EVDEV_MINOR_BASE, EVDEV_MINORS, true);\n    /* 这说明内核已经没办法再分配这种类型的设备了 */\n    if (minor < 0) {\n        error = minor;\n        pr_err(\"failed to reserve new minor: %d\\n\", error);\n        return error;\n    }\n    /* 开始给evdev事件层驱动分配空间了 */\n    evdev = kzalloc(sizeof(struct evdev), GFP_KERNEL);\n    if (!evdev) {\n        error = -ENOMEM;\n        goto err_free_minor;\n    }\n        /* 初始化client_list列表和evdev_wait队列 */\n    INIT_LIST_HEAD(&evdev->client_list);\n    spin_lock_init(&evdev->client_lock);\n    mutex_init(&evdev->mutex);\n    init_waitqueue_head(&evdev->wait);\n    evdev->exist = true;\n    dev_no = minor;\n    /* Normalize device number if it falls into legacy range */\n    if (dev_no < EVDEV_MINOR_BASE + EVDEV_MINORS)\n        dev_no -= EVDEV_MINOR_BASE;\n    /*设置设备节点名称，/dev/eventX 就是在此时设置*/\n    dev_set_name(&evdev->dev, \"event%d\", dev_no);\n    /* 初始化evdev结构体，其中handle为输入设备和事件处理的关联接口 */\n    evdev->handle.dev = input_get_device(dev);\n    evdev->handle.name = dev_name(&evdev->dev);\n    evdev->handle.handler = handler;\n    evdev->handle.private = evdev;\n      /*设置设备号，应用层就是通过设备号，找到该设备的*/\n    evdev->dev.devt = MKDEV(INPUT_MAJOR, minor);\n    evdev->dev.class = &input_class;\n    evdev->dev.parent = &dev->dev;\n    evdev->dev.release = evdev_free;\n    device_initialize(&evdev->dev);\n     /* input_dev设备驱动和handler事件处理层的关联，就在这时由handle完成 */\n    error = input_register_handle(&evdev->handle);\n    if (error)\n        goto err_free_evdev;\n    cdev_init(&evdev->cdev, &evdev_fops);\n    evdev->cdev.kobj.parent = &evdev->dev.kobj;\n    error = cdev_add(&evdev->cdev, evdev->dev.devt, 1);\n    if (error)\n        goto err_unregister_handle;\n    /*将设备加入到Linux设备模型，它的内部将找到它的bus，然后让它的bus\n    给它找到它的driver，在驱动或者总线的probe函数中，一般会在/dev/目录\n    先创建相应的设备节点，这样应用程序就可以通过该设备节点来使用设备了\n    ，/dev/eventX 设备节点就是在此时生成\n    */\n    error = device_add(&evdev->dev);\n    if (error)\n        goto err_cleanup_evdev;\n    return 0;\n err_cleanup_evdev:\n    evdev_cleanup(evdev);\n err_unregister_handle:\n    input_unregister_handle(&evdev->handle);\n err_free_evdev:\n    put_device(&evdev->dev);\n err_free_minor:\n    input_free_minor(minor);\n    return error;\n}\n  </code>\n</pre>   \n<p>over</p>\n<h1>4.应用层的角度分析到底层</h1>\n<p><img src=\"Linux-input子系统/input_logical.png\" alt=\"\" /></p>\n<p>显然，就是input_dev通过输入核心为驱动层提供统一的接口，<code>input_event</code>，来向事件处理层上报数据并唤醒。</p>\n</div>\n</div>\n","source":"_posts/2022/01/Linux-input子系统.md","raw":"---\ntitle: Linux input子系统\npermalink: Linux input子系统\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2022-01-01 21:12:46\npassword:\nsummary:\ntags:\n- linux\n- input\ncategories:\n- linux\nkeywords:\ndescription:\n---\n<div>\n<div>\n<ul>\n<li>\n<h5>Input driver ：主要实现对硬件设备的读写访问，中断设置，并把硬件产生的事件转换为核心层定义的规范提交给事件处理层。</h5>\n</li>\n<li>\n<h5>Input core ：承上启下。为设备驱动层提供了规范和接口；通知事件处理层对事件进行处理；</h5>\n</li>\n<li>\n<h5>Event handler ：提供用户编程的接口（设备节点），并处理驱动层提交的数据处理。</h5>\n</li>\n</ul>\n<p><img src=\"Linux-input子系统/2909691-20220819093409715-1604400596.png\" alt=\"\" /></p>\n<h1>1输入子系统框架分析</h1>\n<div>\n<div>\n<h2>1.1设备驱动层（Input driver）</h2>\n<ul>\n<li>device是纯硬件操作层，包含不同的硬件接口处理，如gpio等</li>\n<li>对于每种不同的具体硬件操作，都对应着不同的input_dev结构体</li>\n<li>该结构体内部也包含着一个h_list，指向handle</li>\n</ul>\n</div>\n</div>\n<div>\n<div>\n<div>\n<div>\n<h2>1.2.系统核心层（Input core）</h2>\n<ul>\n<li>申请主设备号;</li>\n<li>提供input_register_device跟input_register_handler函数分别用于注册device跟handler;</li>\n<li>提供input_register_handle函数用于注册一个事件处理，代表一个成功配对的input_dev和input_handler;</li>\n</ul>\n</div>\n</div>\n<h2>1.3.事件处理层（Event handler）</h2>\n<ul>\n<li>不涉及硬件方面的具体操作，handler层是纯软件层，包含不同的解决方案，如键盘，鼠标，游戏手柄等；</li>\n<li>对于不同的解决方案，都包含一个名为input_handler的结构体，该结构体内含的主要成员如下：</li>\n</ul>\n<table>\n<thead>\n<tr><th>成员</th><th>功能</th></tr>\n</thead>\n<tbody>\n<tr>\n<td>.id_table</td>\n<td>一个存放该handler所支持的设备id的表（其实内部存放的是EV_xxx事件,用于判断device是否支持该事件）</td>\n</tr>\n<tr>\n<td>.fops</td>\n<td>该handler的file_operation</td>\n</tr>\n<tr>\n<td>.connect</td>\n<td>连接该handler跟所支持device的函数</td>\n</tr>\n<tr>\n<td>.disconnect</td>\n<td>断开该连接</td>\n</tr>\n<tr>\n<td>.event</td>\n<td>事件处理函数，让device调用</td>\n</tr>\n<tr>\n<td>h_list</td>\n<td>是一个链表，该链表保存着该handler到所支持的所有device的中间站：handle结构体的指针</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1>2.两条链表连接dev和handler</h1>\n<pre>\n\t<code class=\"yaml\">\n#file pwd: drivers/input/input.c\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@suse.cz>\");\nMODULE_DESCRIPTION(\"Input core\");\nMODULE_LICENSE(\"GPL\");\n#define INPUT_MAX_CHAR_DEVICES        1024\n#define INPUT_FIRST_DYNAMIC_DEV        256\nstatic DEFINE_IDA(input_ida);\nstatic LIST_HEAD(input_dev_list);\nstatic LIST_HEAD(input_handler_list);\n  </code>\n</pre> \n在input.c文件中两个全局链表input_handler_list和<span style=\"color: #000000;\">input_dev_list</span>，通过handle相互关联：</div>\n<div><img src=\"Linux-input子系统/2909691-20220819094250974-180404869.webp\" alt=\"\" />\n<p>&nbsp;</p>\n<h1>3.输入子系统代码分析</h1>\n<p>文件路径：driver/input/input.c （核心层）</p>\n<pre>\n\t<code class=\"yaml\">\nstatic int __init input_init(void)\n{\n    int err;\n    err = class_register(&input_class);  //在/sys/class下创建逻辑（input）类，在类下面挂载input设备\n    if (err) {\n        pr_err(\"unable to register input_dev class\\n\");\n        return err;\n    }\n    err = input_proc_init();　　//在/proc下面建立相关的虚拟文件，proc下创建的文件可以看作是虚拟文件对内核读写的一种操作\n    if (err)\n        goto fail1;\n    err = register_chrdev_region(MKDEV(INPUT_MAJOR, 0),//在/dev下创建input设备号\n                     INPUT_MAX_CHAR_DEVICES, \"input\");\n    if (err) {\n        pr_err(\"unable to register char major %d\", INPUT_MAJOR);\n        goto fail2;\n    }\n    return 0;\n fail2:    input_proc_exit();\n fail1:    class_unregister(&input_class);\n    return err;\n}\nstatic void __exit input_exit(void)\n{\n    input_proc_exit();\n    unregister_chrdev_region(MKDEV(INPUT_MAJOR, 0),\n                 INPUT_MAX_CHAR_DEVICES);\n    class_unregister(&input_class);\n}\nsubsys_initcall(input_init);\nmodule_exit(input_exit);\n  </code>\n</pre> \n<p>现在基本框架已经建成，如何往input系统里面注册dev和hanlder呢？</p>\n<h2>3.1注册dev</h2>\n<pre>\n\t<code class=\"yaml\">\n/**\n * struct input_dev - represents an input device\n * @name: name of the device\n * @phys: physical path to the device in the system hierarchy\n * @uniq: unique identification code for the device (if device has it)\n * @id: id of the device (struct input_id)\n * @propbit: bitmap of device properties and quirks\n * @evbit: bitmap of types of events supported by the device (EV_KEY,\n *    EV_REL, etc.)\n * @keybit: bitmap of keys/buttons this device has\n * @relbit: bitmap of relative axes for the device\n * @absbit: bitmap of absolute axes for the device\n * @mscbit: bitmap of miscellaneous events supported by the device\n * @ledbit: bitmap of leds present on the device\n * @sndbit: bitmap of sound effects supported by the device\n * @ffbit: bitmap of force feedback effects supported by the device\n * @swbit: bitmap of switches present on the device\n * @hint_events_per_packet: average number of events generated by the\n *    device in a packet (between EV_SYN/SYN_REPORT events). Used by\n *    event handlers to estimate size of the buffer needed to hold\n *    events.\n * @keycodemax: size of keycode table\n * @keycodesize: size of elements in keycode table\n * @keycode: map of scancodes to keycodes for this device\n * @getkeycode: optional legacy method to retrieve current keymap.\n * @setkeycode: optional method to alter current keymap, used to implement\n *    sparse keymaps. If not supplied default mechanism will be used.\n *    The method is being called while holding event_lock and thus must\n *    not sleep\n * @ff: force feedback structure associated with the device if device\n *    supports force feedback effects\n * @repeat_key: stores key code of the last key pressed; used to implement\n *    software autorepeat\n * @timer: timer for software autorepeat\n * @rep: current values for autorepeat parameters (delay, rate)\n * @mt: pointer to multitouch state\n * @absinfo: array of &struct input_absinfo elements holding information\n *    about absolute axes (current value, min, max, flat, fuzz,\n *    resolution)\n * @key: reflects current state of device's keys/buttons\n * @led: reflects current state of device's LEDs\n * @snd: reflects current state of sound effects\n * @sw: reflects current state of device's switches\n * @open: this method is called when the very first user calls\n *    input_open_device(). The driver must prepare the device\n *    to start generating events (start polling thread,\n *    request an IRQ, submit URB, etc.)\n * @close: this method is called when the very last user calls\n *    input_close_device().\n * @flush: purges the device. Most commonly used to get rid of force\n *    feedback effects loaded into the device when disconnecting\n *    from it\n * @event: event handler for events sent _to_ the device, like EV_LED\n *    or EV_SND. The device is expected to carry out the requested\n *    action (turn on a LED, play sound, etc.) The call is protected\n *    by @event_lock and must not sleep\n * @grab: input handle that currently has the device grabbed (via\n *    EVIOCGRAB ioctl). When a handle grabs a device it becomes sole\n *    recipient for all input events coming from the device\n * @event_lock: this spinlock is is taken when input core receives\n *    and processes a new event for the device (in input_event()).\n *    Code that accesses and/or modifies parameters of a device\n *    (such as keymap or absmin, absmax, absfuzz, etc.) after device\n *    has been registered with input core must take this lock.\n * @mutex: serializes calls to open(), close() and flush() methods\n * @users: stores number of users (input handlers) that opened this\n *    device. It is used by input_open_device() and input_close_device()\n *    to make sure that dev->open() is only called when the first\n *    user opens device and dev->close() is called when the very\n *    last user closes the device\n * @going_away: marks devices that are in a middle of unregistering and\n *    causes input_open_device*() fail with -ENODEV.\n * @dev: driver model's view of this device\n * @h_list: list of input handles associated with the device. When\n *    accessing the list dev->mutex must be held\n * @node: used to place the device onto input_dev_list\n * @num_vals: number of values queued in the current frame\n * @max_vals: maximum number of values queued in a frame\n * @vals: array of values queued in the current frame\n * @devres_managed: indicates that devices is managed with devres framework\n *    and needs not be explicitly unregistered or freed.\n */\nstruct input_dev {\n    const char *name;\n    const char *phys;\n    const char *uniq;\n    struct input_id id;\n    unsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];\n    unsigned long evbit[BITS_TO_LONGS(EV_CNT)];\n    unsigned long keybit[BITS_TO_LONGS(KEY_CNT)];\n    unsigned long relbit[BITS_TO_LONGS(REL_CNT)];\n    unsigned long absbit[BITS_TO_LONGS(ABS_CNT)];\n    unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)];\n    unsigned long ledbit[BITS_TO_LONGS(LED_CNT)];\n    unsigned long sndbit[BITS_TO_LONGS(SND_CNT)];\n    unsigned long ffbit[BITS_TO_LONGS(FF_CNT)];\n    unsigned long swbit[BITS_TO_LONGS(SW_CNT)];\n    unsigned int hint_events_per_packet;\n    unsigned int keycodemax;\n    unsigned int keycodesize;\n    void *keycode;\n    int (*setkeycode)(struct input_dev *dev,\n              const struct input_keymap_entry *ke,\n              unsigned int *old_keycode);\n    int (*getkeycode)(struct input_dev *dev,\n              struct input_keymap_entry *ke);\n    struct ff_device *ff;\n    unsigned int repeat_key;\n    struct timer_list timer;\n    int rep[REP_CNT];\n    struct input_mt *mt;\n    struct input_absinfo *absinfo;\n    unsigned long key[BITS_TO_LONGS(KEY_CNT)];\n    unsigned long led[BITS_TO_LONGS(LED_CNT)];\n    unsigned long snd[BITS_TO_LONGS(SND_CNT)];\n    unsigned long sw[BITS_TO_LONGS(SW_CNT)];\n    int (*open)(struct input_dev *dev);\n    void (*close)(struct input_dev *dev);\n    int (*flush)(struct input_dev *dev, struct file *file);\n    int (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value);\n    struct input_handle __rcu *grab;\n    spinlock_t event_lock;\n    struct mutex mutex;\n    unsigned int users;\n    bool going_away;\n    struct device dev;\n    struct list_head    h_list;\n    struct list_head    node;\n    unsigned int num_vals;\n    unsigned int max_vals;\n    struct input_value *vals;\n    bool devres_managed;\n};\n#define to_input_dev(d) container_of(d, struct input_dev, dev)\n  </code>\n</pre> \n<p>&nbsp;</p>\n<div>\n<div>&nbsp;</div><pre>\n\t<code class=\"yaml\">\n/**\n * input_register_device - register device with input core\n * @dev: device to be registered\n *\n * This function registers device with input core. The device must be\n * allocated with input_allocate_device() and all it's capabilities\n * set up before registering.\n * If function fails the device must be freed with input_free_device().\n * Once device has been successfully registered it can be unregistered\n * with input_unregister_device(); input_free_device() should not be\n * called in this case.\n *\n * Note that this function is also used to register managed input devices\n * (ones allocated with devm_input_allocate_device()). Such managed input\n * devices need not be explicitly unregistered or freed, their tear down\n * is controlled by the devres infrastructure. It is also worth noting\n * that tear down of managed input devices is internally a 2-step process:\n * registered managed input device is first unregistered, but stays in\n * memory and can still handle input_event() calls (although events will\n * not be delivered anywhere). The freeing of managed input device will\n * happen later, when devres stack is unwound to the point where device\n * allocation was made.\n */\nint input_register_device(struct input_dev *dev)\n{\n    struct input_devres *devres = NULL;\n     /* 输入事件的处理接口指针，用于和设备的事件类型进行匹配 */\n    struct input_handler *handler;\n    unsigned int packet_size;\n    const char *path;\n    int error;\n    if (dev->devres_managed) {\n        devres = devres_alloc(devm_input_device_unregister,\n                      sizeof(struct input_devres), GFP_KERNEL);\n        if (!devres)\n            return -ENOMEM;\n        devres->input = dev;\n    }\n    /* Every input device generates EV_SYN/SYN_REPORT events. */\n    __set_bit(EV_SYN, dev->evbit);\n    /* KEY_RESERVED is not supposed to be transmitted to userspace. */\n    __clear_bit(KEY_RESERVED, dev->keybit);\n    /* Make sure that bitmasks not mentioned in dev->evbit are clean. */\n    input_cleanse_bitmasks(dev);\n    packet_size = input_estimate_events_per_packet(dev);\n    if (dev->hint_events_per_packet < packet_size)\n        dev->hint_events_per_packet = packet_size;\n    dev->max_vals = dev->hint_events_per_packet + 2;\n    dev->vals = kcalloc(dev->max_vals, sizeof(*dev->vals), GFP_KERNEL);\n    if (!dev->vals) {\n        error = -ENOMEM;\n        goto err_devres_free;\n    }\n    /*\n     * If delay and period are pre-set by the driver, then autorepeating\n     * is handled by the driver itself and we don't do it in input.c.\n     */\n    if (!dev->rep[REP_DELAY] && !dev->rep[REP_PERIOD]) {\n        dev->timer.data = (long) dev;\n        dev->timer.function = input_repeat_key;\n        dev->rep[REP_DELAY] = 250;\n        dev->rep[REP_PERIOD] = 33;\n    }\n    if (!dev->getkeycode)\n        dev->getkeycode = input_default_getkeycode;\n    if (!dev->setkeycode)\n        dev->setkeycode = input_default_setkeycode;\n    error = device_add(&dev->dev);\n    if (error)\n        goto err_free_vals;\n    path = kobject_get_path(&dev->dev.kobj, GFP_KERNEL);\n    pr_info(\"%s as %s\\n\",\n        dev->name ? dev->name : \"Unspecified device\",\n        path ? path : \"N/A\");\n    kfree(path);\n    error = mutex_lock_interruptible(&input_mutex);\n    if (error)\n        goto err_device_del;\n    /* 重要:把设备挂到全局的input子系统设备链表input_dev_list上 */\n    list_add_tail(&dev->node, &input_dev_list);\n    /* 核心重点，input设备在增加到input_dev_list链表上之后，会查找\n     * input_handler_list事件处理链表上的handler进行匹配，这里的匹配\n     * 方式与设备模型的device和driver匹配过程很相似*/\n    list_for_each_entry(handler, &input_handler_list, node)\n        input_attach_handler(dev, handler);/*遍历input_handler_list，通过input_match_device试图与每一个handler进行匹配 匹配上了就使用connect连接*/\n    /*\n    static int input_attach_handler(struct input_dev *dev, struct input_handler *handler)\n    {\n        const struct input_device_id *id;\n        int error;\n\n        id = input_match_device(handler, dev);\n        if (!id)\n            return -ENODEV;\n        error = handler->connect(handler, dev, id);\n        if (error && error != -ENODEV)\n            pr_err(\"failed to attach handler %s to device %s, error: %d\\n\",\n                   handler->name, kobject_name(&dev->dev.kobj), error);\n        return error;\n    }\n    */\n    input_wakeup_procfs_readers();\n    mutex_unlock(&input_mutex);\n    if (dev->devres_managed) {\n        dev_dbg(dev->dev.parent, \"%s: registering %s with devres.\\n\",\n            __func__, dev_name(&dev->dev));\n        devres_add(dev->dev.parent, devres);\n    }\n    return 0;\nerr_device_del:\n    device_del(&dev->dev);\nerr_free_vals:\n    kfree(dev->vals);\n    dev->vals = NULL;\nerr_devres_free:\n    devres_free(devres);\n    return error;\n}\nEXPORT_SYMBOL(input_register_device);\n  </code>\n</pre> \n<h2>3.2注册handler</h2>\n<p>一般handler不需要我们自己写 内核里面已经有了很多的hanlder基本够用</p>\n下面以Evdev为例，来分析事件处理层。<br />\nvim drivers/input/evdev.c</div>\n<div>\n<pre>\n\t<code class=\"yaml\">\nstatic const struct input_device_id evdev_ids[] = {\n    { .driver_info = 1 },    /* Matches all devices */\n    { },            /* Terminating zero entry */\n};\nMODULE_DEVICE_TABLE(input, evdev_ids);\nstatic struct input_handler evdev_handler = {\n    .event        = evdev_event,\n    .events        = evdev_events,\n    .connect    = evdev_connect,\n    .disconnect    = evdev_disconnect,\n    .legacy_minors    = true,\n    .minor        = EVDEV_MINOR_BASE,\n    .name        = \"evdev\",\n    .id_table    = evdev_ids,\n};\nstatic int __init evdev_init(void)\n{\n    return input_register_handler(&evdev_handler);\n}\nstatic void __exit evdev_exit(void)\n{\n    input_unregister_handler(&evdev_handler);\n}\nmodule_init(evdev_init);\nmodule_exit(evdev_exit);\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>\");\nMODULE_DESCRIPTION(\"Input driver event char devices\");\nMODULE_LICENSE(\"GPL\");  \n  </code>\n</pre>  \n<p>注册的handler可以在proc/bus/input/danlder中查看到</p>\n</div>\n<p><img src=\"Linux-input子系统/2909691-20220819102740731-2036281828.png\" alt=\"\" /></p><pre>\n\t<code class=\"yaml\">\n/**\n* input_register_handler - register a new input handler\n* @handler: handler to be registered\n*\n* This function registers a new input handler (interface) for input\n* devices in the system and attaches it to all input devices that\n* are compatible with the handler.\n*/\nint input_register_handler(struct input_handler *handler)\n{\n     struct input_dev *dev;\n     int error;\n     error = mutex_lock_interruptible(&input_mutex);\n     if (error)\n         return error;\n \n     INIT_LIST_HEAD(&handler->h_list);\n 　　/* `重要`:把设备处理器挂到全局的input子系统设备链表input_handler_list上 */ \n     list_add_tail(&handler->node, &input_handler_list);\n 　　/*遍历input_dev_list，试图与每一个input_dev进行匹配*/\n     list_for_each_entry(dev, &input_dev_list, node)\n         input_attach_handler(dev, handler);　　　　/*static int input_attach_handler(struct input_dev *dev, struct input_handler *handler)\n{\n    const struct input_device_id *id;\n    int error;\n    ........\n    ........\n    input_wakeup_procfs_readers();\n    mutex_unlock(&input_mutex);\n    return 0;\n}\nEXPORT_SYMBOL(input_register_handler);\n  </code>\n</pre>  \n<p>这个过程和注册dev及其相似</p>\n<h2>3.3 handler的connect函数</h2><pre>\n\t<code class=\"yaml\">\nstatic int evdev_connect(struct input_handler *handler, struct input_dev *dev,\n             const struct input_device_id *id)\n{\n    struct evdev *evdev;\n    int minor;\n    int dev_no;\n    int error;\n    /*申请一个新的次设备号*/\n    minor = input_get_new_minor(EVDEV_MINOR_BASE, EVDEV_MINORS, true);\n    /* 这说明内核已经没办法再分配这种类型的设备了 */\n    if (minor < 0) {\n        error = minor;\n        pr_err(\"failed to reserve new minor: %d\\n\", error);\n        return error;\n    }\n    /* 开始给evdev事件层驱动分配空间了 */\n    evdev = kzalloc(sizeof(struct evdev), GFP_KERNEL);\n    if (!evdev) {\n        error = -ENOMEM;\n        goto err_free_minor;\n    }\n        /* 初始化client_list列表和evdev_wait队列 */\n    INIT_LIST_HEAD(&evdev->client_list);\n    spin_lock_init(&evdev->client_lock);\n    mutex_init(&evdev->mutex);\n    init_waitqueue_head(&evdev->wait);\n    evdev->exist = true;\n    dev_no = minor;\n    /* Normalize device number if it falls into legacy range */\n    if (dev_no < EVDEV_MINOR_BASE + EVDEV_MINORS)\n        dev_no -= EVDEV_MINOR_BASE;\n    /*设置设备节点名称，/dev/eventX 就是在此时设置*/\n    dev_set_name(&evdev->dev, \"event%d\", dev_no);\n    /* 初始化evdev结构体，其中handle为输入设备和事件处理的关联接口 */\n    evdev->handle.dev = input_get_device(dev);\n    evdev->handle.name = dev_name(&evdev->dev);\n    evdev->handle.handler = handler;\n    evdev->handle.private = evdev;\n      /*设置设备号，应用层就是通过设备号，找到该设备的*/\n    evdev->dev.devt = MKDEV(INPUT_MAJOR, minor);\n    evdev->dev.class = &input_class;\n    evdev->dev.parent = &dev->dev;\n    evdev->dev.release = evdev_free;\n    device_initialize(&evdev->dev);\n     /* input_dev设备驱动和handler事件处理层的关联，就在这时由handle完成 */\n    error = input_register_handle(&evdev->handle);\n    if (error)\n        goto err_free_evdev;\n    cdev_init(&evdev->cdev, &evdev_fops);\n    evdev->cdev.kobj.parent = &evdev->dev.kobj;\n    error = cdev_add(&evdev->cdev, evdev->dev.devt, 1);\n    if (error)\n        goto err_unregister_handle;\n    /*将设备加入到Linux设备模型，它的内部将找到它的bus，然后让它的bus\n    给它找到它的driver，在驱动或者总线的probe函数中，一般会在/dev/目录\n    先创建相应的设备节点，这样应用程序就可以通过该设备节点来使用设备了\n    ，/dev/eventX 设备节点就是在此时生成\n    */\n    error = device_add(&evdev->dev);\n    if (error)\n        goto err_cleanup_evdev;\n    return 0;\n err_cleanup_evdev:\n    evdev_cleanup(evdev);\n err_unregister_handle:\n    input_unregister_handle(&evdev->handle);\n err_free_evdev:\n    put_device(&evdev->dev);\n err_free_minor:\n    input_free_minor(minor);\n    return error;\n}\n  </code>\n</pre>   \n<p>over</p>\n<h1>4.应用层的角度分析到底层</h1>\n<p><img src=\"Linux-input子系统/input_logical.png\" alt=\"\" /></p>\n<p>显然，就是input_dev通过输入核心为驱动层提供统一的接口，<code>input_event</code>，来向事件处理层上报数据并唤醒。</p>\n</div>\n</div>\n","slug":"Linux input子系统","published":1,"updated":"2023-04-04T10:56:12.224Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk69d1co0007jsrjueopeg9z","content":"<div>\n<div>\n<ul>\n<li>\n<h5>Input driver ：主要实现对硬件设备的读写访问，中断设置，并把硬件产生的事件转换为核心层定义的规范提交给事件处理层。</h5>\n</li>\n<li>\n<h5>Input core ：承上启下。为设备驱动层提供了规范和接口；通知事件处理层对事件进行处理；</h5>\n</li>\n<li>\n<h5>Event handler ：提供用户编程的接口（设备节点），并处理驱动层提交的数据处理。</h5>\n</li>\n</ul>\n<p><img src=\"/2022/01/linux-input-zi-xi-tong/2909691-20220819093409715-1604400596.png\" alt></p>\n<h1>1输入子系统框架分析</h1>\n<div>\n<div>\n<h2>1.1设备驱动层（Input driver）</h2>\n<ul>\n<li>device是纯硬件操作层，包含不同的硬件接口处理，如gpio等</li>\n<li>对于每种不同的具体硬件操作，都对应着不同的input_dev结构体</li>\n<li>该结构体内部也包含着一个h_list，指向handle</li>\n</ul>\n</div>\n</div>\n<div>\n<div>\n<div>\n<div>\n<h2>1.2.系统核心层（Input core）</h2>\n<ul>\n<li>申请主设备号;</li>\n<li>提供input_register_device跟input_register_handler函数分别用于注册device跟handler;</li>\n<li>提供input_register_handle函数用于注册一个事件处理，代表一个成功配对的input_dev和input_handler;</li>\n</ul>\n</div>\n</div>\n<h2>1.3.事件处理层（Event handler）</h2>\n<ul>\n<li>不涉及硬件方面的具体操作，handler层是纯软件层，包含不同的解决方案，如键盘，鼠标，游戏手柄等；</li>\n<li>对于不同的解决方案，都包含一个名为input_handler的结构体，该结构体内含的主要成员如下：</li>\n</ul>\n<table>\n<thead>\n<tr><th>成员</th><th>功能</th></tr>\n</thead>\n<tbody>\n<tr>\n<td>.id_table</td>\n<td>一个存放该handler所支持的设备id的表（其实内部存放的是EV_xxx事件,用于判断device是否支持该事件）</td>\n</tr>\n<tr>\n<td>.fops</td>\n<td>该handler的file_operation</td>\n</tr>\n<tr>\n<td>.connect</td>\n<td>连接该handler跟所支持device的函数</td>\n</tr>\n<tr>\n<td>.disconnect</td>\n<td>断开该连接</td>\n</tr>\n<tr>\n<td>.event</td>\n<td>事件处理函数，让device调用</td>\n</tr>\n<tr>\n<td>h_list</td>\n<td>是一个链表，该链表保存着该handler到所支持的所有device的中间站：handle结构体的指针</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1>2.两条链表连接dev和handler</h1>\n<pre>\n    <code class=\"yaml\">\n#file pwd: drivers/input/input.c\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@suse.cz>\");\nMODULE_DESCRIPTION(\"Input core\");\nMODULE_LICENSE(\"GPL\");\n#define INPUT_MAX_CHAR_DEVICES        1024\n#define INPUT_FIRST_DYNAMIC_DEV        256\nstatic DEFINE_IDA(input_ida);\nstatic LIST_HEAD(input_dev_list);\nstatic LIST_HEAD(input_handler_list);\n  </vojtech@suse.cz></code>\n</pre> \n在input.c文件中两个全局链表input_handler_list和<span style=\"color: #000000;\">input_dev_list</span>，通过handle相互关联：</div>\n<div><img src=\"/2022/01/linux-input-zi-xi-tong/2909691-20220819094250974-180404869.webp\" alt>\n<p>&nbsp;</p>\n<h1>3.输入子系统代码分析</h1>\n<p>文件路径：driver/input/input.c （核心层）</p>\n<pre>\n    <code class=\"yaml\">\nstatic int __init input_init(void)\n{\n    int err;\n    err = class_register(&input_class);  //在/sys/class下创建逻辑（input）类，在类下面挂载input设备\n    if (err) {\n        pr_err(\"unable to register input_dev class\\n\");\n        return err;\n    }\n    err = input_proc_init();　　//在/proc下面建立相关的虚拟文件，proc下创建的文件可以看作是虚拟文件对内核读写的一种操作\n    if (err)\n        goto fail1;\n    err = register_chrdev_region(MKDEV(INPUT_MAJOR, 0),//在/dev下创建input设备号\n                     INPUT_MAX_CHAR_DEVICES, \"input\");\n    if (err) {\n        pr_err(\"unable to register char major %d\", INPUT_MAJOR);\n        goto fail2;\n    }\n    return 0;\n fail2:    input_proc_exit();\n fail1:    class_unregister(&input_class);\n    return err;\n}\nstatic void __exit input_exit(void)\n{\n    input_proc_exit();\n    unregister_chrdev_region(MKDEV(INPUT_MAJOR, 0),\n                 INPUT_MAX_CHAR_DEVICES);\n    class_unregister(&input_class);\n}\nsubsys_initcall(input_init);\nmodule_exit(input_exit);\n  </code>\n</pre> \n<p>现在基本框架已经建成，如何往input系统里面注册dev和hanlder呢？</p>\n<h2>3.1注册dev</h2>\n<pre>\n    <code class=\"yaml\">\n/**\n * struct input_dev - represents an input device\n * @name: name of the device\n * @phys: physical path to the device in the system hierarchy\n * @uniq: unique identification code for the device (if device has it)\n * @id: id of the device (struct input_id)\n * @propbit: bitmap of device properties and quirks\n * @evbit: bitmap of types of events supported by the device (EV_KEY,\n *    EV_REL, etc.)\n * @keybit: bitmap of keys/buttons this device has\n * @relbit: bitmap of relative axes for the device\n * @absbit: bitmap of absolute axes for the device\n * @mscbit: bitmap of miscellaneous events supported by the device\n * @ledbit: bitmap of leds present on the device\n * @sndbit: bitmap of sound effects supported by the device\n * @ffbit: bitmap of force feedback effects supported by the device\n * @swbit: bitmap of switches present on the device\n * @hint_events_per_packet: average number of events generated by the\n *    device in a packet (between EV_SYN/SYN_REPORT events). Used by\n *    event handlers to estimate size of the buffer needed to hold\n *    events.\n * @keycodemax: size of keycode table\n * @keycodesize: size of elements in keycode table\n * @keycode: map of scancodes to keycodes for this device\n * @getkeycode: optional legacy method to retrieve current keymap.\n * @setkeycode: optional method to alter current keymap, used to implement\n *    sparse keymaps. If not supplied default mechanism will be used.\n *    The method is being called while holding event_lock and thus must\n *    not sleep\n * @ff: force feedback structure associated with the device if device\n *    supports force feedback effects\n * @repeat_key: stores key code of the last key pressed; used to implement\n *    software autorepeat\n * @timer: timer for software autorepeat\n * @rep: current values for autorepeat parameters (delay, rate)\n * @mt: pointer to multitouch state\n * @absinfo: array of &struct input_absinfo elements holding information\n *    about absolute axes (current value, min, max, flat, fuzz,\n *    resolution)\n * @key: reflects current state of device's keys/buttons\n * @led: reflects current state of device's LEDs\n * @snd: reflects current state of sound effects\n * @sw: reflects current state of device's switches\n * @open: this method is called when the very first user calls\n *    input_open_device(). The driver must prepare the device\n *    to start generating events (start polling thread,\n *    request an IRQ, submit URB, etc.)\n * @close: this method is called when the very last user calls\n *    input_close_device().\n * @flush: purges the device. Most commonly used to get rid of force\n *    feedback effects loaded into the device when disconnecting\n *    from it\n * @event: event handler for events sent _to_ the device, like EV_LED\n *    or EV_SND. The device is expected to carry out the requested\n *    action (turn on a LED, play sound, etc.) The call is protected\n *    by @event_lock and must not sleep\n * @grab: input handle that currently has the device grabbed (via\n *    EVIOCGRAB ioctl). When a handle grabs a device it becomes sole\n *    recipient for all input events coming from the device\n * @event_lock: this spinlock is is taken when input core receives\n *    and processes a new event for the device (in input_event()).\n *    Code that accesses and/or modifies parameters of a device\n *    (such as keymap or absmin, absmax, absfuzz, etc.) after device\n *    has been registered with input core must take this lock.\n * @mutex: serializes calls to open(), close() and flush() methods\n * @users: stores number of users (input handlers) that opened this\n *    device. It is used by input_open_device() and input_close_device()\n *    to make sure that dev->open() is only called when the first\n *    user opens device and dev->close() is called when the very\n *    last user closes the device\n * @going_away: marks devices that are in a middle of unregistering and\n *    causes input_open_device*() fail with -ENODEV.\n * @dev: driver model's view of this device\n * @h_list: list of input handles associated with the device. When\n *    accessing the list dev->mutex must be held\n * @node: used to place the device onto input_dev_list\n * @num_vals: number of values queued in the current frame\n * @max_vals: maximum number of values queued in a frame\n * @vals: array of values queued in the current frame\n * @devres_managed: indicates that devices is managed with devres framework\n *    and needs not be explicitly unregistered or freed.\n */\nstruct input_dev {\n    const char *name;\n    const char *phys;\n    const char *uniq;\n    struct input_id id;\n    unsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];\n    unsigned long evbit[BITS_TO_LONGS(EV_CNT)];\n    unsigned long keybit[BITS_TO_LONGS(KEY_CNT)];\n    unsigned long relbit[BITS_TO_LONGS(REL_CNT)];\n    unsigned long absbit[BITS_TO_LONGS(ABS_CNT)];\n    unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)];\n    unsigned long ledbit[BITS_TO_LONGS(LED_CNT)];\n    unsigned long sndbit[BITS_TO_LONGS(SND_CNT)];\n    unsigned long ffbit[BITS_TO_LONGS(FF_CNT)];\n    unsigned long swbit[BITS_TO_LONGS(SW_CNT)];\n    unsigned int hint_events_per_packet;\n    unsigned int keycodemax;\n    unsigned int keycodesize;\n    void *keycode;\n    int (*setkeycode)(struct input_dev *dev,\n              const struct input_keymap_entry *ke,\n              unsigned int *old_keycode);\n    int (*getkeycode)(struct input_dev *dev,\n              struct input_keymap_entry *ke);\n    struct ff_device *ff;\n    unsigned int repeat_key;\n    struct timer_list timer;\n    int rep[REP_CNT];\n    struct input_mt *mt;\n    struct input_absinfo *absinfo;\n    unsigned long key[BITS_TO_LONGS(KEY_CNT)];\n    unsigned long led[BITS_TO_LONGS(LED_CNT)];\n    unsigned long snd[BITS_TO_LONGS(SND_CNT)];\n    unsigned long sw[BITS_TO_LONGS(SW_CNT)];\n    int (*open)(struct input_dev *dev);\n    void (*close)(struct input_dev *dev);\n    int (*flush)(struct input_dev *dev, struct file *file);\n    int (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value);\n    struct input_handle __rcu *grab;\n    spinlock_t event_lock;\n    struct mutex mutex;\n    unsigned int users;\n    bool going_away;\n    struct device dev;\n    struct list_head    h_list;\n    struct list_head    node;\n    unsigned int num_vals;\n    unsigned int max_vals;\n    struct input_value *vals;\n    bool devres_managed;\n};\n#define to_input_dev(d) container_of(d, struct input_dev, dev)\n  </code>\n</pre> \n<p>&nbsp;</p>\n<div>\n<div>&nbsp;</div><pre>\n    <code class=\"yaml\">\n/**\n * input_register_device - register device with input core\n * @dev: device to be registered\n *\n * This function registers device with input core. The device must be\n * allocated with input_allocate_device() and all it's capabilities\n * set up before registering.\n * If function fails the device must be freed with input_free_device().\n * Once device has been successfully registered it can be unregistered\n * with input_unregister_device(); input_free_device() should not be\n * called in this case.\n *\n * Note that this function is also used to register managed input devices\n * (ones allocated with devm_input_allocate_device()). Such managed input\n * devices need not be explicitly unregistered or freed, their tear down\n * is controlled by the devres infrastructure. It is also worth noting\n * that tear down of managed input devices is internally a 2-step process:\n * registered managed input device is first unregistered, but stays in\n * memory and can still handle input_event() calls (although events will\n * not be delivered anywhere). The freeing of managed input device will\n * happen later, when devres stack is unwound to the point where device\n * allocation was made.\n */\nint input_register_device(struct input_dev *dev)\n{\n    struct input_devres *devres = NULL;\n     /* 输入事件的处理接口指针，用于和设备的事件类型进行匹配 */\n    struct input_handler *handler;\n    unsigned int packet_size;\n    const char *path;\n    int error;\n    if (dev->devres_managed) {\n        devres = devres_alloc(devm_input_device_unregister,\n                      sizeof(struct input_devres), GFP_KERNEL);\n        if (!devres)\n            return -ENOMEM;\n        devres->input = dev;\n    }\n    /* Every input device generates EV_SYN/SYN_REPORT events. */\n    __set_bit(EV_SYN, dev->evbit);\n    /* KEY_RESERVED is not supposed to be transmitted to userspace. */\n    __clear_bit(KEY_RESERVED, dev->keybit);\n    /* Make sure that bitmasks not mentioned in dev->evbit are clean. */\n    input_cleanse_bitmasks(dev);\n    packet_size = input_estimate_events_per_packet(dev);\n    if (dev->hint_events_per_packet < packet_size)\n        dev->hint_events_per_packet = packet_size;\n    dev->max_vals = dev->hint_events_per_packet + 2;\n    dev->vals = kcalloc(dev->max_vals, sizeof(*dev->vals), GFP_KERNEL);\n    if (!dev->vals) {\n        error = -ENOMEM;\n        goto err_devres_free;\n    }\n    /*\n     * If delay and period are pre-set by the driver, then autorepeating\n     * is handled by the driver itself and we don't do it in input.c.\n     */\n    if (!dev->rep[REP_DELAY] && !dev->rep[REP_PERIOD]) {\n        dev->timer.data = (long) dev;\n        dev->timer.function = input_repeat_key;\n        dev->rep[REP_DELAY] = 250;\n        dev->rep[REP_PERIOD] = 33;\n    }\n    if (!dev->getkeycode)\n        dev->getkeycode = input_default_getkeycode;\n    if (!dev->setkeycode)\n        dev->setkeycode = input_default_setkeycode;\n    error = device_add(&dev->dev);\n    if (error)\n        goto err_free_vals;\n    path = kobject_get_path(&dev->dev.kobj, GFP_KERNEL);\n    pr_info(\"%s as %s\\n\",\n        dev->name ? dev->name : \"Unspecified device\",\n        path ? path : \"N/A\");\n    kfree(path);\n    error = mutex_lock_interruptible(&input_mutex);\n    if (error)\n        goto err_device_del;\n    /* 重要:把设备挂到全局的input子系统设备链表input_dev_list上 */\n    list_add_tail(&dev->node, &input_dev_list);\n    /* 核心重点，input设备在增加到input_dev_list链表上之后，会查找\n     * input_handler_list事件处理链表上的handler进行匹配，这里的匹配\n     * 方式与设备模型的device和driver匹配过程很相似*/\n    list_for_each_entry(handler, &input_handler_list, node)\n        input_attach_handler(dev, handler);/*遍历input_handler_list，通过input_match_device试图与每一个handler进行匹配 匹配上了就使用connect连接*/\n    /*\n    static int input_attach_handler(struct input_dev *dev, struct input_handler *handler)\n    {\n        const struct input_device_id *id;\n        int error;\n\n<pre><code>    id = input_match_device(handler, dev);\n    if (!id)\n        return -ENODEV;\n    error = handler-&gt;connect(handler, dev, id);\n    if (error &amp;&amp; error != -ENODEV)\n        pr_err(&quot;failed to attach handler %s to device %s, error: %d\\n&quot;,\n               handler-&gt;name, kobject_name(&amp;dev-&gt;dev.kobj), error);\n    return error;\n}\n*/\ninput_wakeup_procfs_readers();\nmutex_unlock(&amp;input_mutex);\nif (dev-&gt;devres_managed) {\n    dev_dbg(dev-&gt;dev.parent, &quot;%s: registering %s with devres.\\n&quot;,\n        __func__, dev_name(&amp;dev-&gt;dev));\n    devres_add(dev-&gt;dev.parent, devres);\n}\nreturn 0;</code></pre><p>err_device_del:<br>    device_del(&amp;dev-&gt;dev);<br>err_free_vals:<br>    kfree(dev-&gt;vals);<br>    dev-&gt;vals = NULL;<br>err_devres_free:<br>    devres_free(devres);<br>    return error;<br>}<br>EXPORT_SYMBOL(input_register_device);<br>  </p></code><br></pre> <p></p>\n<h2>3.2注册handler</h2>\n<p>一般handler不需要我们自己写 内核里面已经有了很多的hanlder基本够用</p>\n下面以Evdev为例，来分析事件处理层。<br>\nvim drivers/input/evdev.c</div>\n<div>\n<pre>\n    <code class=\"yaml\">\nstatic const struct input_device_id evdev_ids[] = {\n    { .driver_info = 1 },    /* Matches all devices */\n    { },            /* Terminating zero entry */\n};\nMODULE_DEVICE_TABLE(input, evdev_ids);\nstatic struct input_handler evdev_handler = {\n    .event        = evdev_event,\n    .events        = evdev_events,\n    .connect    = evdev_connect,\n    .disconnect    = evdev_disconnect,\n    .legacy_minors    = true,\n    .minor        = EVDEV_MINOR_BASE,\n    .name        = \"evdev\",\n    .id_table    = evdev_ids,\n};\nstatic int __init evdev_init(void)\n{\n    return input_register_handler(&evdev_handler);\n}\nstatic void __exit evdev_exit(void)\n{\n    input_unregister_handler(&evdev_handler);\n}\nmodule_init(evdev_init);\nmodule_exit(evdev_exit);\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>\");\nMODULE_DESCRIPTION(\"Input driver event char devices\");\nMODULE_LICENSE(\"GPL\");  \n  </vojtech@ucw.cz></code>\n</pre>  \n<p>注册的handler可以在proc/bus/input/danlder中查看到</p>\n</div>\n<p><img src=\"/2022/01/linux-input-zi-xi-tong/2909691-20220819102740731-2036281828.png\" alt></p><pre>\n    <code class=\"yaml\">\n/**\n* input_register_handler - register a new input handler\n* @handler: handler to be registered\n*\n* This function registers a new input handler (interface) for input\n* devices in the system and attaches it to all input devices that\n* are compatible with the handler.\n*/\nint input_register_handler(struct input_handler *handler)\n{\n     struct input_dev *dev;\n     int error;\n     error = mutex_lock_interruptible(&input_mutex);\n     if (error)\n         return error;\n\n<pre><code> INIT_LIST_HEAD(&amp;handler-&gt;h_list);</code></pre><p> 　　/* <code>重要</code>:把设备处理器挂到全局的input子系统设备链表input_handler_list上 <em>/<br>     list_add_tail(&amp;handler-&gt;node, &amp;input_handler_list);<br> 　　/*遍历input_dev_list，试图与每一个input_dev进行匹配</em>/<br>     list_for_each_entry(dev, &amp;input_dev_list, node)<br>         input_attach_handler(dev, handler);　　　　/*static int input_attach_handler(struct input_dev *dev, struct input_handler *handler)<br>{<br>    const struct input_device_id *id;<br>    int error;<br>    ……..<br>    ……..<br>    input_wakeup_procfs_readers();<br>    mutex_unlock(&amp;input_mutex);<br>    return 0;<br>}<br>EXPORT_SYMBOL(input_register_handler);<br>  </p></code><br></pre>  <p></p>\n<p>这个过程和注册dev及其相似</p>\n<h2>3.3 handler的connect函数</h2><pre>\n    <code class=\"yaml\">\nstatic int evdev_connect(struct input_handler *handler, struct input_dev *dev,\n             const struct input_device_id *id)\n{\n    struct evdev *evdev;\n    int minor;\n    int dev_no;\n    int error;\n    /*申请一个新的次设备号*/\n    minor = input_get_new_minor(EVDEV_MINOR_BASE, EVDEV_MINORS, true);\n    /* 这说明内核已经没办法再分配这种类型的设备了 */\n    if (minor < 0) {\n        error = minor;\n        pr_err(\"failed to reserve new minor: %d\\n\", error);\n        return error;\n    }\n    /* 开始给evdev事件层驱动分配空间了 */\n    evdev = kzalloc(sizeof(struct evdev), GFP_KERNEL);\n    if (!evdev) {\n        error = -ENOMEM;\n        goto err_free_minor;\n    }\n        /* 初始化client_list列表和evdev_wait队列 */\n    INIT_LIST_HEAD(&evdev->client_list);\n    spin_lock_init(&evdev->client_lock);\n    mutex_init(&evdev->mutex);\n    init_waitqueue_head(&evdev->wait);\n    evdev->exist = true;\n    dev_no = minor;\n    /* Normalize device number if it falls into legacy range */\n    if (dev_no < EVDEV_MINOR_BASE + EVDEV_MINORS)\n        dev_no -= EVDEV_MINOR_BASE;\n    /*设置设备节点名称，/dev/eventX 就是在此时设置*/\n    dev_set_name(&evdev->dev, \"event%d\", dev_no);\n    /* 初始化evdev结构体，其中handle为输入设备和事件处理的关联接口 */\n    evdev->handle.dev = input_get_device(dev);\n    evdev->handle.name = dev_name(&evdev->dev);\n    evdev->handle.handler = handler;\n    evdev->handle.private = evdev;\n      /*设置设备号，应用层就是通过设备号，找到该设备的*/\n    evdev->dev.devt = MKDEV(INPUT_MAJOR, minor);\n    evdev->dev.class = &input_class;\n    evdev->dev.parent = &dev->dev;\n    evdev->dev.release = evdev_free;\n    device_initialize(&evdev->dev);\n     /* input_dev设备驱动和handler事件处理层的关联，就在这时由handle完成 */\n    error = input_register_handle(&evdev->handle);\n    if (error)\n        goto err_free_evdev;\n    cdev_init(&evdev->cdev, &evdev_fops);\n    evdev->cdev.kobj.parent = &evdev->dev.kobj;\n    error = cdev_add(&evdev->cdev, evdev->dev.devt, 1);\n    if (error)\n        goto err_unregister_handle;\n    /*将设备加入到Linux设备模型，它的内部将找到它的bus，然后让它的bus\n    给它找到它的driver，在驱动或者总线的probe函数中，一般会在/dev/目录\n    先创建相应的设备节点，这样应用程序就可以通过该设备节点来使用设备了\n    ，/dev/eventX 设备节点就是在此时生成\n    */\n    error = device_add(&evdev->dev);\n    if (error)\n        goto err_cleanup_evdev;\n    return 0;\n err_cleanup_evdev:\n    evdev_cleanup(evdev);\n err_unregister_handle:\n    input_unregister_handle(&evdev->handle);\n err_free_evdev:\n    put_device(&evdev->dev);\n err_free_minor:\n    input_free_minor(minor);\n    return error;\n}\n  </code>\n</pre>   \n<p>over</p>\n<h1>4.应用层的角度分析到底层</h1>\n<p><img src=\"/2022/01/linux-input-zi-xi-tong/input_logical.png\" alt></p>\n<p>显然，就是input_dev通过输入核心为驱动层提供统一的接口，<code>input_event</code>，来向事件处理层上报数据并唤醒。</p>\n</div>\n</div>\n</div>","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<div>\n<div>\n<ul>\n<li>\n<h5>Input driver ：主要实现对硬件设备的读写访问，中断设置，并把硬件产生的事件转换为核心层定义的规范提交给事件处理层。</h5>\n</li>\n<li>\n<h5>Input core ：承上启下。为设备驱动层提供了规范和接口；通知事件处理层对事件进行处理；</h5>\n</li>\n<li>\n<h5>Event handler ：提供用户编程的接口（设备节点），并处理驱动层提交的数据处理。</h5>\n</li>\n</ul>\n<p><img src=\"/2022/01/linux-input-zi-xi-tong/2909691-20220819093409715-1604400596.png\" alt></p>\n<h1>1输入子系统框架分析</h1>\n<div>\n<div>\n<h2>1.1设备驱动层（Input driver）</h2>\n<ul>\n<li>device是纯硬件操作层，包含不同的硬件接口处理，如gpio等</li>\n<li>对于每种不同的具体硬件操作，都对应着不同的input_dev结构体</li>\n<li>该结构体内部也包含着一个h_list，指向handle</li>\n</ul>\n</div>\n</div>\n<div>\n<div>\n<div>\n<div>\n<h2>1.2.系统核心层（Input core）</h2>\n<ul>\n<li>申请主设备号;</li>\n<li>提供input_register_device跟input_register_handler函数分别用于注册device跟handler;</li>\n<li>提供input_register_handle函数用于注册一个事件处理，代表一个成功配对的input_dev和input_handler;</li>\n</ul>\n</div>\n</div>\n<h2>1.3.事件处理层（Event handler）</h2>\n<ul>\n<li>不涉及硬件方面的具体操作，handler层是纯软件层，包含不同的解决方案，如键盘，鼠标，游戏手柄等；</li>\n<li>对于不同的解决方案，都包含一个名为input_handler的结构体，该结构体内含的主要成员如下：</li>\n</ul>\n<table>\n<thead>\n<tr><th>成员</th><th>功能</th></tr>\n</thead>\n<tbody>\n<tr>\n<td>.id_table</td>\n<td>一个存放该handler所支持的设备id的表（其实内部存放的是EV_xxx事件,用于判断device是否支持该事件）</td>\n</tr>\n<tr>\n<td>.fops</td>\n<td>该handler的file_operation</td>\n</tr>\n<tr>\n<td>.connect</td>\n<td>连接该handler跟所支持device的函数</td>\n</tr>\n<tr>\n<td>.disconnect</td>\n<td>断开该连接</td>\n</tr>\n<tr>\n<td>.event</td>\n<td>事件处理函数，让device调用</td>\n</tr>\n<tr>\n<td>h_list</td>\n<td>是一个链表，该链表保存着该handler到所支持的所有device的中间站：handle结构体的指针</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1>2.两条链表连接dev和handler</h1>\n<pre>\n    <code class=\"yaml\">\n#file pwd: drivers/input/input.c\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@suse.cz>\");\nMODULE_DESCRIPTION(\"Input core\");\nMODULE_LICENSE(\"GPL\");\n#define INPUT_MAX_CHAR_DEVICES        1024\n#define INPUT_FIRST_DYNAMIC_DEV        256\nstatic DEFINE_IDA(input_ida);\nstatic LIST_HEAD(input_dev_list);\nstatic LIST_HEAD(input_handler_list);\n  </vojtech@suse.cz></code>\n</pre> \n在input.c文件中两个全局链表input_handler_list和<span style=\"color: #000000;\">input_dev_list</span>，通过handle相互关联：</div>\n<div><img src=\"/2022/01/linux-input-zi-xi-tong/2909691-20220819094250974-180404869.webp\" alt>\n<p>&nbsp;</p>\n<h1>3.输入子系统代码分析</h1>\n<p>文件路径：driver/input/input.c （核心层）</p>\n<pre>\n    <code class=\"yaml\">\nstatic int __init input_init(void)\n{\n    int err;\n    err = class_register(&input_class);  //在/sys/class下创建逻辑（input）类，在类下面挂载input设备\n    if (err) {\n        pr_err(\"unable to register input_dev class\\n\");\n        return err;\n    }\n    err = input_proc_init();　　//在/proc下面建立相关的虚拟文件，proc下创建的文件可以看作是虚拟文件对内核读写的一种操作\n    if (err)\n        goto fail1;\n    err = register_chrdev_region(MKDEV(INPUT_MAJOR, 0),//在/dev下创建input设备号\n                     INPUT_MAX_CHAR_DEVICES, \"input\");\n    if (err) {\n        pr_err(\"unable to register char major %d\", INPUT_MAJOR);\n        goto fail2;\n    }\n    return 0;\n fail2:    input_proc_exit();\n fail1:    class_unregister(&input_class);\n    return err;\n}\nstatic void __exit input_exit(void)\n{\n    input_proc_exit();\n    unregister_chrdev_region(MKDEV(INPUT_MAJOR, 0),\n                 INPUT_MAX_CHAR_DEVICES);\n    class_unregister(&input_class);\n}\nsubsys_initcall(input_init);\nmodule_exit(input_exit);\n  </code>\n</pre> \n<p>现在基本框架已经建成，如何往input系统里面注册dev和hanlder呢？</p>\n<h2>3.1注册dev</h2>\n<pre>\n    <code class=\"yaml\">\n/**\n * struct input_dev - represents an input device\n * @name: name of the device\n * @phys: physical path to the device in the system hierarchy\n * @uniq: unique identification code for the device (if device has it)\n * @id: id of the device (struct input_id)\n * @propbit: bitmap of device properties and quirks\n * @evbit: bitmap of types of events supported by the device (EV_KEY,\n *    EV_REL, etc.)\n * @keybit: bitmap of keys/buttons this device has\n * @relbit: bitmap of relative axes for the device\n * @absbit: bitmap of absolute axes for the device\n * @mscbit: bitmap of miscellaneous events supported by the device\n * @ledbit: bitmap of leds present on the device\n * @sndbit: bitmap of sound effects supported by the device\n * @ffbit: bitmap of force feedback effects supported by the device\n * @swbit: bitmap of switches present on the device\n * @hint_events_per_packet: average number of events generated by the\n *    device in a packet (between EV_SYN/SYN_REPORT events). Used by\n *    event handlers to estimate size of the buffer needed to hold\n *    events.\n * @keycodemax: size of keycode table\n * @keycodesize: size of elements in keycode table\n * @keycode: map of scancodes to keycodes for this device\n * @getkeycode: optional legacy method to retrieve current keymap.\n * @setkeycode: optional method to alter current keymap, used to implement\n *    sparse keymaps. If not supplied default mechanism will be used.\n *    The method is being called while holding event_lock and thus must\n *    not sleep\n * @ff: force feedback structure associated with the device if device\n *    supports force feedback effects\n * @repeat_key: stores key code of the last key pressed; used to implement\n *    software autorepeat\n * @timer: timer for software autorepeat\n * @rep: current values for autorepeat parameters (delay, rate)\n * @mt: pointer to multitouch state\n * @absinfo: array of &struct input_absinfo elements holding information\n *    about absolute axes (current value, min, max, flat, fuzz,\n *    resolution)\n * @key: reflects current state of device's keys/buttons\n * @led: reflects current state of device's LEDs\n * @snd: reflects current state of sound effects\n * @sw: reflects current state of device's switches\n * @open: this method is called when the very first user calls\n *    input_open_device(). The driver must prepare the device\n *    to start generating events (start polling thread,\n *    request an IRQ, submit URB, etc.)\n * @close: this method is called when the very last user calls\n *    input_close_device().\n * @flush: purges the device. Most commonly used to get rid of force\n *    feedback effects loaded into the device when disconnecting\n *    from it\n * @event: event handler for events sent _to_ the device, like EV_LED\n *    or EV_SND. The device is expected to carry out the requested\n *    action (turn on a LED, play sound, etc.) The call is protected\n *    by @event_lock and must not sleep\n * @grab: input handle that currently has the device grabbed (via\n *    EVIOCGRAB ioctl). When a handle grabs a device it becomes sole\n *    recipient for all input events coming from the device\n * @event_lock: this spinlock is is taken when input core receives\n *    and processes a new event for the device (in input_event()).\n *    Code that accesses and/or modifies parameters of a device\n *    (such as keymap or absmin, absmax, absfuzz, etc.) after device\n *    has been registered with input core must take this lock.\n * @mutex: serializes calls to open(), close() and flush() methods\n * @users: stores number of users (input handlers) that opened this\n *    device. It is used by input_open_device() and input_close_device()\n *    to make sure that dev->open() is only called when the first\n *    user opens device and dev->close() is called when the very\n *    last user closes the device\n * @going_away: marks devices that are in a middle of unregistering and\n *    causes input_open_device*() fail with -ENODEV.\n * @dev: driver model's view of this device\n * @h_list: list of input handles associated with the device. When\n *    accessing the list dev->mutex must be held\n * @node: used to place the device onto input_dev_list\n * @num_vals: number of values queued in the current frame\n * @max_vals: maximum number of values queued in a frame\n * @vals: array of values queued in the current frame\n * @devres_managed: indicates that devices is managed with devres framework\n *    and needs not be explicitly unregistered or freed.\n */\nstruct input_dev {\n    const char *name;\n    const char *phys;\n    const char *uniq;\n    struct input_id id;\n    unsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];\n    unsigned long evbit[BITS_TO_LONGS(EV_CNT)];\n    unsigned long keybit[BITS_TO_LONGS(KEY_CNT)];\n    unsigned long relbit[BITS_TO_LONGS(REL_CNT)];\n    unsigned long absbit[BITS_TO_LONGS(ABS_CNT)];\n    unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)];\n    unsigned long ledbit[BITS_TO_LONGS(LED_CNT)];\n    unsigned long sndbit[BITS_TO_LONGS(SND_CNT)];\n    unsigned long ffbit[BITS_TO_LONGS(FF_CNT)];\n    unsigned long swbit[BITS_TO_LONGS(SW_CNT)];\n    unsigned int hint_events_per_packet;\n    unsigned int keycodemax;\n    unsigned int keycodesize;\n    void *keycode;\n    int (*setkeycode)(struct input_dev *dev,\n              const struct input_keymap_entry *ke,\n              unsigned int *old_keycode);\n    int (*getkeycode)(struct input_dev *dev,\n              struct input_keymap_entry *ke);\n    struct ff_device *ff;\n    unsigned int repeat_key;\n    struct timer_list timer;\n    int rep[REP_CNT];\n    struct input_mt *mt;\n    struct input_absinfo *absinfo;\n    unsigned long key[BITS_TO_LONGS(KEY_CNT)];\n    unsigned long led[BITS_TO_LONGS(LED_CNT)];\n    unsigned long snd[BITS_TO_LONGS(SND_CNT)];\n    unsigned long sw[BITS_TO_LONGS(SW_CNT)];\n    int (*open)(struct input_dev *dev);\n    void (*close)(struct input_dev *dev);\n    int (*flush)(struct input_dev *dev, struct file *file);\n    int (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value);\n    struct input_handle __rcu *grab;\n    spinlock_t event_lock;\n    struct mutex mutex;\n    unsigned int users;\n    bool going_away;\n    struct device dev;\n    struct list_head    h_list;\n    struct list_head    node;\n    unsigned int num_vals;\n    unsigned int max_vals;\n    struct input_value *vals;\n    bool devres_managed;\n};\n#define to_input_dev(d) container_of(d, struct input_dev, dev)\n  </code>\n</pre> \n<p>&nbsp;</p>\n<div>\n<div>&nbsp;</div><pre>\n    <code class=\"yaml\">\n/**\n * input_register_device - register device with input core\n * @dev: device to be registered\n *\n * This function registers device with input core. The device must be\n * allocated with input_allocate_device() and all it's capabilities\n * set up before registering.\n * If function fails the device must be freed with input_free_device().\n * Once device has been successfully registered it can be unregistered\n * with input_unregister_device(); input_free_device() should not be\n * called in this case.\n *\n * Note that this function is also used to register managed input devices\n * (ones allocated with devm_input_allocate_device()). Such managed input\n * devices need not be explicitly unregistered or freed, their tear down\n * is controlled by the devres infrastructure. It is also worth noting\n * that tear down of managed input devices is internally a 2-step process:\n * registered managed input device is first unregistered, but stays in\n * memory and can still handle input_event() calls (although events will\n * not be delivered anywhere). The freeing of managed input device will\n * happen later, when devres stack is unwound to the point where device\n * allocation was made.\n */\nint input_register_device(struct input_dev *dev)\n{\n    struct input_devres *devres = NULL;\n     /* 输入事件的处理接口指针，用于和设备的事件类型进行匹配 */\n    struct input_handler *handler;\n    unsigned int packet_size;\n    const char *path;\n    int error;\n    if (dev->devres_managed) {\n        devres = devres_alloc(devm_input_device_unregister,\n                      sizeof(struct input_devres), GFP_KERNEL);\n        if (!devres)\n            return -ENOMEM;\n        devres->input = dev;\n    }\n    /* Every input device generates EV_SYN/SYN_REPORT events. */\n    __set_bit(EV_SYN, dev->evbit);\n    /* KEY_RESERVED is not supposed to be transmitted to userspace. */\n    __clear_bit(KEY_RESERVED, dev->keybit);\n    /* Make sure that bitmasks not mentioned in dev->evbit are clean. */\n    input_cleanse_bitmasks(dev);\n    packet_size = input_estimate_events_per_packet(dev);\n    if (dev->hint_events_per_packet < packet_size)\n        dev->hint_events_per_packet = packet_size;\n    dev->max_vals = dev->hint_events_per_packet + 2;\n    dev->vals = kcalloc(dev->max_vals, sizeof(*dev->vals), GFP_KERNEL);\n    if (!dev->vals) {\n        error = -ENOMEM;\n        goto err_devres_free;\n    }\n    /*\n     * If delay and period are pre-set by the driver, then autorepeating\n     * is handled by the driver itself and we don't do it in input.c.\n     */\n    if (!dev->rep[REP_DELAY] && !dev->rep[REP_PERIOD]) {\n        dev->timer.data = (long) dev;\n        dev->timer.function = input_repeat_key;\n        dev->rep[REP_DELAY] = 250;\n        dev->rep[REP_PERIOD] = 33;\n    }\n    if (!dev->getkeycode)\n        dev->getkeycode = input_default_getkeycode;\n    if (!dev->setkeycode)\n        dev->setkeycode = input_default_setkeycode;\n    error = device_add(&dev->dev);\n    if (error)\n        goto err_free_vals;\n    path = kobject_get_path(&dev->dev.kobj, GFP_KERNEL);\n    pr_info(\"%s as %s\\n\",\n        dev->name ? dev->name : \"Unspecified device\",\n        path ? path : \"N/A\");\n    kfree(path);\n    error = mutex_lock_interruptible(&input_mutex);\n    if (error)\n        goto err_device_del;\n    /* 重要:把设备挂到全局的input子系统设备链表input_dev_list上 */\n    list_add_tail(&dev->node, &input_dev_list);\n    /* 核心重点，input设备在增加到input_dev_list链表上之后，会查找\n     * input_handler_list事件处理链表上的handler进行匹配，这里的匹配\n     * 方式与设备模型的device和driver匹配过程很相似*/\n    list_for_each_entry(handler, &input_handler_list, node)\n        input_attach_handler(dev, handler);/*遍历input_handler_list，通过input_match_device试图与每一个handler进行匹配 匹配上了就使用connect连接*/\n    /*\n    static int input_attach_handler(struct input_dev *dev, struct input_handler *handler)\n    {\n        const struct input_device_id *id;\n        int error;\n\n<pre><code>    id = input_match_device(handler, dev);\n    if (!id)\n        return -ENODEV;\n    error = handler-&gt;connect(handler, dev, id);\n    if (error &amp;&amp; error != -ENODEV)\n        pr_err(&quot;failed to attach handler %s to device %s, error: %d\\n&quot;,\n               handler-&gt;name, kobject_name(&amp;dev-&gt;dev.kobj), error);\n    return error;\n}\n*/\ninput_wakeup_procfs_readers();\nmutex_unlock(&amp;input_mutex);\nif (dev-&gt;devres_managed) {\n    dev_dbg(dev-&gt;dev.parent, &quot;%s: registering %s with devres.\\n&quot;,\n        __func__, dev_name(&amp;dev-&gt;dev));\n    devres_add(dev-&gt;dev.parent, devres);\n}\nreturn 0;</code></pre><p>err_device_del:<br>    device_del(&amp;dev-&gt;dev);<br>err_free_vals:<br>    kfree(dev-&gt;vals);<br>    dev-&gt;vals = NULL;<br>err_devres_free:<br>    devres_free(devres);<br>    return error;<br>}<br>EXPORT_SYMBOL(input_register_device);<br>  </p></code><br></pre> <p></p>\n<h2>3.2注册handler</h2>\n<p>一般handler不需要我们自己写 内核里面已经有了很多的hanlder基本够用</p>\n下面以Evdev为例，来分析事件处理层。<br>\nvim drivers/input/evdev.c</div>\n<div>\n<pre>\n    <code class=\"yaml\">\nstatic const struct input_device_id evdev_ids[] = {\n    { .driver_info = 1 },    /* Matches all devices */\n    { },            /* Terminating zero entry */\n};\nMODULE_DEVICE_TABLE(input, evdev_ids);\nstatic struct input_handler evdev_handler = {\n    .event        = evdev_event,\n    .events        = evdev_events,\n    .connect    = evdev_connect,\n    .disconnect    = evdev_disconnect,\n    .legacy_minors    = true,\n    .minor        = EVDEV_MINOR_BASE,\n    .name        = \"evdev\",\n    .id_table    = evdev_ids,\n};\nstatic int __init evdev_init(void)\n{\n    return input_register_handler(&evdev_handler);\n}\nstatic void __exit evdev_exit(void)\n{\n    input_unregister_handler(&evdev_handler);\n}\nmodule_init(evdev_init);\nmodule_exit(evdev_exit);\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>\");\nMODULE_DESCRIPTION(\"Input driver event char devices\");\nMODULE_LICENSE(\"GPL\");  \n  </vojtech@ucw.cz></code>\n</pre>  \n<p>注册的handler可以在proc/bus/input/danlder中查看到</p>\n</div>\n<p><img src=\"/2022/01/linux-input-zi-xi-tong/2909691-20220819102740731-2036281828.png\" alt></p><pre>\n    <code class=\"yaml\">\n/**\n* input_register_handler - register a new input handler\n* @handler: handler to be registered\n*\n* This function registers a new input handler (interface) for input\n* devices in the system and attaches it to all input devices that\n* are compatible with the handler.\n*/\nint input_register_handler(struct input_handler *handler)\n{\n     struct input_dev *dev;\n     int error;\n     error = mutex_lock_interruptible(&input_mutex);\n     if (error)\n         return error;\n\n<pre><code> INIT_LIST_HEAD(&amp;handler-&gt;h_list);</code></pre><p> 　　/* <code>重要</code>:把设备处理器挂到全局的input子系统设备链表input_handler_list上 <em>/<br>     list_add_tail(&amp;handler-&gt;node, &amp;input_handler_list);<br> 　　/*遍历input_dev_list，试图与每一个input_dev进行匹配</em>/<br>     list_for_each_entry(dev, &amp;input_dev_list, node)<br>         input_attach_handler(dev, handler);　　　　/*static int input_attach_handler(struct input_dev *dev, struct input_handler *handler)<br>{<br>    const struct input_device_id *id;<br>    int error;<br>    ……..<br>    ……..<br>    input_wakeup_procfs_readers();<br>    mutex_unlock(&amp;input_mutex);<br>    return 0;<br>}<br>EXPORT_SYMBOL(input_register_handler);<br>  </p></code><br></pre>  <p></p>\n<p>这个过程和注册dev及其相似</p>\n<h2>3.3 handler的connect函数</h2><pre>\n    <code class=\"yaml\">\nstatic int evdev_connect(struct input_handler *handler, struct input_dev *dev,\n             const struct input_device_id *id)\n{\n    struct evdev *evdev;\n    int minor;\n    int dev_no;\n    int error;\n    /*申请一个新的次设备号*/\n    minor = input_get_new_minor(EVDEV_MINOR_BASE, EVDEV_MINORS, true);\n    /* 这说明内核已经没办法再分配这种类型的设备了 */\n    if (minor < 0) {\n        error = minor;\n        pr_err(\"failed to reserve new minor: %d\\n\", error);\n        return error;\n    }\n    /* 开始给evdev事件层驱动分配空间了 */\n    evdev = kzalloc(sizeof(struct evdev), GFP_KERNEL);\n    if (!evdev) {\n        error = -ENOMEM;\n        goto err_free_minor;\n    }\n        /* 初始化client_list列表和evdev_wait队列 */\n    INIT_LIST_HEAD(&evdev->client_list);\n    spin_lock_init(&evdev->client_lock);\n    mutex_init(&evdev->mutex);\n    init_waitqueue_head(&evdev->wait);\n    evdev->exist = true;\n    dev_no = minor;\n    /* Normalize device number if it falls into legacy range */\n    if (dev_no < EVDEV_MINOR_BASE + EVDEV_MINORS)\n        dev_no -= EVDEV_MINOR_BASE;\n    /*设置设备节点名称，/dev/eventX 就是在此时设置*/\n    dev_set_name(&evdev->dev, \"event%d\", dev_no);\n    /* 初始化evdev结构体，其中handle为输入设备和事件处理的关联接口 */\n    evdev->handle.dev = input_get_device(dev);\n    evdev->handle.name = dev_name(&evdev->dev);\n    evdev->handle.handler = handler;\n    evdev->handle.private = evdev;\n      /*设置设备号，应用层就是通过设备号，找到该设备的*/\n    evdev->dev.devt = MKDEV(INPUT_MAJOR, minor);\n    evdev->dev.class = &input_class;\n    evdev->dev.parent = &dev->dev;\n    evdev->dev.release = evdev_free;\n    device_initialize(&evdev->dev);\n     /* input_dev设备驱动和handler事件处理层的关联，就在这时由handle完成 */\n    error = input_register_handle(&evdev->handle);\n    if (error)\n        goto err_free_evdev;\n    cdev_init(&evdev->cdev, &evdev_fops);\n    evdev->cdev.kobj.parent = &evdev->dev.kobj;\n    error = cdev_add(&evdev->cdev, evdev->dev.devt, 1);\n    if (error)\n        goto err_unregister_handle;\n    /*将设备加入到Linux设备模型，它的内部将找到它的bus，然后让它的bus\n    给它找到它的driver，在驱动或者总线的probe函数中，一般会在/dev/目录\n    先创建相应的设备节点，这样应用程序就可以通过该设备节点来使用设备了\n    ，/dev/eventX 设备节点就是在此时生成\n    */\n    error = device_add(&evdev->dev);\n    if (error)\n        goto err_cleanup_evdev;\n    return 0;\n err_cleanup_evdev:\n    evdev_cleanup(evdev);\n err_unregister_handle:\n    input_unregister_handle(&evdev->handle);\n err_free_evdev:\n    put_device(&evdev->dev);\n err_free_minor:\n    input_free_minor(minor);\n    return error;\n}\n  </code>\n</pre>   \n<p>over</p>\n<h1>4.应用层的角度分析到底层</h1>\n<p><img src=\"/2022/01/linux-input-zi-xi-tong/input_logical.png\" alt></p>\n<p>显然，就是input_dev通过输入核心为驱动层提供统一的接口，<code>input_event</code>，来向事件处理层上报数据并唤醒。</p>\n</div>\n</div>\n</div>"},{"title":"IMX6ull 移植 lVGL总结","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2022-01-01T12:59:25.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"<h1>1 ：准备工作</h1>\n<p>硬件：正点原子的Imx6ull开发板</p>\n<p>环境：ubuntu18.0</p>\n<p>lvgl软件地址：<a href=\"git@gitee.com:qian-qiang/imx6ull_lvgl_demo.git\" target=\"_blank\" rel=\"noopener\">git@gitee.com:qian-qiang/imx6ull_lvgl_demo.git</a></p>\n<h1>2：git 厂库修改文件</h1>\n<p>2.1：修改文件lv_drv_config.h</p>\n<p><img src=\"IMX6ull-移植-lVGL总结/2909691-20220928151916481-1456634923.png\" alt=\"\" height=\"513\" width=\"1084\" /></p>\n<p><img src=\"IMX6ull-移植-lVGL总结/2909691-20220928152209724-1097250473.png\" alt=\"\" height=\"368\" width=\"1087\" /></p>\n<p><img src=\"IMX6ull-移植-lVGL总结/2909691-20220928153140065-1807119912.png\" alt=\"\" height=\"177\" width=\"1081\" /></p>\n<p id=\"1664350186406\"></p>\n<p id=\"1664349615994\">2.2：修改文件lv_conf.h</p>\n<p><img src=\"IMX6ull-移植-lVGL总结/2909691-20220928152957065-501054685.png\" alt=\"\" height=\"387\" width=\"1664\" /></p>\n<p><img src=\"IMX6ull-移植-lVGL总结/2909691-20220928152945955-899676295.png\" alt=\"\" height=\"843\" width=\"1671\" /></p>\n<p><img src=\"IMX6ull-移植-lVGL总结/2909691-20220928152922659-1842915282.png\" alt=\"\" /></p>\n<p id=\"1664350048873\">2.3：修改文件main.c</p>\n<p><img src=\"IMX6ull-移植-lVGL总结/2909691-20220928153305849-1048335725.png\" alt=\"\" /></p>\n<h1>3：make</h1>\n<p>由于环境的问题 make过程中可能有问题 上百度应该改都能解决 最后生成demo文件&nbsp;</p>\n<p><img src=\"IMX6ull-移植-lVGL总结/2909691-20220928153451220-1274979267.png\" alt=\"\" /></p>\n<h1>4：scp到开发板运行即可</h1>\n<p>&nbsp;</p>\n<p id=\"1664350272125\"></p>\n<p id=\"1664349445067\"></p>\n<p>&nbsp;</p>\n","source":"_posts/2022/01/IMX6ull-移植-lVGL总结.md","raw":"---\ntitle: IMX6ull 移植 lVGL总结\npermalink: IMX6ull 移植 lVGL总结\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2022-01-01 20:59:25\npassword:\nsummary:\ntags:\n- linux\n- imx6ull\ncategories:\n- linux\nkeywords:\ndescription:\n---\n<h1>1 ：准备工作</h1>\n<p>硬件：正点原子的Imx6ull开发板</p>\n<p>环境：ubuntu18.0</p>\n<p>lvgl软件地址：<a href=\"git@gitee.com:qian-qiang/imx6ull_lvgl_demo.git\" target=\"_blank\" rel=\"noopener\">git@gitee.com:qian-qiang/imx6ull_lvgl_demo.git</a></p>\n<h1>2：git 厂库修改文件</h1>\n<p>2.1：修改文件lv_drv_config.h</p>\n<p><img src=\"IMX6ull-移植-lVGL总结/2909691-20220928151916481-1456634923.png\" alt=\"\" height=\"513\" width=\"1084\" /></p>\n<p><img src=\"IMX6ull-移植-lVGL总结/2909691-20220928152209724-1097250473.png\" alt=\"\" height=\"368\" width=\"1087\" /></p>\n<p><img src=\"IMX6ull-移植-lVGL总结/2909691-20220928153140065-1807119912.png\" alt=\"\" height=\"177\" width=\"1081\" /></p>\n<p id=\"1664350186406\"></p>\n<p id=\"1664349615994\">2.2：修改文件lv_conf.h</p>\n<p><img src=\"IMX6ull-移植-lVGL总结/2909691-20220928152957065-501054685.png\" alt=\"\" height=\"387\" width=\"1664\" /></p>\n<p><img src=\"IMX6ull-移植-lVGL总结/2909691-20220928152945955-899676295.png\" alt=\"\" height=\"843\" width=\"1671\" /></p>\n<p><img src=\"IMX6ull-移植-lVGL总结/2909691-20220928152922659-1842915282.png\" alt=\"\" /></p>\n<p id=\"1664350048873\">2.3：修改文件main.c</p>\n<p><img src=\"IMX6ull-移植-lVGL总结/2909691-20220928153305849-1048335725.png\" alt=\"\" /></p>\n<h1>3：make</h1>\n<p>由于环境的问题 make过程中可能有问题 上百度应该改都能解决 最后生成demo文件&nbsp;</p>\n<p><img src=\"IMX6ull-移植-lVGL总结/2909691-20220928153451220-1274979267.png\" alt=\"\" /></p>\n<h1>4：scp到开发板运行即可</h1>\n<p>&nbsp;</p>\n<p id=\"1664350272125\"></p>\n<p id=\"1664349445067\"></p>\n<p>&nbsp;</p>\n","slug":"IMX6ull 移植 lVGL总结","published":1,"updated":"2023-04-04T09:24:10.127Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk69d1cr0008jsrjzpyi2nkr","content":"<h1>1 ：准备工作</h1>\n<p>硬件：正点原子的Imx6ull开发板</p>\n<p>环境：ubuntu18.0</p>\n<p>lvgl软件地址：<a href=\"git@gitee.com:qian-qiang/imx6ull_lvgl_demo.git\" target=\"_blank\" rel=\"noopener\">git@gitee.com:qian-qiang/imx6ull_lvgl_demo.git</a></p>\n<h1>2：git 厂库修改文件</h1>\n<p>2.1：修改文件lv_drv_config.h</p>\n<p><img src=\"/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928151916481-1456634923.png\" alt height=\"513\" width=\"1084\"></p>\n<p><img src=\"/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928152209724-1097250473.png\" alt height=\"368\" width=\"1087\"></p>\n<p><img src=\"/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928153140065-1807119912.png\" alt height=\"177\" width=\"1081\"></p>\n<p id=\"1664350186406\"></p>\n<p id=\"1664349615994\">2.2：修改文件lv_conf.h</p>\n<p><img src=\"/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928152957065-501054685.png\" alt height=\"387\" width=\"1664\"></p>\n<p><img src=\"/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928152945955-899676295.png\" alt height=\"843\" width=\"1671\"></p>\n<p><img src=\"/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928152922659-1842915282.png\" alt></p>\n<p id=\"1664350048873\">2.3：修改文件main.c</p>\n<p><img src=\"/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928153305849-1048335725.png\" alt></p>\n<h1>3：make</h1>\n<p>由于环境的问题 make过程中可能有问题 上百度应该改都能解决 最后生成demo文件&nbsp;</p>\n<p><img src=\"/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928153451220-1274979267.png\" alt></p>\n<h1>4：scp到开发板运行即可</h1>\n<p>&nbsp;</p>\n<p id=\"1664350272125\"></p>\n<p id=\"1664349445067\"></p>\n<p>&nbsp;</p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<h1>1 ：准备工作</h1>\n<p>硬件：正点原子的Imx6ull开发板</p>\n<p>环境：ubuntu18.0</p>\n<p>lvgl软件地址：<a href=\"git@gitee.com:qian-qiang/imx6ull_lvgl_demo.git\" target=\"_blank\" rel=\"noopener\">git@gitee.com:qian-qiang/imx6ull_lvgl_demo.git</a></p>\n<h1>2：git 厂库修改文件</h1>\n<p>2.1：修改文件lv_drv_config.h</p>\n<p><img src=\"/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928151916481-1456634923.png\" alt height=\"513\" width=\"1084\"></p>\n<p><img src=\"/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928152209724-1097250473.png\" alt height=\"368\" width=\"1087\"></p>\n<p><img src=\"/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928153140065-1807119912.png\" alt height=\"177\" width=\"1081\"></p>\n<p id=\"1664350186406\"></p>\n<p id=\"1664349615994\">2.2：修改文件lv_conf.h</p>\n<p><img src=\"/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928152957065-501054685.png\" alt height=\"387\" width=\"1664\"></p>\n<p><img src=\"/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928152945955-899676295.png\" alt height=\"843\" width=\"1671\"></p>\n<p><img src=\"/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928152922659-1842915282.png\" alt></p>\n<p id=\"1664350048873\">2.3：修改文件main.c</p>\n<p><img src=\"/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928153305849-1048335725.png\" alt></p>\n<h1>3：make</h1>\n<p>由于环境的问题 make过程中可能有问题 上百度应该改都能解决 最后生成demo文件&nbsp;</p>\n<p><img src=\"/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928153451220-1274979267.png\" alt></p>\n<h1>4：scp到开发板运行即可</h1>\n<p>&nbsp;</p>\n<p id=\"1664350272125\"></p>\n<p id=\"1664349445067\"></p>\n<p>&nbsp;</p>\n"},{"title":"python使用百度翻译的API","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2022-01-01T12:12:26.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"  API 在python中就相当于一串代码，我们直接调用结果就够了，今天我们使用百度API打造自己的翻译小可爱。\n  百度搜索：百度apistore\n  ![](python使用百度翻译的API/20200302112753932.png)\n  进入后点击翻译\n  ![](python使用百度翻译的API/20200302112847600.png)\n  接下来各位就可以探索了，注册的艰巨任务就交给你们了。\n  注册后出现以下数据就ok了![](python使用百度翻译的API/20200302113313981.png)\n  我们参考百度api的文档与支持里面的开发者文档的通用翻译API里面有使用的方法，如图![](python使用百度翻译的API/20200302113654396.png)\n  大概的看下说明文档一下代码就可以很好的理解了 ，接下来直接代码分析\n  \n\n<pre>\n\t<code class=\"yaml\">\nimport random\nimport hashlib\nimport urllib\nimport requests\nimport json                                               #安装相应的库\n\n\nsrc = 'zh'                                                #翻译的源语言\nobj = 'en'                                                #翻译的目标语言\nappid = 'xxxxxxxxxxx'                                     #这里输入你注册后得到的appid\nsecretKey = 'xxxxxxxxxx'                                  #这里输入你注册后得到的密匙       \n\nmyurl = 'http://api.fanyi.baidu.com/api/trans/vip/translate'                  #必须加上的头\nword= input('请输入你要翻译的中文：')                                         #输入你要翻译的中文\nsalt = random.randint(31256, 66253)                                           #产生随计数\n\nsign = appid + word + str(salt) + secretKey                                   #文档的step1拼接字符串\nm1 = hashlib.md5()\nm1.update(sign.encode('utf-8'))\nsign = m1.hexdigest()                                                         #文档的step2计算签名\nmyur1 = myurl  + '?q=' + urllib.parse.quote(\n    word) + '&from=' + src + '&to=' + obj + '&appid='+ appid + '&salt=' + str(salt) + '&sign=' + sign\nprint (myur1)                                                                 #生成的url并打印出来\nenglish_data = requests.get(myur1)                                            #请求url\njs_data = json.loads(english_data.text)                                       #下载json数据\ncontent = js_data['trans_result'][0]['dst']                                   #提取json数据里面的dst\nprint (content)                                                               #打印出翻译的英文\n</code>\n</pre>\n![](python使用百度翻译的API/20200302115943813.png)\n这是运行的结构；其中翻译的url点击进去就会跳到浏览器里面 如图：\n![](python使用百度翻译的API/20200302120105912.png)\n里面的数据其实是字典结构的我们使用json的库提取其中的dst就是我们需要的翻译结果\n\n","source":"_posts/2022/01/python使用百度翻译的API.md","raw":"---\ntitle: python使用百度翻译的API\npermalink: python使用百度翻译的API\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2022-01-01 20:12:26\npassword:\nsummary:\ntags:\n- python\ncategories:\n- python\nkeywords:\ndescription:\n---\n  API 在python中就相当于一串代码，我们直接调用结果就够了，今天我们使用百度API打造自己的翻译小可爱。\n  百度搜索：百度apistore\n  ![](python使用百度翻译的API/20200302112753932.png)\n  进入后点击翻译\n  ![](python使用百度翻译的API/20200302112847600.png)\n  接下来各位就可以探索了，注册的艰巨任务就交给你们了。\n  注册后出现以下数据就ok了![](python使用百度翻译的API/20200302113313981.png)\n  我们参考百度api的文档与支持里面的开发者文档的通用翻译API里面有使用的方法，如图![](python使用百度翻译的API/20200302113654396.png)\n  大概的看下说明文档一下代码就可以很好的理解了 ，接下来直接代码分析\n  \n\n<pre>\n\t<code class=\"yaml\">\nimport random\nimport hashlib\nimport urllib\nimport requests\nimport json                                               #安装相应的库\n\n\nsrc = 'zh'                                                #翻译的源语言\nobj = 'en'                                                #翻译的目标语言\nappid = 'xxxxxxxxxxx'                                     #这里输入你注册后得到的appid\nsecretKey = 'xxxxxxxxxx'                                  #这里输入你注册后得到的密匙       \n\nmyurl = 'http://api.fanyi.baidu.com/api/trans/vip/translate'                  #必须加上的头\nword= input('请输入你要翻译的中文：')                                         #输入你要翻译的中文\nsalt = random.randint(31256, 66253)                                           #产生随计数\n\nsign = appid + word + str(salt) + secretKey                                   #文档的step1拼接字符串\nm1 = hashlib.md5()\nm1.update(sign.encode('utf-8'))\nsign = m1.hexdigest()                                                         #文档的step2计算签名\nmyur1 = myurl  + '?q=' + urllib.parse.quote(\n    word) + '&from=' + src + '&to=' + obj + '&appid='+ appid + '&salt=' + str(salt) + '&sign=' + sign\nprint (myur1)                                                                 #生成的url并打印出来\nenglish_data = requests.get(myur1)                                            #请求url\njs_data = json.loads(english_data.text)                                       #下载json数据\ncontent = js_data['trans_result'][0]['dst']                                   #提取json数据里面的dst\nprint (content)                                                               #打印出翻译的英文\n</code>\n</pre>\n![](python使用百度翻译的API/20200302115943813.png)\n这是运行的结构；其中翻译的url点击进去就会跳到浏览器里面 如图：\n![](python使用百度翻译的API/20200302120105912.png)\n里面的数据其实是字典结构的我们使用json的库提取其中的dst就是我们需要的翻译结果\n\n","slug":"python使用百度翻译的API","published":1,"updated":"2023-04-04T10:36:13.093Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk69d1cu000bjsrjmbcr74d8","content":"<p>  API 在python中就相当于一串代码，我们直接调用结果就够了，今天我们使用百度API打造自己的翻译小可爱。<br>  百度搜索：百度apistore<br>  <img src=\"/2022/01/python-shi-yong-bai-du-fan-yi-de-api/20200302112753932.png\" alt><br>  进入后点击翻译<br>  <img src=\"/2022/01/python-shi-yong-bai-du-fan-yi-de-api/20200302112847600.png\" alt><br>  接下来各位就可以探索了，注册的艰巨任务就交给你们了。<br>  注册后出现以下数据就ok了<img src=\"/2022/01/python-shi-yong-bai-du-fan-yi-de-api/20200302113313981.png\" alt><br>  我们参考百度api的文档与支持里面的开发者文档的通用翻译API里面有使用的方法，如图<img src=\"/2022/01/python-shi-yong-bai-du-fan-yi-de-api/20200302113654396.png\" alt><br>  大概的看下说明文档一下代码就可以很好的理解了 ，接下来直接代码分析</p>\n<pre>\n    <code class=\"yaml\">\nimport random\nimport hashlib\nimport urllib\nimport requests\nimport json                                               #安装相应的库\n\n\nsrc = 'zh'                                                #翻译的源语言\nobj = 'en'                                                #翻译的目标语言\nappid = 'xxxxxxxxxxx'                                     #这里输入你注册后得到的appid\nsecretKey = 'xxxxxxxxxx'                                  #这里输入你注册后得到的密匙       \n\nmyurl = 'http://api.fanyi.baidu.com/api/trans/vip/translate'                  #必须加上的头\nword= input('请输入你要翻译的中文：')                                         #输入你要翻译的中文\nsalt = random.randint(31256, 66253)                                           #产生随计数\n\nsign = appid + word + str(salt) + secretKey                                   #文档的step1拼接字符串\nm1 = hashlib.md5()\nm1.update(sign.encode('utf-8'))\nsign = m1.hexdigest()                                                         #文档的step2计算签名\nmyur1 = myurl  + '?q=' + urllib.parse.quote(\n    word) + '&from=' + src + '&to=' + obj + '&appid='+ appid + '&salt=' + str(salt) + '&sign=' + sign\nprint (myur1)                                                                 #生成的url并打印出来\nenglish_data = requests.get(myur1)                                            #请求url\njs_data = json.loads(english_data.text)                                       #下载json数据\ncontent = js_data['trans_result'][0]['dst']                                   #提取json数据里面的dst\nprint (content)                                                               #打印出翻译的英文\n</code>\n</pre>\n<p><img src=\"/2022/01/python-shi-yong-bai-du-fan-yi-de-api/20200302115943813.png\" alt><br>这是运行的结构；其中翻译的url点击进去就会跳到浏览器里面 如图：<br><img src=\"/2022/01/python-shi-yong-bai-du-fan-yi-de-api/20200302120105912.png\" alt><br>里面的数据其实是字典结构的我们使用json的库提取其中的dst就是我们需要的翻译结果</p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<p>  API 在python中就相当于一串代码，我们直接调用结果就够了，今天我们使用百度API打造自己的翻译小可爱。<br>  百度搜索：百度apistore<br>  <img src=\"/2022/01/python-shi-yong-bai-du-fan-yi-de-api/20200302112753932.png\" alt><br>  进入后点击翻译<br>  <img src=\"/2022/01/python-shi-yong-bai-du-fan-yi-de-api/20200302112847600.png\" alt><br>  接下来各位就可以探索了，注册的艰巨任务就交给你们了。<br>  注册后出现以下数据就ok了<img src=\"/2022/01/python-shi-yong-bai-du-fan-yi-de-api/20200302113313981.png\" alt><br>  我们参考百度api的文档与支持里面的开发者文档的通用翻译API里面有使用的方法，如图<img src=\"/2022/01/python-shi-yong-bai-du-fan-yi-de-api/20200302113654396.png\" alt><br>  大概的看下说明文档一下代码就可以很好的理解了 ，接下来直接代码分析</p>\n<pre>\n    <code class=\"yaml\">\nimport random\nimport hashlib\nimport urllib\nimport requests\nimport json                                               #安装相应的库\n\n\nsrc = 'zh'                                                #翻译的源语言\nobj = 'en'                                                #翻译的目标语言\nappid = 'xxxxxxxxxxx'                                     #这里输入你注册后得到的appid\nsecretKey = 'xxxxxxxxxx'                                  #这里输入你注册后得到的密匙       \n\nmyurl = 'http://api.fanyi.baidu.com/api/trans/vip/translate'                  #必须加上的头\nword= input('请输入你要翻译的中文：')                                         #输入你要翻译的中文\nsalt = random.randint(31256, 66253)                                           #产生随计数\n\nsign = appid + word + str(salt) + secretKey                                   #文档的step1拼接字符串\nm1 = hashlib.md5()\nm1.update(sign.encode('utf-8'))\nsign = m1.hexdigest()                                                         #文档的step2计算签名\nmyur1 = myurl  + '?q=' + urllib.parse.quote(\n    word) + '&from=' + src + '&to=' + obj + '&appid='+ appid + '&salt=' + str(salt) + '&sign=' + sign\nprint (myur1)                                                                 #生成的url并打印出来\nenglish_data = requests.get(myur1)                                            #请求url\njs_data = json.loads(english_data.text)                                       #下载json数据\ncontent = js_data['trans_result'][0]['dst']                                   #提取json数据里面的dst\nprint (content)                                                               #打印出翻译的英文\n</code>\n</pre>\n<p><img src=\"/2022/01/python-shi-yong-bai-du-fan-yi-de-api/20200302115943813.png\" alt><br>这是运行的结构；其中翻译的url点击进去就会跳到浏览器里面 如图：<br><img src=\"/2022/01/python-shi-yong-bai-du-fan-yi-de-api/20200302120105912.png\" alt><br>里面的数据其实是字典结构的我们使用json的库提取其中的dst就是我们需要的翻译结果</p>\n"},{"title":"linux线程","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2022-01-01T13:08:57.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"<blockquote>\n<p>linux内核版本0.11</p>\n</blockquote>\n<h1>1：main</h1>\n<p>首先选出一号选手main函数，代码上和线程相关的主要是以下代码</p>\n<pre>\n\t<code class=\"yaml\">\n    void main(void) {    \n    move_to_user_mode();\n    if (!fork()) {\n        init();\n    }\n    for(;;) pause();\n}</code>\n</pre>\n<h1>&nbsp;2：<span style=\"letter-spacing: 0.5px;\"><strong>move_to_user_mode</strong></span></h1>\n<p><span style=\"letter-spacing: 0.5px; font-size: 15px;\"><span style=\"letter-spacing: 0.5px;\">这行代码的意思直接说非常简单，就是<strong>从内核态转变为了用户态</strong></span></span></p>\n<p>&nbsp;</p>\n<pre>\n\t<code class=\"yaml\">\n\t#define move_to_user_mode() \\\n\t__asm__ (\"movl %%esp,%%eax\\n\\t\" \\\n\t\"pushl $0x17\\n\\t\" \\\n\t\"pushl %%eax\\n\\t\" \\\n\t\"pushfl\\n\\t\" \\\n\t\"pushl $0x0f\\n\\t\" \\\n\t\"pushl $1f\\n\\t\" \\\n\t\"iret\\n\" \\\n\t\"1:\\tmovl $0x17,%%eax\\n\\t\" \\\n\t\"movw %%ax,%%ds\\n\\t\" \\\n\t\"movw %%ax,%%es\\n\\t\" \\\n\t\"movw %%ax,%%fs\\n\\t\" \\\n\t\"movw %%ax,%%gs\" \\\n\t:::\"ax\")\n</code>\n</pre>\n<h1>&nbsp;3：fork</h1>\n<p>fork函数是被系统调用使用的 具体路径如下：</p>\n<p>main.c:static inline _syscall0（int,fork）将fork绑定到_sys_fork</p>\n<p>　　system_call.s:_sys_fork:（调用函数_find_empty_process和_copy_process）</p>\n<p><img src=\"linux线程/2909691-20221018201940242-320806714.png\" alt=\"\" /></p>\n<p>总结作用：</p>\n<p>1：在task链表中找到一个进程空位并存放当前的进程（_find_empty_process）</p>\n<p>2：创建一个tsak_struct</p>\n<p>3：设置task_struct（_copy_process）</p>\n<p>这里就出现一个概念：<span style=\"font-size: 14px; letter-spacing: 0.5px;\">由于我们现在只有 0 号进程，且 task[] 除了 0 号索引位置，其他地方都是空的，所以这个方法运行完，last_pid 就是 1，也就是新进程被分配的 pid 就是 1</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\"><img src=\"linux线程/2909691-20221018202536805-171723429.png\" alt=\"\" /></span></p>\n<h1>4:init()</h1>\n<pre>\n\t<code class=\"yaml\">\n\tvoid init(void)\n\t{\n\t\tint pid,i;\n\t\tsetup((void *) &amp;drive_info);\n\t\t(void) open(\"/dev/tty0\",O_RDWR,0); //打开tty0 标准输入控制台\n\t\t(void) dup(0);//打开tty0 标准输出控制台\n\t\t(void) dup(0);//打开标准错误控制台\n\t\tprintf(\"%d buffers = %d bytes buffer space\\n\\r\",NR_BUFFERS,\n\t\t\tNR_BUFFERS*BLOCK_SIZE);\n\t\tprintf(\"Free mem: %d bytes\\n\\r\",memory_end-main_memory_start);\n\t\t//又创建一个进程（2号进程）<br />　　　　 if (!(pid=fork())) {\n\t\t\tclose(0);\n\t\t\tif (open(\"/etc/rc\",O_RDONLY,0)) ///etc/rc文件\n\t\t\t\t_exit(1);\n\t\t\texecve(\"/bin/sh\",argv_rc,envp_rc);//执行sh\n\t\t\t_exit(2);\n\t\t}\n\t\tif (pid&gt;0)\n\t\t\twhile (pid != wait(&amp;i))//等待父进程退出\n\t\t\t\t/* nothing */;\n\t\twhile (1) {<br />　　　　　　　　 //又创建一个进程 主要是害怕上面的进程创建失败 再创建一次\n\t\t\tif ((pid=fork())&lt;0) {\n\t\t\t\tprintf(\"Fork failed in init\\r\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!pid) {\n\t\t\t\tclose(0);close(1);close(2);\n\t\t\t\tsetsid();\n\t\t\t\t(void) open(\"/dev/tty0\",O_RDWR,0);\n\t\t\t\t(void) dup(0);\n\t\t\t\t(void) dup(0);\n\t\t\t\t_exit(execve(\"/bin/sh\",argv,envp));\n\t\t\t}\n\t\t\twhile (1)\n\t\t\t\tif (pid == wait(&amp;i))  //等待父进程退出 但是零号进程不可能退出\n\t\t\t\t\tbreak;\n\t\t\tprintf(\"\\n\\rchild %d died with code %04x\\n\\r\",pid,i);\n\t\t\tsync();\n\t\t}\n\t\t_exit(0);\t/* NOTE! _exit, not exit() */\n\t}\n</code>\n</pre>\n<p>&nbsp;总结</p>\n<p>1：打开标准输出 输入 错误控制台的句柄</p>\n<p>2：创建2号进程 并在中执行etc/rc文件 执行sh程序</p>\n<p>3：零号进程不可能退出 如果退出就执行for(;;) pause();</p>\n<p>&nbsp;</p>\n<p>目前为止main函数的执行完成 具体逻辑如下：</p>\n<p><img src=\"linux线程/2909691-20221018204634847-2097816257.png\" alt=\"\" /></p>\n<p>&nbsp;</p>\n<p><strong>Q:进程如何调度的</strong></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">不知道你是否还记得，定时器和时钟中断，再mian函数的前面执行了讲的 sched_init 函数。</span></p>\n<pre>\n\t<code class=\"yaml\">\n\tschedule.c\n\t#define HZ 100\n</pre>\n</div>\n<p><span style=\"font-size: 14px;\"><span style=\"letter-spacing: 0.5px;\">这个间隔时间被设置为 10 ms，也就是 100 Hz。</span> <span style=\"letter-spacing: 0.5px;\">发起的中断叫时钟中断，其中断向量号被设置为了timer_interrupt 。</span><span style=\"letter-spacing: 0.5px;\"><span style=\"letter-spacing: 0.5px;\">这样，中断来临时，CPU 会查找到中断处理函数，并跳转过去执行。</span></span></span></p>\n<pre>\n\t<code class=\"yaml\">\n\tsystem_call.s\n\t_timer_interrupt:\n    ...\n    // 增加系统滴答数\n    incl _jiffies\n    ...\n    // 调用函数 do_timer\n    call _do_timer\n    ...\n</code>\n</pre>\n<p>&nbsp;<span style=\"letter-spacing: 0.5px;\">这个函数做了两件事，一个是将<strong>系统滴答数</strong>这个变量 <strong>jiffies</strong> 加一，一个是调用了另一个函数 <strong>do_timer</strong>。</span></p>\n<pre>\n\t<code class=\"yaml\">\n\tsched.c\n\tvoid do_timer(long cpl) {\n    ...\n    // 当前线程还有剩余时间片，直接返回\n    if ((--current-&gt;counter)&gt;0) return;\n    // 若没有剩余时间片，调度\n    schedule();\n}\n</code>\n</pre>\n<p><span style=\"font-size: 14px;\">&nbsp;<span style=\"letter-spacing: 0.5px;\">do_timer 最重要的部分就是上面这段代码，非常简单。</span></span></p>\n<p><span style=\"font-size: 14px;\"><span style=\"letter-spacing: 0.5px;\">首先将当先进程的时间片 -1，然后判断：</span></span></p>\n<p><span style=\"font-size: 14px;\"><span style=\"letter-spacing: 0.5px;\">如果时间片仍然大于零，则什么都不做直接返回。</span></span></p>\n<p><span style=\"font-size: 14px;\"><span style=\"letter-spacing: 0.5px;\">如果时间片已经为零，则调用 schedule()，很明显，这就是进行进程调度的主干。</span></span></p>\n<pre>\n\t<code class=\"yaml\">\n\tvoid schedule(void) {\n\t\tint i, next, c;\n\t\tstruct task_struct ** p;\n\t\t...\n\t\twhile (1) {\n\t\t\tc = -1;\n\t\t\tnext = 0;\n\t\t\ti = NR_TASKS;\n\t\t\tp = &amp;task[NR_TASKS];\n\t\t\twhile (--i) {\n\t\t\t\tif (!*--p)\n\t\t\t\t\tcontinue;\n\t\t\t\tif ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c)\n\t\t\t\t\tc = (*p)-&gt;counter, next = i;\n\t\t\t}\n\t\t\tif (c) break;\n\t\t\tfor(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)\n\t\t\t\tif (*p)\n\t\t\t\t\t(*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; 1) +\n\t\t\t\t\t\t\t(*p)-&gt;priority;\n\t\t}\n\t\tswitch_to(next);\n}\n</code>\n</pre>\n<p>&nbsp;很简答，这个函数就做了三件事：</p>\n<p><span style=\"font-size: 14px;\"><strong><span style=\"letter-spacing: 0.5px;\">1.</span></strong><span style=\"letter-spacing: 0.5px;\"> 拿到剩余时间片（counter的值）最大且在 runnable 状态（state = 0）的进程号 next。</span></span></p>\n<p><span style=\"letter-spacing: 0.5px; font-size: 14px;\"><strong>2.</strong><span style=\"letter-spacing: 0.5px;\"> 如果所有 runnable 进程时间片都为 0，则将所有进程（注意不仅仅是 runnable 的进程）的 counter 重新赋值（counter = counter/2 + priority），然后再次执行步骤 1。</span></span></p>\n<p><span style=\"letter-spacing: 0.5px; font-size: 14px;\"><strong>3.</strong><span style=\"letter-spacing: 0.5px;\"> 最后拿到了一个进程号 next，调用了 switch_to(next) 这个方法，就切换到了这个进程去执行了。</span></span></p>\n<p>&nbsp;总结一下：</p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">罪魁祸首的，就是那个每 10ms 触发一次的定时器滴答。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">而这个滴答将会给 CPU 产生一个时钟中断信号。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">而这个中断信号会使 CPU 查找中断向量表，找到操作系统写好的一个时钟中断处理函数 do_timer。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">do_timer 会首先将当前进程的 counter 变量 -1，如果 counter 此时仍然大于 0，则就此结束。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">但如果 counter = 0 了，就开始进行进程的调度。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">进程调度就是找到所有处于 RUNNABLE 状态的进程，并找到一个 counter 值最大的进程，把它丢进 switch_to 函数的入参里。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">switch_to 这个终极函数，会保存当前进程上下文，恢复要跳转到的这个进程的上下文，同时使得 CPU 跳转到这个进程的偏移地址处。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">接着，这个进程就舒舒服服地运行了起来，等待着下一次时钟中断的来临。</span></p>\n<div class=\"notranslate\" style=\"all: initial;\">&nbsp;</div>\n<div class=\"notranslate\" style=\"all: initial;\">&nbsp;</div>\n<div class=\"notranslate\" style=\"all: initial;\">&nbsp;</div>\n<div class=\"notranslate\" style=\"all: initial;\">&nbsp;</div>\n","source":"_posts/2022/01/linux线程.md","raw":"---\ntitle: linux线程\npermalink: linux线程\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2022-01-01 21:08:57\npassword:\nsummary:\ntags:\n- linux\n- thread\ncategories:\n- linux\nkeywords:\ndescription:\n---\n<blockquote>\n<p>linux内核版本0.11</p>\n</blockquote>\n<h1>1：main</h1>\n<p>首先选出一号选手main函数，代码上和线程相关的主要是以下代码</p>\n<pre>\n\t<code class=\"yaml\">\n    void main(void) {    \n    move_to_user_mode();\n    if (!fork()) {\n        init();\n    }\n    for(;;) pause();\n}</code>\n</pre>\n<h1>&nbsp;2：<span style=\"letter-spacing: 0.5px;\"><strong>move_to_user_mode</strong></span></h1>\n<p><span style=\"letter-spacing: 0.5px; font-size: 15px;\"><span style=\"letter-spacing: 0.5px;\">这行代码的意思直接说非常简单，就是<strong>从内核态转变为了用户态</strong></span></span></p>\n<p>&nbsp;</p>\n<pre>\n\t<code class=\"yaml\">\n\t#define move_to_user_mode() \\\n\t__asm__ (\"movl %%esp,%%eax\\n\\t\" \\\n\t\"pushl $0x17\\n\\t\" \\\n\t\"pushl %%eax\\n\\t\" \\\n\t\"pushfl\\n\\t\" \\\n\t\"pushl $0x0f\\n\\t\" \\\n\t\"pushl $1f\\n\\t\" \\\n\t\"iret\\n\" \\\n\t\"1:\\tmovl $0x17,%%eax\\n\\t\" \\\n\t\"movw %%ax,%%ds\\n\\t\" \\\n\t\"movw %%ax,%%es\\n\\t\" \\\n\t\"movw %%ax,%%fs\\n\\t\" \\\n\t\"movw %%ax,%%gs\" \\\n\t:::\"ax\")\n</code>\n</pre>\n<h1>&nbsp;3：fork</h1>\n<p>fork函数是被系统调用使用的 具体路径如下：</p>\n<p>main.c:static inline _syscall0（int,fork）将fork绑定到_sys_fork</p>\n<p>　　system_call.s:_sys_fork:（调用函数_find_empty_process和_copy_process）</p>\n<p><img src=\"linux线程/2909691-20221018201940242-320806714.png\" alt=\"\" /></p>\n<p>总结作用：</p>\n<p>1：在task链表中找到一个进程空位并存放当前的进程（_find_empty_process）</p>\n<p>2：创建一个tsak_struct</p>\n<p>3：设置task_struct（_copy_process）</p>\n<p>这里就出现一个概念：<span style=\"font-size: 14px; letter-spacing: 0.5px;\">由于我们现在只有 0 号进程，且 task[] 除了 0 号索引位置，其他地方都是空的，所以这个方法运行完，last_pid 就是 1，也就是新进程被分配的 pid 就是 1</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\"><img src=\"linux线程/2909691-20221018202536805-171723429.png\" alt=\"\" /></span></p>\n<h1>4:init()</h1>\n<pre>\n\t<code class=\"yaml\">\n\tvoid init(void)\n\t{\n\t\tint pid,i;\n\t\tsetup((void *) &amp;drive_info);\n\t\t(void) open(\"/dev/tty0\",O_RDWR,0); //打开tty0 标准输入控制台\n\t\t(void) dup(0);//打开tty0 标准输出控制台\n\t\t(void) dup(0);//打开标准错误控制台\n\t\tprintf(\"%d buffers = %d bytes buffer space\\n\\r\",NR_BUFFERS,\n\t\t\tNR_BUFFERS*BLOCK_SIZE);\n\t\tprintf(\"Free mem: %d bytes\\n\\r\",memory_end-main_memory_start);\n\t\t//又创建一个进程（2号进程）<br />　　　　 if (!(pid=fork())) {\n\t\t\tclose(0);\n\t\t\tif (open(\"/etc/rc\",O_RDONLY,0)) ///etc/rc文件\n\t\t\t\t_exit(1);\n\t\t\texecve(\"/bin/sh\",argv_rc,envp_rc);//执行sh\n\t\t\t_exit(2);\n\t\t}\n\t\tif (pid&gt;0)\n\t\t\twhile (pid != wait(&amp;i))//等待父进程退出\n\t\t\t\t/* nothing */;\n\t\twhile (1) {<br />　　　　　　　　 //又创建一个进程 主要是害怕上面的进程创建失败 再创建一次\n\t\t\tif ((pid=fork())&lt;0) {\n\t\t\t\tprintf(\"Fork failed in init\\r\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!pid) {\n\t\t\t\tclose(0);close(1);close(2);\n\t\t\t\tsetsid();\n\t\t\t\t(void) open(\"/dev/tty0\",O_RDWR,0);\n\t\t\t\t(void) dup(0);\n\t\t\t\t(void) dup(0);\n\t\t\t\t_exit(execve(\"/bin/sh\",argv,envp));\n\t\t\t}\n\t\t\twhile (1)\n\t\t\t\tif (pid == wait(&amp;i))  //等待父进程退出 但是零号进程不可能退出\n\t\t\t\t\tbreak;\n\t\t\tprintf(\"\\n\\rchild %d died with code %04x\\n\\r\",pid,i);\n\t\t\tsync();\n\t\t}\n\t\t_exit(0);\t/* NOTE! _exit, not exit() */\n\t}\n</code>\n</pre>\n<p>&nbsp;总结</p>\n<p>1：打开标准输出 输入 错误控制台的句柄</p>\n<p>2：创建2号进程 并在中执行etc/rc文件 执行sh程序</p>\n<p>3：零号进程不可能退出 如果退出就执行for(;;) pause();</p>\n<p>&nbsp;</p>\n<p>目前为止main函数的执行完成 具体逻辑如下：</p>\n<p><img src=\"linux线程/2909691-20221018204634847-2097816257.png\" alt=\"\" /></p>\n<p>&nbsp;</p>\n<p><strong>Q:进程如何调度的</strong></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">不知道你是否还记得，定时器和时钟中断，再mian函数的前面执行了讲的 sched_init 函数。</span></p>\n<pre>\n\t<code class=\"yaml\">\n\tschedule.c\n\t#define HZ 100\n</pre>\n</div>\n<p><span style=\"font-size: 14px;\"><span style=\"letter-spacing: 0.5px;\">这个间隔时间被设置为 10 ms，也就是 100 Hz。</span> <span style=\"letter-spacing: 0.5px;\">发起的中断叫时钟中断，其中断向量号被设置为了timer_interrupt 。</span><span style=\"letter-spacing: 0.5px;\"><span style=\"letter-spacing: 0.5px;\">这样，中断来临时，CPU 会查找到中断处理函数，并跳转过去执行。</span></span></span></p>\n<pre>\n\t<code class=\"yaml\">\n\tsystem_call.s\n\t_timer_interrupt:\n    ...\n    // 增加系统滴答数\n    incl _jiffies\n    ...\n    // 调用函数 do_timer\n    call _do_timer\n    ...\n</code>\n</pre>\n<p>&nbsp;<span style=\"letter-spacing: 0.5px;\">这个函数做了两件事，一个是将<strong>系统滴答数</strong>这个变量 <strong>jiffies</strong> 加一，一个是调用了另一个函数 <strong>do_timer</strong>。</span></p>\n<pre>\n\t<code class=\"yaml\">\n\tsched.c\n\tvoid do_timer(long cpl) {\n    ...\n    // 当前线程还有剩余时间片，直接返回\n    if ((--current-&gt;counter)&gt;0) return;\n    // 若没有剩余时间片，调度\n    schedule();\n}\n</code>\n</pre>\n<p><span style=\"font-size: 14px;\">&nbsp;<span style=\"letter-spacing: 0.5px;\">do_timer 最重要的部分就是上面这段代码，非常简单。</span></span></p>\n<p><span style=\"font-size: 14px;\"><span style=\"letter-spacing: 0.5px;\">首先将当先进程的时间片 -1，然后判断：</span></span></p>\n<p><span style=\"font-size: 14px;\"><span style=\"letter-spacing: 0.5px;\">如果时间片仍然大于零，则什么都不做直接返回。</span></span></p>\n<p><span style=\"font-size: 14px;\"><span style=\"letter-spacing: 0.5px;\">如果时间片已经为零，则调用 schedule()，很明显，这就是进行进程调度的主干。</span></span></p>\n<pre>\n\t<code class=\"yaml\">\n\tvoid schedule(void) {\n\t\tint i, next, c;\n\t\tstruct task_struct ** p;\n\t\t...\n\t\twhile (1) {\n\t\t\tc = -1;\n\t\t\tnext = 0;\n\t\t\ti = NR_TASKS;\n\t\t\tp = &amp;task[NR_TASKS];\n\t\t\twhile (--i) {\n\t\t\t\tif (!*--p)\n\t\t\t\t\tcontinue;\n\t\t\t\tif ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c)\n\t\t\t\t\tc = (*p)-&gt;counter, next = i;\n\t\t\t}\n\t\t\tif (c) break;\n\t\t\tfor(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)\n\t\t\t\tif (*p)\n\t\t\t\t\t(*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; 1) +\n\t\t\t\t\t\t\t(*p)-&gt;priority;\n\t\t}\n\t\tswitch_to(next);\n}\n</code>\n</pre>\n<p>&nbsp;很简答，这个函数就做了三件事：</p>\n<p><span style=\"font-size: 14px;\"><strong><span style=\"letter-spacing: 0.5px;\">1.</span></strong><span style=\"letter-spacing: 0.5px;\"> 拿到剩余时间片（counter的值）最大且在 runnable 状态（state = 0）的进程号 next。</span></span></p>\n<p><span style=\"letter-spacing: 0.5px; font-size: 14px;\"><strong>2.</strong><span style=\"letter-spacing: 0.5px;\"> 如果所有 runnable 进程时间片都为 0，则将所有进程（注意不仅仅是 runnable 的进程）的 counter 重新赋值（counter = counter/2 + priority），然后再次执行步骤 1。</span></span></p>\n<p><span style=\"letter-spacing: 0.5px; font-size: 14px;\"><strong>3.</strong><span style=\"letter-spacing: 0.5px;\"> 最后拿到了一个进程号 next，调用了 switch_to(next) 这个方法，就切换到了这个进程去执行了。</span></span></p>\n<p>&nbsp;总结一下：</p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">罪魁祸首的，就是那个每 10ms 触发一次的定时器滴答。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">而这个滴答将会给 CPU 产生一个时钟中断信号。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">而这个中断信号会使 CPU 查找中断向量表，找到操作系统写好的一个时钟中断处理函数 do_timer。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">do_timer 会首先将当前进程的 counter 变量 -1，如果 counter 此时仍然大于 0，则就此结束。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">但如果 counter = 0 了，就开始进行进程的调度。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">进程调度就是找到所有处于 RUNNABLE 状态的进程，并找到一个 counter 值最大的进程，把它丢进 switch_to 函数的入参里。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">switch_to 这个终极函数，会保存当前进程上下文，恢复要跳转到的这个进程的上下文，同时使得 CPU 跳转到这个进程的偏移地址处。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">接着，这个进程就舒舒服服地运行了起来，等待着下一次时钟中断的来临。</span></p>\n<div class=\"notranslate\" style=\"all: initial;\">&nbsp;</div>\n<div class=\"notranslate\" style=\"all: initial;\">&nbsp;</div>\n<div class=\"notranslate\" style=\"all: initial;\">&nbsp;</div>\n<div class=\"notranslate\" style=\"all: initial;\">&nbsp;</div>\n","slug":"linux线程","published":1,"updated":"2023-04-04T10:57:35.503Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk69d1cw000cjsrjbdvppaad","content":"<blockquote>\n<p>linux内核版本0.11</p>\n</blockquote>\n<h1>1：main</h1>\n<p>首先选出一号选手main函数，代码上和线程相关的主要是以下代码</p>\n<pre>\n    <code class=\"yaml\">\n    void main(void) {    \n    move_to_user_mode();\n    if (!fork()) {\n        init();\n    }\n    for(;;) pause();\n}</code>\n</pre>\n<h1>&nbsp;2：<span style=\"letter-spacing: 0.5px;\"><strong>move_to_user_mode</strong></span></h1>\n<p><span style=\"letter-spacing: 0.5px; font-size: 15px;\"><span style=\"letter-spacing: 0.5px;\">这行代码的意思直接说非常简单，就是<strong>从内核态转变为了用户态</strong></span></span></p>\n<p>&nbsp;</p>\n<pre>\n    <code class=\"yaml\">\n    #define move_to_user_mode() \\\n    __asm__ (\"movl %%esp,%%eax\\n\\t\" \\\n    \"pushl $0x17\\n\\t\" \\\n    \"pushl %%eax\\n\\t\" \\\n    \"pushfl\\n\\t\" \\\n    \"pushl $0x0f\\n\\t\" \\\n    \"pushl $1f\\n\\t\" \\\n    \"iret\\n\" \\\n    \"1:\\tmovl $0x17,%%eax\\n\\t\" \\\n    \"movw %%ax,%%ds\\n\\t\" \\\n    \"movw %%ax,%%es\\n\\t\" \\\n    \"movw %%ax,%%fs\\n\\t\" \\\n    \"movw %%ax,%%gs\" \\\n    :::\"ax\")\n</code>\n</pre>\n<h1>&nbsp;3：fork</h1>\n<p>fork函数是被系统调用使用的 具体路径如下：</p>\n<p>main.c:static inline _syscall0（int,fork）将fork绑定到_sys_fork</p>\n<p>　　system_call.s:_sys_fork:（调用函数_find_empty_process和_copy_process）</p>\n<p><img src=\"/2022/01/linux-xian-cheng/2909691-20221018201940242-320806714.png\" alt></p>\n<p>总结作用：</p>\n<p>1：在task链表中找到一个进程空位并存放当前的进程（_find_empty_process）</p>\n<p>2：创建一个tsak_struct</p>\n<p>3：设置task_struct（_copy_process）</p>\n<p>这里就出现一个概念：<span style=\"font-size: 14px; letter-spacing: 0.5px;\">由于我们现在只有 0 号进程，且 task[] 除了 0 号索引位置，其他地方都是空的，所以这个方法运行完，last_pid 就是 1，也就是新进程被分配的 pid 就是 1</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\"><img src=\"/2022/01/linux-xian-cheng/2909691-20221018202536805-171723429.png\" alt></span></p>\n<h1>4:init()</h1>\n<pre>\n    <code class=\"yaml\">\n    void init(void)\n    {\n        int pid,i;\n        setup((void *) &amp;drive_info);\n        (void) open(\"/dev/tty0\",O_RDWR,0); //打开tty0 标准输入控制台\n        (void) dup(0);//打开tty0 标准输出控制台\n        (void) dup(0);//打开标准错误控制台\n        printf(\"%d buffers = %d bytes buffer space\\n\\r\",NR_BUFFERS,\n            NR_BUFFERS*BLOCK_SIZE);\n        printf(\"Free mem: %d bytes\\n\\r\",memory_end-main_memory_start);\n        //又创建一个进程（2号进程）<br>　　　　 if (!(pid=fork())) {\n            close(0);\n            if (open(\"/etc/rc\",O_RDONLY,0)) ///etc/rc文件\n                _exit(1);\n            execve(\"/bin/sh\",argv_rc,envp_rc);//执行sh\n            _exit(2);\n        }\n        if (pid&gt;0)\n            while (pid != wait(&amp;i))//等待父进程退出\n                /* nothing */;\n        while (1) {<br>　　　　　　　　 //又创建一个进程 主要是害怕上面的进程创建失败 再创建一次\n            if ((pid=fork())&lt;0) {\n                printf(\"Fork failed in init\\r\\n\");\n                continue;\n            }\n            if (!pid) {\n                close(0);close(1);close(2);\n                setsid();\n                (void) open(\"/dev/tty0\",O_RDWR,0);\n                (void) dup(0);\n                (void) dup(0);\n                _exit(execve(\"/bin/sh\",argv,envp));\n            }\n            while (1)\n                if (pid == wait(&amp;i))  //等待父进程退出 但是零号进程不可能退出\n                    break;\n            printf(\"\\n\\rchild %d died with code %04x\\n\\r\",pid,i);\n            sync();\n        }\n        _exit(0);    /* NOTE! _exit, not exit() */\n    }\n</code>\n</pre>\n<p>&nbsp;总结</p>\n<p>1：打开标准输出 输入 错误控制台的句柄</p>\n<p>2：创建2号进程 并在中执行etc/rc文件 执行sh程序</p>\n<p>3：零号进程不可能退出 如果退出就执行for(;;) pause();</p>\n<p>&nbsp;</p>\n<p>目前为止main函数的执行完成 具体逻辑如下：</p>\n<p><img src=\"/2022/01/linux-xian-cheng/2909691-20221018204634847-2097816257.png\" alt></p>\n<p>&nbsp;</p>\n<p><strong>Q:进程如何调度的</strong></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">不知道你是否还记得，定时器和时钟中断，再mian函数的前面执行了讲的 sched_init 函数。</span></p>\n<pre>\n    <code class=\"yaml\">\n    schedule.c\n    #define HZ 100\n</code></pre>\n\n<p><span style=\"font-size: 14px;\"><span style=\"letter-spacing: 0.5px;\">这个间隔时间被设置为 10 ms，也就是 100 Hz。</span> <span style=\"letter-spacing: 0.5px;\">发起的中断叫时钟中断，其中断向量号被设置为了timer_interrupt 。</span><span style=\"letter-spacing: 0.5px;\"><span style=\"letter-spacing: 0.5px;\">这样，中断来临时，CPU 会查找到中断处理函数，并跳转过去执行。</span></span></span></p>\n<pre>\n    <code class=\"yaml\">\n    system_call.s\n    _timer_interrupt:\n    ...\n    // 增加系统滴答数\n    incl _jiffies\n    ...\n    // 调用函数 do_timer\n    call _do_timer\n    ...\n</code>\n</pre>\n<p>&nbsp;<span style=\"letter-spacing: 0.5px;\">这个函数做了两件事，一个是将<strong>系统滴答数</strong>这个变量 <strong>jiffies</strong> 加一，一个是调用了另一个函数 <strong>do_timer</strong>。</span></p>\n<pre>\n    <code class=\"yaml\">\n    sched.c\n    void do_timer(long cpl) {\n    ...\n    // 当前线程还有剩余时间片，直接返回\n    if ((--current-&gt;counter)&gt;0) return;\n    // 若没有剩余时间片，调度\n    schedule();\n}\n</code>\n</pre>\n<p><span style=\"font-size: 14px;\">&nbsp;<span style=\"letter-spacing: 0.5px;\">do_timer 最重要的部分就是上面这段代码，非常简单。</span></span></p>\n<p><span style=\"font-size: 14px;\"><span style=\"letter-spacing: 0.5px;\">首先将当先进程的时间片 -1，然后判断：</span></span></p>\n<p><span style=\"font-size: 14px;\"><span style=\"letter-spacing: 0.5px;\">如果时间片仍然大于零，则什么都不做直接返回。</span></span></p>\n<p><span style=\"font-size: 14px;\"><span style=\"letter-spacing: 0.5px;\">如果时间片已经为零，则调用 schedule()，很明显，这就是进行进程调度的主干。</span></span></p>\n<pre>\n    <code class=\"yaml\">\n    void schedule(void) {\n        int i, next, c;\n        struct task_struct ** p;\n        ...\n        while (1) {\n            c = -1;\n            next = 0;\n            i = NR_TASKS;\n            p = &amp;task[NR_TASKS];\n            while (--i) {\n                if (!*--p)\n                    continue;\n                if ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c)\n                    c = (*p)-&gt;counter, next = i;\n            }\n            if (c) break;\n            for(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)\n                if (*p)\n                    (*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; 1) +\n                            (*p)-&gt;priority;\n        }\n        switch_to(next);\n}\n</code>\n</pre>\n<p>&nbsp;很简答，这个函数就做了三件事：</p>\n<p><span style=\"font-size: 14px;\"><strong><span style=\"letter-spacing: 0.5px;\">1.</span></strong><span style=\"letter-spacing: 0.5px;\"> 拿到剩余时间片（counter的值）最大且在 runnable 状态（state = 0）的进程号 next。</span></span></p>\n<p><span style=\"letter-spacing: 0.5px; font-size: 14px;\"><strong>2.</strong><span style=\"letter-spacing: 0.5px;\"> 如果所有 runnable 进程时间片都为 0，则将所有进程（注意不仅仅是 runnable 的进程）的 counter 重新赋值（counter = counter/2 + priority），然后再次执行步骤 1。</span></span></p>\n<p><span style=\"letter-spacing: 0.5px; font-size: 14px;\"><strong>3.</strong><span style=\"letter-spacing: 0.5px;\"> 最后拿到了一个进程号 next，调用了 switch_to(next) 这个方法，就切换到了这个进程去执行了。</span></span></p>\n<p>&nbsp;总结一下：</p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">罪魁祸首的，就是那个每 10ms 触发一次的定时器滴答。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">而这个滴答将会给 CPU 产生一个时钟中断信号。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">而这个中断信号会使 CPU 查找中断向量表，找到操作系统写好的一个时钟中断处理函数 do_timer。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">do_timer 会首先将当前进程的 counter 变量 -1，如果 counter 此时仍然大于 0，则就此结束。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">但如果 counter = 0 了，就开始进行进程的调度。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">进程调度就是找到所有处于 RUNNABLE 状态的进程，并找到一个 counter 值最大的进程，把它丢进 switch_to 函数的入参里。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">switch_to 这个终极函数，会保存当前进程上下文，恢复要跳转到的这个进程的上下文，同时使得 CPU 跳转到这个进程的偏移地址处。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">接着，这个进程就舒舒服服地运行了起来，等待着下一次时钟中断的来临。</span></p>\n<div class=\"notranslate\" style=\"all: initial;\">&nbsp;</div>\n<div class=\"notranslate\" style=\"all: initial;\">&nbsp;</div>\n<div class=\"notranslate\" style=\"all: initial;\">&nbsp;</div>\n<div class=\"notranslate\" style=\"all: initial;\">&nbsp;</div>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<blockquote>\n<p>linux内核版本0.11</p>\n</blockquote>\n<h1>1：main</h1>\n<p>首先选出一号选手main函数，代码上和线程相关的主要是以下代码</p>\n<pre>\n    <code class=\"yaml\">\n    void main(void) {    \n    move_to_user_mode();\n    if (!fork()) {\n        init();\n    }\n    for(;;) pause();\n}</code>\n</pre>\n<h1>&nbsp;2：<span style=\"letter-spacing: 0.5px;\"><strong>move_to_user_mode</strong></span></h1>\n<p><span style=\"letter-spacing: 0.5px; font-size: 15px;\"><span style=\"letter-spacing: 0.5px;\">这行代码的意思直接说非常简单，就是<strong>从内核态转变为了用户态</strong></span></span></p>\n<p>&nbsp;</p>\n<pre>\n    <code class=\"yaml\">\n    #define move_to_user_mode() \\\n    __asm__ (\"movl %%esp,%%eax\\n\\t\" \\\n    \"pushl $0x17\\n\\t\" \\\n    \"pushl %%eax\\n\\t\" \\\n    \"pushfl\\n\\t\" \\\n    \"pushl $0x0f\\n\\t\" \\\n    \"pushl $1f\\n\\t\" \\\n    \"iret\\n\" \\\n    \"1:\\tmovl $0x17,%%eax\\n\\t\" \\\n    \"movw %%ax,%%ds\\n\\t\" \\\n    \"movw %%ax,%%es\\n\\t\" \\\n    \"movw %%ax,%%fs\\n\\t\" \\\n    \"movw %%ax,%%gs\" \\\n    :::\"ax\")\n</code>\n</pre>\n<h1>&nbsp;3：fork</h1>\n<p>fork函数是被系统调用使用的 具体路径如下：</p>\n<p>main.c:static inline _syscall0（int,fork）将fork绑定到_sys_fork</p>\n<p>　　system_call.s:_sys_fork:（调用函数_find_empty_process和_copy_process）</p>\n<p><img src=\"/2022/01/linux-xian-cheng/2909691-20221018201940242-320806714.png\" alt></p>\n<p>总结作用：</p>\n<p>1：在task链表中找到一个进程空位并存放当前的进程（_find_empty_process）</p>\n<p>2：创建一个tsak_struct</p>\n<p>3：设置task_struct（_copy_process）</p>\n<p>这里就出现一个概念：<span style=\"font-size: 14px; letter-spacing: 0.5px;\">由于我们现在只有 0 号进程，且 task[] 除了 0 号索引位置，其他地方都是空的，所以这个方法运行完，last_pid 就是 1，也就是新进程被分配的 pid 就是 1</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\"><img src=\"/2022/01/linux-xian-cheng/2909691-20221018202536805-171723429.png\" alt></span></p>\n<h1>4:init()</h1>\n<pre>\n    <code class=\"yaml\">\n    void init(void)\n    {\n        int pid,i;\n        setup((void *) &amp;drive_info);\n        (void) open(\"/dev/tty0\",O_RDWR,0); //打开tty0 标准输入控制台\n        (void) dup(0);//打开tty0 标准输出控制台\n        (void) dup(0);//打开标准错误控制台\n        printf(\"%d buffers = %d bytes buffer space\\n\\r\",NR_BUFFERS,\n            NR_BUFFERS*BLOCK_SIZE);\n        printf(\"Free mem: %d bytes\\n\\r\",memory_end-main_memory_start);\n        //又创建一个进程（2号进程）<br>　　　　 if (!(pid=fork())) {\n            close(0);\n            if (open(\"/etc/rc\",O_RDONLY,0)) ///etc/rc文件\n                _exit(1);\n            execve(\"/bin/sh\",argv_rc,envp_rc);//执行sh\n            _exit(2);\n        }\n        if (pid&gt;0)\n            while (pid != wait(&amp;i))//等待父进程退出\n                /* nothing */;\n        while (1) {<br>　　　　　　　　 //又创建一个进程 主要是害怕上面的进程创建失败 再创建一次\n            if ((pid=fork())&lt;0) {\n                printf(\"Fork failed in init\\r\\n\");\n                continue;\n            }\n            if (!pid) {\n                close(0);close(1);close(2);\n                setsid();\n                (void) open(\"/dev/tty0\",O_RDWR,0);\n                (void) dup(0);\n                (void) dup(0);\n                _exit(execve(\"/bin/sh\",argv,envp));\n            }\n            while (1)\n                if (pid == wait(&amp;i))  //等待父进程退出 但是零号进程不可能退出\n                    break;\n            printf(\"\\n\\rchild %d died with code %04x\\n\\r\",pid,i);\n            sync();\n        }\n        _exit(0);    /* NOTE! _exit, not exit() */\n    }\n</code>\n</pre>\n<p>&nbsp;总结</p>\n<p>1：打开标准输出 输入 错误控制台的句柄</p>\n<p>2：创建2号进程 并在中执行etc/rc文件 执行sh程序</p>\n<p>3：零号进程不可能退出 如果退出就执行for(;;) pause();</p>\n<p>&nbsp;</p>\n<p>目前为止main函数的执行完成 具体逻辑如下：</p>\n<p><img src=\"/2022/01/linux-xian-cheng/2909691-20221018204634847-2097816257.png\" alt></p>\n<p>&nbsp;</p>\n<p><strong>Q:进程如何调度的</strong></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">不知道你是否还记得，定时器和时钟中断，再mian函数的前面执行了讲的 sched_init 函数。</span></p>\n<pre>\n    <code class=\"yaml\">\n    schedule.c\n    #define HZ 100\n</code></pre>\n\n<p><span style=\"font-size: 14px;\"><span style=\"letter-spacing: 0.5px;\">这个间隔时间被设置为 10 ms，也就是 100 Hz。</span> <span style=\"letter-spacing: 0.5px;\">发起的中断叫时钟中断，其中断向量号被设置为了timer_interrupt 。</span><span style=\"letter-spacing: 0.5px;\"><span style=\"letter-spacing: 0.5px;\">这样，中断来临时，CPU 会查找到中断处理函数，并跳转过去执行。</span></span></span></p>\n<pre>\n    <code class=\"yaml\">\n    system_call.s\n    _timer_interrupt:\n    ...\n    // 增加系统滴答数\n    incl _jiffies\n    ...\n    // 调用函数 do_timer\n    call _do_timer\n    ...\n</code>\n</pre>\n<p>&nbsp;<span style=\"letter-spacing: 0.5px;\">这个函数做了两件事，一个是将<strong>系统滴答数</strong>这个变量 <strong>jiffies</strong> 加一，一个是调用了另一个函数 <strong>do_timer</strong>。</span></p>\n<pre>\n    <code class=\"yaml\">\n    sched.c\n    void do_timer(long cpl) {\n    ...\n    // 当前线程还有剩余时间片，直接返回\n    if ((--current-&gt;counter)&gt;0) return;\n    // 若没有剩余时间片，调度\n    schedule();\n}\n</code>\n</pre>\n<p><span style=\"font-size: 14px;\">&nbsp;<span style=\"letter-spacing: 0.5px;\">do_timer 最重要的部分就是上面这段代码，非常简单。</span></span></p>\n<p><span style=\"font-size: 14px;\"><span style=\"letter-spacing: 0.5px;\">首先将当先进程的时间片 -1，然后判断：</span></span></p>\n<p><span style=\"font-size: 14px;\"><span style=\"letter-spacing: 0.5px;\">如果时间片仍然大于零，则什么都不做直接返回。</span></span></p>\n<p><span style=\"font-size: 14px;\"><span style=\"letter-spacing: 0.5px;\">如果时间片已经为零，则调用 schedule()，很明显，这就是进行进程调度的主干。</span></span></p>\n<pre>\n    <code class=\"yaml\">\n    void schedule(void) {\n        int i, next, c;\n        struct task_struct ** p;\n        ...\n        while (1) {\n            c = -1;\n            next = 0;\n            i = NR_TASKS;\n            p = &amp;task[NR_TASKS];\n            while (--i) {\n                if (!*--p)\n                    continue;\n                if ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c)\n                    c = (*p)-&gt;counter, next = i;\n            }\n            if (c) break;\n            for(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)\n                if (*p)\n                    (*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; 1) +\n                            (*p)-&gt;priority;\n        }\n        switch_to(next);\n}\n</code>\n</pre>\n<p>&nbsp;很简答，这个函数就做了三件事：</p>\n<p><span style=\"font-size: 14px;\"><strong><span style=\"letter-spacing: 0.5px;\">1.</span></strong><span style=\"letter-spacing: 0.5px;\"> 拿到剩余时间片（counter的值）最大且在 runnable 状态（state = 0）的进程号 next。</span></span></p>\n<p><span style=\"letter-spacing: 0.5px; font-size: 14px;\"><strong>2.</strong><span style=\"letter-spacing: 0.5px;\"> 如果所有 runnable 进程时间片都为 0，则将所有进程（注意不仅仅是 runnable 的进程）的 counter 重新赋值（counter = counter/2 + priority），然后再次执行步骤 1。</span></span></p>\n<p><span style=\"letter-spacing: 0.5px; font-size: 14px;\"><strong>3.</strong><span style=\"letter-spacing: 0.5px;\"> 最后拿到了一个进程号 next，调用了 switch_to(next) 这个方法，就切换到了这个进程去执行了。</span></span></p>\n<p>&nbsp;总结一下：</p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">罪魁祸首的，就是那个每 10ms 触发一次的定时器滴答。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">而这个滴答将会给 CPU 产生一个时钟中断信号。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">而这个中断信号会使 CPU 查找中断向量表，找到操作系统写好的一个时钟中断处理函数 do_timer。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">do_timer 会首先将当前进程的 counter 变量 -1，如果 counter 此时仍然大于 0，则就此结束。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">但如果 counter = 0 了，就开始进行进程的调度。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">进程调度就是找到所有处于 RUNNABLE 状态的进程，并找到一个 counter 值最大的进程，把它丢进 switch_to 函数的入参里。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">switch_to 这个终极函数，会保存当前进程上下文，恢复要跳转到的这个进程的上下文，同时使得 CPU 跳转到这个进程的偏移地址处。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">接着，这个进程就舒舒服服地运行了起来，等待着下一次时钟中断的来临。</span></p>\n<div class=\"notranslate\" style=\"all: initial;\">&nbsp;</div>\n<div class=\"notranslate\" style=\"all: initial;\">&nbsp;</div>\n<div class=\"notranslate\" style=\"all: initial;\">&nbsp;</div>\n<div class=\"notranslate\" style=\"all: initial;\">&nbsp;</div>\n"},{"title":"中华通史.上古史-夏","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2022-01-01T12:35:31.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"@[TOC](夏代)\n\n# 夏国简介\n帝舜去世,禹得到诸侯一致的拥护,继立为天子。他曾受舜封为夏伯,赐姓姒,故国号夏,建都安邑,他先后请皋陶与益佐理政事。禹的政治,一方面督励人民从事农耕;方面整伤社会秩序,法律很严。他从北而南巡视天下,曾大会诸侯于涂山。防风氏后到为禹所杀。史称执玉帛而来与会的有万国,执玉的是大国,执帛的是小国。这些诸侯也就是那个时候的氏族部落,足以说明禹声威之盛远过唐虞。他继续向东方巡视,行至中途,死在会稽山[今浙江绍兴东南],据说他的葬礼极其简单,所谓“桐棺三寸”、“衣衾三领”真是一生刻苦。禹死之后,有一段很短的时间,由益代行政事。后来诸侯,怀念禹功,都拥护禹子启而不拥护益。于是启继位为天子,从此建立了父子相传的君主制度。\n\n\n# 夏代大事\n![](20210703105815619.png)![](20210703105831609.png)![](20210703105920999.png)\n史称:“帝尧之时洪水滔天,浩浩怀山襄陵。”成为当时最严重的一个问题叠经派人治理,都没有成功,尧乃接受四岳的推荐,用鲧治水,鲧就是禹的父亲。鲧用堵塞的方法,多筑堤坝。但是洪水滔滔,随筑随溃,经过九年的功夫,没有成功,引起人民的怨愤。到了舜执政的时候,便将鲧殛死。而用鲧子禹继续治水。这洪水之灾,从尧初算起已经几十年了。舜又命益与弃协助禹。禹伤父功不成,乃焦思苦虑。不惜一切的劳苦,希望能完成先业,以雪父耻。他完全改变他父亲的方法,从疏导着手。他带着许多“准绳”、“规矩”等测量的工具,登山涉水,观察地形高下,而后施工。他又用了许多交通工具,史称“陆行乘车,水行乘船,泥行乘橇,山行乘撵。”他先从黄河的中段冀州地方开始。这也是黄河泛滥的枢纽地带[今山西、河南之间]。一步步的向东方的兖州、青州、徐州、南方的荆州、豫州疏导,最后又折向西北去整理黄河的上游。他将黄河下游的河道分辟为九股,散其水势。然后再分为漯济流入渤海。又疏通了许多其他的河道,完成了许多惊人的工程。他率领人民,和黄河作了十三年的奋斗,把这上百年的洪水之灾,完全治平。使老百姓免于饥溺流离之苦,能在黄河流域安居乐业下来。他这十三年中,为了国家和人民,奋不顾身,曾经几次经过家门而不入。顾不得饮食起居,他治水时总是亲自拿着募锸以身作则带头去作。冒着狂风暴雨,弄得身体憔悴而永不休息。和他同样辛苦的,还有协助他的益和弃。益掌火,在治水之前,纵火焚山林,以驱禽兽,弃为后稷,掌播谷。在水平之后,教人民耕种,从事善后工作。他们这样辛劳,一方面获得百姓的爱戴;一方面获得后世的崇拜,禹成为后来苦行家墨子的宗师。而禹与后稷,被孟子尊为是“历史上最富于同情心的人”。\n夏启继立后,曾大会诸侯于钧台[今河南禹县许昌之间]。有扈氏不服,启率兵与有扈战于甘[今作《甘誓》]灭有扈。夏启的政权,乃归稳定。正式称为“夏后启”,启在位九年卒,子太康立。太康逸豫失政,太康五弟,追思禹德,乃作《五子之歌》。这时有东夷地方的一个有穷氏诸侯后羿作乱,太康被逼迁于斟部[河南巩县附近]。太康传弟仲康,仲康传子相,相又一度迁都于商邱[河南商邱],夏朝实际成为后羿的政权,后来后羿又被其权臣寒浞所杀,寒浞又弑相而篡夏,夏自禹至相不到九十年,而国统几绝。相妻有缗氏怀孕在身,逃至有仍[今山东济宁],生了一个遗腹子,是为少康。少康既长,从有仍氏地方逃到虞地[河南虞城],投奔有虞氏,有虞氏君收纳了少康,给以田一成[方十里为成]、众旅[五百人为旅]。后来少康就凭藉着这一成一旅的资本,强大起来。收抚旧日夏朝的士众,灭掉寒浞,复兴夏朝,还都于安邑,史称少康中兴。这后羿、寒浞之乱前后历时百年。\n少康时曾再度发生河患,以冥为司空再度治河。由少康传子杼,杼传槐[是为夏之第八主]。槐即位,九夷来朝,九夷畎夷、于夷、方夷、黄夷、白夷、赤夷、玄夷、风夷、阳夷都是居住在东方滨海一带的落后民族。这说明在夏朝中叶的时候,夏朝的政教势力,已远达东海之滨。以前五帝到夏禹时,主要的异族战斗是苗、黎。苗、黎在西方。到夏时征服苗黎之后,继之以服九夷,说明夏人之向东发展。这个夏朝的中兴,为时约二百年,传到第十四个君主孔甲,淫乱无度,夏政再衰。诸侯纷纷叛离,中枢的权力,日益纷散,夏政乃一蹶不振。《周语》说:“孔甲乱夏,四世而陨”。夏代从孔甲乱政,以后三传到了履癸,履癸先都斟郛,后都河南禹县。这履癸就是夏桀,种种无道,荒淫奢侈。传说夏桀宠爱有施氏之女妹喜,又宠爱岷山氏二女琬、琰。又营建倾宫瑶台,作酒池肉林,杀忠臣关龙逢。太史令终古哭谏夏桀,夏桀不听,终古就亡奔于商。商人是东方的一个诸侯,世居于今安徽亳县到河南商邱一带的地方。从孔甲失德以后,商人逐渐壮大,逐渐获得诸侯的拥护。到了商汤的时候,诸侯多叛桀而归汤。有些诸侯不服从汤,汤出兵去讨伐。兵行所到之处,百姓无不欢迎。其威德远在夏桀之上。就在夏桀在位的第五十三年[公元前一七五一年],商汤俯顺舆情,率领诸侯之兵,讨伐夏桀。与夏桀大战于鸣条[旧说在山西安邑附近,近人考应在淮河之南],夏桀大败。向东南方逃走,被商汤一路追击。夏桀屡战屡败,终被商汤所俘。商汤就把夏桀流放在南巢[安徽巢县],三年而死,史称“商汤革命”。这是我国历史上第一次的贵族革命。这个夏朝,也是中国历史上第一个正式的朝代。凡历十四世,十七主,四百余年而亡。\n![](20210703111602157.png)\n# 夏代影响\n\n 1.  治水\n禹治水的范围极大,据旧《史记》载,所谓疏“三江五湖”,几乎遍于全国,除了黄河之外,又导黄河的支流济水,又导淮水,又导长江。江、淮、河、济谓之四渎,所谓“四渎修,而民宅安。”我们近人推断,在那个时候,治水范围不会如此之广。我们可相信的是大禹的治水,是以黄河中段的冀州豫州为主。而渐及东方的兖州、徐州、可能的上溯到黄河上游的雍州、梁州和荆州的一部分。其他淮水与长江北面的若干支流。也可能附带的疏导过。然而仅这一个估计的范围已经很大,已经是禹率领着千万人民,经过十几年才能完成的功业。大禹治水的目的,是谋求人民生活的安定,使人民生活安定最好的方法,是使人民在这片新整理的土地上从事农耕。所以大禹治水后,就由弃的协助展开全面的农村建设,从夏朝起中国正式成为一个农业的国家。又由于治河的结果,自然而然的了解到各地的地势物产、风俗人情,自然171中华通史·第一卷·绪论上古史而然的加强了中央与地方及人民的联系。于是他制定了一个政治的区划,这个区划是分全国为九州。这九州是雍州[约当今陕西之地]、冀州[约当今山西南部]、豫州[约当今河南]、兖州[约当今河北南部]、青州[约当今山东]、徐州约当今苏北、皖北、扬州[约当今皖南、苏南]、荆州[约当今豫南与湖北]梁州[约当今陕南]成为中国版图的基础。\n又分为全国为五服[以王畿为中心,王畿四周五百里内为甸服,五百里外为侯服,侯服外五百里为绥服,绥服外五百里为要服,要服外五百里为荒服],构成一个以王京为中心的空间观念。又根据各地的物产,制为九等贡赋。此孟子所谓“夏后氏五十而贡”。这就是禹贡九州。所以由于大禹的治水的结果,他奠定了中国的农业社会;他建立了中国的疆域概念。他是最早建立中华民族成为一个国家的大英雄。禹称夏后氏,“夏”便成为我民族对外之代名辞。按《说文》“夏”字“”作人形,注云:“中国人也”[因之,当时中国境内诸民族,称为诸夏]。故后人称禹为大禹,诚非偶然。\n\n 2. 大禹始称王,始定传子之局。\n以前五帝的共主称氏,以前虞舜的禅让,均未脱氏族的形态。到了夏禹以后传子称王,证明中央的权威提高。诸侯对于中央的关系更加服从,更加密切。中央王室的政权更加稳定,更进一步走向封建帝国。按人类上古史的演变,由最早的部落到封建的君主世袭,这是一个大的进步,这是一个国家组织的完成。我们看禹时诸侯大会涂山,诛防风氏。启时大会诸侯钓台,诛有扈氏。都是说明这个国家组织与中央政府权力的扩大。\n\n 3. 治水成功,推进农业。\n夏人建国后配合农时而制订以建寅为岁首[正月]的历法。最合乎农业的时序,周人称夏人为“得天”。这个“夏正”历法,在商、周、秦时一度改变,到汉以后又恢复采用直用到今天,就是那四序分明的阴历,我们又叫做农历。由于夏禹的治水兴农,而建立了“农历”。我们又由这“农历”,可以推想到夏朝的农业社会。因为这“夏正”,是最符合农业的一个时序。\n夏代的文化已入于铜器时代。我们现在出土的铜器,虽尚未有确切的文字足以证明是夏代的铜器。但在山西、河南带若干出土的铜器中,相信其中或有夏器,并且根据殷商铜器之精美,其铜器制造,一定为时已久,则上推两三百年在夏朝时定有铜器可无疑。禹铸九鼎之说见于《史记》、《说文》、《左传》、《墨子》诸书,自然不是虚构。并且自春秋到秦汉历代有求鼎之事,绝对不是毫无根据的狂妄举动。据说禹铸九鼎是集九牧之铜铸成,上面刻划着各地的方物所谓铸鼎象物”。看了这九鼎,就可以知道九州的产物情形,这和《禹贡》的制度正相配合。这九鼎一直成为传国重器,也就是国家的象征。\n\n> 本文内容均抄录于[中华通史.上古史]，致谢陈致平先生","source":"_posts/2022/01/中华通史-上古史-夏.md","raw":"---\ntitle: 中华通史.上古史-夏\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2022-01-01 20:35:31\npassword:\nsummary:\ntags:\n- history\ncategories:\n- history\nkeywords:\ndescription:\n---\n@[TOC](夏代)\n\n# 夏国简介\n帝舜去世,禹得到诸侯一致的拥护,继立为天子。他曾受舜封为夏伯,赐姓姒,故国号夏,建都安邑,他先后请皋陶与益佐理政事。禹的政治,一方面督励人民从事农耕;方面整伤社会秩序,法律很严。他从北而南巡视天下,曾大会诸侯于涂山。防风氏后到为禹所杀。史称执玉帛而来与会的有万国,执玉的是大国,执帛的是小国。这些诸侯也就是那个时候的氏族部落,足以说明禹声威之盛远过唐虞。他继续向东方巡视,行至中途,死在会稽山[今浙江绍兴东南],据说他的葬礼极其简单,所谓“桐棺三寸”、“衣衾三领”真是一生刻苦。禹死之后,有一段很短的时间,由益代行政事。后来诸侯,怀念禹功,都拥护禹子启而不拥护益。于是启继位为天子,从此建立了父子相传的君主制度。\n\n\n# 夏代大事\n![](20210703105815619.png)![](20210703105831609.png)![](20210703105920999.png)\n史称:“帝尧之时洪水滔天,浩浩怀山襄陵。”成为当时最严重的一个问题叠经派人治理,都没有成功,尧乃接受四岳的推荐,用鲧治水,鲧就是禹的父亲。鲧用堵塞的方法,多筑堤坝。但是洪水滔滔,随筑随溃,经过九年的功夫,没有成功,引起人民的怨愤。到了舜执政的时候,便将鲧殛死。而用鲧子禹继续治水。这洪水之灾,从尧初算起已经几十年了。舜又命益与弃协助禹。禹伤父功不成,乃焦思苦虑。不惜一切的劳苦,希望能完成先业,以雪父耻。他完全改变他父亲的方法,从疏导着手。他带着许多“准绳”、“规矩”等测量的工具,登山涉水,观察地形高下,而后施工。他又用了许多交通工具,史称“陆行乘车,水行乘船,泥行乘橇,山行乘撵。”他先从黄河的中段冀州地方开始。这也是黄河泛滥的枢纽地带[今山西、河南之间]。一步步的向东方的兖州、青州、徐州、南方的荆州、豫州疏导,最后又折向西北去整理黄河的上游。他将黄河下游的河道分辟为九股,散其水势。然后再分为漯济流入渤海。又疏通了许多其他的河道,完成了许多惊人的工程。他率领人民,和黄河作了十三年的奋斗,把这上百年的洪水之灾,完全治平。使老百姓免于饥溺流离之苦,能在黄河流域安居乐业下来。他这十三年中,为了国家和人民,奋不顾身,曾经几次经过家门而不入。顾不得饮食起居,他治水时总是亲自拿着募锸以身作则带头去作。冒着狂风暴雨,弄得身体憔悴而永不休息。和他同样辛苦的,还有协助他的益和弃。益掌火,在治水之前,纵火焚山林,以驱禽兽,弃为后稷,掌播谷。在水平之后,教人民耕种,从事善后工作。他们这样辛劳,一方面获得百姓的爱戴;一方面获得后世的崇拜,禹成为后来苦行家墨子的宗师。而禹与后稷,被孟子尊为是“历史上最富于同情心的人”。\n夏启继立后,曾大会诸侯于钧台[今河南禹县许昌之间]。有扈氏不服,启率兵与有扈战于甘[今作《甘誓》]灭有扈。夏启的政权,乃归稳定。正式称为“夏后启”,启在位九年卒,子太康立。太康逸豫失政,太康五弟,追思禹德,乃作《五子之歌》。这时有东夷地方的一个有穷氏诸侯后羿作乱,太康被逼迁于斟部[河南巩县附近]。太康传弟仲康,仲康传子相,相又一度迁都于商邱[河南商邱],夏朝实际成为后羿的政权,后来后羿又被其权臣寒浞所杀,寒浞又弑相而篡夏,夏自禹至相不到九十年,而国统几绝。相妻有缗氏怀孕在身,逃至有仍[今山东济宁],生了一个遗腹子,是为少康。少康既长,从有仍氏地方逃到虞地[河南虞城],投奔有虞氏,有虞氏君收纳了少康,给以田一成[方十里为成]、众旅[五百人为旅]。后来少康就凭藉着这一成一旅的资本,强大起来。收抚旧日夏朝的士众,灭掉寒浞,复兴夏朝,还都于安邑,史称少康中兴。这后羿、寒浞之乱前后历时百年。\n少康时曾再度发生河患,以冥为司空再度治河。由少康传子杼,杼传槐[是为夏之第八主]。槐即位,九夷来朝,九夷畎夷、于夷、方夷、黄夷、白夷、赤夷、玄夷、风夷、阳夷都是居住在东方滨海一带的落后民族。这说明在夏朝中叶的时候,夏朝的政教势力,已远达东海之滨。以前五帝到夏禹时,主要的异族战斗是苗、黎。苗、黎在西方。到夏时征服苗黎之后,继之以服九夷,说明夏人之向东发展。这个夏朝的中兴,为时约二百年,传到第十四个君主孔甲,淫乱无度,夏政再衰。诸侯纷纷叛离,中枢的权力,日益纷散,夏政乃一蹶不振。《周语》说:“孔甲乱夏,四世而陨”。夏代从孔甲乱政,以后三传到了履癸,履癸先都斟郛,后都河南禹县。这履癸就是夏桀,种种无道,荒淫奢侈。传说夏桀宠爱有施氏之女妹喜,又宠爱岷山氏二女琬、琰。又营建倾宫瑶台,作酒池肉林,杀忠臣关龙逢。太史令终古哭谏夏桀,夏桀不听,终古就亡奔于商。商人是东方的一个诸侯,世居于今安徽亳县到河南商邱一带的地方。从孔甲失德以后,商人逐渐壮大,逐渐获得诸侯的拥护。到了商汤的时候,诸侯多叛桀而归汤。有些诸侯不服从汤,汤出兵去讨伐。兵行所到之处,百姓无不欢迎。其威德远在夏桀之上。就在夏桀在位的第五十三年[公元前一七五一年],商汤俯顺舆情,率领诸侯之兵,讨伐夏桀。与夏桀大战于鸣条[旧说在山西安邑附近,近人考应在淮河之南],夏桀大败。向东南方逃走,被商汤一路追击。夏桀屡战屡败,终被商汤所俘。商汤就把夏桀流放在南巢[安徽巢县],三年而死,史称“商汤革命”。这是我国历史上第一次的贵族革命。这个夏朝,也是中国历史上第一个正式的朝代。凡历十四世,十七主,四百余年而亡。\n![](20210703111602157.png)\n# 夏代影响\n\n 1.  治水\n禹治水的范围极大,据旧《史记》载,所谓疏“三江五湖”,几乎遍于全国,除了黄河之外,又导黄河的支流济水,又导淮水,又导长江。江、淮、河、济谓之四渎,所谓“四渎修,而民宅安。”我们近人推断,在那个时候,治水范围不会如此之广。我们可相信的是大禹的治水,是以黄河中段的冀州豫州为主。而渐及东方的兖州、徐州、可能的上溯到黄河上游的雍州、梁州和荆州的一部分。其他淮水与长江北面的若干支流。也可能附带的疏导过。然而仅这一个估计的范围已经很大,已经是禹率领着千万人民,经过十几年才能完成的功业。大禹治水的目的,是谋求人民生活的安定,使人民生活安定最好的方法,是使人民在这片新整理的土地上从事农耕。所以大禹治水后,就由弃的协助展开全面的农村建设,从夏朝起中国正式成为一个农业的国家。又由于治河的结果,自然而然的了解到各地的地势物产、风俗人情,自然171中华通史·第一卷·绪论上古史而然的加强了中央与地方及人民的联系。于是他制定了一个政治的区划,这个区划是分全国为九州。这九州是雍州[约当今陕西之地]、冀州[约当今山西南部]、豫州[约当今河南]、兖州[约当今河北南部]、青州[约当今山东]、徐州约当今苏北、皖北、扬州[约当今皖南、苏南]、荆州[约当今豫南与湖北]梁州[约当今陕南]成为中国版图的基础。\n又分为全国为五服[以王畿为中心,王畿四周五百里内为甸服,五百里外为侯服,侯服外五百里为绥服,绥服外五百里为要服,要服外五百里为荒服],构成一个以王京为中心的空间观念。又根据各地的物产,制为九等贡赋。此孟子所谓“夏后氏五十而贡”。这就是禹贡九州。所以由于大禹的治水的结果,他奠定了中国的农业社会;他建立了中国的疆域概念。他是最早建立中华民族成为一个国家的大英雄。禹称夏后氏,“夏”便成为我民族对外之代名辞。按《说文》“夏”字“”作人形,注云:“中国人也”[因之,当时中国境内诸民族,称为诸夏]。故后人称禹为大禹,诚非偶然。\n\n 2. 大禹始称王,始定传子之局。\n以前五帝的共主称氏,以前虞舜的禅让,均未脱氏族的形态。到了夏禹以后传子称王,证明中央的权威提高。诸侯对于中央的关系更加服从,更加密切。中央王室的政权更加稳定,更进一步走向封建帝国。按人类上古史的演变,由最早的部落到封建的君主世袭,这是一个大的进步,这是一个国家组织的完成。我们看禹时诸侯大会涂山,诛防风氏。启时大会诸侯钓台,诛有扈氏。都是说明这个国家组织与中央政府权力的扩大。\n\n 3. 治水成功,推进农业。\n夏人建国后配合农时而制订以建寅为岁首[正月]的历法。最合乎农业的时序,周人称夏人为“得天”。这个“夏正”历法,在商、周、秦时一度改变,到汉以后又恢复采用直用到今天,就是那四序分明的阴历,我们又叫做农历。由于夏禹的治水兴农,而建立了“农历”。我们又由这“农历”,可以推想到夏朝的农业社会。因为这“夏正”,是最符合农业的一个时序。\n夏代的文化已入于铜器时代。我们现在出土的铜器,虽尚未有确切的文字足以证明是夏代的铜器。但在山西、河南带若干出土的铜器中,相信其中或有夏器,并且根据殷商铜器之精美,其铜器制造,一定为时已久,则上推两三百年在夏朝时定有铜器可无疑。禹铸九鼎之说见于《史记》、《说文》、《左传》、《墨子》诸书,自然不是虚构。并且自春秋到秦汉历代有求鼎之事,绝对不是毫无根据的狂妄举动。据说禹铸九鼎是集九牧之铜铸成,上面刻划着各地的方物所谓铸鼎象物”。看了这九鼎,就可以知道九州的产物情形,这和《禹贡》的制度正相配合。这九鼎一直成为传国重器,也就是国家的象征。\n\n> 本文内容均抄录于[中华通史.上古史]，致谢陈致平先生","slug":"中华通史-上古史-夏","published":1,"updated":"2023-04-04T09:24:10.135Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk69d1cx000djsrjj0t7n5ku","content":"<p>@<a href=\"夏代\">TOC</a></p>\n<h1 id=\"夏国简介\"><a href=\"#夏国简介\" class=\"headerlink\" title=\"夏国简介\"></a>夏国简介</h1><p>帝舜去世,禹得到诸侯一致的拥护,继立为天子。他曾受舜封为夏伯,赐姓姒,故国号夏,建都安邑,他先后请皋陶与益佐理政事。禹的政治,一方面督励人民从事农耕;方面整伤社会秩序,法律很严。他从北而南巡视天下,曾大会诸侯于涂山。防风氏后到为禹所杀。史称执玉帛而来与会的有万国,执玉的是大国,执帛的是小国。这些诸侯也就是那个时候的氏族部落,足以说明禹声威之盛远过唐虞。他继续向东方巡视,行至中途,死在会稽山[今浙江绍兴东南],据说他的葬礼极其简单,所谓“桐棺三寸”、“衣衾三领”真是一生刻苦。禹死之后,有一段很短的时间,由益代行政事。后来诸侯,怀念禹功,都拥护禹子启而不拥护益。于是启继位为天子,从此建立了父子相传的君主制度。</p>\n<h1 id=\"夏代大事\"><a href=\"#夏代大事\" class=\"headerlink\" title=\"夏代大事\"></a>夏代大事</h1><p><img src=\"/2022/01/zhong-hua-tong-shi-shang-gu-shi-xia/20210703105815619.png\" alt><img src=\"/2022/01/zhong-hua-tong-shi-shang-gu-shi-xia/20210703105831609.png\" alt><img src=\"/2022/01/zhong-hua-tong-shi-shang-gu-shi-xia/20210703105920999.png\" alt><br>史称:“帝尧之时洪水滔天,浩浩怀山襄陵。”成为当时最严重的一个问题叠经派人治理,都没有成功,尧乃接受四岳的推荐,用鲧治水,鲧就是禹的父亲。鲧用堵塞的方法,多筑堤坝。但是洪水滔滔,随筑随溃,经过九年的功夫,没有成功,引起人民的怨愤。到了舜执政的时候,便将鲧殛死。而用鲧子禹继续治水。这洪水之灾,从尧初算起已经几十年了。舜又命益与弃协助禹。禹伤父功不成,乃焦思苦虑。不惜一切的劳苦,希望能完成先业,以雪父耻。他完全改变他父亲的方法,从疏导着手。他带着许多“准绳”、“规矩”等测量的工具,登山涉水,观察地形高下,而后施工。他又用了许多交通工具,史称“陆行乘车,水行乘船,泥行乘橇,山行乘撵。”他先从黄河的中段冀州地方开始。这也是黄河泛滥的枢纽地带[今山西、河南之间]。一步步的向东方的兖州、青州、徐州、南方的荆州、豫州疏导,最后又折向西北去整理黄河的上游。他将黄河下游的河道分辟为九股,散其水势。然后再分为漯济流入渤海。又疏通了许多其他的河道,完成了许多惊人的工程。他率领人民,和黄河作了十三年的奋斗,把这上百年的洪水之灾,完全治平。使老百姓免于饥溺流离之苦,能在黄河流域安居乐业下来。他这十三年中,为了国家和人民,奋不顾身,曾经几次经过家门而不入。顾不得饮食起居,他治水时总是亲自拿着募锸以身作则带头去作。冒着狂风暴雨,弄得身体憔悴而永不休息。和他同样辛苦的,还有协助他的益和弃。益掌火,在治水之前,纵火焚山林,以驱禽兽,弃为后稷,掌播谷。在水平之后,教人民耕种,从事善后工作。他们这样辛劳,一方面获得百姓的爱戴;一方面获得后世的崇拜,禹成为后来苦行家墨子的宗师。而禹与后稷,被孟子尊为是“历史上最富于同情心的人”。<br>夏启继立后,曾大会诸侯于钧台[今河南禹县许昌之间]。有扈氏不服,启率兵与有扈战于甘[今作《甘誓》]灭有扈。夏启的政权,乃归稳定。正式称为“夏后启”,启在位九年卒,子太康立。太康逸豫失政,太康五弟,追思禹德,乃作《五子之歌》。这时有东夷地方的一个有穷氏诸侯后羿作乱,太康被逼迁于斟部[河南巩县附近]。太康传弟仲康,仲康传子相,相又一度迁都于商邱[河南商邱],夏朝实际成为后羿的政权,后来后羿又被其权臣寒浞所杀,寒浞又弑相而篡夏,夏自禹至相不到九十年,而国统几绝。相妻有缗氏怀孕在身,逃至有仍[今山东济宁],生了一个遗腹子,是为少康。少康既长,从有仍氏地方逃到虞地[河南虞城],投奔有虞氏,有虞氏君收纳了少康,给以田一成[方十里为成]、众旅[五百人为旅]。后来少康就凭藉着这一成一旅的资本,强大起来。收抚旧日夏朝的士众,灭掉寒浞,复兴夏朝,还都于安邑,史称少康中兴。这后羿、寒浞之乱前后历时百年。<br>少康时曾再度发生河患,以冥为司空再度治河。由少康传子杼,杼传槐[是为夏之第八主]。槐即位,九夷来朝,九夷畎夷、于夷、方夷、黄夷、白夷、赤夷、玄夷、风夷、阳夷都是居住在东方滨海一带的落后民族。这说明在夏朝中叶的时候,夏朝的政教势力,已远达东海之滨。以前五帝到夏禹时,主要的异族战斗是苗、黎。苗、黎在西方。到夏时征服苗黎之后,继之以服九夷,说明夏人之向东发展。这个夏朝的中兴,为时约二百年,传到第十四个君主孔甲,淫乱无度,夏政再衰。诸侯纷纷叛离,中枢的权力,日益纷散,夏政乃一蹶不振。《周语》说:“孔甲乱夏,四世而陨”。夏代从孔甲乱政,以后三传到了履癸,履癸先都斟郛,后都河南禹县。这履癸就是夏桀,种种无道,荒淫奢侈。传说夏桀宠爱有施氏之女妹喜,又宠爱岷山氏二女琬、琰。又营建倾宫瑶台,作酒池肉林,杀忠臣关龙逢。太史令终古哭谏夏桀,夏桀不听,终古就亡奔于商。商人是东方的一个诸侯,世居于今安徽亳县到河南商邱一带的地方。从孔甲失德以后,商人逐渐壮大,逐渐获得诸侯的拥护。到了商汤的时候,诸侯多叛桀而归汤。有些诸侯不服从汤,汤出兵去讨伐。兵行所到之处,百姓无不欢迎。其威德远在夏桀之上。就在夏桀在位的第五十三年[公元前一七五一年],商汤俯顺舆情,率领诸侯之兵,讨伐夏桀。与夏桀大战于鸣条[旧说在山西安邑附近,近人考应在淮河之南],夏桀大败。向东南方逃走,被商汤一路追击。夏桀屡战屡败,终被商汤所俘。商汤就把夏桀流放在南巢[安徽巢县],三年而死,史称“商汤革命”。这是我国历史上第一次的贵族革命。这个夏朝,也是中国历史上第一个正式的朝代。凡历十四世,十七主,四百余年而亡。<br><img src=\"/2022/01/zhong-hua-tong-shi-shang-gu-shi-xia/20210703111602157.png\" alt></p>\n<h1 id=\"夏代影响\"><a href=\"#夏代影响\" class=\"headerlink\" title=\"夏代影响\"></a>夏代影响</h1><ol>\n<li><p>治水<br>禹治水的范围极大,据旧《史记》载,所谓疏“三江五湖”,几乎遍于全国,除了黄河之外,又导黄河的支流济水,又导淮水,又导长江。江、淮、河、济谓之四渎,所谓“四渎修,而民宅安。”我们近人推断,在那个时候,治水范围不会如此之广。我们可相信的是大禹的治水,是以黄河中段的冀州豫州为主。而渐及东方的兖州、徐州、可能的上溯到黄河上游的雍州、梁州和荆州的一部分。其他淮水与长江北面的若干支流。也可能附带的疏导过。然而仅这一个估计的范围已经很大,已经是禹率领着千万人民,经过十几年才能完成的功业。大禹治水的目的,是谋求人民生活的安定,使人民生活安定最好的方法,是使人民在这片新整理的土地上从事农耕。所以大禹治水后,就由弃的协助展开全面的农村建设,从夏朝起中国正式成为一个农业的国家。又由于治河的结果,自然而然的了解到各地的地势物产、风俗人情,自然171中华通史·第一卷·绪论上古史而然的加强了中央与地方及人民的联系。于是他制定了一个政治的区划,这个区划是分全国为九州。这九州是雍州[约当今陕西之地]、冀州[约当今山西南部]、豫州[约当今河南]、兖州[约当今河北南部]、青州[约当今山东]、徐州约当今苏北、皖北、扬州[约当今皖南、苏南]、荆州[约当今豫南与湖北]梁州[约当今陕南]成为中国版图的基础。<br>又分为全国为五服[以王畿为中心,王畿四周五百里内为甸服,五百里外为侯服,侯服外五百里为绥服,绥服外五百里为要服,要服外五百里为荒服],构成一个以王京为中心的空间观念。又根据各地的物产,制为九等贡赋。此孟子所谓“夏后氏五十而贡”。这就是禹贡九州。所以由于大禹的治水的结果,他奠定了中国的农业社会;他建立了中国的疆域概念。他是最早建立中华民族成为一个国家的大英雄。禹称夏后氏,“夏”便成为我民族对外之代名辞。按《说文》“夏”字“”作人形,注云:“中国人也”[因之,当时中国境内诸民族,称为诸夏]。故后人称禹为大禹,诚非偶然。</p>\n</li>\n<li><p>大禹始称王,始定传子之局。<br>以前五帝的共主称氏,以前虞舜的禅让,均未脱氏族的形态。到了夏禹以后传子称王,证明中央的权威提高。诸侯对于中央的关系更加服从,更加密切。中央王室的政权更加稳定,更进一步走向封建帝国。按人类上古史的演变,由最早的部落到封建的君主世袭,这是一个大的进步,这是一个国家组织的完成。我们看禹时诸侯大会涂山,诛防风氏。启时大会诸侯钓台,诛有扈氏。都是说明这个国家组织与中央政府权力的扩大。</p>\n</li>\n<li><p>治水成功,推进农业。<br>夏人建国后配合农时而制订以建寅为岁首[正月]的历法。最合乎农业的时序,周人称夏人为“得天”。这个“夏正”历法,在商、周、秦时一度改变,到汉以后又恢复采用直用到今天,就是那四序分明的阴历,我们又叫做农历。由于夏禹的治水兴农,而建立了“农历”。我们又由这“农历”,可以推想到夏朝的农业社会。因为这“夏正”,是最符合农业的一个时序。<br>夏代的文化已入于铜器时代。我们现在出土的铜器,虽尚未有确切的文字足以证明是夏代的铜器。但在山西、河南带若干出土的铜器中,相信其中或有夏器,并且根据殷商铜器之精美,其铜器制造,一定为时已久,则上推两三百年在夏朝时定有铜器可无疑。禹铸九鼎之说见于《史记》、《说文》、《左传》、《墨子》诸书,自然不是虚构。并且自春秋到秦汉历代有求鼎之事,绝对不是毫无根据的狂妄举动。据说禹铸九鼎是集九牧之铜铸成,上面刻划着各地的方物所谓铸鼎象物”。看了这九鼎,就可以知道九州的产物情形,这和《禹贡》的制度正相配合。这九鼎一直成为传国重器,也就是国家的象征。</p>\n</li>\n</ol>\n<blockquote>\n<p>本文内容均抄录于[中华通史.上古史]，致谢陈致平先生</p>\n</blockquote>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<p>@<a href=\"夏代\">TOC</a></p>\n<h1 id=\"夏国简介\"><a href=\"#夏国简介\" class=\"headerlink\" title=\"夏国简介\"></a>夏国简介</h1><p>帝舜去世,禹得到诸侯一致的拥护,继立为天子。他曾受舜封为夏伯,赐姓姒,故国号夏,建都安邑,他先后请皋陶与益佐理政事。禹的政治,一方面督励人民从事农耕;方面整伤社会秩序,法律很严。他从北而南巡视天下,曾大会诸侯于涂山。防风氏后到为禹所杀。史称执玉帛而来与会的有万国,执玉的是大国,执帛的是小国。这些诸侯也就是那个时候的氏族部落,足以说明禹声威之盛远过唐虞。他继续向东方巡视,行至中途,死在会稽山[今浙江绍兴东南],据说他的葬礼极其简单,所谓“桐棺三寸”、“衣衾三领”真是一生刻苦。禹死之后,有一段很短的时间,由益代行政事。后来诸侯,怀念禹功,都拥护禹子启而不拥护益。于是启继位为天子,从此建立了父子相传的君主制度。</p>\n<h1 id=\"夏代大事\"><a href=\"#夏代大事\" class=\"headerlink\" title=\"夏代大事\"></a>夏代大事</h1><p><img src=\"/2022/01/zhong-hua-tong-shi-shang-gu-shi-xia/20210703105815619.png\" alt><img src=\"/2022/01/zhong-hua-tong-shi-shang-gu-shi-xia/20210703105831609.png\" alt><img src=\"/2022/01/zhong-hua-tong-shi-shang-gu-shi-xia/20210703105920999.png\" alt><br>史称:“帝尧之时洪水滔天,浩浩怀山襄陵。”成为当时最严重的一个问题叠经派人治理,都没有成功,尧乃接受四岳的推荐,用鲧治水,鲧就是禹的父亲。鲧用堵塞的方法,多筑堤坝。但是洪水滔滔,随筑随溃,经过九年的功夫,没有成功,引起人民的怨愤。到了舜执政的时候,便将鲧殛死。而用鲧子禹继续治水。这洪水之灾,从尧初算起已经几十年了。舜又命益与弃协助禹。禹伤父功不成,乃焦思苦虑。不惜一切的劳苦,希望能完成先业,以雪父耻。他完全改变他父亲的方法,从疏导着手。他带着许多“准绳”、“规矩”等测量的工具,登山涉水,观察地形高下,而后施工。他又用了许多交通工具,史称“陆行乘车,水行乘船,泥行乘橇,山行乘撵。”他先从黄河的中段冀州地方开始。这也是黄河泛滥的枢纽地带[今山西、河南之间]。一步步的向东方的兖州、青州、徐州、南方的荆州、豫州疏导,最后又折向西北去整理黄河的上游。他将黄河下游的河道分辟为九股,散其水势。然后再分为漯济流入渤海。又疏通了许多其他的河道,完成了许多惊人的工程。他率领人民,和黄河作了十三年的奋斗,把这上百年的洪水之灾,完全治平。使老百姓免于饥溺流离之苦,能在黄河流域安居乐业下来。他这十三年中,为了国家和人民,奋不顾身,曾经几次经过家门而不入。顾不得饮食起居,他治水时总是亲自拿着募锸以身作则带头去作。冒着狂风暴雨,弄得身体憔悴而永不休息。和他同样辛苦的,还有协助他的益和弃。益掌火,在治水之前,纵火焚山林,以驱禽兽,弃为后稷,掌播谷。在水平之后,教人民耕种,从事善后工作。他们这样辛劳,一方面获得百姓的爱戴;一方面获得后世的崇拜,禹成为后来苦行家墨子的宗师。而禹与后稷,被孟子尊为是“历史上最富于同情心的人”。<br>夏启继立后,曾大会诸侯于钧台[今河南禹县许昌之间]。有扈氏不服,启率兵与有扈战于甘[今作《甘誓》]灭有扈。夏启的政权,乃归稳定。正式称为“夏后启”,启在位九年卒,子太康立。太康逸豫失政,太康五弟,追思禹德,乃作《五子之歌》。这时有东夷地方的一个有穷氏诸侯后羿作乱,太康被逼迁于斟部[河南巩县附近]。太康传弟仲康,仲康传子相,相又一度迁都于商邱[河南商邱],夏朝实际成为后羿的政权,后来后羿又被其权臣寒浞所杀,寒浞又弑相而篡夏,夏自禹至相不到九十年,而国统几绝。相妻有缗氏怀孕在身,逃至有仍[今山东济宁],生了一个遗腹子,是为少康。少康既长,从有仍氏地方逃到虞地[河南虞城],投奔有虞氏,有虞氏君收纳了少康,给以田一成[方十里为成]、众旅[五百人为旅]。后来少康就凭藉着这一成一旅的资本,强大起来。收抚旧日夏朝的士众,灭掉寒浞,复兴夏朝,还都于安邑,史称少康中兴。这后羿、寒浞之乱前后历时百年。<br>少康时曾再度发生河患,以冥为司空再度治河。由少康传子杼,杼传槐[是为夏之第八主]。槐即位,九夷来朝,九夷畎夷、于夷、方夷、黄夷、白夷、赤夷、玄夷、风夷、阳夷都是居住在东方滨海一带的落后民族。这说明在夏朝中叶的时候,夏朝的政教势力,已远达东海之滨。以前五帝到夏禹时,主要的异族战斗是苗、黎。苗、黎在西方。到夏时征服苗黎之后,继之以服九夷,说明夏人之向东发展。这个夏朝的中兴,为时约二百年,传到第十四个君主孔甲,淫乱无度,夏政再衰。诸侯纷纷叛离,中枢的权力,日益纷散,夏政乃一蹶不振。《周语》说:“孔甲乱夏,四世而陨”。夏代从孔甲乱政,以后三传到了履癸,履癸先都斟郛,后都河南禹县。这履癸就是夏桀,种种无道,荒淫奢侈。传说夏桀宠爱有施氏之女妹喜,又宠爱岷山氏二女琬、琰。又营建倾宫瑶台,作酒池肉林,杀忠臣关龙逢。太史令终古哭谏夏桀,夏桀不听,终古就亡奔于商。商人是东方的一个诸侯,世居于今安徽亳县到河南商邱一带的地方。从孔甲失德以后,商人逐渐壮大,逐渐获得诸侯的拥护。到了商汤的时候,诸侯多叛桀而归汤。有些诸侯不服从汤,汤出兵去讨伐。兵行所到之处,百姓无不欢迎。其威德远在夏桀之上。就在夏桀在位的第五十三年[公元前一七五一年],商汤俯顺舆情,率领诸侯之兵,讨伐夏桀。与夏桀大战于鸣条[旧说在山西安邑附近,近人考应在淮河之南],夏桀大败。向东南方逃走,被商汤一路追击。夏桀屡战屡败,终被商汤所俘。商汤就把夏桀流放在南巢[安徽巢县],三年而死,史称“商汤革命”。这是我国历史上第一次的贵族革命。这个夏朝,也是中国历史上第一个正式的朝代。凡历十四世,十七主,四百余年而亡。<br><img src=\"/2022/01/zhong-hua-tong-shi-shang-gu-shi-xia/20210703111602157.png\" alt></p>\n<h1 id=\"夏代影响\"><a href=\"#夏代影响\" class=\"headerlink\" title=\"夏代影响\"></a>夏代影响</h1><ol>\n<li><p>治水<br>禹治水的范围极大,据旧《史记》载,所谓疏“三江五湖”,几乎遍于全国,除了黄河之外,又导黄河的支流济水,又导淮水,又导长江。江、淮、河、济谓之四渎,所谓“四渎修,而民宅安。”我们近人推断,在那个时候,治水范围不会如此之广。我们可相信的是大禹的治水,是以黄河中段的冀州豫州为主。而渐及东方的兖州、徐州、可能的上溯到黄河上游的雍州、梁州和荆州的一部分。其他淮水与长江北面的若干支流。也可能附带的疏导过。然而仅这一个估计的范围已经很大,已经是禹率领着千万人民,经过十几年才能完成的功业。大禹治水的目的,是谋求人民生活的安定,使人民生活安定最好的方法,是使人民在这片新整理的土地上从事农耕。所以大禹治水后,就由弃的协助展开全面的农村建设,从夏朝起中国正式成为一个农业的国家。又由于治河的结果,自然而然的了解到各地的地势物产、风俗人情,自然171中华通史·第一卷·绪论上古史而然的加强了中央与地方及人民的联系。于是他制定了一个政治的区划,这个区划是分全国为九州。这九州是雍州[约当今陕西之地]、冀州[约当今山西南部]、豫州[约当今河南]、兖州[约当今河北南部]、青州[约当今山东]、徐州约当今苏北、皖北、扬州[约当今皖南、苏南]、荆州[约当今豫南与湖北]梁州[约当今陕南]成为中国版图的基础。<br>又分为全国为五服[以王畿为中心,王畿四周五百里内为甸服,五百里外为侯服,侯服外五百里为绥服,绥服外五百里为要服,要服外五百里为荒服],构成一个以王京为中心的空间观念。又根据各地的物产,制为九等贡赋。此孟子所谓“夏后氏五十而贡”。这就是禹贡九州。所以由于大禹的治水的结果,他奠定了中国的农业社会;他建立了中国的疆域概念。他是最早建立中华民族成为一个国家的大英雄。禹称夏后氏,“夏”便成为我民族对外之代名辞。按《说文》“夏”字“”作人形,注云:“中国人也”[因之,当时中国境内诸民族,称为诸夏]。故后人称禹为大禹,诚非偶然。</p>\n</li>\n<li><p>大禹始称王,始定传子之局。<br>以前五帝的共主称氏,以前虞舜的禅让,均未脱氏族的形态。到了夏禹以后传子称王,证明中央的权威提高。诸侯对于中央的关系更加服从,更加密切。中央王室的政权更加稳定,更进一步走向封建帝国。按人类上古史的演变,由最早的部落到封建的君主世袭,这是一个大的进步,这是一个国家组织的完成。我们看禹时诸侯大会涂山,诛防风氏。启时大会诸侯钓台,诛有扈氏。都是说明这个国家组织与中央政府权力的扩大。</p>\n</li>\n<li><p>治水成功,推进农业。<br>夏人建国后配合农时而制订以建寅为岁首[正月]的历法。最合乎农业的时序,周人称夏人为“得天”。这个“夏正”历法,在商、周、秦时一度改变,到汉以后又恢复采用直用到今天,就是那四序分明的阴历,我们又叫做农历。由于夏禹的治水兴农,而建立了“农历”。我们又由这“农历”,可以推想到夏朝的农业社会。因为这“夏正”,是最符合农业的一个时序。<br>夏代的文化已入于铜器时代。我们现在出土的铜器,虽尚未有确切的文字足以证明是夏代的铜器。但在山西、河南带若干出土的铜器中,相信其中或有夏器,并且根据殷商铜器之精美,其铜器制造,一定为时已久,则上推两三百年在夏朝时定有铜器可无疑。禹铸九鼎之说见于《史记》、《说文》、《左传》、《墨子》诸书,自然不是虚构。并且自春秋到秦汉历代有求鼎之事,绝对不是毫无根据的狂妄举动。据说禹铸九鼎是集九牧之铜铸成,上面刻划着各地的方物所谓铸鼎象物”。看了这九鼎,就可以知道九州的产物情形,这和《禹贡》的制度正相配合。这九鼎一直成为传国重器,也就是国家的象征。</p>\n</li>\n</ol>\n<blockquote>\n<p>本文内容均抄录于[中华通史.上古史]，致谢陈致平先生</p>\n</blockquote>\n"},{"title":"菜鸟应该如何开始设计一个项目的嵌入式软件架构","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2022-01-01T12:21:23.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"@[toc]\n## 前言\n*<font size=2 >CSDN，GIT等各大论坛上很多文章都有讲，如何设计项目的嵌入式软件架构，But门槛实在太高了，需要做需求调研，需求分析，概要设计，详细设计，架构验证，开发-单元测试，集成测试等等，实不相瞒这些没有半年八载的项目经验根本做不出来的，刚好经过这周的嵌入式架构培训，提炼下最近在做项目的嵌入式软件架构的设计经验吧，不喜勿碰，谢谢。*\n## 六步走战略\n### 第0步——嵌软需求：功能/接口/质量/硬件约束/方案约束/数据流\n ## 技能一：用例图和用例描述\n<font color=blue>Q:需求如何转换成软件框架\n<font color=blue>A:画用例图，写用列描述 \n\n**<font size=4 >用例图**（Use Case Diagrame）：描述了人们希望如何使用一个系统，将相关用户、用户需要系统提供的服务以及系统需要用户提供的服务更清晰的显示出来，以便使系统用户更容易理解这些元素的用途，也便于开发人员最终实现这些元素。\n用例图包括了三方面的内容：1用例，2参与者，3参与者和用例之间的关系。\n**<font size=3 >用例**：是对系统的用户需求（主要是功能需求）的描述，用例表达了系统的功能和所提供的服务，描述了活动者与系统交互中的对话。\n**<font size=3 >参与者**：参与者是系统外部的一个实体，它以某种方式参与了用例的执行过程，在UML中，通常用名字写在下面的人形图标表示。值得注意的是：参与者不一定是人，也可以是任何的事。\n**<font size=3 >参与者和用例之间的关系**：1关联关系，2泛化关系，3包含关系，4扩展关系下面使用亿图软件演示下用例，参与者以及二者之间的关系。\n下面这张图网上扣的，是图书馆的用例图(这里画的用例还不完全)：\n![图书馆系统](菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329193127889.jpg)<font size=2 >为什么要画用例图，而不是UML，状态机这些专业的语言用图，其实最重要的一点就是产品想做好就必须站在客户的角度思考问题，在产品需求分析阶段就要开始为上帝考虑，等到设计阶段再来思考用户体验就为时已晚，产品基本也就失败了。\n\n**<font size=4 >用例描述**：用例图仅仅是描述了系统具有的功能，但是并没有描述每一个用例的行为，也就是执行过程。\n我们不需要对每一个用例进行分析，而是需要在这些用例中，找出那些关键用例，然后对这些关键用例写出用例描述，因为关键用例才是系统架构的决定因素。\n\nQ：关键用例如何分析？。\nA: 抓住功能/接口/质量/硬件约束/方案约束/数据流这几个方面来思考。·\n\t功能：产品最关键的因素，以实现的功能来展开用例\n\t接口：硬件接口是实现功能的方式，软件接口决定层间接口的好坏\n\t质量：提高产品竞争里的核心\n\t硬件约束：决定底层驱动的复杂程度\n\t方案约束：高内聚，低耦合的前提\n\t数据流：拿捏代码逻辑的最好方法\n下面也是从网络上找的用例描述示例，可以看到并没有统一的格式，需要根据项目的性质进行增减。\n![用例描述](菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329195920218.jpg)\n\nQ:假设我们在不断的搜集和分析中，尽可能地列出了所有的需求(功能需求、质量属性、条件约束)，下一步需要做什么呢？需求这么多，该从哪一个需求入手呢？\n\nA:关键需求 = 关键功能 + 关键质量。它确定了架构的大方向。\n\n\n### 第1步——粗粒度分层\n### 第2步——中粒度分模块\n### 第3步——细粒度分ISR/周期仸务/事件驱动任务\n ## 技能二：分层，分模块，分子系统\n<font color=blue>Q:如何将需求阶段的用例图和用例描述，转换成代码\n<font color=blue>A:分层，分模块，分子系统\n\n这里举一个电梯的例子：\n![](菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329201443609.png)\n\n\n\n**<font size=4 >分层**：这里的分层是指软件代码的层次结构，并不是电梯的楼层哟，请看下图\n![分层](菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329200632579.png)底层库，驱动，HAL，服务层，功能层，用户层等，我们需要的是在第0步种对用例描述的功能，接口，硬件，约束等进行总结，提炼出我们需要做的驱动，服务和用户接口。\n这里安利一种思维是“洋葱皮”分层模式：上层调用下层，下层不能调上层。入口组装func模块，func组装下层模块。如下图所示：\n![](菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329202548677.png)\n在分层上的体现就是如下图所示：\n![](菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329202358795.png)\n**<font size=4 >分模块**：一句话按功能划分模块，电梯这个项目有几个功能就划分几个模块，以下对移动功能列出一个模块：\n![分模块](菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329201646615.png)项目的设计过程种，由着诸多的需求。而很多需求都可以进行归类，根据功能需求的方法进行模块的划分。可以让需求在归类上得到明确的划分，而且通过功能需求进行软件的模块划分使得功能分解，任务分配等方面都有较好的分解。不知道大家发现没其实分模块阶段就进行了ISR/周期仸务/事件驱动任务的设计。\n如果一个项目大家分析到这里是不是大概觉得自己知道写哪些代码了，接下来就是将模块连接起来，形成软件的骨架。\n\n**<font size=4 >分子系统**：\nQ:子系统如何分\nA:纵深封装\n什么叫纵深封装，意思就是形成跨层子系统，func层模块，封装drv模块，子系统接口公开，接口粒度大，所以松耦合\n![子系统](菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329203021908.png)在分层上的体现就是：\n![在这里插入图片描述](菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329203335481.png)子系统在分层上的体现就是：\n![子系统](菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329203626594.png)到这里设计完每个子系统之后，层层递进，层组成模块，模块细化层，子系统连接模块，模块递进成子系统。\n\n到这里基本软件的框架就能设计出来，具体的模块封装，任务并发，模块接口这些就看个人道行了。\n### 第4步——分析一个功能的协作链：定义task间通信方式/数据流关系\n### 第5步——分析并发情况下协作链：优化task的并发执行/数据流关系\n### 第6步——分析参与多功能的同一模块：优化模块的通用性/灵活性/可扩展\n以上3步是大佬总结的bug的3个方向，想要有一个稳定的系统，这3步是必须做的，其实我把他们统称为Bug，简而言之我们就要要有发现Bug的能力。\n ## 技能三：Bug工程师，要会找bu g\n这里提供几种找Bug的方法：\n1：SystemView分析工具：[rtthread的systemview分析工具](https://www.rt-thread.org/document/site/application-note/debug/systemview/an0009-systemview/)\n2：CmBacktrace：[ARM Cortex-M 系列 MCU 错误追踪库](http://packages.rt-thread.org/detail.html?package=CmBacktrace)\n3：Pc-lint:[静态代码检查工具](https://freertos.blog.csdn.net/article/details/5930634?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control&dist_request_id=1328740.41223.16170229474446557&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control)\n生命不止，BUG不止。发现好的bug工具再来补充。\n\n**后续步——5、 6循环，不断优化。但若发现架构大缺陷，回溯到1-2-3-4**\n\n经过这次的架构培训，我基本上把自己在平常工作中，对应用程序架构设计的这个思考过程描述了一遍。\n\n佛经里说了：凡是回归原点，不懂就不懂，努力学习。懂了也要相信人外有人，放下架子，谦虚，能力提升方可最大化。\n\n这篇文章介绍的设计流程，也是一个套路而已。这个套路在面对一个新领域、新项目时，就像一个脚手架一样，告诉我们这一步该做什么，下一步该做什么，应该使用什么样的工具。\n\n在僵化的运用这个套路之后，你可以继续改造、优化，然后丢掉这个套路，从而形成适合你自己的套路，从此走向思考致富的道路！\n\nGOOD LUCK\n\n\n\n\n\n \n\n","source":"_posts/2022/01/菜鸟应该如何开始设计一个项目的嵌入式软件架构.md","raw":"---\ntitle: 菜鸟应该如何开始设计一个项目的嵌入式软件架构\npermalink: 菜鸟应该如何开始设计一个项目的嵌入式软件架构\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2022-01-01 20:21:23\npassword:\nsummary:\ntags:\n- Embedded system\ncategories:\n- Embedded system\nkeywords:\ndescription:\n---\n@[toc]\n## 前言\n*<font size=2 >CSDN，GIT等各大论坛上很多文章都有讲，如何设计项目的嵌入式软件架构，But门槛实在太高了，需要做需求调研，需求分析，概要设计，详细设计，架构验证，开发-单元测试，集成测试等等，实不相瞒这些没有半年八载的项目经验根本做不出来的，刚好经过这周的嵌入式架构培训，提炼下最近在做项目的嵌入式软件架构的设计经验吧，不喜勿碰，谢谢。*\n## 六步走战略\n### 第0步——嵌软需求：功能/接口/质量/硬件约束/方案约束/数据流\n ## 技能一：用例图和用例描述\n<font color=blue>Q:需求如何转换成软件框架\n<font color=blue>A:画用例图，写用列描述 \n\n**<font size=4 >用例图**（Use Case Diagrame）：描述了人们希望如何使用一个系统，将相关用户、用户需要系统提供的服务以及系统需要用户提供的服务更清晰的显示出来，以便使系统用户更容易理解这些元素的用途，也便于开发人员最终实现这些元素。\n用例图包括了三方面的内容：1用例，2参与者，3参与者和用例之间的关系。\n**<font size=3 >用例**：是对系统的用户需求（主要是功能需求）的描述，用例表达了系统的功能和所提供的服务，描述了活动者与系统交互中的对话。\n**<font size=3 >参与者**：参与者是系统外部的一个实体，它以某种方式参与了用例的执行过程，在UML中，通常用名字写在下面的人形图标表示。值得注意的是：参与者不一定是人，也可以是任何的事。\n**<font size=3 >参与者和用例之间的关系**：1关联关系，2泛化关系，3包含关系，4扩展关系下面使用亿图软件演示下用例，参与者以及二者之间的关系。\n下面这张图网上扣的，是图书馆的用例图(这里画的用例还不完全)：\n![图书馆系统](菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329193127889.jpg)<font size=2 >为什么要画用例图，而不是UML，状态机这些专业的语言用图，其实最重要的一点就是产品想做好就必须站在客户的角度思考问题，在产品需求分析阶段就要开始为上帝考虑，等到设计阶段再来思考用户体验就为时已晚，产品基本也就失败了。\n\n**<font size=4 >用例描述**：用例图仅仅是描述了系统具有的功能，但是并没有描述每一个用例的行为，也就是执行过程。\n我们不需要对每一个用例进行分析，而是需要在这些用例中，找出那些关键用例，然后对这些关键用例写出用例描述，因为关键用例才是系统架构的决定因素。\n\nQ：关键用例如何分析？。\nA: 抓住功能/接口/质量/硬件约束/方案约束/数据流这几个方面来思考。·\n\t功能：产品最关键的因素，以实现的功能来展开用例\n\t接口：硬件接口是实现功能的方式，软件接口决定层间接口的好坏\n\t质量：提高产品竞争里的核心\n\t硬件约束：决定底层驱动的复杂程度\n\t方案约束：高内聚，低耦合的前提\n\t数据流：拿捏代码逻辑的最好方法\n下面也是从网络上找的用例描述示例，可以看到并没有统一的格式，需要根据项目的性质进行增减。\n![用例描述](菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329195920218.jpg)\n\nQ:假设我们在不断的搜集和分析中，尽可能地列出了所有的需求(功能需求、质量属性、条件约束)，下一步需要做什么呢？需求这么多，该从哪一个需求入手呢？\n\nA:关键需求 = 关键功能 + 关键质量。它确定了架构的大方向。\n\n\n### 第1步——粗粒度分层\n### 第2步——中粒度分模块\n### 第3步——细粒度分ISR/周期仸务/事件驱动任务\n ## 技能二：分层，分模块，分子系统\n<font color=blue>Q:如何将需求阶段的用例图和用例描述，转换成代码\n<font color=blue>A:分层，分模块，分子系统\n\n这里举一个电梯的例子：\n![](菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329201443609.png)\n\n\n\n**<font size=4 >分层**：这里的分层是指软件代码的层次结构，并不是电梯的楼层哟，请看下图\n![分层](菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329200632579.png)底层库，驱动，HAL，服务层，功能层，用户层等，我们需要的是在第0步种对用例描述的功能，接口，硬件，约束等进行总结，提炼出我们需要做的驱动，服务和用户接口。\n这里安利一种思维是“洋葱皮”分层模式：上层调用下层，下层不能调上层。入口组装func模块，func组装下层模块。如下图所示：\n![](菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329202548677.png)\n在分层上的体现就是如下图所示：\n![](菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329202358795.png)\n**<font size=4 >分模块**：一句话按功能划分模块，电梯这个项目有几个功能就划分几个模块，以下对移动功能列出一个模块：\n![分模块](菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329201646615.png)项目的设计过程种，由着诸多的需求。而很多需求都可以进行归类，根据功能需求的方法进行模块的划分。可以让需求在归类上得到明确的划分，而且通过功能需求进行软件的模块划分使得功能分解，任务分配等方面都有较好的分解。不知道大家发现没其实分模块阶段就进行了ISR/周期仸务/事件驱动任务的设计。\n如果一个项目大家分析到这里是不是大概觉得自己知道写哪些代码了，接下来就是将模块连接起来，形成软件的骨架。\n\n**<font size=4 >分子系统**：\nQ:子系统如何分\nA:纵深封装\n什么叫纵深封装，意思就是形成跨层子系统，func层模块，封装drv模块，子系统接口公开，接口粒度大，所以松耦合\n![子系统](菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329203021908.png)在分层上的体现就是：\n![在这里插入图片描述](菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329203335481.png)子系统在分层上的体现就是：\n![子系统](菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329203626594.png)到这里设计完每个子系统之后，层层递进，层组成模块，模块细化层，子系统连接模块，模块递进成子系统。\n\n到这里基本软件的框架就能设计出来，具体的模块封装，任务并发，模块接口这些就看个人道行了。\n### 第4步——分析一个功能的协作链：定义task间通信方式/数据流关系\n### 第5步——分析并发情况下协作链：优化task的并发执行/数据流关系\n### 第6步——分析参与多功能的同一模块：优化模块的通用性/灵活性/可扩展\n以上3步是大佬总结的bug的3个方向，想要有一个稳定的系统，这3步是必须做的，其实我把他们统称为Bug，简而言之我们就要要有发现Bug的能力。\n ## 技能三：Bug工程师，要会找bu g\n这里提供几种找Bug的方法：\n1：SystemView分析工具：[rtthread的systemview分析工具](https://www.rt-thread.org/document/site/application-note/debug/systemview/an0009-systemview/)\n2：CmBacktrace：[ARM Cortex-M 系列 MCU 错误追踪库](http://packages.rt-thread.org/detail.html?package=CmBacktrace)\n3：Pc-lint:[静态代码检查工具](https://freertos.blog.csdn.net/article/details/5930634?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control&dist_request_id=1328740.41223.16170229474446557&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control)\n生命不止，BUG不止。发现好的bug工具再来补充。\n\n**后续步——5、 6循环，不断优化。但若发现架构大缺陷，回溯到1-2-3-4**\n\n经过这次的架构培训，我基本上把自己在平常工作中，对应用程序架构设计的这个思考过程描述了一遍。\n\n佛经里说了：凡是回归原点，不懂就不懂，努力学习。懂了也要相信人外有人，放下架子，谦虚，能力提升方可最大化。\n\n这篇文章介绍的设计流程，也是一个套路而已。这个套路在面对一个新领域、新项目时，就像一个脚手架一样，告诉我们这一步该做什么，下一步该做什么，应该使用什么样的工具。\n\n在僵化的运用这个套路之后，你可以继续改造、优化，然后丢掉这个套路，从而形成适合你自己的套路，从此走向思考致富的道路！\n\nGOOD LUCK\n\n\n\n\n\n \n\n","slug":"菜鸟应该如何开始设计一个项目的嵌入式软件架构","published":1,"updated":"2023-04-04T09:24:10.139Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk69d1d0000gjsrj2eem4h0i","content":"<p>@[toc]</p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>*<font size=\"2\">CSDN，GIT等各大论坛上很多文章都有讲，如何设计项目的嵌入式软件架构，But门槛实在太高了，需要做需求调研，需求分析，概要设计，详细设计，架构验证，开发-单元测试，集成测试等等，实不相瞒这些没有半年八载的项目经验根本做不出来的，刚好经过这周的嵌入式架构培训，提炼下最近在做项目的嵌入式软件架构的设计经验吧，不喜勿碰，谢谢。*</font></p>\n<h2 id=\"六步走战略\"><a href=\"#六步走战略\" class=\"headerlink\" title=\"六步走战略\"></a>六步走战略</h2><h3 id=\"第0步——嵌软需求：功能-接口-质量-硬件约束-方案约束-数据流\"><a href=\"#第0步——嵌软需求：功能-接口-质量-硬件约束-方案约束-数据流\" class=\"headerlink\" title=\"第0步——嵌软需求：功能/接口/质量/硬件约束/方案约束/数据流\"></a>第0步——嵌软需求：功能/接口/质量/硬件约束/方案约束/数据流</h3><h2 id=\"技能一：用例图和用例描述\"><a href=\"#技能一：用例图和用例描述\" class=\"headerlink\" title=\"技能一：用例图和用例描述\"></a>技能一：用例图和用例描述</h2><p><font color=\"blue\">Q:需求如何转换成软件框架<br><font color=\"blue\">A:画用例图，写用列描述 </font></font></p>\n<p><strong><font size=\"4\">用例图</font></strong>（Use Case Diagrame）：描述了人们希望如何使用一个系统，将相关用户、用户需要系统提供的服务以及系统需要用户提供的服务更清晰的显示出来，以便使系统用户更容易理解这些元素的用途，也便于开发人员最终实现这些元素。<br>用例图包括了三方面的内容：1用例，2参与者，3参与者和用例之间的关系。<br><strong><font size=\"3\">用例</font></strong>：是对系统的用户需求（主要是功能需求）的描述，用例表达了系统的功能和所提供的服务，描述了活动者与系统交互中的对话。<br><strong><font size=\"3\">参与者</font></strong>：参与者是系统外部的一个实体，它以某种方式参与了用例的执行过程，在UML中，通常用名字写在下面的人形图标表示。值得注意的是：参与者不一定是人，也可以是任何的事。<br><strong><font size=\"3\">参与者和用例之间的关系</font></strong>：1关联关系，2泛化关系，3包含关系，4扩展关系下面使用亿图软件演示下用例，参与者以及二者之间的关系。<br>下面这张图网上扣的，是图书馆的用例图(这里画的用例还不完全)：<br><img src=\"/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329193127889.jpg\" alt=\"图书馆系统\"><font size=\"2\">为什么要画用例图，而不是UML，状态机这些专业的语言用图，其实最重要的一点就是产品想做好就必须站在客户的角度思考问题，在产品需求分析阶段就要开始为上帝考虑，等到设计阶段再来思考用户体验就为时已晚，产品基本也就失败了。</font></p>\n<p><strong><font size=\"4\">用例描述</font></strong>：用例图仅仅是描述了系统具有的功能，但是并没有描述每一个用例的行为，也就是执行过程。<br>我们不需要对每一个用例进行分析，而是需要在这些用例中，找出那些关键用例，然后对这些关键用例写出用例描述，因为关键用例才是系统架构的决定因素。</p>\n<p>Q：关键用例如何分析？。<br>A: 抓住功能/接口/质量/硬件约束/方案约束/数据流这几个方面来思考。·<br>    功能：产品最关键的因素，以实现的功能来展开用例<br>    接口：硬件接口是实现功能的方式，软件接口决定层间接口的好坏<br>    质量：提高产品竞争里的核心<br>    硬件约束：决定底层驱动的复杂程度<br>    方案约束：高内聚，低耦合的前提<br>    数据流：拿捏代码逻辑的最好方法<br>下面也是从网络上找的用例描述示例，可以看到并没有统一的格式，需要根据项目的性质进行增减。<br><img src=\"/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329195920218.jpg\" alt=\"用例描述\"></p>\n<p>Q:假设我们在不断的搜集和分析中，尽可能地列出了所有的需求(功能需求、质量属性、条件约束)，下一步需要做什么呢？需求这么多，该从哪一个需求入手呢？</p>\n<p>A:关键需求 = 关键功能 + 关键质量。它确定了架构的大方向。</p>\n<h3 id=\"第1步——粗粒度分层\"><a href=\"#第1步——粗粒度分层\" class=\"headerlink\" title=\"第1步——粗粒度分层\"></a>第1步——粗粒度分层</h3><h3 id=\"第2步——中粒度分模块\"><a href=\"#第2步——中粒度分模块\" class=\"headerlink\" title=\"第2步——中粒度分模块\"></a>第2步——中粒度分模块</h3><h3 id=\"第3步——细粒度分ISR-周期仸务-事件驱动任务\"><a href=\"#第3步——细粒度分ISR-周期仸务-事件驱动任务\" class=\"headerlink\" title=\"第3步——细粒度分ISR/周期仸务/事件驱动任务\"></a>第3步——细粒度分ISR/周期仸务/事件驱动任务</h3><h2 id=\"技能二：分层，分模块，分子系统\"><a href=\"#技能二：分层，分模块，分子系统\" class=\"headerlink\" title=\"技能二：分层，分模块，分子系统\"></a>技能二：分层，分模块，分子系统</h2><p><font color=\"blue\">Q:如何将需求阶段的用例图和用例描述，转换成代码<br><font color=\"blue\">A:分层，分模块，分子系统</font></font></p>\n<p>这里举一个电梯的例子：<br><img src=\"/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329201443609.png\" alt></p>\n<p><strong><font size=\"4\">分层</font></strong>：这里的分层是指软件代码的层次结构，并不是电梯的楼层哟，请看下图<br><img src=\"/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329200632579.png\" alt=\"分层\">底层库，驱动，HAL，服务层，功能层，用户层等，我们需要的是在第0步种对用例描述的功能，接口，硬件，约束等进行总结，提炼出我们需要做的驱动，服务和用户接口。<br>这里安利一种思维是“洋葱皮”分层模式：上层调用下层，下层不能调上层。入口组装func模块，func组装下层模块。如下图所示：<br><img src=\"/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329202548677.png\" alt><br>在分层上的体现就是如下图所示：<br><img src=\"/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329202358795.png\" alt><br><strong><font size=\"4\">分模块</font></strong>：一句话按功能划分模块，电梯这个项目有几个功能就划分几个模块，以下对移动功能列出一个模块：<br><img src=\"/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329201646615.png\" alt=\"分模块\">项目的设计过程种，由着诸多的需求。而很多需求都可以进行归类，根据功能需求的方法进行模块的划分。可以让需求在归类上得到明确的划分，而且通过功能需求进行软件的模块划分使得功能分解，任务分配等方面都有较好的分解。不知道大家发现没其实分模块阶段就进行了ISR/周期仸务/事件驱动任务的设计。<br>如果一个项目大家分析到这里是不是大概觉得自己知道写哪些代码了，接下来就是将模块连接起来，形成软件的骨架。</p>\n<p><strong><font size=\"4\">分子系统</font></strong>：<br>Q:子系统如何分<br>A:纵深封装<br>什么叫纵深封装，意思就是形成跨层子系统，func层模块，封装drv模块，子系统接口公开，接口粒度大，所以松耦合<br><img src=\"/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329203021908.png\" alt=\"子系统\">在分层上的体现就是：<br><img src=\"/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329203335481.png\" alt=\"在这里插入图片描述\">子系统在分层上的体现就是：<br><img src=\"/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329203626594.png\" alt=\"子系统\">到这里设计完每个子系统之后，层层递进，层组成模块，模块细化层，子系统连接模块，模块递进成子系统。</p>\n<p>到这里基本软件的框架就能设计出来，具体的模块封装，任务并发，模块接口这些就看个人道行了。</p>\n<h3 id=\"第4步——分析一个功能的协作链：定义task间通信方式-数据流关系\"><a href=\"#第4步——分析一个功能的协作链：定义task间通信方式-数据流关系\" class=\"headerlink\" title=\"第4步——分析一个功能的协作链：定义task间通信方式/数据流关系\"></a>第4步——分析一个功能的协作链：定义task间通信方式/数据流关系</h3><h3 id=\"第5步——分析并发情况下协作链：优化task的并发执行-数据流关系\"><a href=\"#第5步——分析并发情况下协作链：优化task的并发执行-数据流关系\" class=\"headerlink\" title=\"第5步——分析并发情况下协作链：优化task的并发执行/数据流关系\"></a>第5步——分析并发情况下协作链：优化task的并发执行/数据流关系</h3><h3 id=\"第6步——分析参与多功能的同一模块：优化模块的通用性-灵活性-可扩展\"><a href=\"#第6步——分析参与多功能的同一模块：优化模块的通用性-灵活性-可扩展\" class=\"headerlink\" title=\"第6步——分析参与多功能的同一模块：优化模块的通用性/灵活性/可扩展\"></a>第6步——分析参与多功能的同一模块：优化模块的通用性/灵活性/可扩展</h3><p>以上3步是大佬总结的bug的3个方向，想要有一个稳定的系统，这3步是必须做的，其实我把他们统称为Bug，简而言之我们就要要有发现Bug的能力。</p>\n<h2 id=\"技能三：Bug工程师，要会找bu-g\"><a href=\"#技能三：Bug工程师，要会找bu-g\" class=\"headerlink\" title=\"技能三：Bug工程师，要会找bu g\"></a>技能三：Bug工程师，要会找bu g</h2><p>这里提供几种找Bug的方法：<br>1：SystemView分析工具：<a href=\"https://www.rt-thread.org/document/site/application-note/debug/systemview/an0009-systemview/\" target=\"_blank\" rel=\"noopener\">rtthread的systemview分析工具</a><br>2：CmBacktrace：<a href=\"http://packages.rt-thread.org/detail.html?package=CmBacktrace\" target=\"_blank\" rel=\"noopener\">ARM Cortex-M 系列 MCU 错误追踪库</a><br>3：Pc-lint:<a href=\"https://freertos.blog.csdn.net/article/details/5930634?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control&dist_request_id=1328740.41223.16170229474446557&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control\" target=\"_blank\" rel=\"noopener\">静态代码检查工具</a><br>生命不止，BUG不止。发现好的bug工具再来补充。</p>\n<p><strong>后续步——5、 6循环，不断优化。但若发现架构大缺陷，回溯到1-2-3-4</strong></p>\n<p>经过这次的架构培训，我基本上把自己在平常工作中，对应用程序架构设计的这个思考过程描述了一遍。</p>\n<p>佛经里说了：凡是回归原点，不懂就不懂，努力学习。懂了也要相信人外有人，放下架子，谦虚，能力提升方可最大化。</p>\n<p>这篇文章介绍的设计流程，也是一个套路而已。这个套路在面对一个新领域、新项目时，就像一个脚手架一样，告诉我们这一步该做什么，下一步该做什么，应该使用什么样的工具。</p>\n<p>在僵化的运用这个套路之后，你可以继续改造、优化，然后丢掉这个套路，从而形成适合你自己的套路，从此走向思考致富的道路！</p>\n<p>GOOD LUCK</p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<p>@[toc]</p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>*<font size=\"2\">CSDN，GIT等各大论坛上很多文章都有讲，如何设计项目的嵌入式软件架构，But门槛实在太高了，需要做需求调研，需求分析，概要设计，详细设计，架构验证，开发-单元测试，集成测试等等，实不相瞒这些没有半年八载的项目经验根本做不出来的，刚好经过这周的嵌入式架构培训，提炼下最近在做项目的嵌入式软件架构的设计经验吧，不喜勿碰，谢谢。*</font></p>\n<h2 id=\"六步走战略\"><a href=\"#六步走战略\" class=\"headerlink\" title=\"六步走战略\"></a>六步走战略</h2><h3 id=\"第0步——嵌软需求：功能-接口-质量-硬件约束-方案约束-数据流\"><a href=\"#第0步——嵌软需求：功能-接口-质量-硬件约束-方案约束-数据流\" class=\"headerlink\" title=\"第0步——嵌软需求：功能/接口/质量/硬件约束/方案约束/数据流\"></a>第0步——嵌软需求：功能/接口/质量/硬件约束/方案约束/数据流</h3><h2 id=\"技能一：用例图和用例描述\"><a href=\"#技能一：用例图和用例描述\" class=\"headerlink\" title=\"技能一：用例图和用例描述\"></a>技能一：用例图和用例描述</h2><p><font color=\"blue\">Q:需求如何转换成软件框架<br><font color=\"blue\">A:画用例图，写用列描述 </font></font></p>\n<p><strong><font size=\"4\">用例图</font></strong>（Use Case Diagrame）：描述了人们希望如何使用一个系统，将相关用户、用户需要系统提供的服务以及系统需要用户提供的服务更清晰的显示出来，以便使系统用户更容易理解这些元素的用途，也便于开发人员最终实现这些元素。<br>用例图包括了三方面的内容：1用例，2参与者，3参与者和用例之间的关系。<br><strong><font size=\"3\">用例</font></strong>：是对系统的用户需求（主要是功能需求）的描述，用例表达了系统的功能和所提供的服务，描述了活动者与系统交互中的对话。<br><strong><font size=\"3\">参与者</font></strong>：参与者是系统外部的一个实体，它以某种方式参与了用例的执行过程，在UML中，通常用名字写在下面的人形图标表示。值得注意的是：参与者不一定是人，也可以是任何的事。<br><strong><font size=\"3\">参与者和用例之间的关系</font></strong>：1关联关系，2泛化关系，3包含关系，4扩展关系下面使用亿图软件演示下用例，参与者以及二者之间的关系。<br>下面这张图网上扣的，是图书馆的用例图(这里画的用例还不完全)：<br><img src=\"/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329193127889.jpg\" alt=\"图书馆系统\"><font size=\"2\">为什么要画用例图，而不是UML，状态机这些专业的语言用图，其实最重要的一点就是产品想做好就必须站在客户的角度思考问题，在产品需求分析阶段就要开始为上帝考虑，等到设计阶段再来思考用户体验就为时已晚，产品基本也就失败了。</font></p>\n<p><strong><font size=\"4\">用例描述</font></strong>：用例图仅仅是描述了系统具有的功能，但是并没有描述每一个用例的行为，也就是执行过程。<br>我们不需要对每一个用例进行分析，而是需要在这些用例中，找出那些关键用例，然后对这些关键用例写出用例描述，因为关键用例才是系统架构的决定因素。</p>\n<p>Q：关键用例如何分析？。<br>A: 抓住功能/接口/质量/硬件约束/方案约束/数据流这几个方面来思考。·<br>    功能：产品最关键的因素，以实现的功能来展开用例<br>    接口：硬件接口是实现功能的方式，软件接口决定层间接口的好坏<br>    质量：提高产品竞争里的核心<br>    硬件约束：决定底层驱动的复杂程度<br>    方案约束：高内聚，低耦合的前提<br>    数据流：拿捏代码逻辑的最好方法<br>下面也是从网络上找的用例描述示例，可以看到并没有统一的格式，需要根据项目的性质进行增减。<br><img src=\"/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329195920218.jpg\" alt=\"用例描述\"></p>\n<p>Q:假设我们在不断的搜集和分析中，尽可能地列出了所有的需求(功能需求、质量属性、条件约束)，下一步需要做什么呢？需求这么多，该从哪一个需求入手呢？</p>\n<p>A:关键需求 = 关键功能 + 关键质量。它确定了架构的大方向。</p>\n<h3 id=\"第1步——粗粒度分层\"><a href=\"#第1步——粗粒度分层\" class=\"headerlink\" title=\"第1步——粗粒度分层\"></a>第1步——粗粒度分层</h3><h3 id=\"第2步——中粒度分模块\"><a href=\"#第2步——中粒度分模块\" class=\"headerlink\" title=\"第2步——中粒度分模块\"></a>第2步——中粒度分模块</h3><h3 id=\"第3步——细粒度分ISR-周期仸务-事件驱动任务\"><a href=\"#第3步——细粒度分ISR-周期仸务-事件驱动任务\" class=\"headerlink\" title=\"第3步——细粒度分ISR/周期仸务/事件驱动任务\"></a>第3步——细粒度分ISR/周期仸务/事件驱动任务</h3><h2 id=\"技能二：分层，分模块，分子系统\"><a href=\"#技能二：分层，分模块，分子系统\" class=\"headerlink\" title=\"技能二：分层，分模块，分子系统\"></a>技能二：分层，分模块，分子系统</h2><p><font color=\"blue\">Q:如何将需求阶段的用例图和用例描述，转换成代码<br><font color=\"blue\">A:分层，分模块，分子系统</font></font></p>\n<p>这里举一个电梯的例子：<br><img src=\"/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329201443609.png\" alt></p>\n<p><strong><font size=\"4\">分层</font></strong>：这里的分层是指软件代码的层次结构，并不是电梯的楼层哟，请看下图<br><img src=\"/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329200632579.png\" alt=\"分层\">底层库，驱动，HAL，服务层，功能层，用户层等，我们需要的是在第0步种对用例描述的功能，接口，硬件，约束等进行总结，提炼出我们需要做的驱动，服务和用户接口。<br>这里安利一种思维是“洋葱皮”分层模式：上层调用下层，下层不能调上层。入口组装func模块，func组装下层模块。如下图所示：<br><img src=\"/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329202548677.png\" alt><br>在分层上的体现就是如下图所示：<br><img src=\"/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329202358795.png\" alt><br><strong><font size=\"4\">分模块</font></strong>：一句话按功能划分模块，电梯这个项目有几个功能就划分几个模块，以下对移动功能列出一个模块：<br><img src=\"/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329201646615.png\" alt=\"分模块\">项目的设计过程种，由着诸多的需求。而很多需求都可以进行归类，根据功能需求的方法进行模块的划分。可以让需求在归类上得到明确的划分，而且通过功能需求进行软件的模块划分使得功能分解，任务分配等方面都有较好的分解。不知道大家发现没其实分模块阶段就进行了ISR/周期仸务/事件驱动任务的设计。<br>如果一个项目大家分析到这里是不是大概觉得自己知道写哪些代码了，接下来就是将模块连接起来，形成软件的骨架。</p>\n<p><strong><font size=\"4\">分子系统</font></strong>：<br>Q:子系统如何分<br>A:纵深封装<br>什么叫纵深封装，意思就是形成跨层子系统，func层模块，封装drv模块，子系统接口公开，接口粒度大，所以松耦合<br><img src=\"/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329203021908.png\" alt=\"子系统\">在分层上的体现就是：<br><img src=\"/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329203335481.png\" alt=\"在这里插入图片描述\">子系统在分层上的体现就是：<br><img src=\"/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329203626594.png\" alt=\"子系统\">到这里设计完每个子系统之后，层层递进，层组成模块，模块细化层，子系统连接模块，模块递进成子系统。</p>\n<p>到这里基本软件的框架就能设计出来，具体的模块封装，任务并发，模块接口这些就看个人道行了。</p>\n<h3 id=\"第4步——分析一个功能的协作链：定义task间通信方式-数据流关系\"><a href=\"#第4步——分析一个功能的协作链：定义task间通信方式-数据流关系\" class=\"headerlink\" title=\"第4步——分析一个功能的协作链：定义task间通信方式/数据流关系\"></a>第4步——分析一个功能的协作链：定义task间通信方式/数据流关系</h3><h3 id=\"第5步——分析并发情况下协作链：优化task的并发执行-数据流关系\"><a href=\"#第5步——分析并发情况下协作链：优化task的并发执行-数据流关系\" class=\"headerlink\" title=\"第5步——分析并发情况下协作链：优化task的并发执行/数据流关系\"></a>第5步——分析并发情况下协作链：优化task的并发执行/数据流关系</h3><h3 id=\"第6步——分析参与多功能的同一模块：优化模块的通用性-灵活性-可扩展\"><a href=\"#第6步——分析参与多功能的同一模块：优化模块的通用性-灵活性-可扩展\" class=\"headerlink\" title=\"第6步——分析参与多功能的同一模块：优化模块的通用性/灵活性/可扩展\"></a>第6步——分析参与多功能的同一模块：优化模块的通用性/灵活性/可扩展</h3><p>以上3步是大佬总结的bug的3个方向，想要有一个稳定的系统，这3步是必须做的，其实我把他们统称为Bug，简而言之我们就要要有发现Bug的能力。</p>\n<h2 id=\"技能三：Bug工程师，要会找bu-g\"><a href=\"#技能三：Bug工程师，要会找bu-g\" class=\"headerlink\" title=\"技能三：Bug工程师，要会找bu g\"></a>技能三：Bug工程师，要会找bu g</h2><p>这里提供几种找Bug的方法：<br>1：SystemView分析工具：<a href=\"https://www.rt-thread.org/document/site/application-note/debug/systemview/an0009-systemview/\" target=\"_blank\" rel=\"noopener\">rtthread的systemview分析工具</a><br>2：CmBacktrace：<a href=\"http://packages.rt-thread.org/detail.html?package=CmBacktrace\" target=\"_blank\" rel=\"noopener\">ARM Cortex-M 系列 MCU 错误追踪库</a><br>3：Pc-lint:<a href=\"https://freertos.blog.csdn.net/article/details/5930634?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control&dist_request_id=1328740.41223.16170229474446557&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control\" target=\"_blank\" rel=\"noopener\">静态代码检查工具</a><br>生命不止，BUG不止。发现好的bug工具再来补充。</p>\n<p><strong>后续步——5、 6循环，不断优化。但若发现架构大缺陷，回溯到1-2-3-4</strong></p>\n<p>经过这次的架构培训，我基本上把自己在平常工作中，对应用程序架构设计的这个思考过程描述了一遍。</p>\n<p>佛经里说了：凡是回归原点，不懂就不懂，努力学习。懂了也要相信人外有人，放下架子，谦虚，能力提升方可最大化。</p>\n<p>这篇文章介绍的设计流程，也是一个套路而已。这个套路在面对一个新领域、新项目时，就像一个脚手架一样，告诉我们这一步该做什么，下一步该做什么，应该使用什么样的工具。</p>\n<p>在僵化的运用这个套路之后，你可以继续改造、优化，然后丢掉这个套路，从而形成适合你自己的套路，从此走向思考致富的道路！</p>\n<p>GOOD LUCK</p>\n"},{"title":"超详细解析python爬取外网图片","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2022-01-01T11:46:39.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"废话不多说直接上货\n\n```python\nfrom bs4 import BeautifulSoup          #网页解析库\nimport requests                        #网页请求库\nimport json                            #json数据解析库\nimport random                          #随机数产生库\nimport hashlib                         #MD5加密算法的模块\nimport urllib                          #python自带的http请求库\n\nlist = []                              #存放图片的网站\n\nheaders ={\n    'accept':'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',\n    'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:73.0) Gecko/20100101 Firefox/73.0'\n}                                      #我用的是Firefox浏览器伪造请求头\ndef baidu_translate(text, fromLang='zh', toLang='en'):                    #中文翻译函数（不懂请看下面链接）\n    appid = 'xxxxxxxxxxxxxx'                                              #每个账号的appid\n    secretKey = 'xxxxxxxxxxxxx'                                           #每个账号的钥匙\n\n    myurl = 'http://api.fanyi.baidu.com/api/trans/vip/translate'          #百度翻译必须带上的头部\n    q = text                                                              #需要翻译的中文\n    salt = random.randint(32768, 65536)                                   #salt是产生的随机数\n\n    sign = appid + q + str(salt) + secretKey                              #拼接字符串1\n    m1 = hashlib.md5()                                                 \n    m1.update(sign.encode('utf-8'))                             \n    sign = m1.hexdigest()                                                 #mdk5加密生成的计算签名\n    myur1 = myurl  + '?q=' + urllib.parse.quote(\n        q) + '&from=' + fromLang + '&to=' + toLang + '&appid='+ appid + '&salt=' + str(salt) + '&sign=' + sign                                     #拼接字符串1+mdk5加密生成的计算签名生产的翻译网页\n    return myur1                                                          #函数返回翻译网页\n\nurl_path = 'https://unsplash.com/s/photos/'         #我爬取的是国外的unsplash网站的图片\nword= input('请输入你要下载的图片：')                                      #输入中文要下载的图片\nenglish_data = requests.get(baidu_translate(word))                       #请求百度翻译api的翻译                                          \njs_data = json.loads(english_data.text)                                  #下载翻译网页返回的json数据                          \ncontent = js_data['trans_result'][0]['dst']                              #提取其中的英文翻译\nurl = url_path + content + '/'                      #将英文翻译添加到图片网站上形成你要访问的图片主页\n\nwb_data = requests.get(url,headers=headers)                              #请求图片网站数据\nsoup = BeautifulSoup(wb_data.text,'lxml')                                #解析数据\nimgs = soup.select('a > div > img')                                      #定位到图片的网页地址\n\nfor img in imgs:                                                         #将所有的图片url都下载到list中\n    photo = img.get('src')                                               #提取src节点的数据\n    list.append(photo)                                                   #得到图片的url\n\npath = 'C:/Users/qq/Pictures/Camera Roll/'                               #我的保存路径\nfor item in list:                                                        #读取每个图片的url\n        data = requests.get(item,headers=headers)                        #请求url\n        fp = open(path+item.split('?')[0][-27:]+'.jpg','wb')             #图片的名字\n        fp.write(data.content)                                           #下载图片\n        fp.close()                                                       #下载完成关闭图片\n       \n\n\n```\n下面说下重点\n1.百度翻译的实现过程，请看下面的文章：[百度API的使用方法](https://blog.csdn.net/weixin_43495433/article/details/104608087)\n2.图片网站和图片的url：\n   图片网站是指查找图片的网站!![](超详细解析python爬取外网图片/20200302110709393.png)\n   这个是图片的url![这个是图片的url](超详细解析python爬取外网图片/20200302111109517.png)","source":"_posts/2022/01/超详细解析python爬取外网图片.md","raw":"---\ntitle: 超详细解析python爬取外网图片\npermalink: 超详细解析python爬取外网图片\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2022-01-01 19:46:39\npassword:\nsummary:\ntags:\n- python\ncategories:\n- python\nkeywords:\ndescription:\n---\n废话不多说直接上货\n\n```python\nfrom bs4 import BeautifulSoup          #网页解析库\nimport requests                        #网页请求库\nimport json                            #json数据解析库\nimport random                          #随机数产生库\nimport hashlib                         #MD5加密算法的模块\nimport urllib                          #python自带的http请求库\n\nlist = []                              #存放图片的网站\n\nheaders ={\n    'accept':'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',\n    'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:73.0) Gecko/20100101 Firefox/73.0'\n}                                      #我用的是Firefox浏览器伪造请求头\ndef baidu_translate(text, fromLang='zh', toLang='en'):                    #中文翻译函数（不懂请看下面链接）\n    appid = 'xxxxxxxxxxxxxx'                                              #每个账号的appid\n    secretKey = 'xxxxxxxxxxxxx'                                           #每个账号的钥匙\n\n    myurl = 'http://api.fanyi.baidu.com/api/trans/vip/translate'          #百度翻译必须带上的头部\n    q = text                                                              #需要翻译的中文\n    salt = random.randint(32768, 65536)                                   #salt是产生的随机数\n\n    sign = appid + q + str(salt) + secretKey                              #拼接字符串1\n    m1 = hashlib.md5()                                                 \n    m1.update(sign.encode('utf-8'))                             \n    sign = m1.hexdigest()                                                 #mdk5加密生成的计算签名\n    myur1 = myurl  + '?q=' + urllib.parse.quote(\n        q) + '&from=' + fromLang + '&to=' + toLang + '&appid='+ appid + '&salt=' + str(salt) + '&sign=' + sign                                     #拼接字符串1+mdk5加密生成的计算签名生产的翻译网页\n    return myur1                                                          #函数返回翻译网页\n\nurl_path = 'https://unsplash.com/s/photos/'         #我爬取的是国外的unsplash网站的图片\nword= input('请输入你要下载的图片：')                                      #输入中文要下载的图片\nenglish_data = requests.get(baidu_translate(word))                       #请求百度翻译api的翻译                                          \njs_data = json.loads(english_data.text)                                  #下载翻译网页返回的json数据                          \ncontent = js_data['trans_result'][0]['dst']                              #提取其中的英文翻译\nurl = url_path + content + '/'                      #将英文翻译添加到图片网站上形成你要访问的图片主页\n\nwb_data = requests.get(url,headers=headers)                              #请求图片网站数据\nsoup = BeautifulSoup(wb_data.text,'lxml')                                #解析数据\nimgs = soup.select('a > div > img')                                      #定位到图片的网页地址\n\nfor img in imgs:                                                         #将所有的图片url都下载到list中\n    photo = img.get('src')                                               #提取src节点的数据\n    list.append(photo)                                                   #得到图片的url\n\npath = 'C:/Users/qq/Pictures/Camera Roll/'                               #我的保存路径\nfor item in list:                                                        #读取每个图片的url\n        data = requests.get(item,headers=headers)                        #请求url\n        fp = open(path+item.split('?')[0][-27:]+'.jpg','wb')             #图片的名字\n        fp.write(data.content)                                           #下载图片\n        fp.close()                                                       #下载完成关闭图片\n       \n\n\n```\n下面说下重点\n1.百度翻译的实现过程，请看下面的文章：[百度API的使用方法](https://blog.csdn.net/weixin_43495433/article/details/104608087)\n2.图片网站和图片的url：\n   图片网站是指查找图片的网站!![](超详细解析python爬取外网图片/20200302110709393.png)\n   这个是图片的url![这个是图片的url](超详细解析python爬取外网图片/20200302111109517.png)","slug":"超详细解析python爬取外网图片","published":1,"updated":"2023-04-04T09:24:10.143Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk69d1d2000hjsrjijp5qtey","content":"<p>废话不多说直接上货</p>\n<pre class=\" language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> bs4 <span class=\"token keyword\">import</span> BeautifulSoup          <span class=\"token comment\" spellcheck=\"true\">#网页解析库</span>\n<span class=\"token keyword\">import</span> requests                        <span class=\"token comment\" spellcheck=\"true\">#网页请求库</span>\n<span class=\"token keyword\">import</span> json                            <span class=\"token comment\" spellcheck=\"true\">#json数据解析库</span>\n<span class=\"token keyword\">import</span> random                          <span class=\"token comment\" spellcheck=\"true\">#随机数产生库</span>\n<span class=\"token keyword\">import</span> hashlib                         <span class=\"token comment\" spellcheck=\"true\">#MD5加密算法的模块</span>\n<span class=\"token keyword\">import</span> urllib                          <span class=\"token comment\" spellcheck=\"true\">#python自带的http请求库</span>\n\nlist <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>                              <span class=\"token comment\" spellcheck=\"true\">#存放图片的网站</span>\n\nheaders <span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>\n    <span class=\"token string\">'accept'</span><span class=\"token punctuation\">:</span><span class=\"token string\">'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'User-Agent'</span><span class=\"token punctuation\">:</span><span class=\"token string\">'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:73.0) Gecko/20100101 Firefox/73.0'</span>\n<span class=\"token punctuation\">}</span>                                      <span class=\"token comment\" spellcheck=\"true\">#我用的是Firefox浏览器伪造请求头</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">baidu_translate</span><span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">,</span> fromLang<span class=\"token operator\">=</span><span class=\"token string\">'zh'</span><span class=\"token punctuation\">,</span> toLang<span class=\"token operator\">=</span><span class=\"token string\">'en'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>                    <span class=\"token comment\" spellcheck=\"true\">#中文翻译函数（不懂请看下面链接）</span>\n    appid <span class=\"token operator\">=</span> <span class=\"token string\">'xxxxxxxxxxxxxx'</span>                                              <span class=\"token comment\" spellcheck=\"true\">#每个账号的appid</span>\n    secretKey <span class=\"token operator\">=</span> <span class=\"token string\">'xxxxxxxxxxxxx'</span>                                           <span class=\"token comment\" spellcheck=\"true\">#每个账号的钥匙</span>\n\n    myurl <span class=\"token operator\">=</span> <span class=\"token string\">'http://api.fanyi.baidu.com/api/trans/vip/translate'</span>          <span class=\"token comment\" spellcheck=\"true\">#百度翻译必须带上的头部</span>\n    q <span class=\"token operator\">=</span> text                                                              <span class=\"token comment\" spellcheck=\"true\">#需要翻译的中文</span>\n    salt <span class=\"token operator\">=</span> random<span class=\"token punctuation\">.</span>randint<span class=\"token punctuation\">(</span><span class=\"token number\">32768</span><span class=\"token punctuation\">,</span> <span class=\"token number\">65536</span><span class=\"token punctuation\">)</span>                                   <span class=\"token comment\" spellcheck=\"true\">#salt是产生的随机数</span>\n\n    sign <span class=\"token operator\">=</span> appid <span class=\"token operator\">+</span> q <span class=\"token operator\">+</span> str<span class=\"token punctuation\">(</span>salt<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> secretKey                              <span class=\"token comment\" spellcheck=\"true\">#拼接字符串1</span>\n    m1 <span class=\"token operator\">=</span> hashlib<span class=\"token punctuation\">.</span>md5<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>                                                 \n    m1<span class=\"token punctuation\">.</span>update<span class=\"token punctuation\">(</span>sign<span class=\"token punctuation\">.</span>encode<span class=\"token punctuation\">(</span><span class=\"token string\">'utf-8'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>                             \n    sign <span class=\"token operator\">=</span> m1<span class=\"token punctuation\">.</span>hexdigest<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>                                                 <span class=\"token comment\" spellcheck=\"true\">#mdk5加密生成的计算签名</span>\n    myur1 <span class=\"token operator\">=</span> myurl  <span class=\"token operator\">+</span> <span class=\"token string\">'?q='</span> <span class=\"token operator\">+</span> urllib<span class=\"token punctuation\">.</span>parse<span class=\"token punctuation\">.</span>quote<span class=\"token punctuation\">(</span>\n        q<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">'&amp;from='</span> <span class=\"token operator\">+</span> fromLang <span class=\"token operator\">+</span> <span class=\"token string\">'&amp;to='</span> <span class=\"token operator\">+</span> toLang <span class=\"token operator\">+</span> <span class=\"token string\">'&amp;appid='</span><span class=\"token operator\">+</span> appid <span class=\"token operator\">+</span> <span class=\"token string\">'&amp;salt='</span> <span class=\"token operator\">+</span> str<span class=\"token punctuation\">(</span>salt<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">'&amp;sign='</span> <span class=\"token operator\">+</span> sign                                     <span class=\"token comment\" spellcheck=\"true\">#拼接字符串1+mdk5加密生成的计算签名生产的翻译网页</span>\n    <span class=\"token keyword\">return</span> myur1                                                          <span class=\"token comment\" spellcheck=\"true\">#函数返回翻译网页</span>\n\nurl_path <span class=\"token operator\">=</span> <span class=\"token string\">'https://unsplash.com/s/photos/'</span>         <span class=\"token comment\" spellcheck=\"true\">#我爬取的是国外的unsplash网站的图片</span>\nword<span class=\"token operator\">=</span> input<span class=\"token punctuation\">(</span><span class=\"token string\">'请输入你要下载的图片：'</span><span class=\"token punctuation\">)</span>                                      <span class=\"token comment\" spellcheck=\"true\">#输入中文要下载的图片</span>\nenglish_data <span class=\"token operator\">=</span> requests<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span>baidu_translate<span class=\"token punctuation\">(</span>word<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>                       <span class=\"token comment\" spellcheck=\"true\">#请求百度翻译api的翻译                                          </span>\njs_data <span class=\"token operator\">=</span> json<span class=\"token punctuation\">.</span>loads<span class=\"token punctuation\">(</span>english_data<span class=\"token punctuation\">.</span>text<span class=\"token punctuation\">)</span>                                  <span class=\"token comment\" spellcheck=\"true\">#下载翻译网页返回的json数据                          </span>\ncontent <span class=\"token operator\">=</span> js_data<span class=\"token punctuation\">[</span><span class=\"token string\">'trans_result'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token string\">'dst'</span><span class=\"token punctuation\">]</span>                              <span class=\"token comment\" spellcheck=\"true\">#提取其中的英文翻译</span>\nurl <span class=\"token operator\">=</span> url_path <span class=\"token operator\">+</span> content <span class=\"token operator\">+</span> <span class=\"token string\">'/'</span>                      <span class=\"token comment\" spellcheck=\"true\">#将英文翻译添加到图片网站上形成你要访问的图片主页</span>\n\nwb_data <span class=\"token operator\">=</span> requests<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">,</span>headers<span class=\"token operator\">=</span>headers<span class=\"token punctuation\">)</span>                              <span class=\"token comment\" spellcheck=\"true\">#请求图片网站数据</span>\nsoup <span class=\"token operator\">=</span> BeautifulSoup<span class=\"token punctuation\">(</span>wb_data<span class=\"token punctuation\">.</span>text<span class=\"token punctuation\">,</span><span class=\"token string\">'lxml'</span><span class=\"token punctuation\">)</span>                                <span class=\"token comment\" spellcheck=\"true\">#解析数据</span>\nimgs <span class=\"token operator\">=</span> soup<span class=\"token punctuation\">.</span>select<span class=\"token punctuation\">(</span><span class=\"token string\">'a > div > img'</span><span class=\"token punctuation\">)</span>                                      <span class=\"token comment\" spellcheck=\"true\">#定位到图片的网页地址</span>\n\n<span class=\"token keyword\">for</span> img <span class=\"token keyword\">in</span> imgs<span class=\"token punctuation\">:</span>                                                         <span class=\"token comment\" spellcheck=\"true\">#将所有的图片url都下载到list中</span>\n    photo <span class=\"token operator\">=</span> img<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span><span class=\"token string\">'src'</span><span class=\"token punctuation\">)</span>                                               <span class=\"token comment\" spellcheck=\"true\">#提取src节点的数据</span>\n    list<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>photo<span class=\"token punctuation\">)</span>                                                   <span class=\"token comment\" spellcheck=\"true\">#得到图片的url</span>\n\npath <span class=\"token operator\">=</span> <span class=\"token string\">'C:/Users/qq/Pictures/Camera Roll/'</span>                               <span class=\"token comment\" spellcheck=\"true\">#我的保存路径</span>\n<span class=\"token keyword\">for</span> item <span class=\"token keyword\">in</span> list<span class=\"token punctuation\">:</span>                                                        <span class=\"token comment\" spellcheck=\"true\">#读取每个图片的url</span>\n        data <span class=\"token operator\">=</span> requests<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">,</span>headers<span class=\"token operator\">=</span>headers<span class=\"token punctuation\">)</span>                        <span class=\"token comment\" spellcheck=\"true\">#请求url</span>\n        fp <span class=\"token operator\">=</span> open<span class=\"token punctuation\">(</span>path<span class=\"token operator\">+</span>item<span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token string\">'?'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">27</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span><span class=\"token operator\">+</span><span class=\"token string\">'.jpg'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'wb'</span><span class=\"token punctuation\">)</span>             <span class=\"token comment\" spellcheck=\"true\">#图片的名字</span>\n        fp<span class=\"token punctuation\">.</span>write<span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">.</span>content<span class=\"token punctuation\">)</span>                                           <span class=\"token comment\" spellcheck=\"true\">#下载图片</span>\n        fp<span class=\"token punctuation\">.</span>close<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>                                                       <span class=\"token comment\" spellcheck=\"true\">#下载完成关闭图片</span>\n\n\n</code></pre>\n<p>下面说下重点<br>1.百度翻译的实现过程，请看下面的文章：<a href=\"https://blog.csdn.net/weixin_43495433/article/details/104608087\" target=\"_blank\" rel=\"noopener\">百度API的使用方法</a><br>2.图片网站和图片的url：<br>   图片网站是指查找图片的网站!<img src=\"/2022/01/chao-xiang-xi-jie-xi-python-pa-qu-wai-wang-tu-pian/20200302110709393.png\" alt><br>   这个是图片的url<img src=\"/2022/01/chao-xiang-xi-jie-xi-python-pa-qu-wai-wang-tu-pian/20200302111109517.png\" alt=\"这个是图片的url\"></p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<p>废话不多说直接上货</p>\n<pre><code class=\"python\">from bs4 import BeautifulSoup          #网页解析库\nimport requests                        #网页请求库\nimport json                            #json数据解析库\nimport random                          #随机数产生库\nimport hashlib                         #MD5加密算法的模块\nimport urllib                          #python自带的http请求库\n\nlist = []                              #存放图片的网站\n\nheaders ={\n    &#39;accept&#39;:&#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&#39;,\n    &#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:73.0) Gecko/20100101 Firefox/73.0&#39;\n}                                      #我用的是Firefox浏览器伪造请求头\ndef baidu_translate(text, fromLang=&#39;zh&#39;, toLang=&#39;en&#39;):                    #中文翻译函数（不懂请看下面链接）\n    appid = &#39;xxxxxxxxxxxxxx&#39;                                              #每个账号的appid\n    secretKey = &#39;xxxxxxxxxxxxx&#39;                                           #每个账号的钥匙\n\n    myurl = &#39;http://api.fanyi.baidu.com/api/trans/vip/translate&#39;          #百度翻译必须带上的头部\n    q = text                                                              #需要翻译的中文\n    salt = random.randint(32768, 65536)                                   #salt是产生的随机数\n\n    sign = appid + q + str(salt) + secretKey                              #拼接字符串1\n    m1 = hashlib.md5()                                                 \n    m1.update(sign.encode(&#39;utf-8&#39;))                             \n    sign = m1.hexdigest()                                                 #mdk5加密生成的计算签名\n    myur1 = myurl  + &#39;?q=&#39; + urllib.parse.quote(\n        q) + &#39;&amp;from=&#39; + fromLang + &#39;&amp;to=&#39; + toLang + &#39;&amp;appid=&#39;+ appid + &#39;&amp;salt=&#39; + str(salt) + &#39;&amp;sign=&#39; + sign                                     #拼接字符串1+mdk5加密生成的计算签名生产的翻译网页\n    return myur1                                                          #函数返回翻译网页\n\nurl_path = &#39;https://unsplash.com/s/photos/&#39;         #我爬取的是国外的unsplash网站的图片\nword= input(&#39;请输入你要下载的图片：&#39;)                                      #输入中文要下载的图片\nenglish_data = requests.get(baidu_translate(word))                       #请求百度翻译api的翻译                                          \njs_data = json.loads(english_data.text)                                  #下载翻译网页返回的json数据                          \ncontent = js_data[&#39;trans_result&#39;][0][&#39;dst&#39;]                              #提取其中的英文翻译\nurl = url_path + content + &#39;/&#39;                      #将英文翻译添加到图片网站上形成你要访问的图片主页\n\nwb_data = requests.get(url,headers=headers)                              #请求图片网站数据\nsoup = BeautifulSoup(wb_data.text,&#39;lxml&#39;)                                #解析数据\nimgs = soup.select(&#39;a &gt; div &gt; img&#39;)                                      #定位到图片的网页地址\n\nfor img in imgs:                                                         #将所有的图片url都下载到list中\n    photo = img.get(&#39;src&#39;)                                               #提取src节点的数据\n    list.append(photo)                                                   #得到图片的url\n\npath = &#39;C:/Users/qq/Pictures/Camera Roll/&#39;                               #我的保存路径\nfor item in list:                                                        #读取每个图片的url\n        data = requests.get(item,headers=headers)                        #请求url\n        fp = open(path+item.split(&#39;?&#39;)[0][-27:]+&#39;.jpg&#39;,&#39;wb&#39;)             #图片的名字\n        fp.write(data.content)                                           #下载图片\n        fp.close()                                                       #下载完成关闭图片\n\n\n</code></pre>\n<p>下面说下重点<br>1.百度翻译的实现过程，请看下面的文章：<a href=\"https://blog.csdn.net/weixin_43495433/article/details/104608087\" target=\"_blank\" rel=\"noopener\">百度API的使用方法</a><br>2.图片网站和图片的url：<br>   图片网站是指查找图片的网站!<img src=\"/2022/01/chao-xiang-xi-jie-xi-python-pa-qu-wai-wang-tu-pian/20200302110709393.png\" alt><br>   这个是图片的url<img src=\"/2022/01/chao-xiang-xi-jie-xi-python-pa-qu-wai-wang-tu-pian/20200302111109517.png\" alt=\"这个是图片的url\"></p>\n"},{"title":"EMC-EMI","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-04-04T11:24:09.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"<blockquote>EMC=EMI+EMS</blockquote>\n<h1>1：理论概念</h1>\n<h2>1.1时域和频域</h2>\n<p>建议通过示波器的FFT变换去了解时域和频域的概念</p>\n<h2>1.2分贝</h2>\n<p>电磁兼容测试中常用单位：</p>\n<p>&nbsp; 　　功率：P<sub>db</sub>=10lg(p1/p2) P2与P1应采用相同的单位。应该明确dB为两个量的比值，是无量纲的。<br />&nbsp;　　 电压:&nbsp; 同上 电压分贝常用&mu;V为单位<br />&nbsp; 　　电流：同上 以&mu;A为单位的电流。</p>\n<p>　　&nbsp; 电场强度与磁场强度：H=E/Z <br />&nbsp; 　　功率密度：S=E X H&nbsp;&nbsp;&nbsp; 功率密度的基本单位为W/m2(电场强度V／m;磁场强度A/m),<br />功率密度的物理作用比较难理解 提供一个关系来理解：后面的db数值和一个叫自由空间波阻抗的概念有关</p>\n<pre>\n\t<code class=\"yaml\">\n在自由空间，功率密度S与电场强度E的关系化为分贝：\nSdB（W/m2）=EdB（V/m） &ndash; 25.8dB    \nSdB（mW/cm2）=EdB（&mu;V/m） &ndash; 155.8dB  \nSdB（&mu;W/cm2）=EdB（&mu;V/m） &ndash; 125.8dB\n    </code>\n</pre>\n<h2>&nbsp;1.3电场和磁场</h2>\n<p>高中概念E/H场正交同时传播 建议了解下<strong>天线模型</strong></p>\n<h2>&nbsp;1.4共模和差模</h2>\n<p>电压和电流的变化通过通过导线传输时有两中形态，即&ldquo;差模&rdquo;和&ldquo;共模&rdquo; 。 这里我们把这两根线比喻成两个小人，一个MM，一个GG。来张图，形象点</p>\n<p><img src=\"EMC-EMI/2023-04-04_19-28-04.png\" alt=\"\" /></p>\n<p>这里是两个人MM和GG，他们俩都会飞，他们手牵手飞到离地面10米的位置，那他们对地的高度即为共模信号，当他们俩一个想飞高点一个想飞低点时，这时候他们牵着飞手就会感受到拉力，这就是差模信号。也就是说这两个人是对差模信号有响应的，对共模信号没有响应。理论上讲这两个人只对差模有响应而对共模没有响应。但你让这俩人往地底下飞试试，那就苦命鸳鸯，撞死了。地下不行就去遨游太空啊，行，还是苦命鸳鸯，没空气憋死了。所以共模信号也有一定的共模范围的。差模信号也有一定差模范围。</p>\n<p>借助上面的比喻来系统理解下几个基础的概念：</p>\n<pre>\n\t<code class=\"yaml\">\n借助上面的比喻来系统理解下几个基础的概念：\n共模电压：在每一导体和所规定的参照点之间（往往是大地或机架）出现的相量电压平均值。或者说同时加在电压表两测量端和规定公共端之间的那部分输出电压。\n\n差模电压：一组规定的带电导体中任意两根之间的电压。使差模电压又称对称电压。\n\n共模干扰：干扰电压在信号线及其回线（一般称为信号地线）上的幅度相同，这里的电压以附近任何一个物体（大地、金属机箱、参考地线板等）为参考电位，干扰电流回路则是在导线与参考物体构成的回路中流动。\n简明说就是信号线到地的回路干扰。\n\n差模干扰：干扰电压存在于信号线及其回线（一般称为信号地线）之间，干扰电流回路则是在导线与参考物体构成的回路中流动。\n简明说就是信号线到信号线的回路干扰。\n    </code>\n</pre>\n<h1>2：简介</h1>\n<h2>2.1：电磁干扰形成的三要素</h2>\n<p>形成电磁干扰必然具备三个基本要素:<br />①电磁骚扰源，<br />②耦合途径或传播通道，<br />③敏感设备。<br />电磁兼容设计即是从这三个基本要素出发。<br /><img src=\"EMC-EMI/2023-04-04_19-30-08.png\" alt=\"\" /></p>\n<p>所以我们可以从3个路径来解决emc问题：1干掉干扰源 2解决传播途径问题 3优化敏感设备</p>\n<h2>2.2：电磁骚扰的传播途径</h2>\n<p>电磁骚扰的传播途径包括传导耦合（传导耦合包括互传导耦合和导线间的感性与容性耦合）和辐射耦合<br />（辐射耦合包括近场耦合和远场耦合）<br /><img src=\"EMC-EMI/2023-04-04_19-31-27.png\" alt=\"\" /></p>\n<h1>3：EMC测试类型</h1>\n<blockquote>\n<p>由于前几天做的是辐射测试这里只对EMI的辐射发射测试做分析介绍</p>\n\n</blockquote>\n<p data-pid=\"hw0JtPdM\">EMI测试项目包括：</p>\n<p data-pid=\"ajAvvm_K\">1、辐射发射测试</p>\n<p data-pid=\"aMKdQ727\">2、传导发射测试</p>\n<p data-pid=\"V4hfmcc8\">3、骚扰功率测试</p>\n<p data-pid=\"HlkauZDq\">4、电流谐波测试</p>\n<p data-pid=\"iKa3kjf2\">5、电源谐波测量</p>\n<p data-pid=\"qa38dtwO\">6、闪烁测试</p>\n<p data-pid=\"ufgEgLKt\">EMS测试项目包括：</p>\n<p data-pid=\"yJxWLW6l\">1、静电放电抗扰度</p>\n<p data-pid=\"cY_CdNFF\">2、射频电磁场抗扰度</p>\n<p data-pid=\"w_TvMw5R\">3、电快速瞬变脉冲群抗扰度</p>\n<p data-pid=\"VAiXwT4K\">4、冲击（包括雷击和浪涌）抗扰度</p>\n<p data-pid=\"4njCrycj\">5、射频场感应传导抗扰度</p>\n<p data-pid=\"_pVOSVWw\">6、工频磁场抗扰度试验</p>\n<p data-pid=\"Ejw7z-1t\">7、电压跌落短时中断和电压渐降抗扰度</p>\n<p data-pid=\"Ejw7z-1t\">具体测试方法请看《EMC设计与测试案列分析》</p>\n<h1>4：辐射发射测试</h1>\n<h2>4.1辐射发射测试的目的</h2>\n<p>　　因为EMC设计及EMC问题的分析是建立在EMC测试的基础上的，所以有必要对EMC测试做简单的阐述。测试电子，电气和机电设备及其部件的辐射发射，包括来自所有组件、电缆及连接线上的辐射发射。它用来鉴定其辐射是否符合标准的要求，以致在正常使用过程中影响同一环境中的其他设备。</p>\n<h2>4.2 常用的辐射发射测试设备</h2>\n<p>根据常用传导骚扰测试标准CISPR16及EN55022的要求，辐射发射测试主要需要以下设备：</p>\n<p>（1） EMI自动测试控制系统（电脑及其界面单元）；(2) EMI测试接收机;</p>\n<p>（3）各式天线（主动、被动棒状天线、大小形状环路天线、功率双锥天线、对数螺旋天线、喇叭天线）及天线控制单元等；</p>\n<p>&nbsp; (4)半电波暗室或开阔场。</p>\n<p>EMI测试接收机是EMC测试中最常用的基本测试仪器，基于测试接收机的频率响应特性要求，按CISPR16标准规定，测试接收机应有四种基本检波方式，即准峰值检波、均方根值检波、峰值检波及平均值检波。然而，大多数电磁干扰都是脉冲干扰，它们对音频影响的客观效果随着重复频率的增高而增大，具有特定时间常数的准峰值检波器的输出特性，可以近似反映这种影响。</p>\n<h2>4.3 辐射发射的测试方法</h2>\n<p>下图是符合CISPR16及EN55022标准要求的辐射发射测试布置图。辐射发射测试时，被测设备（EUT）置于半电波暗室内部，并在转台上旋转，以找到最大的辐射点。辐射信号由接收天线接收后，通过电缆传到电波暗室外的接收机。</p>\n<p><img src=\"EMC-EMI/2023-04-04_19-32-29.png\" alt=\"\" /></p>\n<h1>5：整改</h1>\n<p><em><strong>常见的电磁兼容整改措施：</strong></em><br />&nbsp;　　对常见的电磁兼容问题，我们通过综合采用以下几个方面的整改措施，一般可以解决大部分的问题：<br />屏蔽问题：<br />&nbsp;　　可以在屏蔽体的装配面处涂导电胶，或者在装配面处加导电衬垫，甚至采用导电金属胶带进行补救。<br />&nbsp;　　导电衬垫可以是编织的金属丝线、硬度较低易于塑型的软金属(铜、铅等)、包装金属层的橡胶、导电橡胶或者是梳状簧片接触指状物等。<br />布局布线问题：<br />&nbsp;　　在不影响性能的前提下，适当调整设备电缆走向和排列，做到不同类型的电缆相互隔离。<br />电缆问题：<br />&nbsp;　　改变普通的小信号或高频信号电缆为带屏蔽的电缆，改变普通的大电流信号或数据传输信号电缆为对称绞线电缆。</p>\n<p>接地问题：<br />　　加强接地的机械性能，降低接地电阻。同时对于设备整体要有单独的低阻抗接地。<br />接口问题：<br />&nbsp;　　在设备电源输入线上加装或串联电源滤波器。<br />关键部位的处理：<br />&nbsp;　　在可能的情况下，对重要器件进行屏蔽、隔离处理，如加装接地良好的金属隔离板或小的屏蔽罩等。<br />电路和电源问题：<br />&nbsp;　　在各器件电源输入端并联小电容，以旁路电源带来的高频干扰。</p>\n<p>现在就对我们遇到的问题做分析：电磁骚扰发射：分为传导发射（连续发射和断续发射）和辐射发射（骚扰场强和骚扰功率）</p>\n<p><em><strong>针对电磁骚扰发射测试常见问题对策及整改措施</strong></em></p>\n<p>1：产品内主要电磁骚扰源分析（电源/电机/电路板/高频器件？）</p>\n<p>2：骚扰源定位（这里我们出现了一个错误后面介绍）</p>\n<p>3：产品连续传导发射超标问题及对策</p>\n<p>4：产品断续传导发射超标问题及对策</p>\n<p>5：产品辐射骚扰超标问题及对策</p>\n<p>6：骚扰功率干扰的产生和对策</p>\n<h2>5.1：主要电磁骚扰源</h2>\n<p>a:设备开关电源的开关回路：骚扰源主频几十kHz到百余kHz，高次谐波可延伸到数十MHz。<br />b:设备直流电源的整流回路：工频线性电源工频整流噪声频率上限可延伸到数百kHz；开关电源高频整流噪声频率上限可延伸到数十MHz。<br />&nbsp;c:电动设备直流电机的电刷噪声：噪声频率上限可延伸到数百MHz。<br />&nbsp;d:电动设备交流电机的运行噪声：高次谐波可延伸到数十MHz。<br />&nbsp;e:变频调速电路的骚扰发射：开关调速回路骚扰源频率从几十kHz到几十MHz。<br />&nbsp;f:设备运行状态切换的开关噪声：由机械或电子开关动作产生的噪声频率上限可延伸到数百MHz。<br />&nbsp;g:智能控制设备的晶振及数字电路电磁骚扰：骚扰源主频几十kHz到几十MHz，高次谐波可延伸到数百MHz。<br />&nbsp;等等.................</p>\n<h2>5.2：骚扰源定位</h2>\n<p><strong>根据测量曲线定位</strong>：依据：超标骚扰频率范围、超标骚扰频域分布、窄带还是宽带骚扰等来判断<br /><br /><img src=\"EMC-EMI/2023-04-04_19-32-59.png\" alt=\"\" /></p>\n<p><img src=\"EMC-EMI/2023-04-04_19-33-05.png\" alt=\"\" /></p>\n<p><strong>根据被测设备工作方式和内部结构定位</strong>：</p>\n<p>a:有没有使用标准不建议使用的半波整流和对称/非对称电源调整电路?<br />b:内部结构中电路板布局是否合理?<br />c:内部电缆走线是否合理?</p>\n<p>d:内部滤波器（滤波电路）安装是否合理?<br />e:内部电路接地和搭接方式是否合理?<br />f:机箱屏蔽是否满足对应产品的需求?</p>\n<p><br /><strong>根据功能模块工作情况进行故障定位</strong><br />a:若设备的各个模块可以暂停和恢复工作，可以通过逐个暂停这些模块的工作来判断骚扰来源。<br />b:若模块不可以独立暂停和恢复工作，可以通过与该设备其它功能模块一起组合进行暂停和恢复工作，从而判断骚扰的大概来源。<br />c:若模块不可以独立暂停和恢复工作，也可以通过用待判断模块与其它合格设备的相关功能模块组合并测量的方式，从而判断骚扰的大概来源。<br />d:对怀疑骚扰超标的模块，可以用与合格模块置换的方式来进行骚扰判定。<br />但是需要注意的是不能测试完一个模块发现没有起到作用又将这个模块恢复到初始状态 这个时候应该保持更改不变 继续下一个模块的排查，我们在最初的排查过程中就犯了这个错误，导致浪费了测试时间。<br />下面去个例子说明：</p>\n<p>　　假设一个系统在测试时出现了辐射发射超标，使系统不能满足EMC标准中对辐射发射的限值。经过初步分析，原因可能有4个，它们分别是：</p>\n<p>（1）主机与键盘之间的互连电缆（电缆1）上的共模电流产生的辐射；</p>\n<p>（2）主机与打印机之间的互连电缆（电缆2）上的共模电流产生的辐射；</p>\n<p>（3）机箱面板与机箱基体之间的缝隙（开口1）产生的泄漏；</p>\n<p>（4）某显示窗口（开口2）产生的泄漏。</p>\n<p>在诊断时，首先在电缆1上套一个铁氧体磁环，以减小共模辐射，结果发现频谱仪屏幕上显示的信号并没有明显减小。于是认为电缆1不是一个主要的泄漏源，将铁氧体磁环取下，套在电缆2上，结果发现频谱仪屏幕上显示的信号还没有明显减小。结果得出结论，电缆不是泄漏源。</p>\n<p>再对机箱上的泄漏进行检查。用屏蔽胶带将开口1堵上，发现频谱仪屏幕上显示的信号没有明显减小。认为开口1不是主要泄漏源，将屏蔽胶带取下，堵到开口2上。结果频谱仪上的显示信号还没有减小。之所以会发生这个问题，是因为测试人员忽视了频谱分析仪上显示的信号幅度是以dB为单位显示的。下面看一下为什么会有这种现象。</p>\n<p>假设这4个泄漏源所占的成分各占1／4，并且在每个辐射源上采取的措施能够将这个辐射源完全抑制掉，则采取以上4个措施中的一个时，频谱仪上显示信号降低的幅度&Delta;A为</p>\n<p>&Delta;A=20lg(4/3)=2.5 dB</p>\n<p>幅度减小这么少，显然是微不足道的。但这却已经将泄漏减少了25％。</p>\n<p>正确的方法是，在对一个可能的泄漏源采取了抑制措施后，即使没有明显的改善，也不要将这个措施去掉，继续对可能的泄漏源采取措施。当采取到某个措施时，如果干扰幅度降低很多，并不一定说明这个泄漏源是主要的，而仅说明这个干扰源是最后一个。按照这个步骤对4个泄漏源逐个处理的结果如图</p>\n\n<img src=\"EMC-EMI/2023-04-04_19-33-48.png\" alt=\"\" />\n<p>在前面的叙述中，假定对某个泄漏源采取措施后，这个泄漏源被100％消除掉，如果这样，当最后一个泄漏源去掉后，电磁干扰的减小应为无限大。实际这是不可能的。在采取任何一个措施时，都不可能将干扰源100％消除。泄漏源去掉的程度可以是99％，或99.9％，甚至99.99％以上，而绝不可能是100％，所以当最后一个泄漏源去掉后，尽管改善很大，但仍是有限值。</p>\n<h2>5.3：连续传导发射超标问题及对策</h2>\n<p><strong>连续传导骚扰的主要来源：</strong></p>\n<p>a:开关电源的开关频率及谐波骚扰<br />b:电源整流回路的整流噪声<br />c:交流电机的运行噪声</p>\n<p>d:直流电机的电刷噪声</p>\n<p>e:智能控制设备的晶振</p>\n<p>f:数字电路电磁骚扰<br /><strong>导致射频传导发射超标的原因如图所示:</strong><br /><img src=\"EMC-EMI/2023-04-04_19-34-25.png\" alt=\"\" /></p>\n<p>（1）开关电源或DC/DC变换器工作在脉冲状态，它们本身会产生很强的干扰，这种干扰既有共模分量，也有差模分量。对于一般开关电源和变换器，在1MHz以下以差模干扰为主，在1MHz以上以共模干扰为主。<br />（2）数字电路的工作电流是瞬变的，虽然在每个电路芯片的旁边和线路板上都安装了解耦电容，但还是会有一部分瞬变电流反映在电源中，沿着电源线传导发射。<br />（3）机箱内的线路板、电缆都是辐射源，这些辐射能量会感应进电源线和电源电路本身，形成传导发射。需要注意的是，当机箱内各种频率的信号耦合进电源电路时，由于电源内有许多二极管、三极管电路，会使这些不同频率的信号相互发生混频、调制，甚至对干扰进行放大，从而导致严重的干扰。<br /><strong>解决方法：</strong></p>\n<p>在电源线入口处安装电源线滤波器是保证通过射频传导发射试验的唯一方法（滤波器的安装位置也很重要）。<br />如果仅做150kHz~30MHz范围内的传导发射试验，一般的电源线滤波器就可以满足要求，大部分电源线滤波器在100kHz以上都已有较大的插入损耗。由于30MHz以上的高频性能不良会导致辐射发射的问题，所以应加以注意。如果需要做30~300MHz频率范围内的骚扰功率发射试验或30~1GHz频率范围内的辐射骚扰，选择滤波器时必须注意滤波器的高频特性。</p>\n<p>对电源线的处理：<br />（1）检查电源线附近有无信号电缆存在，有无可能是因为信号电缆与电源线之间的耦合使电源线的传导骚扰发射超标（这种情况多见于超标频率的频段较高的情况下）。如有，或拉大两者间的距离，或采取屏蔽措施。<br />（2）加装电源线滤波器（如果已经有滤波器。则换用高性能的滤波器），要特别注意安装位置（尽可能放在机箱中电源线入口端）和安装情况，要保证滤波器外壳与机箱搭接良好、接地良好。<br />（3）虽经采取措施，设备传导骚扰发射仍未达标。此时可考虑在设备内部线路连接接地端子的地方串入一个电感。由于这部分连接属单点接地，平时无电流流过，因此这个电感可以做得较大，而无需担心有铁芯的饱和问题。<br />采取这一措施的理由是设备传导骚扰发射测试实际上是对地电压测试（电源线对大地的骚扰电压测试），电源线上有工作电流流过，故滤波器的滤波电感值受制于工作电流，不能做得很大，滤波器的插入损耗也就有限，特别是低频端损耗更加有限。新方案里的附加电感正好可以弥补这一缺憾，从而取得更好的传导骚扰抑制能力。<br />对信号线的处理：<br />（1）注意信号线周围有无其他辐射能量（附近的布线及印刷板的布局）被引到信号线上。如有，或拉大两者的距离，或采取屏蔽措施，或考虑改变设备内部布局和印刷板的布局。<br />（2）在信号线上套铁氧体磁环（或铁氧体磁夹）。<br />（3）对信号线进行共模滤波，必要时采用滤波连接器（或滤波阵列板）。注意滤波器的参数，传导骚扰发射超标的频率比辐射骚扰发射超标的频率应低些，因此取用的元件参数应当偏大一些</p>\n<h2>5.4：断续传导发射超标问题及对策</h2>\n<p><strong>断续传导骚扰的主要来源：</strong></p>\n<p>a:恒温控制器具，程序自动的机器和其他电气控制或操作的器具的开关操作会产生断续骚扰。此类操作一般通过继电器和程控电子/机械开关等实现。此类骚扰一般由继电器、开关的触点抖动及非纯阻负载通断所产生的电涌冲击形成。<br /><strong>解决方法：</strong><br />从内部电路和结构上考虑，减少其断续骚扰，使其满足测量要求。<br />从电源电路和电源结构入手，在电源中采取适当的措施，对内部电路产生的断续骚扰加以抑制，使其满足测量标准的要求。<br />a:在开关触点或开关模块两端并联高频电容或RC、DRC吸波网络，吸收开关抖动脉冲及非阻性负载的浪涌脉冲。 同时应留意这些元器件的耐压和功率承受能力应满足设备正常工作的要求。<br />b:对被供电设备内通过程控开关控制的非阻性部件的供电回路上增加限流电路或软启动装置，抑制其启动浪涌冲击。<br />c:对被供电设备内通过开关量控制的感性部件应增加反向浪涌吸收元件，以吸收部件断电时产生的反向感应高压浪涌冲击。<br />d:在被供电设备的电源输入端增加高频吸收回路，抑制其高频骚扰向电源反向注入。</p>\n<h2>5.5：辐射骚扰超标问题及对策</h2>\n<p><strong>辐射骚扰的主要骚扰来源:</strong><br />a:开关电源的开关频率及谐波骚扰<br />b:交流电机的运行噪声、直流电机的电刷噪声<br />c:电磁感应设备的电磁骚扰<br />d:智能控制设备的晶振及数字电路电磁骚扰等</p>\n<p>导致辐射发射试验失败的原因有两种可能最大：</p>\n<p>　　一种是设备外壳的屏蔽性能不完善；<br />　　另一种是射频骚扰经由电源线和其他线缆的逸出。<br /><br /><strong>解决方法：</strong><br /><img src=\"EMC-EMI/2023-04-04_19-35-03.png\" alt=\"\" /></p>\n<p>当我们通过骚扰定位方式找到辐射骚扰超标点的骚扰源后，即可采用相对应的骚扰源抑制措施。<br />一般来说：<br />首先抑制骚扰源，这可以通过优化电路设计、电路结构和排版，加强滤波和正确的接地来达到。<br />其次是要切断耦合途径，这可以通过正确的机壳屏蔽和传输线滤波达到。<br /><strong>首先说下机箱问题：</strong></p>\n<p>一、金属机箱屏蔽性能不完善（非金属机箱还没碰到不做讨论）<br />对于金属机箱屏蔽性能不完善引起的辐射骚扰发射超标，应采取以下措施：<br />1）机箱的缝隙过大，或机箱配合上存在问题<br />　处理意见：<br />（1）清除结合面上的油漆、氧化层及表面玷污；<br />（2）增加结合面上的紧固件数目及接触表面的平整度；<br />（3）采取永久性的接缝（要连续焊接）；<br />（4）采用导电衬垫来改善接触表面的接触性能。<br />2）其他功能性开孔过大<br />处理意见：<br />（1）通风口采用防尘板，必要时采用波导通风板，但后者成本昂贵；<br />（2）显示窗口采用带有屏蔽作用的透明材料；或采用隔舱，并对信号线采取滤波措施；<br />（3）对键盘等采用隔舱，并对信号线采取滤波措施。<br />3）机箱内部布线不当，电磁骚扰透过缝隙逸出<br />处理意见：<br />&nbsp; 将印刷板及设备内部布线等可能产生辐射骚扰的布局，远离缝隙或功能性开孔的部位，<br />&nbsp; 或采取增加屏蔽的补救措施或重新布局。<br /><strong>其次说下线缆问题：</strong><br />1）对电源线的处理<br />（1）加装电源线滤波器（如果己经有滤波器，则换用高性能的滤波器），要特别注意安装位置（尽可能放在机箱中电源线入口端）和安装情况，要保证滤波器外壳与机箱搭接良好、接地良好；<br />（2）如果不合格的频率比较高，可考虑在电源线入口的部分套装铁氧体磁环。<br />2）对信号线的处理<br />（1）在信号线上套铁氧体磁环（或铁氧体磁夹）；<br />（2）对信号线滤波（共模滤波），必要时将连接器改用滤波阵列板或滤波连接器；<br />（3）换用屏蔽电缆，屏蔽电缆的屏蔽层与机箱尽量采用360&deg;搭接方式，必要时在屏蔽线上再套铁氧体磁环</p>\n<h2>5.6：骚扰功率干扰的产生和对策</h2>\n<p><strong>骚扰功率的主要来源：</strong></p>\n<p>a:电源线滤波装置的高频插入损耗不足</p>\n<p><strong>解决方法：</strong></p>\n<p>（1）滤波器电路没有屏蔽，这种情况经常发生在将滤波电路安装在线路板上的场合，高频干扰直接耦合进滤波电路，造成滤波器失效；<br />（2）滤波器本身高频性能不良，在100MHz以上插入损耗很小；<br />（3）使用非屏蔽机箱，导致滤波器的金属外壳无处端接；<strong><br /></strong>（4）使用非屏蔽机箱，干扰直接耦合到电源线和信号线上，滤波器实际上没有起作用；<br />（5）在屏蔽机箱中，滤波器离电源进口过远、造成干扰直接耦合到电源线和信号线上；<br />（6）在屏蔽机箱中，滤波器外壳与金属机箱之间连接阻抗过大（没有直接搭接，而是通过长导线连接）；<br />（7）滤波器的输入线与输出线靠得很近，发生耦合，导致滤波器的高频插人损耗不足。<strong><br /><br /></strong></p>\n<p><strong>参考书籍:&lt;EMC（电磁兼容）设计与测试案例分析 郑军奇编著 电子工业出版社&gt;</strong></p>\n<p><strong>看书的时候整理了一下导图无私分享下：</strong></p>\n<div class=\"cnblogs_Highlighter\">\n<pre class=\"brush:csharp;gutter:true;\">git@gitee.com:qian-qiang/book-map.git\n</pre>\n</div>\n<p>&nbsp;</p>\n","source":"_posts/2023/04/EMC-EMI.md","raw":"---\ntitle: EMC-EMI\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-04-04 19:24:09\npassword:\nsummary:\ntags:\n- EMC-EMI\ncategories:\n- 硬件\nkeywords:\ndescription:\n---\n<blockquote>EMC=EMI+EMS</blockquote>\n<h1>1：理论概念</h1>\n<h2>1.1时域和频域</h2>\n<p>建议通过示波器的FFT变换去了解时域和频域的概念</p>\n<h2>1.2分贝</h2>\n<p>电磁兼容测试中常用单位：</p>\n<p>&nbsp; 　　功率：P<sub>db</sub>=10lg(p1/p2) P2与P1应采用相同的单位。应该明确dB为两个量的比值，是无量纲的。<br />&nbsp;　　 电压:&nbsp; 同上 电压分贝常用&mu;V为单位<br />&nbsp; 　　电流：同上 以&mu;A为单位的电流。</p>\n<p>　　&nbsp; 电场强度与磁场强度：H=E/Z <br />&nbsp; 　　功率密度：S=E X H&nbsp;&nbsp;&nbsp; 功率密度的基本单位为W/m2(电场强度V／m;磁场强度A/m),<br />功率密度的物理作用比较难理解 提供一个关系来理解：后面的db数值和一个叫自由空间波阻抗的概念有关</p>\n<pre>\n\t<code class=\"yaml\">\n在自由空间，功率密度S与电场强度E的关系化为分贝：\nSdB（W/m2）=EdB（V/m） &ndash; 25.8dB    \nSdB（mW/cm2）=EdB（&mu;V/m） &ndash; 155.8dB  \nSdB（&mu;W/cm2）=EdB（&mu;V/m） &ndash; 125.8dB\n    </code>\n</pre>\n<h2>&nbsp;1.3电场和磁场</h2>\n<p>高中概念E/H场正交同时传播 建议了解下<strong>天线模型</strong></p>\n<h2>&nbsp;1.4共模和差模</h2>\n<p>电压和电流的变化通过通过导线传输时有两中形态，即&ldquo;差模&rdquo;和&ldquo;共模&rdquo; 。 这里我们把这两根线比喻成两个小人，一个MM，一个GG。来张图，形象点</p>\n<p><img src=\"EMC-EMI/2023-04-04_19-28-04.png\" alt=\"\" /></p>\n<p>这里是两个人MM和GG，他们俩都会飞，他们手牵手飞到离地面10米的位置，那他们对地的高度即为共模信号，当他们俩一个想飞高点一个想飞低点时，这时候他们牵着飞手就会感受到拉力，这就是差模信号。也就是说这两个人是对差模信号有响应的，对共模信号没有响应。理论上讲这两个人只对差模有响应而对共模没有响应。但你让这俩人往地底下飞试试，那就苦命鸳鸯，撞死了。地下不行就去遨游太空啊，行，还是苦命鸳鸯，没空气憋死了。所以共模信号也有一定的共模范围的。差模信号也有一定差模范围。</p>\n<p>借助上面的比喻来系统理解下几个基础的概念：</p>\n<pre>\n\t<code class=\"yaml\">\n借助上面的比喻来系统理解下几个基础的概念：\n共模电压：在每一导体和所规定的参照点之间（往往是大地或机架）出现的相量电压平均值。或者说同时加在电压表两测量端和规定公共端之间的那部分输出电压。\n\n差模电压：一组规定的带电导体中任意两根之间的电压。使差模电压又称对称电压。\n\n共模干扰：干扰电压在信号线及其回线（一般称为信号地线）上的幅度相同，这里的电压以附近任何一个物体（大地、金属机箱、参考地线板等）为参考电位，干扰电流回路则是在导线与参考物体构成的回路中流动。\n简明说就是信号线到地的回路干扰。\n\n差模干扰：干扰电压存在于信号线及其回线（一般称为信号地线）之间，干扰电流回路则是在导线与参考物体构成的回路中流动。\n简明说就是信号线到信号线的回路干扰。\n    </code>\n</pre>\n<h1>2：简介</h1>\n<h2>2.1：电磁干扰形成的三要素</h2>\n<p>形成电磁干扰必然具备三个基本要素:<br />①电磁骚扰源，<br />②耦合途径或传播通道，<br />③敏感设备。<br />电磁兼容设计即是从这三个基本要素出发。<br /><img src=\"EMC-EMI/2023-04-04_19-30-08.png\" alt=\"\" /></p>\n<p>所以我们可以从3个路径来解决emc问题：1干掉干扰源 2解决传播途径问题 3优化敏感设备</p>\n<h2>2.2：电磁骚扰的传播途径</h2>\n<p>电磁骚扰的传播途径包括传导耦合（传导耦合包括互传导耦合和导线间的感性与容性耦合）和辐射耦合<br />（辐射耦合包括近场耦合和远场耦合）<br /><img src=\"EMC-EMI/2023-04-04_19-31-27.png\" alt=\"\" /></p>\n<h1>3：EMC测试类型</h1>\n<blockquote>\n<p>由于前几天做的是辐射测试这里只对EMI的辐射发射测试做分析介绍</p>\n\n</blockquote>\n<p data-pid=\"hw0JtPdM\">EMI测试项目包括：</p>\n<p data-pid=\"ajAvvm_K\">1、辐射发射测试</p>\n<p data-pid=\"aMKdQ727\">2、传导发射测试</p>\n<p data-pid=\"V4hfmcc8\">3、骚扰功率测试</p>\n<p data-pid=\"HlkauZDq\">4、电流谐波测试</p>\n<p data-pid=\"iKa3kjf2\">5、电源谐波测量</p>\n<p data-pid=\"qa38dtwO\">6、闪烁测试</p>\n<p data-pid=\"ufgEgLKt\">EMS测试项目包括：</p>\n<p data-pid=\"yJxWLW6l\">1、静电放电抗扰度</p>\n<p data-pid=\"cY_CdNFF\">2、射频电磁场抗扰度</p>\n<p data-pid=\"w_TvMw5R\">3、电快速瞬变脉冲群抗扰度</p>\n<p data-pid=\"VAiXwT4K\">4、冲击（包括雷击和浪涌）抗扰度</p>\n<p data-pid=\"4njCrycj\">5、射频场感应传导抗扰度</p>\n<p data-pid=\"_pVOSVWw\">6、工频磁场抗扰度试验</p>\n<p data-pid=\"Ejw7z-1t\">7、电压跌落短时中断和电压渐降抗扰度</p>\n<p data-pid=\"Ejw7z-1t\">具体测试方法请看《EMC设计与测试案列分析》</p>\n<h1>4：辐射发射测试</h1>\n<h2>4.1辐射发射测试的目的</h2>\n<p>　　因为EMC设计及EMC问题的分析是建立在EMC测试的基础上的，所以有必要对EMC测试做简单的阐述。测试电子，电气和机电设备及其部件的辐射发射，包括来自所有组件、电缆及连接线上的辐射发射。它用来鉴定其辐射是否符合标准的要求，以致在正常使用过程中影响同一环境中的其他设备。</p>\n<h2>4.2 常用的辐射发射测试设备</h2>\n<p>根据常用传导骚扰测试标准CISPR16及EN55022的要求，辐射发射测试主要需要以下设备：</p>\n<p>（1） EMI自动测试控制系统（电脑及其界面单元）；(2) EMI测试接收机;</p>\n<p>（3）各式天线（主动、被动棒状天线、大小形状环路天线、功率双锥天线、对数螺旋天线、喇叭天线）及天线控制单元等；</p>\n<p>&nbsp; (4)半电波暗室或开阔场。</p>\n<p>EMI测试接收机是EMC测试中最常用的基本测试仪器，基于测试接收机的频率响应特性要求，按CISPR16标准规定，测试接收机应有四种基本检波方式，即准峰值检波、均方根值检波、峰值检波及平均值检波。然而，大多数电磁干扰都是脉冲干扰，它们对音频影响的客观效果随着重复频率的增高而增大，具有特定时间常数的准峰值检波器的输出特性，可以近似反映这种影响。</p>\n<h2>4.3 辐射发射的测试方法</h2>\n<p>下图是符合CISPR16及EN55022标准要求的辐射发射测试布置图。辐射发射测试时，被测设备（EUT）置于半电波暗室内部，并在转台上旋转，以找到最大的辐射点。辐射信号由接收天线接收后，通过电缆传到电波暗室外的接收机。</p>\n<p><img src=\"EMC-EMI/2023-04-04_19-32-29.png\" alt=\"\" /></p>\n<h1>5：整改</h1>\n<p><em><strong>常见的电磁兼容整改措施：</strong></em><br />&nbsp;　　对常见的电磁兼容问题，我们通过综合采用以下几个方面的整改措施，一般可以解决大部分的问题：<br />屏蔽问题：<br />&nbsp;　　可以在屏蔽体的装配面处涂导电胶，或者在装配面处加导电衬垫，甚至采用导电金属胶带进行补救。<br />&nbsp;　　导电衬垫可以是编织的金属丝线、硬度较低易于塑型的软金属(铜、铅等)、包装金属层的橡胶、导电橡胶或者是梳状簧片接触指状物等。<br />布局布线问题：<br />&nbsp;　　在不影响性能的前提下，适当调整设备电缆走向和排列，做到不同类型的电缆相互隔离。<br />电缆问题：<br />&nbsp;　　改变普通的小信号或高频信号电缆为带屏蔽的电缆，改变普通的大电流信号或数据传输信号电缆为对称绞线电缆。</p>\n<p>接地问题：<br />　　加强接地的机械性能，降低接地电阻。同时对于设备整体要有单独的低阻抗接地。<br />接口问题：<br />&nbsp;　　在设备电源输入线上加装或串联电源滤波器。<br />关键部位的处理：<br />&nbsp;　　在可能的情况下，对重要器件进行屏蔽、隔离处理，如加装接地良好的金属隔离板或小的屏蔽罩等。<br />电路和电源问题：<br />&nbsp;　　在各器件电源输入端并联小电容，以旁路电源带来的高频干扰。</p>\n<p>现在就对我们遇到的问题做分析：电磁骚扰发射：分为传导发射（连续发射和断续发射）和辐射发射（骚扰场强和骚扰功率）</p>\n<p><em><strong>针对电磁骚扰发射测试常见问题对策及整改措施</strong></em></p>\n<p>1：产品内主要电磁骚扰源分析（电源/电机/电路板/高频器件？）</p>\n<p>2：骚扰源定位（这里我们出现了一个错误后面介绍）</p>\n<p>3：产品连续传导发射超标问题及对策</p>\n<p>4：产品断续传导发射超标问题及对策</p>\n<p>5：产品辐射骚扰超标问题及对策</p>\n<p>6：骚扰功率干扰的产生和对策</p>\n<h2>5.1：主要电磁骚扰源</h2>\n<p>a:设备开关电源的开关回路：骚扰源主频几十kHz到百余kHz，高次谐波可延伸到数十MHz。<br />b:设备直流电源的整流回路：工频线性电源工频整流噪声频率上限可延伸到数百kHz；开关电源高频整流噪声频率上限可延伸到数十MHz。<br />&nbsp;c:电动设备直流电机的电刷噪声：噪声频率上限可延伸到数百MHz。<br />&nbsp;d:电动设备交流电机的运行噪声：高次谐波可延伸到数十MHz。<br />&nbsp;e:变频调速电路的骚扰发射：开关调速回路骚扰源频率从几十kHz到几十MHz。<br />&nbsp;f:设备运行状态切换的开关噪声：由机械或电子开关动作产生的噪声频率上限可延伸到数百MHz。<br />&nbsp;g:智能控制设备的晶振及数字电路电磁骚扰：骚扰源主频几十kHz到几十MHz，高次谐波可延伸到数百MHz。<br />&nbsp;等等.................</p>\n<h2>5.2：骚扰源定位</h2>\n<p><strong>根据测量曲线定位</strong>：依据：超标骚扰频率范围、超标骚扰频域分布、窄带还是宽带骚扰等来判断<br /><br /><img src=\"EMC-EMI/2023-04-04_19-32-59.png\" alt=\"\" /></p>\n<p><img src=\"EMC-EMI/2023-04-04_19-33-05.png\" alt=\"\" /></p>\n<p><strong>根据被测设备工作方式和内部结构定位</strong>：</p>\n<p>a:有没有使用标准不建议使用的半波整流和对称/非对称电源调整电路?<br />b:内部结构中电路板布局是否合理?<br />c:内部电缆走线是否合理?</p>\n<p>d:内部滤波器（滤波电路）安装是否合理?<br />e:内部电路接地和搭接方式是否合理?<br />f:机箱屏蔽是否满足对应产品的需求?</p>\n<p><br /><strong>根据功能模块工作情况进行故障定位</strong><br />a:若设备的各个模块可以暂停和恢复工作，可以通过逐个暂停这些模块的工作来判断骚扰来源。<br />b:若模块不可以独立暂停和恢复工作，可以通过与该设备其它功能模块一起组合进行暂停和恢复工作，从而判断骚扰的大概来源。<br />c:若模块不可以独立暂停和恢复工作，也可以通过用待判断模块与其它合格设备的相关功能模块组合并测量的方式，从而判断骚扰的大概来源。<br />d:对怀疑骚扰超标的模块，可以用与合格模块置换的方式来进行骚扰判定。<br />但是需要注意的是不能测试完一个模块发现没有起到作用又将这个模块恢复到初始状态 这个时候应该保持更改不变 继续下一个模块的排查，我们在最初的排查过程中就犯了这个错误，导致浪费了测试时间。<br />下面去个例子说明：</p>\n<p>　　假设一个系统在测试时出现了辐射发射超标，使系统不能满足EMC标准中对辐射发射的限值。经过初步分析，原因可能有4个，它们分别是：</p>\n<p>（1）主机与键盘之间的互连电缆（电缆1）上的共模电流产生的辐射；</p>\n<p>（2）主机与打印机之间的互连电缆（电缆2）上的共模电流产生的辐射；</p>\n<p>（3）机箱面板与机箱基体之间的缝隙（开口1）产生的泄漏；</p>\n<p>（4）某显示窗口（开口2）产生的泄漏。</p>\n<p>在诊断时，首先在电缆1上套一个铁氧体磁环，以减小共模辐射，结果发现频谱仪屏幕上显示的信号并没有明显减小。于是认为电缆1不是一个主要的泄漏源，将铁氧体磁环取下，套在电缆2上，结果发现频谱仪屏幕上显示的信号还没有明显减小。结果得出结论，电缆不是泄漏源。</p>\n<p>再对机箱上的泄漏进行检查。用屏蔽胶带将开口1堵上，发现频谱仪屏幕上显示的信号没有明显减小。认为开口1不是主要泄漏源，将屏蔽胶带取下，堵到开口2上。结果频谱仪上的显示信号还没有减小。之所以会发生这个问题，是因为测试人员忽视了频谱分析仪上显示的信号幅度是以dB为单位显示的。下面看一下为什么会有这种现象。</p>\n<p>假设这4个泄漏源所占的成分各占1／4，并且在每个辐射源上采取的措施能够将这个辐射源完全抑制掉，则采取以上4个措施中的一个时，频谱仪上显示信号降低的幅度&Delta;A为</p>\n<p>&Delta;A=20lg(4/3)=2.5 dB</p>\n<p>幅度减小这么少，显然是微不足道的。但这却已经将泄漏减少了25％。</p>\n<p>正确的方法是，在对一个可能的泄漏源采取了抑制措施后，即使没有明显的改善，也不要将这个措施去掉，继续对可能的泄漏源采取措施。当采取到某个措施时，如果干扰幅度降低很多，并不一定说明这个泄漏源是主要的，而仅说明这个干扰源是最后一个。按照这个步骤对4个泄漏源逐个处理的结果如图</p>\n\n<img src=\"EMC-EMI/2023-04-04_19-33-48.png\" alt=\"\" />\n<p>在前面的叙述中，假定对某个泄漏源采取措施后，这个泄漏源被100％消除掉，如果这样，当最后一个泄漏源去掉后，电磁干扰的减小应为无限大。实际这是不可能的。在采取任何一个措施时，都不可能将干扰源100％消除。泄漏源去掉的程度可以是99％，或99.9％，甚至99.99％以上，而绝不可能是100％，所以当最后一个泄漏源去掉后，尽管改善很大，但仍是有限值。</p>\n<h2>5.3：连续传导发射超标问题及对策</h2>\n<p><strong>连续传导骚扰的主要来源：</strong></p>\n<p>a:开关电源的开关频率及谐波骚扰<br />b:电源整流回路的整流噪声<br />c:交流电机的运行噪声</p>\n<p>d:直流电机的电刷噪声</p>\n<p>e:智能控制设备的晶振</p>\n<p>f:数字电路电磁骚扰<br /><strong>导致射频传导发射超标的原因如图所示:</strong><br /><img src=\"EMC-EMI/2023-04-04_19-34-25.png\" alt=\"\" /></p>\n<p>（1）开关电源或DC/DC变换器工作在脉冲状态，它们本身会产生很强的干扰，这种干扰既有共模分量，也有差模分量。对于一般开关电源和变换器，在1MHz以下以差模干扰为主，在1MHz以上以共模干扰为主。<br />（2）数字电路的工作电流是瞬变的，虽然在每个电路芯片的旁边和线路板上都安装了解耦电容，但还是会有一部分瞬变电流反映在电源中，沿着电源线传导发射。<br />（3）机箱内的线路板、电缆都是辐射源，这些辐射能量会感应进电源线和电源电路本身，形成传导发射。需要注意的是，当机箱内各种频率的信号耦合进电源电路时，由于电源内有许多二极管、三极管电路，会使这些不同频率的信号相互发生混频、调制，甚至对干扰进行放大，从而导致严重的干扰。<br /><strong>解决方法：</strong></p>\n<p>在电源线入口处安装电源线滤波器是保证通过射频传导发射试验的唯一方法（滤波器的安装位置也很重要）。<br />如果仅做150kHz~30MHz范围内的传导发射试验，一般的电源线滤波器就可以满足要求，大部分电源线滤波器在100kHz以上都已有较大的插入损耗。由于30MHz以上的高频性能不良会导致辐射发射的问题，所以应加以注意。如果需要做30~300MHz频率范围内的骚扰功率发射试验或30~1GHz频率范围内的辐射骚扰，选择滤波器时必须注意滤波器的高频特性。</p>\n<p>对电源线的处理：<br />（1）检查电源线附近有无信号电缆存在，有无可能是因为信号电缆与电源线之间的耦合使电源线的传导骚扰发射超标（这种情况多见于超标频率的频段较高的情况下）。如有，或拉大两者间的距离，或采取屏蔽措施。<br />（2）加装电源线滤波器（如果已经有滤波器。则换用高性能的滤波器），要特别注意安装位置（尽可能放在机箱中电源线入口端）和安装情况，要保证滤波器外壳与机箱搭接良好、接地良好。<br />（3）虽经采取措施，设备传导骚扰发射仍未达标。此时可考虑在设备内部线路连接接地端子的地方串入一个电感。由于这部分连接属单点接地，平时无电流流过，因此这个电感可以做得较大，而无需担心有铁芯的饱和问题。<br />采取这一措施的理由是设备传导骚扰发射测试实际上是对地电压测试（电源线对大地的骚扰电压测试），电源线上有工作电流流过，故滤波器的滤波电感值受制于工作电流，不能做得很大，滤波器的插入损耗也就有限，特别是低频端损耗更加有限。新方案里的附加电感正好可以弥补这一缺憾，从而取得更好的传导骚扰抑制能力。<br />对信号线的处理：<br />（1）注意信号线周围有无其他辐射能量（附近的布线及印刷板的布局）被引到信号线上。如有，或拉大两者的距离，或采取屏蔽措施，或考虑改变设备内部布局和印刷板的布局。<br />（2）在信号线上套铁氧体磁环（或铁氧体磁夹）。<br />（3）对信号线进行共模滤波，必要时采用滤波连接器（或滤波阵列板）。注意滤波器的参数，传导骚扰发射超标的频率比辐射骚扰发射超标的频率应低些，因此取用的元件参数应当偏大一些</p>\n<h2>5.4：断续传导发射超标问题及对策</h2>\n<p><strong>断续传导骚扰的主要来源：</strong></p>\n<p>a:恒温控制器具，程序自动的机器和其他电气控制或操作的器具的开关操作会产生断续骚扰。此类操作一般通过继电器和程控电子/机械开关等实现。此类骚扰一般由继电器、开关的触点抖动及非纯阻负载通断所产生的电涌冲击形成。<br /><strong>解决方法：</strong><br />从内部电路和结构上考虑，减少其断续骚扰，使其满足测量要求。<br />从电源电路和电源结构入手，在电源中采取适当的措施，对内部电路产生的断续骚扰加以抑制，使其满足测量标准的要求。<br />a:在开关触点或开关模块两端并联高频电容或RC、DRC吸波网络，吸收开关抖动脉冲及非阻性负载的浪涌脉冲。 同时应留意这些元器件的耐压和功率承受能力应满足设备正常工作的要求。<br />b:对被供电设备内通过程控开关控制的非阻性部件的供电回路上增加限流电路或软启动装置，抑制其启动浪涌冲击。<br />c:对被供电设备内通过开关量控制的感性部件应增加反向浪涌吸收元件，以吸收部件断电时产生的反向感应高压浪涌冲击。<br />d:在被供电设备的电源输入端增加高频吸收回路，抑制其高频骚扰向电源反向注入。</p>\n<h2>5.5：辐射骚扰超标问题及对策</h2>\n<p><strong>辐射骚扰的主要骚扰来源:</strong><br />a:开关电源的开关频率及谐波骚扰<br />b:交流电机的运行噪声、直流电机的电刷噪声<br />c:电磁感应设备的电磁骚扰<br />d:智能控制设备的晶振及数字电路电磁骚扰等</p>\n<p>导致辐射发射试验失败的原因有两种可能最大：</p>\n<p>　　一种是设备外壳的屏蔽性能不完善；<br />　　另一种是射频骚扰经由电源线和其他线缆的逸出。<br /><br /><strong>解决方法：</strong><br /><img src=\"EMC-EMI/2023-04-04_19-35-03.png\" alt=\"\" /></p>\n<p>当我们通过骚扰定位方式找到辐射骚扰超标点的骚扰源后，即可采用相对应的骚扰源抑制措施。<br />一般来说：<br />首先抑制骚扰源，这可以通过优化电路设计、电路结构和排版，加强滤波和正确的接地来达到。<br />其次是要切断耦合途径，这可以通过正确的机壳屏蔽和传输线滤波达到。<br /><strong>首先说下机箱问题：</strong></p>\n<p>一、金属机箱屏蔽性能不完善（非金属机箱还没碰到不做讨论）<br />对于金属机箱屏蔽性能不完善引起的辐射骚扰发射超标，应采取以下措施：<br />1）机箱的缝隙过大，或机箱配合上存在问题<br />　处理意见：<br />（1）清除结合面上的油漆、氧化层及表面玷污；<br />（2）增加结合面上的紧固件数目及接触表面的平整度；<br />（3）采取永久性的接缝（要连续焊接）；<br />（4）采用导电衬垫来改善接触表面的接触性能。<br />2）其他功能性开孔过大<br />处理意见：<br />（1）通风口采用防尘板，必要时采用波导通风板，但后者成本昂贵；<br />（2）显示窗口采用带有屏蔽作用的透明材料；或采用隔舱，并对信号线采取滤波措施；<br />（3）对键盘等采用隔舱，并对信号线采取滤波措施。<br />3）机箱内部布线不当，电磁骚扰透过缝隙逸出<br />处理意见：<br />&nbsp; 将印刷板及设备内部布线等可能产生辐射骚扰的布局，远离缝隙或功能性开孔的部位，<br />&nbsp; 或采取增加屏蔽的补救措施或重新布局。<br /><strong>其次说下线缆问题：</strong><br />1）对电源线的处理<br />（1）加装电源线滤波器（如果己经有滤波器，则换用高性能的滤波器），要特别注意安装位置（尽可能放在机箱中电源线入口端）和安装情况，要保证滤波器外壳与机箱搭接良好、接地良好；<br />（2）如果不合格的频率比较高，可考虑在电源线入口的部分套装铁氧体磁环。<br />2）对信号线的处理<br />（1）在信号线上套铁氧体磁环（或铁氧体磁夹）；<br />（2）对信号线滤波（共模滤波），必要时将连接器改用滤波阵列板或滤波连接器；<br />（3）换用屏蔽电缆，屏蔽电缆的屏蔽层与机箱尽量采用360&deg;搭接方式，必要时在屏蔽线上再套铁氧体磁环</p>\n<h2>5.6：骚扰功率干扰的产生和对策</h2>\n<p><strong>骚扰功率的主要来源：</strong></p>\n<p>a:电源线滤波装置的高频插入损耗不足</p>\n<p><strong>解决方法：</strong></p>\n<p>（1）滤波器电路没有屏蔽，这种情况经常发生在将滤波电路安装在线路板上的场合，高频干扰直接耦合进滤波电路，造成滤波器失效；<br />（2）滤波器本身高频性能不良，在100MHz以上插入损耗很小；<br />（3）使用非屏蔽机箱，导致滤波器的金属外壳无处端接；<strong><br /></strong>（4）使用非屏蔽机箱，干扰直接耦合到电源线和信号线上，滤波器实际上没有起作用；<br />（5）在屏蔽机箱中，滤波器离电源进口过远、造成干扰直接耦合到电源线和信号线上；<br />（6）在屏蔽机箱中，滤波器外壳与金属机箱之间连接阻抗过大（没有直接搭接，而是通过长导线连接）；<br />（7）滤波器的输入线与输出线靠得很近，发生耦合，导致滤波器的高频插人损耗不足。<strong><br /><br /></strong></p>\n<p><strong>参考书籍:&lt;EMC（电磁兼容）设计与测试案例分析 郑军奇编著 电子工业出版社&gt;</strong></p>\n<p><strong>看书的时候整理了一下导图无私分享下：</strong></p>\n<div class=\"cnblogs_Highlighter\">\n<pre class=\"brush:csharp;gutter:true;\">git@gitee.com:qian-qiang/book-map.git\n</pre>\n</div>\n<p>&nbsp;</p>\n","slug":"EMC-EMI","published":1,"updated":"2023-04-04T11:36:29.800Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk69d1d5000ljsrjyo1w1f2c","content":"<blockquote>EMC=EMI+EMS</blockquote>\n<h1>1：理论概念</h1>\n<h2>1.1时域和频域</h2>\n<p>建议通过示波器的FFT变换去了解时域和频域的概念</p>\n<h2>1.2分贝</h2>\n<p>电磁兼容测试中常用单位：</p>\n<p>&nbsp; 　　功率：P<sub>db</sub>=10lg(p1/p2) P2与P1应采用相同的单位。应该明确dB为两个量的比值，是无量纲的。<br>&nbsp;　　 电压:&nbsp; 同上 电压分贝常用&mu;V为单位<br>&nbsp; 　　电流：同上 以&mu;A为单位的电流。</p>\n<p>　　&nbsp; 电场强度与磁场强度：H=E/Z <br>&nbsp; 　　功率密度：S=E X H&nbsp;&nbsp;&nbsp; 功率密度的基本单位为W/m2(电场强度V／m;磁场强度A/m),<br>功率密度的物理作用比较难理解 提供一个关系来理解：后面的db数值和一个叫自由空间波阻抗的概念有关</p>\n<pre>\n    <code class=\"yaml\">\n在自由空间，功率密度S与电场强度E的关系化为分贝：\nSdB（W/m2）=EdB（V/m） &ndash; 25.8dB    \nSdB（mW/cm2）=EdB（&mu;V/m） &ndash; 155.8dB  \nSdB（&mu;W/cm2）=EdB（&mu;V/m） &ndash; 125.8dB\n    </code>\n</pre>\n<h2>&nbsp;1.3电场和磁场</h2>\n<p>高中概念E/H场正交同时传播 建议了解下<strong>天线模型</strong></p>\n<h2>&nbsp;1.4共模和差模</h2>\n<p>电压和电流的变化通过通过导线传输时有两中形态，即&ldquo;差模&rdquo;和&ldquo;共模&rdquo; 。 这里我们把这两根线比喻成两个小人，一个MM，一个GG。来张图，形象点</p>\n<p><img src=\"/2023/04/emc-emi/2023-04-04_19-28-04.png\" alt></p>\n<p>这里是两个人MM和GG，他们俩都会飞，他们手牵手飞到离地面10米的位置，那他们对地的高度即为共模信号，当他们俩一个想飞高点一个想飞低点时，这时候他们牵着飞手就会感受到拉力，这就是差模信号。也就是说这两个人是对差模信号有响应的，对共模信号没有响应。理论上讲这两个人只对差模有响应而对共模没有响应。但你让这俩人往地底下飞试试，那就苦命鸳鸯，撞死了。地下不行就去遨游太空啊，行，还是苦命鸳鸯，没空气憋死了。所以共模信号也有一定的共模范围的。差模信号也有一定差模范围。</p>\n<p>借助上面的比喻来系统理解下几个基础的概念：</p>\n<pre>\n    <code class=\"yaml\">\n借助上面的比喻来系统理解下几个基础的概念：\n共模电压：在每一导体和所规定的参照点之间（往往是大地或机架）出现的相量电压平均值。或者说同时加在电压表两测量端和规定公共端之间的那部分输出电压。\n\n<p>差模电压：一组规定的带电导体中任意两根之间的电压。使差模电压又称对称电压。</p>\n<p>共模干扰：干扰电压在信号线及其回线（一般称为信号地线）上的幅度相同，这里的电压以附近任何一个物体（大地、金属机箱、参考地线板等）为参考电位，干扰电流回路则是在导线与参考物体构成的回路中流动。<br>简明说就是信号线到地的回路干扰。</p>\n<p>差模干扰：干扰电压存在于信号线及其回线（一般称为信号地线）之间，干扰电流回路则是在导线与参考物体构成的回路中流动。<br>简明说就是信号线到信号线的回路干扰。<br>    </p></code><br></pre><p></p>\n<h1>2：简介</h1>\n<h2>2.1：电磁干扰形成的三要素</h2>\n<p>形成电磁干扰必然具备三个基本要素:<br>①电磁骚扰源，<br>②耦合途径或传播通道，<br>③敏感设备。<br>电磁兼容设计即是从这三个基本要素出发。<br><img src=\"/2023/04/emc-emi/2023-04-04_19-30-08.png\" alt></p>\n<p>所以我们可以从3个路径来解决emc问题：1干掉干扰源 2解决传播途径问题 3优化敏感设备</p>\n<h2>2.2：电磁骚扰的传播途径</h2>\n<p>电磁骚扰的传播途径包括传导耦合（传导耦合包括互传导耦合和导线间的感性与容性耦合）和辐射耦合<br>（辐射耦合包括近场耦合和远场耦合）<br><img src=\"/2023/04/emc-emi/2023-04-04_19-31-27.png\" alt></p>\n<h1>3：EMC测试类型</h1>\n<blockquote>\n<p>由于前几天做的是辐射测试这里只对EMI的辐射发射测试做分析介绍</p>\n\n</blockquote>\n<p data-pid=\"hw0JtPdM\">EMI测试项目包括：</p>\n<p data-pid=\"ajAvvm_K\">1、辐射发射测试</p>\n<p data-pid=\"aMKdQ727\">2、传导发射测试</p>\n<p data-pid=\"V4hfmcc8\">3、骚扰功率测试</p>\n<p data-pid=\"HlkauZDq\">4、电流谐波测试</p>\n<p data-pid=\"iKa3kjf2\">5、电源谐波测量</p>\n<p data-pid=\"qa38dtwO\">6、闪烁测试</p>\n<p data-pid=\"ufgEgLKt\">EMS测试项目包括：</p>\n<p data-pid=\"yJxWLW6l\">1、静电放电抗扰度</p>\n<p data-pid=\"cY_CdNFF\">2、射频电磁场抗扰度</p>\n<p data-pid=\"w_TvMw5R\">3、电快速瞬变脉冲群抗扰度</p>\n<p data-pid=\"VAiXwT4K\">4、冲击（包括雷击和浪涌）抗扰度</p>\n<p data-pid=\"4njCrycj\">5、射频场感应传导抗扰度</p>\n<p data-pid=\"_pVOSVWw\">6、工频磁场抗扰度试验</p>\n<p data-pid=\"Ejw7z-1t\">7、电压跌落短时中断和电压渐降抗扰度</p>\n<p data-pid=\"Ejw7z-1t\">具体测试方法请看《EMC设计与测试案列分析》</p>\n<h1>4：辐射发射测试</h1>\n<h2>4.1辐射发射测试的目的</h2>\n<p>　　因为EMC设计及EMC问题的分析是建立在EMC测试的基础上的，所以有必要对EMC测试做简单的阐述。测试电子，电气和机电设备及其部件的辐射发射，包括来自所有组件、电缆及连接线上的辐射发射。它用来鉴定其辐射是否符合标准的要求，以致在正常使用过程中影响同一环境中的其他设备。</p>\n<h2>4.2 常用的辐射发射测试设备</h2>\n<p>根据常用传导骚扰测试标准CISPR16及EN55022的要求，辐射发射测试主要需要以下设备：</p>\n<p>（1） EMI自动测试控制系统（电脑及其界面单元）；(2) EMI测试接收机;</p>\n<p>（3）各式天线（主动、被动棒状天线、大小形状环路天线、功率双锥天线、对数螺旋天线、喇叭天线）及天线控制单元等；</p>\n<p>&nbsp; (4)半电波暗室或开阔场。</p>\n<p>EMI测试接收机是EMC测试中最常用的基本测试仪器，基于测试接收机的频率响应特性要求，按CISPR16标准规定，测试接收机应有四种基本检波方式，即准峰值检波、均方根值检波、峰值检波及平均值检波。然而，大多数电磁干扰都是脉冲干扰，它们对音频影响的客观效果随着重复频率的增高而增大，具有特定时间常数的准峰值检波器的输出特性，可以近似反映这种影响。</p>\n<h2>4.3 辐射发射的测试方法</h2>\n<p>下图是符合CISPR16及EN55022标准要求的辐射发射测试布置图。辐射发射测试时，被测设备（EUT）置于半电波暗室内部，并在转台上旋转，以找到最大的辐射点。辐射信号由接收天线接收后，通过电缆传到电波暗室外的接收机。</p>\n<p><img src=\"/2023/04/emc-emi/2023-04-04_19-32-29.png\" alt></p>\n<h1>5：整改</h1>\n<p><em><strong>常见的电磁兼容整改措施：</strong></em><br>&nbsp;　　对常见的电磁兼容问题，我们通过综合采用以下几个方面的整改措施，一般可以解决大部分的问题：<br>屏蔽问题：<br>&nbsp;　　可以在屏蔽体的装配面处涂导电胶，或者在装配面处加导电衬垫，甚至采用导电金属胶带进行补救。<br>&nbsp;　　导电衬垫可以是编织的金属丝线、硬度较低易于塑型的软金属(铜、铅等)、包装金属层的橡胶、导电橡胶或者是梳状簧片接触指状物等。<br>布局布线问题：<br>&nbsp;　　在不影响性能的前提下，适当调整设备电缆走向和排列，做到不同类型的电缆相互隔离。<br>电缆问题：<br>&nbsp;　　改变普通的小信号或高频信号电缆为带屏蔽的电缆，改变普通的大电流信号或数据传输信号电缆为对称绞线电缆。</p>\n<p>接地问题：<br>　　加强接地的机械性能，降低接地电阻。同时对于设备整体要有单独的低阻抗接地。<br>接口问题：<br>&nbsp;　　在设备电源输入线上加装或串联电源滤波器。<br>关键部位的处理：<br>&nbsp;　　在可能的情况下，对重要器件进行屏蔽、隔离处理，如加装接地良好的金属隔离板或小的屏蔽罩等。<br>电路和电源问题：<br>&nbsp;　　在各器件电源输入端并联小电容，以旁路电源带来的高频干扰。</p>\n<p>现在就对我们遇到的问题做分析：电磁骚扰发射：分为传导发射（连续发射和断续发射）和辐射发射（骚扰场强和骚扰功率）</p>\n<p><em><strong>针对电磁骚扰发射测试常见问题对策及整改措施</strong></em></p>\n<p>1：产品内主要电磁骚扰源分析（电源/电机/电路板/高频器件？）</p>\n<p>2：骚扰源定位（这里我们出现了一个错误后面介绍）</p>\n<p>3：产品连续传导发射超标问题及对策</p>\n<p>4：产品断续传导发射超标问题及对策</p>\n<p>5：产品辐射骚扰超标问题及对策</p>\n<p>6：骚扰功率干扰的产生和对策</p>\n<h2>5.1：主要电磁骚扰源</h2>\n<p>a:设备开关电源的开关回路：骚扰源主频几十kHz到百余kHz，高次谐波可延伸到数十MHz。<br>b:设备直流电源的整流回路：工频线性电源工频整流噪声频率上限可延伸到数百kHz；开关电源高频整流噪声频率上限可延伸到数十MHz。<br>&nbsp;c:电动设备直流电机的电刷噪声：噪声频率上限可延伸到数百MHz。<br>&nbsp;d:电动设备交流电机的运行噪声：高次谐波可延伸到数十MHz。<br>&nbsp;e:变频调速电路的骚扰发射：开关调速回路骚扰源频率从几十kHz到几十MHz。<br>&nbsp;f:设备运行状态切换的开关噪声：由机械或电子开关动作产生的噪声频率上限可延伸到数百MHz。<br>&nbsp;g:智能控制设备的晶振及数字电路电磁骚扰：骚扰源主频几十kHz到几十MHz，高次谐波可延伸到数百MHz。<br>&nbsp;等等.................</p>\n<h2>5.2：骚扰源定位</h2>\n<p><strong>根据测量曲线定位</strong>：依据：超标骚扰频率范围、超标骚扰频域分布、窄带还是宽带骚扰等来判断<br><br><img src=\"/2023/04/emc-emi/2023-04-04_19-32-59.png\" alt></p>\n<p><img src=\"/2023/04/emc-emi/2023-04-04_19-33-05.png\" alt></p>\n<p><strong>根据被测设备工作方式和内部结构定位</strong>：</p>\n<p>a:有没有使用标准不建议使用的半波整流和对称/非对称电源调整电路?<br>b:内部结构中电路板布局是否合理?<br>c:内部电缆走线是否合理?</p>\n<p>d:内部滤波器（滤波电路）安装是否合理?<br>e:内部电路接地和搭接方式是否合理?<br>f:机箱屏蔽是否满足对应产品的需求?</p>\n<p><br><strong>根据功能模块工作情况进行故障定位</strong><br>a:若设备的各个模块可以暂停和恢复工作，可以通过逐个暂停这些模块的工作来判断骚扰来源。<br>b:若模块不可以独立暂停和恢复工作，可以通过与该设备其它功能模块一起组合进行暂停和恢复工作，从而判断骚扰的大概来源。<br>c:若模块不可以独立暂停和恢复工作，也可以通过用待判断模块与其它合格设备的相关功能模块组合并测量的方式，从而判断骚扰的大概来源。<br>d:对怀疑骚扰超标的模块，可以用与合格模块置换的方式来进行骚扰判定。<br>但是需要注意的是不能测试完一个模块发现没有起到作用又将这个模块恢复到初始状态 这个时候应该保持更改不变 继续下一个模块的排查，我们在最初的排查过程中就犯了这个错误，导致浪费了测试时间。<br>下面去个例子说明：</p>\n<p>　　假设一个系统在测试时出现了辐射发射超标，使系统不能满足EMC标准中对辐射发射的限值。经过初步分析，原因可能有4个，它们分别是：</p>\n<p>（1）主机与键盘之间的互连电缆（电缆1）上的共模电流产生的辐射；</p>\n<p>（2）主机与打印机之间的互连电缆（电缆2）上的共模电流产生的辐射；</p>\n<p>（3）机箱面板与机箱基体之间的缝隙（开口1）产生的泄漏；</p>\n<p>（4）某显示窗口（开口2）产生的泄漏。</p>\n<p>在诊断时，首先在电缆1上套一个铁氧体磁环，以减小共模辐射，结果发现频谱仪屏幕上显示的信号并没有明显减小。于是认为电缆1不是一个主要的泄漏源，将铁氧体磁环取下，套在电缆2上，结果发现频谱仪屏幕上显示的信号还没有明显减小。结果得出结论，电缆不是泄漏源。</p>\n<p>再对机箱上的泄漏进行检查。用屏蔽胶带将开口1堵上，发现频谱仪屏幕上显示的信号没有明显减小。认为开口1不是主要泄漏源，将屏蔽胶带取下，堵到开口2上。结果频谱仪上的显示信号还没有减小。之所以会发生这个问题，是因为测试人员忽视了频谱分析仪上显示的信号幅度是以dB为单位显示的。下面看一下为什么会有这种现象。</p>\n<p>假设这4个泄漏源所占的成分各占1／4，并且在每个辐射源上采取的措施能够将这个辐射源完全抑制掉，则采取以上4个措施中的一个时，频谱仪上显示信号降低的幅度&Delta;A为</p>\n<p>&Delta;A=20lg(4/3)=2.5 dB</p>\n<p>幅度减小这么少，显然是微不足道的。但这却已经将泄漏减少了25％。</p>\n<p>正确的方法是，在对一个可能的泄漏源采取了抑制措施后，即使没有明显的改善，也不要将这个措施去掉，继续对可能的泄漏源采取措施。当采取到某个措施时，如果干扰幅度降低很多，并不一定说明这个泄漏源是主要的，而仅说明这个干扰源是最后一个。按照这个步骤对4个泄漏源逐个处理的结果如图</p>\n\n<img src=\"/2023/04/emc-emi/2023-04-04_19-33-48.png\" alt>\n<p>在前面的叙述中，假定对某个泄漏源采取措施后，这个泄漏源被100％消除掉，如果这样，当最后一个泄漏源去掉后，电磁干扰的减小应为无限大。实际这是不可能的。在采取任何一个措施时，都不可能将干扰源100％消除。泄漏源去掉的程度可以是99％，或99.9％，甚至99.99％以上，而绝不可能是100％，所以当最后一个泄漏源去掉后，尽管改善很大，但仍是有限值。</p>\n<h2>5.3：连续传导发射超标问题及对策</h2>\n<p><strong>连续传导骚扰的主要来源：</strong></p>\n<p>a:开关电源的开关频率及谐波骚扰<br>b:电源整流回路的整流噪声<br>c:交流电机的运行噪声</p>\n<p>d:直流电机的电刷噪声</p>\n<p>e:智能控制设备的晶振</p>\n<p>f:数字电路电磁骚扰<br><strong>导致射频传导发射超标的原因如图所示:</strong><br><img src=\"/2023/04/emc-emi/2023-04-04_19-34-25.png\" alt></p>\n<p>（1）开关电源或DC/DC变换器工作在脉冲状态，它们本身会产生很强的干扰，这种干扰既有共模分量，也有差模分量。对于一般开关电源和变换器，在1MHz以下以差模干扰为主，在1MHz以上以共模干扰为主。<br>（2）数字电路的工作电流是瞬变的，虽然在每个电路芯片的旁边和线路板上都安装了解耦电容，但还是会有一部分瞬变电流反映在电源中，沿着电源线传导发射。<br>（3）机箱内的线路板、电缆都是辐射源，这些辐射能量会感应进电源线和电源电路本身，形成传导发射。需要注意的是，当机箱内各种频率的信号耦合进电源电路时，由于电源内有许多二极管、三极管电路，会使这些不同频率的信号相互发生混频、调制，甚至对干扰进行放大，从而导致严重的干扰。<br><strong>解决方法：</strong></p>\n<p>在电源线入口处安装电源线滤波器是保证通过射频传导发射试验的唯一方法（滤波器的安装位置也很重要）。<br>如果仅做150kHz~30MHz范围内的传导发射试验，一般的电源线滤波器就可以满足要求，大部分电源线滤波器在100kHz以上都已有较大的插入损耗。由于30MHz以上的高频性能不良会导致辐射发射的问题，所以应加以注意。如果需要做30~300MHz频率范围内的骚扰功率发射试验或30~1GHz频率范围内的辐射骚扰，选择滤波器时必须注意滤波器的高频特性。</p>\n<p>对电源线的处理：<br>（1）检查电源线附近有无信号电缆存在，有无可能是因为信号电缆与电源线之间的耦合使电源线的传导骚扰发射超标（这种情况多见于超标频率的频段较高的情况下）。如有，或拉大两者间的距离，或采取屏蔽措施。<br>（2）加装电源线滤波器（如果已经有滤波器。则换用高性能的滤波器），要特别注意安装位置（尽可能放在机箱中电源线入口端）和安装情况，要保证滤波器外壳与机箱搭接良好、接地良好。<br>（3）虽经采取措施，设备传导骚扰发射仍未达标。此时可考虑在设备内部线路连接接地端子的地方串入一个电感。由于这部分连接属单点接地，平时无电流流过，因此这个电感可以做得较大，而无需担心有铁芯的饱和问题。<br>采取这一措施的理由是设备传导骚扰发射测试实际上是对地电压测试（电源线对大地的骚扰电压测试），电源线上有工作电流流过，故滤波器的滤波电感值受制于工作电流，不能做得很大，滤波器的插入损耗也就有限，特别是低频端损耗更加有限。新方案里的附加电感正好可以弥补这一缺憾，从而取得更好的传导骚扰抑制能力。<br>对信号线的处理：<br>（1）注意信号线周围有无其他辐射能量（附近的布线及印刷板的布局）被引到信号线上。如有，或拉大两者的距离，或采取屏蔽措施，或考虑改变设备内部布局和印刷板的布局。<br>（2）在信号线上套铁氧体磁环（或铁氧体磁夹）。<br>（3）对信号线进行共模滤波，必要时采用滤波连接器（或滤波阵列板）。注意滤波器的参数，传导骚扰发射超标的频率比辐射骚扰发射超标的频率应低些，因此取用的元件参数应当偏大一些</p>\n<h2>5.4：断续传导发射超标问题及对策</h2>\n<p><strong>断续传导骚扰的主要来源：</strong></p>\n<p>a:恒温控制器具，程序自动的机器和其他电气控制或操作的器具的开关操作会产生断续骚扰。此类操作一般通过继电器和程控电子/机械开关等实现。此类骚扰一般由继电器、开关的触点抖动及非纯阻负载通断所产生的电涌冲击形成。<br><strong>解决方法：</strong><br>从内部电路和结构上考虑，减少其断续骚扰，使其满足测量要求。<br>从电源电路和电源结构入手，在电源中采取适当的措施，对内部电路产生的断续骚扰加以抑制，使其满足测量标准的要求。<br>a:在开关触点或开关模块两端并联高频电容或RC、DRC吸波网络，吸收开关抖动脉冲及非阻性负载的浪涌脉冲。 同时应留意这些元器件的耐压和功率承受能力应满足设备正常工作的要求。<br>b:对被供电设备内通过程控开关控制的非阻性部件的供电回路上增加限流电路或软启动装置，抑制其启动浪涌冲击。<br>c:对被供电设备内通过开关量控制的感性部件应增加反向浪涌吸收元件，以吸收部件断电时产生的反向感应高压浪涌冲击。<br>d:在被供电设备的电源输入端增加高频吸收回路，抑制其高频骚扰向电源反向注入。</p>\n<h2>5.5：辐射骚扰超标问题及对策</h2>\n<p><strong>辐射骚扰的主要骚扰来源:</strong><br>a:开关电源的开关频率及谐波骚扰<br>b:交流电机的运行噪声、直流电机的电刷噪声<br>c:电磁感应设备的电磁骚扰<br>d:智能控制设备的晶振及数字电路电磁骚扰等</p>\n<p>导致辐射发射试验失败的原因有两种可能最大：</p>\n<p>　　一种是设备外壳的屏蔽性能不完善；<br>　　另一种是射频骚扰经由电源线和其他线缆的逸出。<br><br><strong>解决方法：</strong><br><img src=\"/2023/04/emc-emi/2023-04-04_19-35-03.png\" alt></p>\n<p>当我们通过骚扰定位方式找到辐射骚扰超标点的骚扰源后，即可采用相对应的骚扰源抑制措施。<br>一般来说：<br>首先抑制骚扰源，这可以通过优化电路设计、电路结构和排版，加强滤波和正确的接地来达到。<br>其次是要切断耦合途径，这可以通过正确的机壳屏蔽和传输线滤波达到。<br><strong>首先说下机箱问题：</strong></p>\n<p>一、金属机箱屏蔽性能不完善（非金属机箱还没碰到不做讨论）<br>对于金属机箱屏蔽性能不完善引起的辐射骚扰发射超标，应采取以下措施：<br>1）机箱的缝隙过大，或机箱配合上存在问题<br>　处理意见：<br>（1）清除结合面上的油漆、氧化层及表面玷污；<br>（2）增加结合面上的紧固件数目及接触表面的平整度；<br>（3）采取永久性的接缝（要连续焊接）；<br>（4）采用导电衬垫来改善接触表面的接触性能。<br>2）其他功能性开孔过大<br>处理意见：<br>（1）通风口采用防尘板，必要时采用波导通风板，但后者成本昂贵；<br>（2）显示窗口采用带有屏蔽作用的透明材料；或采用隔舱，并对信号线采取滤波措施；<br>（3）对键盘等采用隔舱，并对信号线采取滤波措施。<br>3）机箱内部布线不当，电磁骚扰透过缝隙逸出<br>处理意见：<br>&nbsp; 将印刷板及设备内部布线等可能产生辐射骚扰的布局，远离缝隙或功能性开孔的部位，<br>&nbsp; 或采取增加屏蔽的补救措施或重新布局。<br><strong>其次说下线缆问题：</strong><br>1）对电源线的处理<br>（1）加装电源线滤波器（如果己经有滤波器，则换用高性能的滤波器），要特别注意安装位置（尽可能放在机箱中电源线入口端）和安装情况，要保证滤波器外壳与机箱搭接良好、接地良好；<br>（2）如果不合格的频率比较高，可考虑在电源线入口的部分套装铁氧体磁环。<br>2）对信号线的处理<br>（1）在信号线上套铁氧体磁环（或铁氧体磁夹）；<br>（2）对信号线滤波（共模滤波），必要时将连接器改用滤波阵列板或滤波连接器；<br>（3）换用屏蔽电缆，屏蔽电缆的屏蔽层与机箱尽量采用360&deg;搭接方式，必要时在屏蔽线上再套铁氧体磁环</p>\n<h2>5.6：骚扰功率干扰的产生和对策</h2>\n<p><strong>骚扰功率的主要来源：</strong></p>\n<p>a:电源线滤波装置的高频插入损耗不足</p>\n<p><strong>解决方法：</strong></p>\n<p>（1）滤波器电路没有屏蔽，这种情况经常发生在将滤波电路安装在线路板上的场合，高频干扰直接耦合进滤波电路，造成滤波器失效；<br>（2）滤波器本身高频性能不良，在100MHz以上插入损耗很小；<br>（3）使用非屏蔽机箱，导致滤波器的金属外壳无处端接；<strong><br></strong>（4）使用非屏蔽机箱，干扰直接耦合到电源线和信号线上，滤波器实际上没有起作用；<br>（5）在屏蔽机箱中，滤波器离电源进口过远、造成干扰直接耦合到电源线和信号线上；<br>（6）在屏蔽机箱中，滤波器外壳与金属机箱之间连接阻抗过大（没有直接搭接，而是通过长导线连接）；<br>（7）滤波器的输入线与输出线靠得很近，发生耦合，导致滤波器的高频插人损耗不足。<strong><br><br></strong></p>\n<p><strong>参考书籍:&lt;EMC（电磁兼容）设计与测试案例分析 郑军奇编著 电子工业出版社&gt;</strong></p>\n<p><strong>看书的时候整理了一下导图无私分享下：</strong></p>\n<div class=\"cnblogs_Highlighter\">\n<pre class=\"brush:csharp;gutter:true;\">git@gitee.com:qian-qiang/book-map.git\n</pre>\n</div>\n<p>&nbsp;</p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<blockquote>EMC=EMI+EMS</blockquote>\n<h1>1：理论概念</h1>\n<h2>1.1时域和频域</h2>\n<p>建议通过示波器的FFT变换去了解时域和频域的概念</p>\n<h2>1.2分贝</h2>\n<p>电磁兼容测试中常用单位：</p>\n<p>&nbsp; 　　功率：P<sub>db</sub>=10lg(p1/p2) P2与P1应采用相同的单位。应该明确dB为两个量的比值，是无量纲的。<br>&nbsp;　　 电压:&nbsp; 同上 电压分贝常用&mu;V为单位<br>&nbsp; 　　电流：同上 以&mu;A为单位的电流。</p>\n<p>　　&nbsp; 电场强度与磁场强度：H=E/Z <br>&nbsp; 　　功率密度：S=E X H&nbsp;&nbsp;&nbsp; 功率密度的基本单位为W/m2(电场强度V／m;磁场强度A/m),<br>功率密度的物理作用比较难理解 提供一个关系来理解：后面的db数值和一个叫自由空间波阻抗的概念有关</p>\n<pre>\n    <code class=\"yaml\">\n在自由空间，功率密度S与电场强度E的关系化为分贝：\nSdB（W/m2）=EdB（V/m） &ndash; 25.8dB    \nSdB（mW/cm2）=EdB（&mu;V/m） &ndash; 155.8dB  \nSdB（&mu;W/cm2）=EdB（&mu;V/m） &ndash; 125.8dB\n    </code>\n</pre>\n<h2>&nbsp;1.3电场和磁场</h2>\n<p>高中概念E/H场正交同时传播 建议了解下<strong>天线模型</strong></p>\n<h2>&nbsp;1.4共模和差模</h2>\n<p>电压和电流的变化通过通过导线传输时有两中形态，即&ldquo;差模&rdquo;和&ldquo;共模&rdquo; 。 这里我们把这两根线比喻成两个小人，一个MM，一个GG。来张图，形象点</p>\n<p><img src=\"/2023/04/emc-emi/2023-04-04_19-28-04.png\" alt></p>\n<p>这里是两个人MM和GG，他们俩都会飞，他们手牵手飞到离地面10米的位置，那他们对地的高度即为共模信号，当他们俩一个想飞高点一个想飞低点时，这时候他们牵着飞手就会感受到拉力，这就是差模信号。也就是说这两个人是对差模信号有响应的，对共模信号没有响应。理论上讲这两个人只对差模有响应而对共模没有响应。但你让这俩人往地底下飞试试，那就苦命鸳鸯，撞死了。地下不行就去遨游太空啊，行，还是苦命鸳鸯，没空气憋死了。所以共模信号也有一定的共模范围的。差模信号也有一定差模范围。</p>\n<p>借助上面的比喻来系统理解下几个基础的概念：</p>\n<pre>\n    <code class=\"yaml\">\n借助上面的比喻来系统理解下几个基础的概念：\n共模电压：在每一导体和所规定的参照点之间（往往是大地或机架）出现的相量电压平均值。或者说同时加在电压表两测量端和规定公共端之间的那部分输出电压。\n\n<p>差模电压：一组规定的带电导体中任意两根之间的电压。使差模电压又称对称电压。</p>\n<p>共模干扰：干扰电压在信号线及其回线（一般称为信号地线）上的幅度相同，这里的电压以附近任何一个物体（大地、金属机箱、参考地线板等）为参考电位，干扰电流回路则是在导线与参考物体构成的回路中流动。<br>简明说就是信号线到地的回路干扰。</p>\n<p>差模干扰：干扰电压存在于信号线及其回线（一般称为信号地线）之间，干扰电流回路则是在导线与参考物体构成的回路中流动。<br>简明说就是信号线到信号线的回路干扰。<br>    </p></code><br></pre><p></p>\n<h1>2：简介</h1>\n<h2>2.1：电磁干扰形成的三要素</h2>\n<p>形成电磁干扰必然具备三个基本要素:<br>①电磁骚扰源，<br>②耦合途径或传播通道，<br>③敏感设备。<br>电磁兼容设计即是从这三个基本要素出发。<br><img src=\"/2023/04/emc-emi/2023-04-04_19-30-08.png\" alt></p>\n<p>所以我们可以从3个路径来解决emc问题：1干掉干扰源 2解决传播途径问题 3优化敏感设备</p>\n<h2>2.2：电磁骚扰的传播途径</h2>\n<p>电磁骚扰的传播途径包括传导耦合（传导耦合包括互传导耦合和导线间的感性与容性耦合）和辐射耦合<br>（辐射耦合包括近场耦合和远场耦合）<br><img src=\"/2023/04/emc-emi/2023-04-04_19-31-27.png\" alt></p>\n<h1>3：EMC测试类型</h1>\n<blockquote>\n<p>由于前几天做的是辐射测试这里只对EMI的辐射发射测试做分析介绍</p>\n\n</blockquote>\n<p data-pid=\"hw0JtPdM\">EMI测试项目包括：</p>\n<p data-pid=\"ajAvvm_K\">1、辐射发射测试</p>\n<p data-pid=\"aMKdQ727\">2、传导发射测试</p>\n<p data-pid=\"V4hfmcc8\">3、骚扰功率测试</p>\n<p data-pid=\"HlkauZDq\">4、电流谐波测试</p>\n<p data-pid=\"iKa3kjf2\">5、电源谐波测量</p>\n<p data-pid=\"qa38dtwO\">6、闪烁测试</p>\n<p data-pid=\"ufgEgLKt\">EMS测试项目包括：</p>\n<p data-pid=\"yJxWLW6l\">1、静电放电抗扰度</p>\n<p data-pid=\"cY_CdNFF\">2、射频电磁场抗扰度</p>\n<p data-pid=\"w_TvMw5R\">3、电快速瞬变脉冲群抗扰度</p>\n<p data-pid=\"VAiXwT4K\">4、冲击（包括雷击和浪涌）抗扰度</p>\n<p data-pid=\"4njCrycj\">5、射频场感应传导抗扰度</p>\n<p data-pid=\"_pVOSVWw\">6、工频磁场抗扰度试验</p>\n<p data-pid=\"Ejw7z-1t\">7、电压跌落短时中断和电压渐降抗扰度</p>\n<p data-pid=\"Ejw7z-1t\">具体测试方法请看《EMC设计与测试案列分析》</p>\n<h1>4：辐射发射测试</h1>\n<h2>4.1辐射发射测试的目的</h2>\n<p>　　因为EMC设计及EMC问题的分析是建立在EMC测试的基础上的，所以有必要对EMC测试做简单的阐述。测试电子，电气和机电设备及其部件的辐射发射，包括来自所有组件、电缆及连接线上的辐射发射。它用来鉴定其辐射是否符合标准的要求，以致在正常使用过程中影响同一环境中的其他设备。</p>\n<h2>4.2 常用的辐射发射测试设备</h2>\n<p>根据常用传导骚扰测试标准CISPR16及EN55022的要求，辐射发射测试主要需要以下设备：</p>\n<p>（1） EMI自动测试控制系统（电脑及其界面单元）；(2) EMI测试接收机;</p>\n<p>（3）各式天线（主动、被动棒状天线、大小形状环路天线、功率双锥天线、对数螺旋天线、喇叭天线）及天线控制单元等；</p>\n<p>&nbsp; (4)半电波暗室或开阔场。</p>\n<p>EMI测试接收机是EMC测试中最常用的基本测试仪器，基于测试接收机的频率响应特性要求，按CISPR16标准规定，测试接收机应有四种基本检波方式，即准峰值检波、均方根值检波、峰值检波及平均值检波。然而，大多数电磁干扰都是脉冲干扰，它们对音频影响的客观效果随着重复频率的增高而增大，具有特定时间常数的准峰值检波器的输出特性，可以近似反映这种影响。</p>\n<h2>4.3 辐射发射的测试方法</h2>\n<p>下图是符合CISPR16及EN55022标准要求的辐射发射测试布置图。辐射发射测试时，被测设备（EUT）置于半电波暗室内部，并在转台上旋转，以找到最大的辐射点。辐射信号由接收天线接收后，通过电缆传到电波暗室外的接收机。</p>\n<p><img src=\"/2023/04/emc-emi/2023-04-04_19-32-29.png\" alt></p>\n<h1>5：整改</h1>\n<p><em><strong>常见的电磁兼容整改措施：</strong></em><br>&nbsp;　　对常见的电磁兼容问题，我们通过综合采用以下几个方面的整改措施，一般可以解决大部分的问题：<br>屏蔽问题：<br>&nbsp;　　可以在屏蔽体的装配面处涂导电胶，或者在装配面处加导电衬垫，甚至采用导电金属胶带进行补救。<br>&nbsp;　　导电衬垫可以是编织的金属丝线、硬度较低易于塑型的软金属(铜、铅等)、包装金属层的橡胶、导电橡胶或者是梳状簧片接触指状物等。<br>布局布线问题：<br>&nbsp;　　在不影响性能的前提下，适当调整设备电缆走向和排列，做到不同类型的电缆相互隔离。<br>电缆问题：<br>&nbsp;　　改变普通的小信号或高频信号电缆为带屏蔽的电缆，改变普通的大电流信号或数据传输信号电缆为对称绞线电缆。</p>\n<p>接地问题：<br>　　加强接地的机械性能，降低接地电阻。同时对于设备整体要有单独的低阻抗接地。<br>接口问题：<br>&nbsp;　　在设备电源输入线上加装或串联电源滤波器。<br>关键部位的处理：<br>&nbsp;　　在可能的情况下，对重要器件进行屏蔽、隔离处理，如加装接地良好的金属隔离板或小的屏蔽罩等。<br>电路和电源问题：<br>&nbsp;　　在各器件电源输入端并联小电容，以旁路电源带来的高频干扰。</p>\n<p>现在就对我们遇到的问题做分析：电磁骚扰发射：分为传导发射（连续发射和断续发射）和辐射发射（骚扰场强和骚扰功率）</p>\n<p><em><strong>针对电磁骚扰发射测试常见问题对策及整改措施</strong></em></p>\n<p>1：产品内主要电磁骚扰源分析（电源/电机/电路板/高频器件？）</p>\n<p>2：骚扰源定位（这里我们出现了一个错误后面介绍）</p>\n<p>3：产品连续传导发射超标问题及对策</p>\n<p>4：产品断续传导发射超标问题及对策</p>\n<p>5：产品辐射骚扰超标问题及对策</p>\n<p>6：骚扰功率干扰的产生和对策</p>\n<h2>5.1：主要电磁骚扰源</h2>\n<p>a:设备开关电源的开关回路：骚扰源主频几十kHz到百余kHz，高次谐波可延伸到数十MHz。<br>b:设备直流电源的整流回路：工频线性电源工频整流噪声频率上限可延伸到数百kHz；开关电源高频整流噪声频率上限可延伸到数十MHz。<br>&nbsp;c:电动设备直流电机的电刷噪声：噪声频率上限可延伸到数百MHz。<br>&nbsp;d:电动设备交流电机的运行噪声：高次谐波可延伸到数十MHz。<br>&nbsp;e:变频调速电路的骚扰发射：开关调速回路骚扰源频率从几十kHz到几十MHz。<br>&nbsp;f:设备运行状态切换的开关噪声：由机械或电子开关动作产生的噪声频率上限可延伸到数百MHz。<br>&nbsp;g:智能控制设备的晶振及数字电路电磁骚扰：骚扰源主频几十kHz到几十MHz，高次谐波可延伸到数百MHz。<br>&nbsp;等等.................</p>\n<h2>5.2：骚扰源定位</h2>\n<p><strong>根据测量曲线定位</strong>：依据：超标骚扰频率范围、超标骚扰频域分布、窄带还是宽带骚扰等来判断<br><br><img src=\"/2023/04/emc-emi/2023-04-04_19-32-59.png\" alt></p>\n<p><img src=\"/2023/04/emc-emi/2023-04-04_19-33-05.png\" alt></p>\n<p><strong>根据被测设备工作方式和内部结构定位</strong>：</p>\n<p>a:有没有使用标准不建议使用的半波整流和对称/非对称电源调整电路?<br>b:内部结构中电路板布局是否合理?<br>c:内部电缆走线是否合理?</p>\n<p>d:内部滤波器（滤波电路）安装是否合理?<br>e:内部电路接地和搭接方式是否合理?<br>f:机箱屏蔽是否满足对应产品的需求?</p>\n<p><br><strong>根据功能模块工作情况进行故障定位</strong><br>a:若设备的各个模块可以暂停和恢复工作，可以通过逐个暂停这些模块的工作来判断骚扰来源。<br>b:若模块不可以独立暂停和恢复工作，可以通过与该设备其它功能模块一起组合进行暂停和恢复工作，从而判断骚扰的大概来源。<br>c:若模块不可以独立暂停和恢复工作，也可以通过用待判断模块与其它合格设备的相关功能模块组合并测量的方式，从而判断骚扰的大概来源。<br>d:对怀疑骚扰超标的模块，可以用与合格模块置换的方式来进行骚扰判定。<br>但是需要注意的是不能测试完一个模块发现没有起到作用又将这个模块恢复到初始状态 这个时候应该保持更改不变 继续下一个模块的排查，我们在最初的排查过程中就犯了这个错误，导致浪费了测试时间。<br>下面去个例子说明：</p>\n<p>　　假设一个系统在测试时出现了辐射发射超标，使系统不能满足EMC标准中对辐射发射的限值。经过初步分析，原因可能有4个，它们分别是：</p>\n<p>（1）主机与键盘之间的互连电缆（电缆1）上的共模电流产生的辐射；</p>\n<p>（2）主机与打印机之间的互连电缆（电缆2）上的共模电流产生的辐射；</p>\n<p>（3）机箱面板与机箱基体之间的缝隙（开口1）产生的泄漏；</p>\n<p>（4）某显示窗口（开口2）产生的泄漏。</p>\n<p>在诊断时，首先在电缆1上套一个铁氧体磁环，以减小共模辐射，结果发现频谱仪屏幕上显示的信号并没有明显减小。于是认为电缆1不是一个主要的泄漏源，将铁氧体磁环取下，套在电缆2上，结果发现频谱仪屏幕上显示的信号还没有明显减小。结果得出结论，电缆不是泄漏源。</p>\n<p>再对机箱上的泄漏进行检查。用屏蔽胶带将开口1堵上，发现频谱仪屏幕上显示的信号没有明显减小。认为开口1不是主要泄漏源，将屏蔽胶带取下，堵到开口2上。结果频谱仪上的显示信号还没有减小。之所以会发生这个问题，是因为测试人员忽视了频谱分析仪上显示的信号幅度是以dB为单位显示的。下面看一下为什么会有这种现象。</p>\n<p>假设这4个泄漏源所占的成分各占1／4，并且在每个辐射源上采取的措施能够将这个辐射源完全抑制掉，则采取以上4个措施中的一个时，频谱仪上显示信号降低的幅度&Delta;A为</p>\n<p>&Delta;A=20lg(4/3)=2.5 dB</p>\n<p>幅度减小这么少，显然是微不足道的。但这却已经将泄漏减少了25％。</p>\n<p>正确的方法是，在对一个可能的泄漏源采取了抑制措施后，即使没有明显的改善，也不要将这个措施去掉，继续对可能的泄漏源采取措施。当采取到某个措施时，如果干扰幅度降低很多，并不一定说明这个泄漏源是主要的，而仅说明这个干扰源是最后一个。按照这个步骤对4个泄漏源逐个处理的结果如图</p>\n\n<img src=\"/2023/04/emc-emi/2023-04-04_19-33-48.png\" alt>\n<p>在前面的叙述中，假定对某个泄漏源采取措施后，这个泄漏源被100％消除掉，如果这样，当最后一个泄漏源去掉后，电磁干扰的减小应为无限大。实际这是不可能的。在采取任何一个措施时，都不可能将干扰源100％消除。泄漏源去掉的程度可以是99％，或99.9％，甚至99.99％以上，而绝不可能是100％，所以当最后一个泄漏源去掉后，尽管改善很大，但仍是有限值。</p>\n<h2>5.3：连续传导发射超标问题及对策</h2>\n<p><strong>连续传导骚扰的主要来源：</strong></p>\n<p>a:开关电源的开关频率及谐波骚扰<br>b:电源整流回路的整流噪声<br>c:交流电机的运行噪声</p>\n<p>d:直流电机的电刷噪声</p>\n<p>e:智能控制设备的晶振</p>\n<p>f:数字电路电磁骚扰<br><strong>导致射频传导发射超标的原因如图所示:</strong><br><img src=\"/2023/04/emc-emi/2023-04-04_19-34-25.png\" alt></p>\n<p>（1）开关电源或DC/DC变换器工作在脉冲状态，它们本身会产生很强的干扰，这种干扰既有共模分量，也有差模分量。对于一般开关电源和变换器，在1MHz以下以差模干扰为主，在1MHz以上以共模干扰为主。<br>（2）数字电路的工作电流是瞬变的，虽然在每个电路芯片的旁边和线路板上都安装了解耦电容，但还是会有一部分瞬变电流反映在电源中，沿着电源线传导发射。<br>（3）机箱内的线路板、电缆都是辐射源，这些辐射能量会感应进电源线和电源电路本身，形成传导发射。需要注意的是，当机箱内各种频率的信号耦合进电源电路时，由于电源内有许多二极管、三极管电路，会使这些不同频率的信号相互发生混频、调制，甚至对干扰进行放大，从而导致严重的干扰。<br><strong>解决方法：</strong></p>\n<p>在电源线入口处安装电源线滤波器是保证通过射频传导发射试验的唯一方法（滤波器的安装位置也很重要）。<br>如果仅做150kHz~30MHz范围内的传导发射试验，一般的电源线滤波器就可以满足要求，大部分电源线滤波器在100kHz以上都已有较大的插入损耗。由于30MHz以上的高频性能不良会导致辐射发射的问题，所以应加以注意。如果需要做30~300MHz频率范围内的骚扰功率发射试验或30~1GHz频率范围内的辐射骚扰，选择滤波器时必须注意滤波器的高频特性。</p>\n<p>对电源线的处理：<br>（1）检查电源线附近有无信号电缆存在，有无可能是因为信号电缆与电源线之间的耦合使电源线的传导骚扰发射超标（这种情况多见于超标频率的频段较高的情况下）。如有，或拉大两者间的距离，或采取屏蔽措施。<br>（2）加装电源线滤波器（如果已经有滤波器。则换用高性能的滤波器），要特别注意安装位置（尽可能放在机箱中电源线入口端）和安装情况，要保证滤波器外壳与机箱搭接良好、接地良好。<br>（3）虽经采取措施，设备传导骚扰发射仍未达标。此时可考虑在设备内部线路连接接地端子的地方串入一个电感。由于这部分连接属单点接地，平时无电流流过，因此这个电感可以做得较大，而无需担心有铁芯的饱和问题。<br>采取这一措施的理由是设备传导骚扰发射测试实际上是对地电压测试（电源线对大地的骚扰电压测试），电源线上有工作电流流过，故滤波器的滤波电感值受制于工作电流，不能做得很大，滤波器的插入损耗也就有限，特别是低频端损耗更加有限。新方案里的附加电感正好可以弥补这一缺憾，从而取得更好的传导骚扰抑制能力。<br>对信号线的处理：<br>（1）注意信号线周围有无其他辐射能量（附近的布线及印刷板的布局）被引到信号线上。如有，或拉大两者的距离，或采取屏蔽措施，或考虑改变设备内部布局和印刷板的布局。<br>（2）在信号线上套铁氧体磁环（或铁氧体磁夹）。<br>（3）对信号线进行共模滤波，必要时采用滤波连接器（或滤波阵列板）。注意滤波器的参数，传导骚扰发射超标的频率比辐射骚扰发射超标的频率应低些，因此取用的元件参数应当偏大一些</p>\n<h2>5.4：断续传导发射超标问题及对策</h2>\n<p><strong>断续传导骚扰的主要来源：</strong></p>\n<p>a:恒温控制器具，程序自动的机器和其他电气控制或操作的器具的开关操作会产生断续骚扰。此类操作一般通过继电器和程控电子/机械开关等实现。此类骚扰一般由继电器、开关的触点抖动及非纯阻负载通断所产生的电涌冲击形成。<br><strong>解决方法：</strong><br>从内部电路和结构上考虑，减少其断续骚扰，使其满足测量要求。<br>从电源电路和电源结构入手，在电源中采取适当的措施，对内部电路产生的断续骚扰加以抑制，使其满足测量标准的要求。<br>a:在开关触点或开关模块两端并联高频电容或RC、DRC吸波网络，吸收开关抖动脉冲及非阻性负载的浪涌脉冲。 同时应留意这些元器件的耐压和功率承受能力应满足设备正常工作的要求。<br>b:对被供电设备内通过程控开关控制的非阻性部件的供电回路上增加限流电路或软启动装置，抑制其启动浪涌冲击。<br>c:对被供电设备内通过开关量控制的感性部件应增加反向浪涌吸收元件，以吸收部件断电时产生的反向感应高压浪涌冲击。<br>d:在被供电设备的电源输入端增加高频吸收回路，抑制其高频骚扰向电源反向注入。</p>\n<h2>5.5：辐射骚扰超标问题及对策</h2>\n<p><strong>辐射骚扰的主要骚扰来源:</strong><br>a:开关电源的开关频率及谐波骚扰<br>b:交流电机的运行噪声、直流电机的电刷噪声<br>c:电磁感应设备的电磁骚扰<br>d:智能控制设备的晶振及数字电路电磁骚扰等</p>\n<p>导致辐射发射试验失败的原因有两种可能最大：</p>\n<p>　　一种是设备外壳的屏蔽性能不完善；<br>　　另一种是射频骚扰经由电源线和其他线缆的逸出。<br><br><strong>解决方法：</strong><br><img src=\"/2023/04/emc-emi/2023-04-04_19-35-03.png\" alt></p>\n<p>当我们通过骚扰定位方式找到辐射骚扰超标点的骚扰源后，即可采用相对应的骚扰源抑制措施。<br>一般来说：<br>首先抑制骚扰源，这可以通过优化电路设计、电路结构和排版，加强滤波和正确的接地来达到。<br>其次是要切断耦合途径，这可以通过正确的机壳屏蔽和传输线滤波达到。<br><strong>首先说下机箱问题：</strong></p>\n<p>一、金属机箱屏蔽性能不完善（非金属机箱还没碰到不做讨论）<br>对于金属机箱屏蔽性能不完善引起的辐射骚扰发射超标，应采取以下措施：<br>1）机箱的缝隙过大，或机箱配合上存在问题<br>　处理意见：<br>（1）清除结合面上的油漆、氧化层及表面玷污；<br>（2）增加结合面上的紧固件数目及接触表面的平整度；<br>（3）采取永久性的接缝（要连续焊接）；<br>（4）采用导电衬垫来改善接触表面的接触性能。<br>2）其他功能性开孔过大<br>处理意见：<br>（1）通风口采用防尘板，必要时采用波导通风板，但后者成本昂贵；<br>（2）显示窗口采用带有屏蔽作用的透明材料；或采用隔舱，并对信号线采取滤波措施；<br>（3）对键盘等采用隔舱，并对信号线采取滤波措施。<br>3）机箱内部布线不当，电磁骚扰透过缝隙逸出<br>处理意见：<br>&nbsp; 将印刷板及设备内部布线等可能产生辐射骚扰的布局，远离缝隙或功能性开孔的部位，<br>&nbsp; 或采取增加屏蔽的补救措施或重新布局。<br><strong>其次说下线缆问题：</strong><br>1）对电源线的处理<br>（1）加装电源线滤波器（如果己经有滤波器，则换用高性能的滤波器），要特别注意安装位置（尽可能放在机箱中电源线入口端）和安装情况，要保证滤波器外壳与机箱搭接良好、接地良好；<br>（2）如果不合格的频率比较高，可考虑在电源线入口的部分套装铁氧体磁环。<br>2）对信号线的处理<br>（1）在信号线上套铁氧体磁环（或铁氧体磁夹）；<br>（2）对信号线滤波（共模滤波），必要时将连接器改用滤波阵列板或滤波连接器；<br>（3）换用屏蔽电缆，屏蔽电缆的屏蔽层与机箱尽量采用360&deg;搭接方式，必要时在屏蔽线上再套铁氧体磁环</p>\n<h2>5.6：骚扰功率干扰的产生和对策</h2>\n<p><strong>骚扰功率的主要来源：</strong></p>\n<p>a:电源线滤波装置的高频插入损耗不足</p>\n<p><strong>解决方法：</strong></p>\n<p>（1）滤波器电路没有屏蔽，这种情况经常发生在将滤波电路安装在线路板上的场合，高频干扰直接耦合进滤波电路，造成滤波器失效；<br>（2）滤波器本身高频性能不良，在100MHz以上插入损耗很小；<br>（3）使用非屏蔽机箱，导致滤波器的金属外壳无处端接；<strong><br></strong>（4）使用非屏蔽机箱，干扰直接耦合到电源线和信号线上，滤波器实际上没有起作用；<br>（5）在屏蔽机箱中，滤波器离电源进口过远、造成干扰直接耦合到电源线和信号线上；<br>（6）在屏蔽机箱中，滤波器外壳与金属机箱之间连接阻抗过大（没有直接搭接，而是通过长导线连接）；<br>（7）滤波器的输入线与输出线靠得很近，发生耦合，导致滤波器的高频插人损耗不足。<strong><br><br></strong></p>\n<p><strong>参考书籍:&lt;EMC（电磁兼容）设计与测试案例分析 郑军奇编著 电子工业出版社&gt;</strong></p>\n<p><strong>看书的时候整理了一下导图无私分享下：</strong></p>\n<div class=\"cnblogs_Highlighter\">\n<pre class=\"brush:csharp;gutter:true;\">git@gitee.com:qian-qiang/book-map.git\n</pre>\n</div>\n<p>&nbsp;</p>\n"},{"title":"腾格里","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-04-28T05:15:39.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"\n![6.jpg](6.jpg)\n![4.jpg](4.jpg)\n![5.jpg](5.jpg)\n![IMG_6912.JPG](IMG_6912.JPG)\n![1.jpg](1.jpg)\n![3.jpg](3.jpg)\n![2.jpg](2.jpg)\n![IMG_7069.JPG](IMG_7069.JPG)\n![IMG_6899.JPG](IMG_6899.JPG)\n","source":"_posts/2023/04/ten-ge-li.md","raw":"---\ntitle: 腾格里\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-04-28 13:15:39\npassword:\nsummary:\ntags:\n- gallery-腾格里\ncategories:\n- gallery\nkeywords:\ndescription:\n---\n\n![6.jpg](6.jpg)\n![4.jpg](4.jpg)\n![5.jpg](5.jpg)\n![IMG_6912.JPG](IMG_6912.JPG)\n![1.jpg](1.jpg)\n![3.jpg](3.jpg)\n![2.jpg](2.jpg)\n![IMG_7069.JPG](IMG_7069.JPG)\n![IMG_6899.JPG](IMG_6899.JPG)\n","slug":"ten-ge-li","published":1,"updated":"2023-04-28T06:45:42.210Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk69d1d7000ojsrjakxhwll9","content":"<p><img src=\"/2023/04/ten-ge-li/6.jpg\" alt=\"6.jpg\"><br><img src=\"/2023/04/ten-ge-li/4.jpg\" alt=\"4.jpg\"><br><img src=\"/2023/04/ten-ge-li/5.jpg\" alt=\"5.jpg\"><br><img src=\"/2023/04/ten-ge-li/IMG_6912.JPG\" alt=\"IMG_6912.JPG\"><br><img src=\"/2023/04/ten-ge-li/1.jpg\" alt=\"1.jpg\"><br><img src=\"/2023/04/ten-ge-li/3.jpg\" alt=\"3.jpg\"><br><img src=\"/2023/04/ten-ge-li/2.jpg\" alt=\"2.jpg\"><br><img src=\"/2023/04/ten-ge-li/IMG_7069.JPG\" alt=\"IMG_7069.JPG\"><br><img src=\"/2023/04/ten-ge-li/IMG_6899.JPG\" alt=\"IMG_6899.JPG\"></p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<p><img src=\"/2023/04/ten-ge-li/6.jpg\" alt=\"6.jpg\"><br><img src=\"/2023/04/ten-ge-li/4.jpg\" alt=\"4.jpg\"><br><img src=\"/2023/04/ten-ge-li/5.jpg\" alt=\"5.jpg\"><br><img src=\"/2023/04/ten-ge-li/IMG_6912.JPG\" alt=\"IMG_6912.JPG\"><br><img src=\"/2023/04/ten-ge-li/1.jpg\" alt=\"1.jpg\"><br><img src=\"/2023/04/ten-ge-li/3.jpg\" alt=\"3.jpg\"><br><img src=\"/2023/04/ten-ge-li/2.jpg\" alt=\"2.jpg\"><br><img src=\"/2023/04/ten-ge-li/IMG_7069.JPG\" alt=\"IMG_7069.JPG\"><br><img src=\"/2023/04/ten-ge-li/IMG_6899.JPG\" alt=\"IMG_6899.JPG\"></p>\n"},{"title":"上海","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-04-02T15:09:12.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"\n![20230403160820.jpg](20230403160820.jpg)\n![20230403160809.jpg](20230403160809.jpg)\n![20230403160752.jpg](20230403160752.jpg)\n![20230403160815.jpg](20230403160815.jpg)\n","source":"_posts/2023/04/上海.md","raw":"---\ntitle: 上海\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-04-02 23:09:12\npassword:\nsummary:\ntags:\n- gallery-上海\ncategories:\n- gallery\nkeywords:\ndescription:\n---\n\n![20230403160820.jpg](20230403160820.jpg)\n![20230403160809.jpg](20230403160809.jpg)\n![20230403160752.jpg](20230403160752.jpg)\n![20230403160815.jpg](20230403160815.jpg)\n","slug":"上海","published":1,"updated":"2023-04-04T09:24:10.147Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk69d1d9000tjsrjllaqn27b","content":"<p><img src=\"/2023/04/shang-hai/20230403160820.jpg\" alt=\"20230403160820.jpg\"><br><img src=\"/2023/04/shang-hai/20230403160809.jpg\" alt=\"20230403160809.jpg\"><br><img src=\"/2023/04/shang-hai/20230403160752.jpg\" alt=\"20230403160752.jpg\"><br><img src=\"/2023/04/shang-hai/20230403160815.jpg\" alt=\"20230403160815.jpg\"></p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<p><img src=\"/2023/04/shang-hai/20230403160820.jpg\" alt=\"20230403160820.jpg\"><br><img src=\"/2023/04/shang-hai/20230403160809.jpg\" alt=\"20230403160809.jpg\"><br><img src=\"/2023/04/shang-hai/20230403160752.jpg\" alt=\"20230403160752.jpg\"><br><img src=\"/2023/04/shang-hai/20230403160815.jpg\" alt=\"20230403160815.jpg\"></p>\n"},{"title":"如何写一份需求","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-04-17T03:30:46.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"# Q：如何写好一个需求\n\n**使用以下模板写出滴滴出行软件的需求**\n![模板](业务功能-业务流程-业务规则分析/模板.png)\n\n# A：迭代需求\n## 第一版（分析起步）\n\n![分析起步](业务功能-业务流程-业务规则分析/分析起步.png)\n\t\n## 第二版（主干流程）\n\n![主干流程](业务功能-业务流程-业务规则分析/主干流程.png)\n\n## 第三版（探索分支）\n\n![探索分支](业务功能-业务流程-业务规则分析/探索分支.png)\n\n## 第四版（穷尽分支）\n\n![穷尽分支](业务功能-业务流程-业务规则分析/穷尽分支.png)\n\n## 第五版（业务规则）\n\n![业务规则](业务功能-业务流程-业务规则分析/业务规则.png)\n\n\n","source":"_posts/2023/04/业务功能-业务流程-业务规则分析.md","raw":"---\ntitle: 如何写一份需求\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-04-17 11:30:46\npassword:\nsummary:\ntags: Embedded system\ncategories: Embedded system\nkeywords:\ndescription:\n---\n# Q：如何写好一个需求\n\n**使用以下模板写出滴滴出行软件的需求**\n![模板](业务功能-业务流程-业务规则分析/模板.png)\n\n# A：迭代需求\n## 第一版（分析起步）\n\n![分析起步](业务功能-业务流程-业务规则分析/分析起步.png)\n\t\n## 第二版（主干流程）\n\n![主干流程](业务功能-业务流程-业务规则分析/主干流程.png)\n\n## 第三版（探索分支）\n\n![探索分支](业务功能-业务流程-业务规则分析/探索分支.png)\n\n## 第四版（穷尽分支）\n\n![穷尽分支](业务功能-业务流程-业务规则分析/穷尽分支.png)\n\n## 第五版（业务规则）\n\n![业务规则](业务功能-业务流程-业务规则分析/业务规则.png)\n\n\n","slug":"业务功能-业务流程-业务规则分析","published":1,"updated":"2023-04-17T05:52:57.687Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk69d1e6001pjsrjtf8tagtq","content":"<h1 id=\"Q：如何写好一个需求\"><a href=\"#Q：如何写好一个需求\" class=\"headerlink\" title=\"Q：如何写好一个需求\"></a>Q：如何写好一个需求</h1><p><strong>使用以下模板写出滴滴出行软件的需求</strong><br><img src=\"/2023/04/ye-wu-gong-neng-ye-wu-liu-cheng-ye-wu-gui-ze-fen-xi/%E6%A8%A1%E6%9D%BF.png\" alt=\"模板\"></p>\n<h1 id=\"A：迭代需求\"><a href=\"#A：迭代需求\" class=\"headerlink\" title=\"A：迭代需求\"></a>A：迭代需求</h1><h2 id=\"第一版（分析起步）\"><a href=\"#第一版（分析起步）\" class=\"headerlink\" title=\"第一版（分析起步）\"></a>第一版（分析起步）</h2><p><img src=\"/2023/04/ye-wu-gong-neng-ye-wu-liu-cheng-ye-wu-gui-ze-fen-xi/%E5%88%86%E6%9E%90%E8%B5%B7%E6%AD%A5.png\" alt=\"分析起步\"></p>\n<h2 id=\"第二版（主干流程）\"><a href=\"#第二版（主干流程）\" class=\"headerlink\" title=\"第二版（主干流程）\"></a>第二版（主干流程）</h2><p><img src=\"/2023/04/ye-wu-gong-neng-ye-wu-liu-cheng-ye-wu-gui-ze-fen-xi/%E4%B8%BB%E5%B9%B2%E6%B5%81%E7%A8%8B.png\" alt=\"主干流程\"></p>\n<h2 id=\"第三版（探索分支）\"><a href=\"#第三版（探索分支）\" class=\"headerlink\" title=\"第三版（探索分支）\"></a>第三版（探索分支）</h2><p><img src=\"/2023/04/ye-wu-gong-neng-ye-wu-liu-cheng-ye-wu-gui-ze-fen-xi/%E6%8E%A2%E7%B4%A2%E5%88%86%E6%94%AF.png\" alt=\"探索分支\"></p>\n<h2 id=\"第四版（穷尽分支）\"><a href=\"#第四版（穷尽分支）\" class=\"headerlink\" title=\"第四版（穷尽分支）\"></a>第四版（穷尽分支）</h2><p><img src=\"/2023/04/ye-wu-gong-neng-ye-wu-liu-cheng-ye-wu-gui-ze-fen-xi/%E7%A9%B7%E5%B0%BD%E5%88%86%E6%94%AF.png\" alt=\"穷尽分支\"></p>\n<h2 id=\"第五版（业务规则）\"><a href=\"#第五版（业务规则）\" class=\"headerlink\" title=\"第五版（业务规则）\"></a>第五版（业务规则）</h2><p><img src=\"/2023/04/ye-wu-gong-neng-ye-wu-liu-cheng-ye-wu-gui-ze-fen-xi/%E4%B8%9A%E5%8A%A1%E8%A7%84%E5%88%99.png\" alt=\"业务规则\"></p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<h1 id=\"Q：如何写好一个需求\"><a href=\"#Q：如何写好一个需求\" class=\"headerlink\" title=\"Q：如何写好一个需求\"></a>Q：如何写好一个需求</h1><p><strong>使用以下模板写出滴滴出行软件的需求</strong><br><img src=\"/2023/04/ye-wu-gong-neng-ye-wu-liu-cheng-ye-wu-gui-ze-fen-xi/%E6%A8%A1%E6%9D%BF.png\" alt=\"模板\"></p>\n<h1 id=\"A：迭代需求\"><a href=\"#A：迭代需求\" class=\"headerlink\" title=\"A：迭代需求\"></a>A：迭代需求</h1><h2 id=\"第一版（分析起步）\"><a href=\"#第一版（分析起步）\" class=\"headerlink\" title=\"第一版（分析起步）\"></a>第一版（分析起步）</h2><p><img src=\"/2023/04/ye-wu-gong-neng-ye-wu-liu-cheng-ye-wu-gui-ze-fen-xi/%E5%88%86%E6%9E%90%E8%B5%B7%E6%AD%A5.png\" alt=\"分析起步\"></p>\n<h2 id=\"第二版（主干流程）\"><a href=\"#第二版（主干流程）\" class=\"headerlink\" title=\"第二版（主干流程）\"></a>第二版（主干流程）</h2><p><img src=\"/2023/04/ye-wu-gong-neng-ye-wu-liu-cheng-ye-wu-gui-ze-fen-xi/%E4%B8%BB%E5%B9%B2%E6%B5%81%E7%A8%8B.png\" alt=\"主干流程\"></p>\n<h2 id=\"第三版（探索分支）\"><a href=\"#第三版（探索分支）\" class=\"headerlink\" title=\"第三版（探索分支）\"></a>第三版（探索分支）</h2><p><img src=\"/2023/04/ye-wu-gong-neng-ye-wu-liu-cheng-ye-wu-gui-ze-fen-xi/%E6%8E%A2%E7%B4%A2%E5%88%86%E6%94%AF.png\" alt=\"探索分支\"></p>\n<h2 id=\"第四版（穷尽分支）\"><a href=\"#第四版（穷尽分支）\" class=\"headerlink\" title=\"第四版（穷尽分支）\"></a>第四版（穷尽分支）</h2><p><img src=\"/2023/04/ye-wu-gong-neng-ye-wu-liu-cheng-ye-wu-gui-ze-fen-xi/%E7%A9%B7%E5%B0%BD%E5%88%86%E6%94%AF.png\" alt=\"穷尽分支\"></p>\n<h2 id=\"第五版（业务规则）\"><a href=\"#第五版（业务规则）\" class=\"headerlink\" title=\"第五版（业务规则）\"></a>第五版（业务规则）</h2><p><img src=\"/2023/04/ye-wu-gong-neng-ye-wu-liu-cheng-ye-wu-gui-ze-fen-xi/%E4%B8%9A%E5%8A%A1%E8%A7%84%E5%88%99.png\" alt=\"业务规则\"></p>\n"},{"title":"北京","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-04-17T06:02:09.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"\n![DSC01755.JPG](DSC01755.JPG)\n![DSC01687.JPG](DSC01687.JPG)\n![IMG_6717.JPG](IMG_6717.JPG)\n![DSC01645.JPG](DSC01645.JPG)\n![DSC01697.JPG](DSC01697.JPG)\n![DSC01821.JPG](DSC01821.JPG)\n![DSC01699.JPG](DSC01699.JPG)\n![DSC01827.JPG](DSC01827.JPG)\n![IMG_6716.JPG](IMG_6716.JPG)\n![DSC01722.JPG](DSC01722.JPG)\n","source":"_posts/2023/04/北京.md","raw":"---\ntitle: 北京\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-04-17 14:02:09\npassword:\nsummary:\ntags:\n- gallery-北京\ncategories:\n- gallery\nkeywords:\ndescription:\n---\n\n![DSC01755.JPG](DSC01755.JPG)\n![DSC01687.JPG](DSC01687.JPG)\n![IMG_6717.JPG](IMG_6717.JPG)\n![DSC01645.JPG](DSC01645.JPG)\n![DSC01697.JPG](DSC01697.JPG)\n![DSC01821.JPG](DSC01821.JPG)\n![DSC01699.JPG](DSC01699.JPG)\n![DSC01827.JPG](DSC01827.JPG)\n![IMG_6716.JPG](IMG_6716.JPG)\n![DSC01722.JPG](DSC01722.JPG)\n","slug":"北京","published":1,"updated":"2023-04-17T06:15:14.815Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk69d1e6001qjsrjfcp6k092","content":"<p><img src=\"/2023/04/bei-jing/DSC01755.JPG\" alt=\"DSC01755.JPG\"><br><img src=\"/2023/04/bei-jing/DSC01687.JPG\" alt=\"DSC01687.JPG\"><br><img src=\"/2023/04/bei-jing/IMG_6717.JPG\" alt=\"IMG_6717.JPG\"><br><img src=\"/2023/04/bei-jing/DSC01645.JPG\" alt=\"DSC01645.JPG\"><br><img src=\"/2023/04/bei-jing/DSC01697.JPG\" alt=\"DSC01697.JPG\"><br><img src=\"/2023/04/bei-jing/DSC01821.JPG\" alt=\"DSC01821.JPG\"><br><img src=\"/2023/04/bei-jing/DSC01699.JPG\" alt=\"DSC01699.JPG\"><br><img src=\"/2023/04/bei-jing/DSC01827.JPG\" alt=\"DSC01827.JPG\"><br><img src=\"/2023/04/bei-jing/IMG_6716.JPG\" alt=\"IMG_6716.JPG\"><br><img src=\"/2023/04/bei-jing/DSC01722.JPG\" alt=\"DSC01722.JPG\"></p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<p><img src=\"/2023/04/bei-jing/DSC01755.JPG\" alt=\"DSC01755.JPG\"><br><img src=\"/2023/04/bei-jing/DSC01687.JPG\" alt=\"DSC01687.JPG\"><br><img src=\"/2023/04/bei-jing/IMG_6717.JPG\" alt=\"IMG_6717.JPG\"><br><img src=\"/2023/04/bei-jing/DSC01645.JPG\" alt=\"DSC01645.JPG\"><br><img src=\"/2023/04/bei-jing/DSC01697.JPG\" alt=\"DSC01697.JPG\"><br><img src=\"/2023/04/bei-jing/DSC01821.JPG\" alt=\"DSC01821.JPG\"><br><img src=\"/2023/04/bei-jing/DSC01699.JPG\" alt=\"DSC01699.JPG\"><br><img src=\"/2023/04/bei-jing/DSC01827.JPG\" alt=\"DSC01827.JPG\"><br><img src=\"/2023/04/bei-jing/IMG_6716.JPG\" alt=\"IMG_6716.JPG\"><br><img src=\"/2023/04/bei-jing/DSC01722.JPG\" alt=\"DSC01722.JPG\"></p>\n"},{"title":"新疆","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-04-02T15:09:07.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"\n![a2a9265c2707c16b5a1ca704a4d0856d.JPG](a2a9265c2707c16b5a1ca704a4d0856d.JPG)\n![88a98ae85a4705294439aca39ae07d672.JPG](88a98ae85a4705294439aca39ae07d672.JPG)\n![XRBQ0574.JPG](XRBQ0574.JPG)\n![MOVG5083.JPG](MOVG5083.JPG)\n![ANKG1449.JPG](ANKG1449.JPG)\n![1b706b934fc955412e3ed163fd0b7cbc2.JPG](1b706b934fc955412e3ed163fd0b7cbc2.JPG)\n![a51d80549e7edc0d1ba69a885aa946ff2.JPG](a51d80549e7edc0d1ba69a885aa946ff2.JPG)\n![95d557eb4ef2235d74a45743be1b05842.JPG](95d557eb4ef2235d74a45743be1b05842.JPG)\n![76d386e1b8eeeb85abab758cefc855e0.JPG](76d386e1b8eeeb85abab758cefc855e0.JPG)\n![AQSR2937.JPG](AQSR2937.JPG)\n![AZQE3071.JPG](AZQE3071.JPG)\n![YJUM1401.JPG](YJUM1401.JPG)\n![89c05a76a9273811c585c395890c9f522.JPG](89c05a76a9273811c585c395890c9f522.JPG)\n![BBOD4958.JPG](BBOD4958.JPG)\n![2d25bdf0ce35910c874badcedff928002.JPG](2d25bdf0ce35910c874badcedff928002.JPG)\n![IGAX1811.JPG](IGAX1811.JPG)\n![5d0b74a8910a3abba7e860149b9d40e12.JPG](5d0b74a8910a3abba7e860149b9d40e12.JPG)\n","source":"_posts/2023/04/新疆.md","raw":"---\ntitle: 新疆\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-04-02 23:09:07\npassword:\nsummary:\ntags: \n- gallery-新疆\ncategories:\n- gallery\nkeywords:\ndescription:\n---\n\n![a2a9265c2707c16b5a1ca704a4d0856d.JPG](a2a9265c2707c16b5a1ca704a4d0856d.JPG)\n![88a98ae85a4705294439aca39ae07d672.JPG](88a98ae85a4705294439aca39ae07d672.JPG)\n![XRBQ0574.JPG](XRBQ0574.JPG)\n![MOVG5083.JPG](MOVG5083.JPG)\n![ANKG1449.JPG](ANKG1449.JPG)\n![1b706b934fc955412e3ed163fd0b7cbc2.JPG](1b706b934fc955412e3ed163fd0b7cbc2.JPG)\n![a51d80549e7edc0d1ba69a885aa946ff2.JPG](a51d80549e7edc0d1ba69a885aa946ff2.JPG)\n![95d557eb4ef2235d74a45743be1b05842.JPG](95d557eb4ef2235d74a45743be1b05842.JPG)\n![76d386e1b8eeeb85abab758cefc855e0.JPG](76d386e1b8eeeb85abab758cefc855e0.JPG)\n![AQSR2937.JPG](AQSR2937.JPG)\n![AZQE3071.JPG](AZQE3071.JPG)\n![YJUM1401.JPG](YJUM1401.JPG)\n![89c05a76a9273811c585c395890c9f522.JPG](89c05a76a9273811c585c395890c9f522.JPG)\n![BBOD4958.JPG](BBOD4958.JPG)\n![2d25bdf0ce35910c874badcedff928002.JPG](2d25bdf0ce35910c874badcedff928002.JPG)\n![IGAX1811.JPG](IGAX1811.JPG)\n![5d0b74a8910a3abba7e860149b9d40e12.JPG](5d0b74a8910a3abba7e860149b9d40e12.JPG)\n","slug":"新疆","published":1,"updated":"2023-04-04T11:45:47.620Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk69d1e7001sjsrjsn0ti7kd","content":"<p><img src=\"/2023/04/xin-jiang/a2a9265c2707c16b5a1ca704a4d0856d.JPG\" alt=\"a2a9265c2707c16b5a1ca704a4d0856d.JPG\"><br><img src=\"/2023/04/xin-jiang/88a98ae85a4705294439aca39ae07d672.JPG\" alt=\"88a98ae85a4705294439aca39ae07d672.JPG\"><br><img src=\"/2023/04/xin-jiang/XRBQ0574.JPG\" alt=\"XRBQ0574.JPG\"><br><img src=\"/2023/04/xin-jiang/MOVG5083.JPG\" alt=\"MOVG5083.JPG\"><br><img src=\"/2023/04/xin-jiang/ANKG1449.JPG\" alt=\"ANKG1449.JPG\"><br><img src=\"/2023/04/xin-jiang/1b706b934fc955412e3ed163fd0b7cbc2.JPG\" alt=\"1b706b934fc955412e3ed163fd0b7cbc2.JPG\"><br><img src=\"/2023/04/xin-jiang/a51d80549e7edc0d1ba69a885aa946ff2.JPG\" alt=\"a51d80549e7edc0d1ba69a885aa946ff2.JPG\"><br><img src=\"/2023/04/xin-jiang/95d557eb4ef2235d74a45743be1b05842.JPG\" alt=\"95d557eb4ef2235d74a45743be1b05842.JPG\"><br><img src=\"/2023/04/xin-jiang/76d386e1b8eeeb85abab758cefc855e0.JPG\" alt=\"76d386e1b8eeeb85abab758cefc855e0.JPG\"><br><img src=\"/2023/04/xin-jiang/AQSR2937.JPG\" alt=\"AQSR2937.JPG\"><br><img src=\"/2023/04/xin-jiang/AZQE3071.JPG\" alt=\"AZQE3071.JPG\"><br><img src=\"/2023/04/xin-jiang/YJUM1401.JPG\" alt=\"YJUM1401.JPG\"><br><img src=\"/2023/04/xin-jiang/89c05a76a9273811c585c395890c9f522.JPG\" alt=\"89c05a76a9273811c585c395890c9f522.JPG\"><br><img src=\"/2023/04/xin-jiang/BBOD4958.JPG\" alt=\"BBOD4958.JPG\"><br><img src=\"/2023/04/xin-jiang/2d25bdf0ce35910c874badcedff928002.JPG\" alt=\"2d25bdf0ce35910c874badcedff928002.JPG\"><br><img src=\"/2023/04/xin-jiang/IGAX1811.JPG\" alt=\"IGAX1811.JPG\"><br><img src=\"/2023/04/xin-jiang/5d0b74a8910a3abba7e860149b9d40e12.JPG\" alt=\"5d0b74a8910a3abba7e860149b9d40e12.JPG\"></p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<p><img src=\"/2023/04/xin-jiang/a2a9265c2707c16b5a1ca704a4d0856d.JPG\" alt=\"a2a9265c2707c16b5a1ca704a4d0856d.JPG\"><br><img src=\"/2023/04/xin-jiang/88a98ae85a4705294439aca39ae07d672.JPG\" alt=\"88a98ae85a4705294439aca39ae07d672.JPG\"><br><img src=\"/2023/04/xin-jiang/XRBQ0574.JPG\" alt=\"XRBQ0574.JPG\"><br><img src=\"/2023/04/xin-jiang/MOVG5083.JPG\" alt=\"MOVG5083.JPG\"><br><img src=\"/2023/04/xin-jiang/ANKG1449.JPG\" alt=\"ANKG1449.JPG\"><br><img src=\"/2023/04/xin-jiang/1b706b934fc955412e3ed163fd0b7cbc2.JPG\" alt=\"1b706b934fc955412e3ed163fd0b7cbc2.JPG\"><br><img src=\"/2023/04/xin-jiang/a51d80549e7edc0d1ba69a885aa946ff2.JPG\" alt=\"a51d80549e7edc0d1ba69a885aa946ff2.JPG\"><br><img src=\"/2023/04/xin-jiang/95d557eb4ef2235d74a45743be1b05842.JPG\" alt=\"95d557eb4ef2235d74a45743be1b05842.JPG\"><br><img src=\"/2023/04/xin-jiang/76d386e1b8eeeb85abab758cefc855e0.JPG\" alt=\"76d386e1b8eeeb85abab758cefc855e0.JPG\"><br><img src=\"/2023/04/xin-jiang/AQSR2937.JPG\" alt=\"AQSR2937.JPG\"><br><img src=\"/2023/04/xin-jiang/AZQE3071.JPG\" alt=\"AZQE3071.JPG\"><br><img src=\"/2023/04/xin-jiang/YJUM1401.JPG\" alt=\"YJUM1401.JPG\"><br><img src=\"/2023/04/xin-jiang/89c05a76a9273811c585c395890c9f522.JPG\" alt=\"89c05a76a9273811c585c395890c9f522.JPG\"><br><img src=\"/2023/04/xin-jiang/BBOD4958.JPG\" alt=\"BBOD4958.JPG\"><br><img src=\"/2023/04/xin-jiang/2d25bdf0ce35910c874badcedff928002.JPG\" alt=\"2d25bdf0ce35910c874badcedff928002.JPG\"><br><img src=\"/2023/04/xin-jiang/IGAX1811.JPG\" alt=\"IGAX1811.JPG\"><br><img src=\"/2023/04/xin-jiang/5d0b74a8910a3abba7e860149b9d40e12.JPG\" alt=\"5d0b74a8910a3abba7e860149b9d40e12.JPG\"></p>\n"},{"title":"深圳梧桐山-毛棉杜鹃","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-04-03T05:08:19.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"![2b135a37c965e856f04d4a5faf8d2f2b2.JPG](2b135a37c965e856f04d4a5faf8d2f2b2.JPG)\n![f4e3370968454b29062472df853b648e.JPG](f4e3370968454b29062472df853b648e.JPG)\n![d2a7004a2e039c3f37d5fef10c7cc28a2.JPG](d2a7004a2e039c3f37d5fef10c7cc28a2.JPG)\n![7d011510a39a8f6e23429fa828448a7c2.JPG](7d011510a39a8f6e23429fa828448a7c2.JPG)\n![0a32e20ee914cca207bd5e0446eca332.JPG](0a32e20ee914cca207bd5e0446eca332.JPG)\n![6f19a8a8bff80c030eeba535032db0f6.JPG](6f19a8a8bff80c030eeba535032db0f6.JPG)\n","source":"_posts/2023/04/深圳梧桐山-毛棉杜鹃.md","raw":"---\ntitle: 深圳梧桐山-毛棉杜鹃\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-04-03 13:08:19\npassword:\nsummary:\ntags:\n- gallery-深圳梧桐山-毛棉杜鹃\ncategories:\n- gallery\nkeywords:\ndescription:\n---\n![2b135a37c965e856f04d4a5faf8d2f2b2.JPG](2b135a37c965e856f04d4a5faf8d2f2b2.JPG)\n![f4e3370968454b29062472df853b648e.JPG](f4e3370968454b29062472df853b648e.JPG)\n![d2a7004a2e039c3f37d5fef10c7cc28a2.JPG](d2a7004a2e039c3f37d5fef10c7cc28a2.JPG)\n![7d011510a39a8f6e23429fa828448a7c2.JPG](7d011510a39a8f6e23429fa828448a7c2.JPG)\n![0a32e20ee914cca207bd5e0446eca332.JPG](0a32e20ee914cca207bd5e0446eca332.JPG)\n![6f19a8a8bff80c030eeba535032db0f6.JPG](6f19a8a8bff80c030eeba535032db0f6.JPG)\n","slug":"深圳梧桐山-毛棉杜鹃","published":1,"updated":"2023-04-04T09:24:10.267Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk69d1e9001ujsrje4323ru4","content":"<p><img src=\"/2023/04/shen-zhen-wu-tong-shan-mao-mian-du-juan/2b135a37c965e856f04d4a5faf8d2f2b2.JPG\" alt=\"2b135a37c965e856f04d4a5faf8d2f2b2.JPG\"><br><img src=\"/2023/04/shen-zhen-wu-tong-shan-mao-mian-du-juan/f4e3370968454b29062472df853b648e.JPG\" alt=\"f4e3370968454b29062472df853b648e.JPG\"><br><img src=\"/2023/04/shen-zhen-wu-tong-shan-mao-mian-du-juan/d2a7004a2e039c3f37d5fef10c7cc28a2.JPG\" alt=\"d2a7004a2e039c3f37d5fef10c7cc28a2.JPG\"><br><img src=\"/2023/04/shen-zhen-wu-tong-shan-mao-mian-du-juan/7d011510a39a8f6e23429fa828448a7c2.JPG\" alt=\"7d011510a39a8f6e23429fa828448a7c2.JPG\"><br><img src=\"/2023/04/shen-zhen-wu-tong-shan-mao-mian-du-juan/0a32e20ee914cca207bd5e0446eca332.JPG\" alt=\"0a32e20ee914cca207bd5e0446eca332.JPG\"><br><img src=\"/2023/04/shen-zhen-wu-tong-shan-mao-mian-du-juan/6f19a8a8bff80c030eeba535032db0f6.JPG\" alt=\"6f19a8a8bff80c030eeba535032db0f6.JPG\"></p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<p><img src=\"/2023/04/shen-zhen-wu-tong-shan-mao-mian-du-juan/2b135a37c965e856f04d4a5faf8d2f2b2.JPG\" alt=\"2b135a37c965e856f04d4a5faf8d2f2b2.JPG\"><br><img src=\"/2023/04/shen-zhen-wu-tong-shan-mao-mian-du-juan/f4e3370968454b29062472df853b648e.JPG\" alt=\"f4e3370968454b29062472df853b648e.JPG\"><br><img src=\"/2023/04/shen-zhen-wu-tong-shan-mao-mian-du-juan/d2a7004a2e039c3f37d5fef10c7cc28a2.JPG\" alt=\"d2a7004a2e039c3f37d5fef10c7cc28a2.JPG\"><br><img src=\"/2023/04/shen-zhen-wu-tong-shan-mao-mian-du-juan/7d011510a39a8f6e23429fa828448a7c2.JPG\" alt=\"7d011510a39a8f6e23429fa828448a7c2.JPG\"><br><img src=\"/2023/04/shen-zhen-wu-tong-shan-mao-mian-du-juan/0a32e20ee914cca207bd5e0446eca332.JPG\" alt=\"0a32e20ee914cca207bd5e0446eca332.JPG\"><br><img src=\"/2023/04/shen-zhen-wu-tong-shan-mao-mian-du-juan/6f19a8a8bff80c030eeba535032db0f6.JPG\" alt=\"6f19a8a8bff80c030eeba535032db0f6.JPG\"></p>\n"},{"title":"衡山","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-04-03T08:11:43.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"![20230403161412.jpg](20230403161412.jpg)\n![20230403161440.jpg](20230403161440.jpg)\n![20230403161404.jpg](20230403161404.jpg)\n![20230403161331.jpg](20230403161331.jpg)\n![20230403161427.jpg](20230403161427.jpg)\n![20230403161419.jpg](20230403161419.jpg)\n![20230403161434.jpg](20230403161434.jpg)\n","source":"_posts/2023/04/衡山.md","raw":"---\ntitle: 衡山\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-04-03 16:11:43\npassword:\nsummary:\ntags:\n- gallery-衡山\ncategories:\n- gallery\nkeywords:\ndescription:\n---\n![20230403161412.jpg](20230403161412.jpg)\n![20230403161440.jpg](20230403161440.jpg)\n![20230403161404.jpg](20230403161404.jpg)\n![20230403161331.jpg](20230403161331.jpg)\n![20230403161427.jpg](20230403161427.jpg)\n![20230403161419.jpg](20230403161419.jpg)\n![20230403161434.jpg](20230403161434.jpg)\n","slug":"衡山","published":1,"updated":"2023-04-04T09:24:10.275Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk69d1ec001wjsrjchy36da6","content":"<p><img src=\"/2023/04/heng-shan/20230403161412.jpg\" alt=\"20230403161412.jpg\"><br><img src=\"/2023/04/heng-shan/20230403161440.jpg\" alt=\"20230403161440.jpg\"><br><img src=\"/2023/04/heng-shan/20230403161404.jpg\" alt=\"20230403161404.jpg\"><br><img src=\"/2023/04/heng-shan/20230403161331.jpg\" alt=\"20230403161331.jpg\"><br><img src=\"/2023/04/heng-shan/20230403161427.jpg\" alt=\"20230403161427.jpg\"><br><img src=\"/2023/04/heng-shan/20230403161419.jpg\" alt=\"20230403161419.jpg\"><br><img src=\"/2023/04/heng-shan/20230403161434.jpg\" alt=\"20230403161434.jpg\"></p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<p><img src=\"/2023/04/heng-shan/20230403161412.jpg\" alt=\"20230403161412.jpg\"><br><img src=\"/2023/04/heng-shan/20230403161440.jpg\" alt=\"20230403161440.jpg\"><br><img src=\"/2023/04/heng-shan/20230403161404.jpg\" alt=\"20230403161404.jpg\"><br><img src=\"/2023/04/heng-shan/20230403161331.jpg\" alt=\"20230403161331.jpg\"><br><img src=\"/2023/04/heng-shan/20230403161427.jpg\" alt=\"20230403161427.jpg\"><br><img src=\"/2023/04/heng-shan/20230403161419.jpg\" alt=\"20230403161419.jpg\"><br><img src=\"/2023/04/heng-shan/20230403161434.jpg\" alt=\"20230403161434.jpg\"></p>\n"},{"title":"单链表-报警模块","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-05-07T11:02:38.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"\n# 报警模块\n\n单向链表的实际应用。你可以在报警系统中使用它。\n\n# 特性\n\n-不同的报警级别\n\n-易于添加错误id\n\n-高可扩展性\n\n\n# 安装\n\n克隆[源码](https://github.com/qian-qiang/Unidirectional_linked_list)以添加到项目中，并将函数thread_error_entry()添加到线程中\n\n# 先决条件\n\ngcc编译器\n\n# 使用\n\n1. “error_id.h”在error_id_t中添加你的error_id\n2. 将error_id添加到ERROR_BUF中\n3. 将error_id添加到ERROR_BUF_LVL_X\n\n示例：\n\n1. make\n2. ./error\n3. 在终端中输入 insert/delete/print 调试\n","source":"_posts/2023/05/单链表-报警模块.md","raw":"---\ntitle: 单链表-报警模块\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-05-07 19:02:38\npassword:\nsummary:\ntags:\n- 模块\ncategories:\n- Embedded system\nkeywords:\ndescription:\n---\n\n# 报警模块\n\n单向链表的实际应用。你可以在报警系统中使用它。\n\n# 特性\n\n-不同的报警级别\n\n-易于添加错误id\n\n-高可扩展性\n\n\n# 安装\n\n克隆[源码](https://github.com/qian-qiang/Unidirectional_linked_list)以添加到项目中，并将函数thread_error_entry()添加到线程中\n\n# 先决条件\n\ngcc编译器\n\n# 使用\n\n1. “error_id.h”在error_id_t中添加你的error_id\n2. 将error_id添加到ERROR_BUF中\n3. 将error_id添加到ERROR_BUF_LVL_X\n\n示例：\n\n1. make\n2. ./error\n3. 在终端中输入 insert/delete/print 调试\n","slug":"单链表-报警模块","published":1,"updated":"2023-05-07T11:14:28.601Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk69d1ef001yjsrj9go321lj","content":"<h1 id=\"报警模块\"><a href=\"#报警模块\" class=\"headerlink\" title=\"报警模块\"></a>报警模块</h1><p>单向链表的实际应用。你可以在报警系统中使用它。</p>\n<h1 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h1><p>-不同的报警级别</p>\n<p>-易于添加错误id</p>\n<p>-高可扩展性</p>\n<h1 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h1><p>克隆<a href=\"https://github.com/qian-qiang/Unidirectional_linked_list\" target=\"_blank\" rel=\"noopener\">源码</a>以添加到项目中，并将函数thread_error_entry()添加到线程中</p>\n<h1 id=\"先决条件\"><a href=\"#先决条件\" class=\"headerlink\" title=\"先决条件\"></a>先决条件</h1><p>gcc编译器</p>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><ol>\n<li>“error_id.h”在error_id_t中添加你的error_id</li>\n<li>将error_id添加到ERROR_BUF中</li>\n<li>将error_id添加到ERROR_BUF_LVL_X</li>\n</ol>\n<p>示例：</p>\n<ol>\n<li>make</li>\n<li>./error</li>\n<li>在终端中输入 insert/delete/print 调试</li>\n</ol>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<h1 id=\"报警模块\"><a href=\"#报警模块\" class=\"headerlink\" title=\"报警模块\"></a>报警模块</h1><p>单向链表的实际应用。你可以在报警系统中使用它。</p>\n<h1 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h1><p>-不同的报警级别</p>\n<p>-易于添加错误id</p>\n<p>-高可扩展性</p>\n<h1 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h1><p>克隆<a href=\"https://github.com/qian-qiang/Unidirectional_linked_list\" target=\"_blank\" rel=\"noopener\">源码</a>以添加到项目中，并将函数thread_error_entry()添加到线程中</p>\n<h1 id=\"先决条件\"><a href=\"#先决条件\" class=\"headerlink\" title=\"先决条件\"></a>先决条件</h1><p>gcc编译器</p>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><ol>\n<li>“error_id.h”在error_id_t中添加你的error_id</li>\n<li>将error_id添加到ERROR_BUF中</li>\n<li>将error_id添加到ERROR_BUF_LVL_X</li>\n</ol>\n<p>示例：</p>\n<ol>\n<li>make</li>\n<li>./error</li>\n<li>在终端中输入 insert/delete/print 调试</li>\n</ol>\n"},{"title":"PIN->GPIO","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-05-20T17:14:31.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"\n# A：在linux中你会如何设计gpio的管理系统？\n# Q：分层 分模块\n\n> 概念：设备树/platform驱动/pinctrl（pic）/gpio\n\n## 分层： 应用层->pin contrl core->pin contrl driverx->hw layer\n\n![pin contrl mode](PIN-GPIO/Pinctrl.png)\n\n应用层：就是为某种设备写的驱动调用了pic的接口\npin contrl core：pic的核心管理层，解决pic的内部问题\npin contrl driverx：每个芯片的架构可能不同，就有不同的实现方式给到pic中\nhw layer：硬件最底层的实现\n\n## 模块： pin contrl模块 gpio模块 I2C模块 PWM模块....\n\npin contrl模块是最核心的模块，gpio模块 I2C模块 PWM模块等都是调用了pin contrl模块的api\n\n![gpio mode](PIN-GPIO/gpio.png)\n你以为两者是分离的，实际上不是的，gpio模块是基于pinctrl模块的，gpio的API接口的实现很多都是基于pinctrl模块的函数\n\n# A：现在是不是能实现外设的管理和控制了，接下来你会如何设计代码？\n# Q：我也不知道 分析源码\n\n## 源码架构\n\n![pinctrl 源码架构](PIN-GPIO/pinctrl_system.png)\n\n在此框架中，（1）、（2）、（3）由半导体厂商搞定，半导体厂商会利用 Linux 提供的框架，根据自己的芯片，客制化代码。普通的驱动工程师就是调用 API 即可，就算是写驱动了。\n着重讲解（2），所以由图我们知道，pinctrl 子系统和 gpio 子系统都依赖于（2）的驱动。\n\n## 设计思路\n\n### 抽象出pinctrl的类\n类的成员经过总结应该设计有：A:操作函数 B:和设备树相关的部分 C：gpio相关的部分\n\n于是linux出现了这样的数据结构\n![pinctrl-class](PIN-GPIO/pinctrl%20struct.png)\n\npinctrl_dev（kernel/drivers/pinctrl/core.h）是 pinctrl 子系统的根源结构体，它主要包含三条路：\n\n1、pinctrl_desc：这里包含了pinctrl 子系统三个最重要的结构体，有三个操作函数集，pinctrl_ops 包含了对 PIN 的操作函数集，pinmux_ops 包含了对 PIN 的复用函数集，pinconf_ops 包含了对 PIN 的配置函数，大家可以在自己平台中点进去看看自己平台实现了哪个函数，如何实现的。\n\n2、pinctrl 结构体：这里包含了 PIN 控制器所控制 PIN 的状态 state，state 里面包含了 setting，这个 setting 就是在设备树中对PIN的设置，大家点进去看相关数据结构就可以看到自己在设备树中用到的字符串。\n\n3、gpio 相关的结构体，我们说过 pinctrl 子系统和 gpio 子系统是耦合的，我们从结构体就可以看得出来，它包含了最重要的结构体 gpio_chip。\n\n### pinctrl子系统源码\n\nkernel/drivers/pinctrl/core.c 文件初始化pinctrl子系统\n>1：初始化阶段开启调试文件目录 /sys/kernel/debug/pinctrl# ls\n20e0000.iomuxc  2290000.iomuxc-snvs  pinctrl-devices  pinctrl-handles  pinctrl-maps\n2:提供pinctrl_register函数\n3:形成pinctrl核心层 提供API\n\n### 芯片厂商的pinctrl驱动\n\ndrivers/pinctrl/freescale/pinctrl-imx6ul.c 文件\n![imx6ull pinctrl driver](PIN-GPIO/imx6ull%20pinctrl.png)\nimx6ul_pinctrl_of_match.compatible 就是你设备树定义的数据 如果匹配上了就执行imx6ul_pinctrl_probe函数\n![imx6ull pin](PIN-GPIO/iomuxc.png)\n\nso 看下probe干了啥：\n![imx6ul_pinctrl_probe 函数执行流程](PIN-GPIO/probe.png)\n\n`imx_pinctrl_probe`函数是i.MX平台的引脚控制器驱动的探测函数，用于在设备探测阶段进行引脚控制器的初始化和注册。\n\n该函数的主要步骤如下：\n\n1. 验证传入的`info`参数和相关字段是否有效，包括`pins`和`npins`字段。\n2. 为`imx_pinctrl_desc`和`ipctl`分配内存，并进行初始化。\n3. 为引脚寄存器数组`info->pin_regs`分配内存，并进行初始化。\n4. 获取引脚控制器的物理内存资源并进行映射。\n5. 如果设备树中定义了\"fsl,input-sel\"属性，读取并映射输入选择寄存器的物理地址。\n6. 设置`imx_pinctrl_desc`的相关字段，如名称、引脚数组、操作函数等。\n7. 调用`imx_pinctrl_probe_dt`函数解析设备树中的属性并配置引脚控制器。\n8. 设置`ipctl`的相关字段。\n9. 调用`pinctrl_register`函数注册引脚控制器设备。\n10. 如果注册成功，打印初始化完成的信息。\n11. 返回操作结果，成功返回0，否则返回相应的错误码。\n\n总体来说，`imx_pinctrl_probe`函数完成了引脚控制器设备的初始化、资源分配、设备树属性解析以及注册到内核的引脚控制器子系统中的过程。\n\n就不继续深入研究，有兴趣自己看代码，介绍下pinctrl_register（）函数\n\n`pinctrl_register`函数用于注册一个引脚控制器设备，并返回一个指向注册设备的指针。\n\n函数的具体步骤如下：\n\n1. 检查传入的`pctldesc`参数是否有效，包括检查描述符指针和名称是否为空。\n2. 使用`kzalloc`为引脚控制器设备分配内存，并进行初始化。\n3. 设置引脚控制器设备的相关字段，如所有者、描述符、驱动程序数据等。\n4. 初始化引脚描述符的radix树和GPIO范围链表。\n5. 初始化互斥锁。\n6. 检查引脚控制器核心操作函数的正确性。\n7. 如果实现了引脚复用功能，检查引脚复用操作函数的正确性。\n8. 如果实现了引脚配置功能，检查引脚配置操作函数的正确性。\n9. 注册所有的引脚。\n10. 将引脚控制器设备添加到全局引脚控制器设备列表中。\n11. 获取引脚控制器设备的默认状态和睡眠状态，并进行相应的设置。\n12. 初始化引脚控制器设备的debugfs调试文件系统。\n13. 返回注册后的引脚控制器设备结构体指针。\n\n如果在注册过程中出现错误，将释放已分配的内存，并返回`NULL`。\n\n总之，`pinctrl_register`函数完成了引脚控制器设备的注册，包括分配内存、设置相关字段、注册引脚、添加到全局列表以及初始化调试功能等操作。\n\n### 使用pinctrl的API\n\n经过前面的设备厂商提供的pinctrl驱动代码，注册到pinctrl中后就可以调用pinctrl的API了。\n要调用`pinctrl`的API，你需要按照以下步骤进行操作：\n\n1. 引入相关头文件：\n   ```c\n   #include <linux/pinctrl/pinctrl.h>\n   ```\n\n2. 获取指向`struct pinctrl_dev`的指针，该指针代表已注册的引脚控制器设备。\n\n   - 如果你已经有一个指向设备结构体（如`struct device`）的指针 `dev`，可以通过以下方式获取 `struct pinctrl_dev` 指针：\n     ```c\n     struct pinctrl_dev *pctldev = dev_get_drvdata(dev);\n     ```\n   - 如果你知道设备的名称，可以使用以下函数获取 `struct pinctrl_dev` 指针：\n     ```c\n     struct pinctrl_dev *pctldev = pinctrl_get(pinctrl_dev_name);\n     ```\n\n3. 使用获得的 `struct pinctrl_dev` 指针调用相应的 `pinctrl` API 函数。例如，要选择引脚控制器设备上的某个引脚状态，可以使用 `pinctrl_select_state` 函数：\n   ```c\n   int ret = pinctrl_select_state(pctldev, state_name);\n   ```\n\n   其中，`state_name` 是要选择的引脚状态的名称。具体的 API 函数和参数将取决于你要执行的具体操作，例如配置引脚功能、设置引脚属性等。\n\n   请注意，在使用 `pinctrl` API 之前，你需要确保已正确初始化和注册了引脚控制器设备，并且你具有适当的权限来执行相关操作。\n\n## GPIO模块\n   GPIO模块的核心层调用了很多的pinctrl的函数，可以去看下源码的设计，设计思路和pinctrl是一样的就不重复了。\n   可以看下这篇文章的调用方式：[手把手教你使用 gpio 子系统 API](https://mp.weixin.qq.com/s/iquUV-xzx1c08spOeW-vPg)。\n\n","source":"_posts/2023/05/PIN-GPIO.md","raw":"---\ntitle: PIN->GPIO\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-05-21 01:14:31\npassword:\nsummary:\ntags:\n- PIN GPIO\n- linux\ncategories:\n- linux\nkeywords:\ndescription:\n---\n\n# A：在linux中你会如何设计gpio的管理系统？\n# Q：分层 分模块\n\n> 概念：设备树/platform驱动/pinctrl（pic）/gpio\n\n## 分层： 应用层->pin contrl core->pin contrl driverx->hw layer\n\n![pin contrl mode](PIN-GPIO/Pinctrl.png)\n\n应用层：就是为某种设备写的驱动调用了pic的接口\npin contrl core：pic的核心管理层，解决pic的内部问题\npin contrl driverx：每个芯片的架构可能不同，就有不同的实现方式给到pic中\nhw layer：硬件最底层的实现\n\n## 模块： pin contrl模块 gpio模块 I2C模块 PWM模块....\n\npin contrl模块是最核心的模块，gpio模块 I2C模块 PWM模块等都是调用了pin contrl模块的api\n\n![gpio mode](PIN-GPIO/gpio.png)\n你以为两者是分离的，实际上不是的，gpio模块是基于pinctrl模块的，gpio的API接口的实现很多都是基于pinctrl模块的函数\n\n# A：现在是不是能实现外设的管理和控制了，接下来你会如何设计代码？\n# Q：我也不知道 分析源码\n\n## 源码架构\n\n![pinctrl 源码架构](PIN-GPIO/pinctrl_system.png)\n\n在此框架中，（1）、（2）、（3）由半导体厂商搞定，半导体厂商会利用 Linux 提供的框架，根据自己的芯片，客制化代码。普通的驱动工程师就是调用 API 即可，就算是写驱动了。\n着重讲解（2），所以由图我们知道，pinctrl 子系统和 gpio 子系统都依赖于（2）的驱动。\n\n## 设计思路\n\n### 抽象出pinctrl的类\n类的成员经过总结应该设计有：A:操作函数 B:和设备树相关的部分 C：gpio相关的部分\n\n于是linux出现了这样的数据结构\n![pinctrl-class](PIN-GPIO/pinctrl%20struct.png)\n\npinctrl_dev（kernel/drivers/pinctrl/core.h）是 pinctrl 子系统的根源结构体，它主要包含三条路：\n\n1、pinctrl_desc：这里包含了pinctrl 子系统三个最重要的结构体，有三个操作函数集，pinctrl_ops 包含了对 PIN 的操作函数集，pinmux_ops 包含了对 PIN 的复用函数集，pinconf_ops 包含了对 PIN 的配置函数，大家可以在自己平台中点进去看看自己平台实现了哪个函数，如何实现的。\n\n2、pinctrl 结构体：这里包含了 PIN 控制器所控制 PIN 的状态 state，state 里面包含了 setting，这个 setting 就是在设备树中对PIN的设置，大家点进去看相关数据结构就可以看到自己在设备树中用到的字符串。\n\n3、gpio 相关的结构体，我们说过 pinctrl 子系统和 gpio 子系统是耦合的，我们从结构体就可以看得出来，它包含了最重要的结构体 gpio_chip。\n\n### pinctrl子系统源码\n\nkernel/drivers/pinctrl/core.c 文件初始化pinctrl子系统\n>1：初始化阶段开启调试文件目录 /sys/kernel/debug/pinctrl# ls\n20e0000.iomuxc  2290000.iomuxc-snvs  pinctrl-devices  pinctrl-handles  pinctrl-maps\n2:提供pinctrl_register函数\n3:形成pinctrl核心层 提供API\n\n### 芯片厂商的pinctrl驱动\n\ndrivers/pinctrl/freescale/pinctrl-imx6ul.c 文件\n![imx6ull pinctrl driver](PIN-GPIO/imx6ull%20pinctrl.png)\nimx6ul_pinctrl_of_match.compatible 就是你设备树定义的数据 如果匹配上了就执行imx6ul_pinctrl_probe函数\n![imx6ull pin](PIN-GPIO/iomuxc.png)\n\nso 看下probe干了啥：\n![imx6ul_pinctrl_probe 函数执行流程](PIN-GPIO/probe.png)\n\n`imx_pinctrl_probe`函数是i.MX平台的引脚控制器驱动的探测函数，用于在设备探测阶段进行引脚控制器的初始化和注册。\n\n该函数的主要步骤如下：\n\n1. 验证传入的`info`参数和相关字段是否有效，包括`pins`和`npins`字段。\n2. 为`imx_pinctrl_desc`和`ipctl`分配内存，并进行初始化。\n3. 为引脚寄存器数组`info->pin_regs`分配内存，并进行初始化。\n4. 获取引脚控制器的物理内存资源并进行映射。\n5. 如果设备树中定义了\"fsl,input-sel\"属性，读取并映射输入选择寄存器的物理地址。\n6. 设置`imx_pinctrl_desc`的相关字段，如名称、引脚数组、操作函数等。\n7. 调用`imx_pinctrl_probe_dt`函数解析设备树中的属性并配置引脚控制器。\n8. 设置`ipctl`的相关字段。\n9. 调用`pinctrl_register`函数注册引脚控制器设备。\n10. 如果注册成功，打印初始化完成的信息。\n11. 返回操作结果，成功返回0，否则返回相应的错误码。\n\n总体来说，`imx_pinctrl_probe`函数完成了引脚控制器设备的初始化、资源分配、设备树属性解析以及注册到内核的引脚控制器子系统中的过程。\n\n就不继续深入研究，有兴趣自己看代码，介绍下pinctrl_register（）函数\n\n`pinctrl_register`函数用于注册一个引脚控制器设备，并返回一个指向注册设备的指针。\n\n函数的具体步骤如下：\n\n1. 检查传入的`pctldesc`参数是否有效，包括检查描述符指针和名称是否为空。\n2. 使用`kzalloc`为引脚控制器设备分配内存，并进行初始化。\n3. 设置引脚控制器设备的相关字段，如所有者、描述符、驱动程序数据等。\n4. 初始化引脚描述符的radix树和GPIO范围链表。\n5. 初始化互斥锁。\n6. 检查引脚控制器核心操作函数的正确性。\n7. 如果实现了引脚复用功能，检查引脚复用操作函数的正确性。\n8. 如果实现了引脚配置功能，检查引脚配置操作函数的正确性。\n9. 注册所有的引脚。\n10. 将引脚控制器设备添加到全局引脚控制器设备列表中。\n11. 获取引脚控制器设备的默认状态和睡眠状态，并进行相应的设置。\n12. 初始化引脚控制器设备的debugfs调试文件系统。\n13. 返回注册后的引脚控制器设备结构体指针。\n\n如果在注册过程中出现错误，将释放已分配的内存，并返回`NULL`。\n\n总之，`pinctrl_register`函数完成了引脚控制器设备的注册，包括分配内存、设置相关字段、注册引脚、添加到全局列表以及初始化调试功能等操作。\n\n### 使用pinctrl的API\n\n经过前面的设备厂商提供的pinctrl驱动代码，注册到pinctrl中后就可以调用pinctrl的API了。\n要调用`pinctrl`的API，你需要按照以下步骤进行操作：\n\n1. 引入相关头文件：\n   ```c\n   #include <linux/pinctrl/pinctrl.h>\n   ```\n\n2. 获取指向`struct pinctrl_dev`的指针，该指针代表已注册的引脚控制器设备。\n\n   - 如果你已经有一个指向设备结构体（如`struct device`）的指针 `dev`，可以通过以下方式获取 `struct pinctrl_dev` 指针：\n     ```c\n     struct pinctrl_dev *pctldev = dev_get_drvdata(dev);\n     ```\n   - 如果你知道设备的名称，可以使用以下函数获取 `struct pinctrl_dev` 指针：\n     ```c\n     struct pinctrl_dev *pctldev = pinctrl_get(pinctrl_dev_name);\n     ```\n\n3. 使用获得的 `struct pinctrl_dev` 指针调用相应的 `pinctrl` API 函数。例如，要选择引脚控制器设备上的某个引脚状态，可以使用 `pinctrl_select_state` 函数：\n   ```c\n   int ret = pinctrl_select_state(pctldev, state_name);\n   ```\n\n   其中，`state_name` 是要选择的引脚状态的名称。具体的 API 函数和参数将取决于你要执行的具体操作，例如配置引脚功能、设置引脚属性等。\n\n   请注意，在使用 `pinctrl` API 之前，你需要确保已正确初始化和注册了引脚控制器设备，并且你具有适当的权限来执行相关操作。\n\n## GPIO模块\n   GPIO模块的核心层调用了很多的pinctrl的函数，可以去看下源码的设计，设计思路和pinctrl是一样的就不重复了。\n   可以看下这篇文章的调用方式：[手把手教你使用 gpio 子系统 API](https://mp.weixin.qq.com/s/iquUV-xzx1c08spOeW-vPg)。\n\n","slug":"PIN-GPIO","published":1,"updated":"2023-05-21T09:37:21.376Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk69d1ei0022jsrjqqynsrnr","content":"<h1 id=\"A：在linux中你会如何设计gpio的管理系统？\"><a href=\"#A：在linux中你会如何设计gpio的管理系统？\" class=\"headerlink\" title=\"A：在linux中你会如何设计gpio的管理系统？\"></a>A：在linux中你会如何设计gpio的管理系统？</h1><h1 id=\"Q：分层-分模块\"><a href=\"#Q：分层-分模块\" class=\"headerlink\" title=\"Q：分层 分模块\"></a>Q：分层 分模块</h1><blockquote>\n<p>概念：设备树/platform驱动/pinctrl（pic）/gpio</p>\n</blockquote>\n<h2 id=\"分层：-应用层-gt-pin-contrl-core-gt-pin-contrl-driverx-gt-hw-layer\"><a href=\"#分层：-应用层-gt-pin-contrl-core-gt-pin-contrl-driverx-gt-hw-layer\" class=\"headerlink\" title=\"分层： 应用层-&gt;pin contrl core-&gt;pin contrl driverx-&gt;hw layer\"></a>分层： 应用层-&gt;pin contrl core-&gt;pin contrl driverx-&gt;hw layer</h2><p><img src=\"/2023/05/pin-gpio/Pinctrl.png\" alt=\"pin contrl mode\"></p>\n<p>应用层：就是为某种设备写的驱动调用了pic的接口<br>pin contrl core：pic的核心管理层，解决pic的内部问题<br>pin contrl driverx：每个芯片的架构可能不同，就有不同的实现方式给到pic中<br>hw layer：硬件最底层的实现</p>\n<h2 id=\"模块：-pin-contrl模块-gpio模块-I2C模块-PWM模块…\"><a href=\"#模块：-pin-contrl模块-gpio模块-I2C模块-PWM模块…\" class=\"headerlink\" title=\"模块： pin contrl模块 gpio模块 I2C模块 PWM模块….\"></a>模块： pin contrl模块 gpio模块 I2C模块 PWM模块….</h2><p>pin contrl模块是最核心的模块，gpio模块 I2C模块 PWM模块等都是调用了pin contrl模块的api</p>\n<p><img src=\"/2023/05/pin-gpio/gpio.png\" alt=\"gpio mode\"><br>你以为两者是分离的，实际上不是的，gpio模块是基于pinctrl模块的，gpio的API接口的实现很多都是基于pinctrl模块的函数</p>\n<h1 id=\"A：现在是不是能实现外设的管理和控制了，接下来你会如何设计代码？\"><a href=\"#A：现在是不是能实现外设的管理和控制了，接下来你会如何设计代码？\" class=\"headerlink\" title=\"A：现在是不是能实现外设的管理和控制了，接下来你会如何设计代码？\"></a>A：现在是不是能实现外设的管理和控制了，接下来你会如何设计代码？</h1><h1 id=\"Q：我也不知道-分析源码\"><a href=\"#Q：我也不知道-分析源码\" class=\"headerlink\" title=\"Q：我也不知道 分析源码\"></a>Q：我也不知道 分析源码</h1><h2 id=\"源码架构\"><a href=\"#源码架构\" class=\"headerlink\" title=\"源码架构\"></a>源码架构</h2><p><img src=\"/2023/05/pin-gpio/pinctrl_system.png\" alt=\"pinctrl 源码架构\"></p>\n<p>在此框架中，（1）、（2）、（3）由半导体厂商搞定，半导体厂商会利用 Linux 提供的框架，根据自己的芯片，客制化代码。普通的驱动工程师就是调用 API 即可，就算是写驱动了。<br>着重讲解（2），所以由图我们知道，pinctrl 子系统和 gpio 子系统都依赖于（2）的驱动。</p>\n<h2 id=\"设计思路\"><a href=\"#设计思路\" class=\"headerlink\" title=\"设计思路\"></a>设计思路</h2><h3 id=\"抽象出pinctrl的类\"><a href=\"#抽象出pinctrl的类\" class=\"headerlink\" title=\"抽象出pinctrl的类\"></a>抽象出pinctrl的类</h3><p>类的成员经过总结应该设计有：A:操作函数 B:和设备树相关的部分 C：gpio相关的部分</p>\n<p>于是linux出现了这样的数据结构<br><img src=\"/2023/05/pin-gpio/pinctrl%20struct.png\" alt=\"pinctrl-class\"></p>\n<p>pinctrl_dev（kernel/drivers/pinctrl/core.h）是 pinctrl 子系统的根源结构体，它主要包含三条路：</p>\n<p>1、pinctrl_desc：这里包含了pinctrl 子系统三个最重要的结构体，有三个操作函数集，pinctrl_ops 包含了对 PIN 的操作函数集，pinmux_ops 包含了对 PIN 的复用函数集，pinconf_ops 包含了对 PIN 的配置函数，大家可以在自己平台中点进去看看自己平台实现了哪个函数，如何实现的。</p>\n<p>2、pinctrl 结构体：这里包含了 PIN 控制器所控制 PIN 的状态 state，state 里面包含了 setting，这个 setting 就是在设备树中对PIN的设置，大家点进去看相关数据结构就可以看到自己在设备树中用到的字符串。</p>\n<p>3、gpio 相关的结构体，我们说过 pinctrl 子系统和 gpio 子系统是耦合的，我们从结构体就可以看得出来，它包含了最重要的结构体 gpio_chip。</p>\n<h3 id=\"pinctrl子系统源码\"><a href=\"#pinctrl子系统源码\" class=\"headerlink\" title=\"pinctrl子系统源码\"></a>pinctrl子系统源码</h3><p>kernel/drivers/pinctrl/core.c 文件初始化pinctrl子系统</p>\n<blockquote>\n<p>1：初始化阶段开启调试文件目录 /sys/kernel/debug/pinctrl# ls<br>20e0000.iomuxc  2290000.iomuxc-snvs  pinctrl-devices  pinctrl-handles  pinctrl-maps<br>2:提供pinctrl_register函数<br>3:形成pinctrl核心层 提供API</p>\n</blockquote>\n<h3 id=\"芯片厂商的pinctrl驱动\"><a href=\"#芯片厂商的pinctrl驱动\" class=\"headerlink\" title=\"芯片厂商的pinctrl驱动\"></a>芯片厂商的pinctrl驱动</h3><p>drivers/pinctrl/freescale/pinctrl-imx6ul.c 文件<br><img src=\"/2023/05/pin-gpio/imx6ull%20pinctrl.png\" alt=\"imx6ull pinctrl driver\"><br>imx6ul_pinctrl_of_match.compatible 就是你设备树定义的数据 如果匹配上了就执行imx6ul_pinctrl_probe函数<br><img src=\"/2023/05/pin-gpio/iomuxc.png\" alt=\"imx6ull pin\"></p>\n<p>so 看下probe干了啥：<br><img src=\"/2023/05/pin-gpio/probe.png\" alt=\"imx6ul_pinctrl_probe 函数执行流程\"></p>\n<p><code>imx_pinctrl_probe</code>函数是i.MX平台的引脚控制器驱动的探测函数，用于在设备探测阶段进行引脚控制器的初始化和注册。</p>\n<p>该函数的主要步骤如下：</p>\n<ol>\n<li>验证传入的<code>info</code>参数和相关字段是否有效，包括<code>pins</code>和<code>npins</code>字段。</li>\n<li>为<code>imx_pinctrl_desc</code>和<code>ipctl</code>分配内存，并进行初始化。</li>\n<li>为引脚寄存器数组<code>info-&gt;pin_regs</code>分配内存，并进行初始化。</li>\n<li>获取引脚控制器的物理内存资源并进行映射。</li>\n<li>如果设备树中定义了”fsl,input-sel”属性，读取并映射输入选择寄存器的物理地址。</li>\n<li>设置<code>imx_pinctrl_desc</code>的相关字段，如名称、引脚数组、操作函数等。</li>\n<li>调用<code>imx_pinctrl_probe_dt</code>函数解析设备树中的属性并配置引脚控制器。</li>\n<li>设置<code>ipctl</code>的相关字段。</li>\n<li>调用<code>pinctrl_register</code>函数注册引脚控制器设备。</li>\n<li>如果注册成功，打印初始化完成的信息。</li>\n<li>返回操作结果，成功返回0，否则返回相应的错误码。</li>\n</ol>\n<p>总体来说，<code>imx_pinctrl_probe</code>函数完成了引脚控制器设备的初始化、资源分配、设备树属性解析以及注册到内核的引脚控制器子系统中的过程。</p>\n<p>就不继续深入研究，有兴趣自己看代码，介绍下pinctrl_register（）函数</p>\n<p><code>pinctrl_register</code>函数用于注册一个引脚控制器设备，并返回一个指向注册设备的指针。</p>\n<p>函数的具体步骤如下：</p>\n<ol>\n<li>检查传入的<code>pctldesc</code>参数是否有效，包括检查描述符指针和名称是否为空。</li>\n<li>使用<code>kzalloc</code>为引脚控制器设备分配内存，并进行初始化。</li>\n<li>设置引脚控制器设备的相关字段，如所有者、描述符、驱动程序数据等。</li>\n<li>初始化引脚描述符的radix树和GPIO范围链表。</li>\n<li>初始化互斥锁。</li>\n<li>检查引脚控制器核心操作函数的正确性。</li>\n<li>如果实现了引脚复用功能，检查引脚复用操作函数的正确性。</li>\n<li>如果实现了引脚配置功能，检查引脚配置操作函数的正确性。</li>\n<li>注册所有的引脚。</li>\n<li>将引脚控制器设备添加到全局引脚控制器设备列表中。</li>\n<li>获取引脚控制器设备的默认状态和睡眠状态，并进行相应的设置。</li>\n<li>初始化引脚控制器设备的debugfs调试文件系统。</li>\n<li>返回注册后的引脚控制器设备结构体指针。</li>\n</ol>\n<p>如果在注册过程中出现错误，将释放已分配的内存，并返回<code>NULL</code>。</p>\n<p>总之，<code>pinctrl_register</code>函数完成了引脚控制器设备的注册，包括分配内存、设置相关字段、注册引脚、添加到全局列表以及初始化调试功能等操作。</p>\n<h3 id=\"使用pinctrl的API\"><a href=\"#使用pinctrl的API\" class=\"headerlink\" title=\"使用pinctrl的API\"></a>使用pinctrl的API</h3><p>经过前面的设备厂商提供的pinctrl驱动代码，注册到pinctrl中后就可以调用pinctrl的API了。<br>要调用<code>pinctrl</code>的API，你需要按照以下步骤进行操作：</p>\n<ol>\n<li><p>引入相关头文件：</p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;linux/pinctrl/pinctrl.h></span></span></code></pre>\n</li>\n<li><p>获取指向<code>struct pinctrl_dev</code>的指针，该指针代表已注册的引脚控制器设备。</p>\n<ul>\n<li>如果你已经有一个指向设备结构体（如<code>struct device</code>）的指针 <code>dev</code>，可以通过以下方式获取 <code>struct pinctrl_dev</code> 指针：<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> pinctrl_dev <span class=\"token operator\">*</span>pctldev <span class=\"token operator\">=</span> <span class=\"token function\">dev_get_drvdata</span><span class=\"token punctuation\">(</span>dev<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n</li>\n<li>如果你知道设备的名称，可以使用以下函数获取 <code>struct pinctrl_dev</code> 指针：<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> pinctrl_dev <span class=\"token operator\">*</span>pctldev <span class=\"token operator\">=</span> <span class=\"token function\">pinctrl_get</span><span class=\"token punctuation\">(</span>pinctrl_dev_name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n</li>\n</ul>\n</li>\n<li><p>使用获得的 <code>struct pinctrl_dev</code> 指针调用相应的 <code>pinctrl</code> API 函数。例如，要选择引脚控制器设备上的某个引脚状态，可以使用 <code>pinctrl_select_state</code> 函数：</p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> ret <span class=\"token operator\">=</span> <span class=\"token function\">pinctrl_select_state</span><span class=\"token punctuation\">(</span>pctldev<span class=\"token punctuation\">,</span> state_name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>其中，<code>state_name</code> 是要选择的引脚状态的名称。具体的 API 函数和参数将取决于你要执行的具体操作，例如配置引脚功能、设置引脚属性等。</p>\n<p>请注意，在使用 <code>pinctrl</code> API 之前，你需要确保已正确初始化和注册了引脚控制器设备，并且你具有适当的权限来执行相关操作。</p>\n</li>\n</ol>\n<h2 id=\"GPIO模块\"><a href=\"#GPIO模块\" class=\"headerlink\" title=\"GPIO模块\"></a>GPIO模块</h2><p>   GPIO模块的核心层调用了很多的pinctrl的函数，可以去看下源码的设计，设计思路和pinctrl是一样的就不重复了。<br>   可以看下这篇文章的调用方式：<a href=\"https://mp.weixin.qq.com/s/iquUV-xzx1c08spOeW-vPg\" target=\"_blank\" rel=\"noopener\">手把手教你使用 gpio 子系统 API</a>。</p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<h1 id=\"A：在linux中你会如何设计gpio的管理系统？\"><a href=\"#A：在linux中你会如何设计gpio的管理系统？\" class=\"headerlink\" title=\"A：在linux中你会如何设计gpio的管理系统？\"></a>A：在linux中你会如何设计gpio的管理系统？</h1><h1 id=\"Q：分层-分模块\"><a href=\"#Q：分层-分模块\" class=\"headerlink\" title=\"Q：分层 分模块\"></a>Q：分层 分模块</h1><blockquote>\n<p>概念：设备树/platform驱动/pinctrl（pic）/gpio</p>\n</blockquote>\n<h2 id=\"分层：-应用层-gt-pin-contrl-core-gt-pin-contrl-driverx-gt-hw-layer\"><a href=\"#分层：-应用层-gt-pin-contrl-core-gt-pin-contrl-driverx-gt-hw-layer\" class=\"headerlink\" title=\"分层： 应用层-&gt;pin contrl core-&gt;pin contrl driverx-&gt;hw layer\"></a>分层： 应用层-&gt;pin contrl core-&gt;pin contrl driverx-&gt;hw layer</h2><p><img src=\"/2023/05/pin-gpio/Pinctrl.png\" alt=\"pin contrl mode\"></p>\n<p>应用层：就是为某种设备写的驱动调用了pic的接口<br>pin contrl core：pic的核心管理层，解决pic的内部问题<br>pin contrl driverx：每个芯片的架构可能不同，就有不同的实现方式给到pic中<br>hw layer：硬件最底层的实现</p>\n<h2 id=\"模块：-pin-contrl模块-gpio模块-I2C模块-PWM模块…\"><a href=\"#模块：-pin-contrl模块-gpio模块-I2C模块-PWM模块…\" class=\"headerlink\" title=\"模块： pin contrl模块 gpio模块 I2C模块 PWM模块….\"></a>模块： pin contrl模块 gpio模块 I2C模块 PWM模块….</h2><p>pin contrl模块是最核心的模块，gpio模块 I2C模块 PWM模块等都是调用了pin contrl模块的api</p>\n<p><img src=\"/2023/05/pin-gpio/gpio.png\" alt=\"gpio mode\"><br>你以为两者是分离的，实际上不是的，gpio模块是基于pinctrl模块的，gpio的API接口的实现很多都是基于pinctrl模块的函数</p>\n<h1 id=\"A：现在是不是能实现外设的管理和控制了，接下来你会如何设计代码？\"><a href=\"#A：现在是不是能实现外设的管理和控制了，接下来你会如何设计代码？\" class=\"headerlink\" title=\"A：现在是不是能实现外设的管理和控制了，接下来你会如何设计代码？\"></a>A：现在是不是能实现外设的管理和控制了，接下来你会如何设计代码？</h1><h1 id=\"Q：我也不知道-分析源码\"><a href=\"#Q：我也不知道-分析源码\" class=\"headerlink\" title=\"Q：我也不知道 分析源码\"></a>Q：我也不知道 分析源码</h1><h2 id=\"源码架构\"><a href=\"#源码架构\" class=\"headerlink\" title=\"源码架构\"></a>源码架构</h2><p><img src=\"/2023/05/pin-gpio/pinctrl_system.png\" alt=\"pinctrl 源码架构\"></p>\n<p>在此框架中，（1）、（2）、（3）由半导体厂商搞定，半导体厂商会利用 Linux 提供的框架，根据自己的芯片，客制化代码。普通的驱动工程师就是调用 API 即可，就算是写驱动了。<br>着重讲解（2），所以由图我们知道，pinctrl 子系统和 gpio 子系统都依赖于（2）的驱动。</p>\n<h2 id=\"设计思路\"><a href=\"#设计思路\" class=\"headerlink\" title=\"设计思路\"></a>设计思路</h2><h3 id=\"抽象出pinctrl的类\"><a href=\"#抽象出pinctrl的类\" class=\"headerlink\" title=\"抽象出pinctrl的类\"></a>抽象出pinctrl的类</h3><p>类的成员经过总结应该设计有：A:操作函数 B:和设备树相关的部分 C：gpio相关的部分</p>\n<p>于是linux出现了这样的数据结构<br><img src=\"/2023/05/pin-gpio/pinctrl%20struct.png\" alt=\"pinctrl-class\"></p>\n<p>pinctrl_dev（kernel/drivers/pinctrl/core.h）是 pinctrl 子系统的根源结构体，它主要包含三条路：</p>\n<p>1、pinctrl_desc：这里包含了pinctrl 子系统三个最重要的结构体，有三个操作函数集，pinctrl_ops 包含了对 PIN 的操作函数集，pinmux_ops 包含了对 PIN 的复用函数集，pinconf_ops 包含了对 PIN 的配置函数，大家可以在自己平台中点进去看看自己平台实现了哪个函数，如何实现的。</p>\n<p>2、pinctrl 结构体：这里包含了 PIN 控制器所控制 PIN 的状态 state，state 里面包含了 setting，这个 setting 就是在设备树中对PIN的设置，大家点进去看相关数据结构就可以看到自己在设备树中用到的字符串。</p>\n<p>3、gpio 相关的结构体，我们说过 pinctrl 子系统和 gpio 子系统是耦合的，我们从结构体就可以看得出来，它包含了最重要的结构体 gpio_chip。</p>\n<h3 id=\"pinctrl子系统源码\"><a href=\"#pinctrl子系统源码\" class=\"headerlink\" title=\"pinctrl子系统源码\"></a>pinctrl子系统源码</h3><p>kernel/drivers/pinctrl/core.c 文件初始化pinctrl子系统</p>\n<blockquote>\n<p>1：初始化阶段开启调试文件目录 /sys/kernel/debug/pinctrl# ls<br>20e0000.iomuxc  2290000.iomuxc-snvs  pinctrl-devices  pinctrl-handles  pinctrl-maps<br>2:提供pinctrl_register函数<br>3:形成pinctrl核心层 提供API</p>\n</blockquote>\n<h3 id=\"芯片厂商的pinctrl驱动\"><a href=\"#芯片厂商的pinctrl驱动\" class=\"headerlink\" title=\"芯片厂商的pinctrl驱动\"></a>芯片厂商的pinctrl驱动</h3><p>drivers/pinctrl/freescale/pinctrl-imx6ul.c 文件<br><img src=\"/2023/05/pin-gpio/imx6ull%20pinctrl.png\" alt=\"imx6ull pinctrl driver\"><br>imx6ul_pinctrl_of_match.compatible 就是你设备树定义的数据 如果匹配上了就执行imx6ul_pinctrl_probe函数<br><img src=\"/2023/05/pin-gpio/iomuxc.png\" alt=\"imx6ull pin\"></p>\n<p>so 看下probe干了啥：<br><img src=\"/2023/05/pin-gpio/probe.png\" alt=\"imx6ul_pinctrl_probe 函数执行流程\"></p>\n<p><code>imx_pinctrl_probe</code>函数是i.MX平台的引脚控制器驱动的探测函数，用于在设备探测阶段进行引脚控制器的初始化和注册。</p>\n<p>该函数的主要步骤如下：</p>\n<ol>\n<li>验证传入的<code>info</code>参数和相关字段是否有效，包括<code>pins</code>和<code>npins</code>字段。</li>\n<li>为<code>imx_pinctrl_desc</code>和<code>ipctl</code>分配内存，并进行初始化。</li>\n<li>为引脚寄存器数组<code>info-&gt;pin_regs</code>分配内存，并进行初始化。</li>\n<li>获取引脚控制器的物理内存资源并进行映射。</li>\n<li>如果设备树中定义了”fsl,input-sel”属性，读取并映射输入选择寄存器的物理地址。</li>\n<li>设置<code>imx_pinctrl_desc</code>的相关字段，如名称、引脚数组、操作函数等。</li>\n<li>调用<code>imx_pinctrl_probe_dt</code>函数解析设备树中的属性并配置引脚控制器。</li>\n<li>设置<code>ipctl</code>的相关字段。</li>\n<li>调用<code>pinctrl_register</code>函数注册引脚控制器设备。</li>\n<li>如果注册成功，打印初始化完成的信息。</li>\n<li>返回操作结果，成功返回0，否则返回相应的错误码。</li>\n</ol>\n<p>总体来说，<code>imx_pinctrl_probe</code>函数完成了引脚控制器设备的初始化、资源分配、设备树属性解析以及注册到内核的引脚控制器子系统中的过程。</p>\n<p>就不继续深入研究，有兴趣自己看代码，介绍下pinctrl_register（）函数</p>\n<p><code>pinctrl_register</code>函数用于注册一个引脚控制器设备，并返回一个指向注册设备的指针。</p>\n<p>函数的具体步骤如下：</p>\n<ol>\n<li>检查传入的<code>pctldesc</code>参数是否有效，包括检查描述符指针和名称是否为空。</li>\n<li>使用<code>kzalloc</code>为引脚控制器设备分配内存，并进行初始化。</li>\n<li>设置引脚控制器设备的相关字段，如所有者、描述符、驱动程序数据等。</li>\n<li>初始化引脚描述符的radix树和GPIO范围链表。</li>\n<li>初始化互斥锁。</li>\n<li>检查引脚控制器核心操作函数的正确性。</li>\n<li>如果实现了引脚复用功能，检查引脚复用操作函数的正确性。</li>\n<li>如果实现了引脚配置功能，检查引脚配置操作函数的正确性。</li>\n<li>注册所有的引脚。</li>\n<li>将引脚控制器设备添加到全局引脚控制器设备列表中。</li>\n<li>获取引脚控制器设备的默认状态和睡眠状态，并进行相应的设置。</li>\n<li>初始化引脚控制器设备的debugfs调试文件系统。</li>\n<li>返回注册后的引脚控制器设备结构体指针。</li>\n</ol>\n<p>如果在注册过程中出现错误，将释放已分配的内存，并返回<code>NULL</code>。</p>\n<p>总之，<code>pinctrl_register</code>函数完成了引脚控制器设备的注册，包括分配内存、设置相关字段、注册引脚、添加到全局列表以及初始化调试功能等操作。</p>\n<h3 id=\"使用pinctrl的API\"><a href=\"#使用pinctrl的API\" class=\"headerlink\" title=\"使用pinctrl的API\"></a>使用pinctrl的API</h3><p>经过前面的设备厂商提供的pinctrl驱动代码，注册到pinctrl中后就可以调用pinctrl的API了。<br>要调用<code>pinctrl</code>的API，你需要按照以下步骤进行操作：</p>\n<ol>\n<li><p>引入相关头文件：</p>\n<pre><code class=\"c\">#include &lt;linux/pinctrl/pinctrl.h&gt;</code></pre>\n</li>\n<li><p>获取指向<code>struct pinctrl_dev</code>的指针，该指针代表已注册的引脚控制器设备。</p>\n<ul>\n<li>如果你已经有一个指向设备结构体（如<code>struct device</code>）的指针 <code>dev</code>，可以通过以下方式获取 <code>struct pinctrl_dev</code> 指针：<pre><code class=\"c\">struct pinctrl_dev *pctldev = dev_get_drvdata(dev);</code></pre>\n</li>\n<li>如果你知道设备的名称，可以使用以下函数获取 <code>struct pinctrl_dev</code> 指针：<pre><code class=\"c\">struct pinctrl_dev *pctldev = pinctrl_get(pinctrl_dev_name);</code></pre>\n</li>\n</ul>\n</li>\n<li><p>使用获得的 <code>struct pinctrl_dev</code> 指针调用相应的 <code>pinctrl</code> API 函数。例如，要选择引脚控制器设备上的某个引脚状态，可以使用 <code>pinctrl_select_state</code> 函数：</p>\n<pre><code class=\"c\">int ret = pinctrl_select_state(pctldev, state_name);</code></pre>\n<p>其中，<code>state_name</code> 是要选择的引脚状态的名称。具体的 API 函数和参数将取决于你要执行的具体操作，例如配置引脚功能、设置引脚属性等。</p>\n<p>请注意，在使用 <code>pinctrl</code> API 之前，你需要确保已正确初始化和注册了引脚控制器设备，并且你具有适当的权限来执行相关操作。</p>\n</li>\n</ol>\n<h2 id=\"GPIO模块\"><a href=\"#GPIO模块\" class=\"headerlink\" title=\"GPIO模块\"></a>GPIO模块</h2><p>   GPIO模块的核心层调用了很多的pinctrl的函数，可以去看下源码的设计，设计思路和pinctrl是一样的就不重复了。<br>   可以看下这篇文章的调用方式：<a href=\"https://mp.weixin.qq.com/s/iquUV-xzx1c08spOeW-vPg\" target=\"_blank\" rel=\"noopener\">手把手教你使用 gpio 子系统 API</a>。</p>\n"},{"title":"提升EMC的软件编程策略","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-05-09T01:02:29.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"\n# EMC [简介](https://qian-qiang.github.io/2023/04/emc-emi.html)\n\n# 有哪些电磁失效可能？\n\n由于EMC干扰的注入，对于一个电子系统而言，可能会引起哪些功能失效呢？\n\n- 微控制器无响应 ：怎么会呢？比如因为干扰原因，软件采集的一个错误的输入值，导致进入了死锁。\n- PC指针失控，软件跑飞\n- 执行意外指令\n- 错误的地址指向，数据损坏或丢失\n- 子例程执行错误\n- 设备重启和/或外部异常中断\n- IP 配置损坏 \n- I/O表现异常，比如显示屏花屏，按键功能失效，继电器乱动，模数采样噪声增加，数模输出异常.......\n\n软件故障的后果示例：\n- 产品意外响应 \n- 上下文丢失\n- 进程中的意外分支 \n- 中断丢失 \n- 数据完整性缺失\n- 输入值误读\n\n# 软件编程策略\n\n## 使用硬件&软件看门狗\n为了确保MCU能够从软件失控故障中恢复，看门狗是最有效的可用工具。\n软件看门狗的原理：它是一个在计数结束时产生MCU复位的定时器。一旦看门狗启动，\n防止看门狗复位控制器的唯一方式就是在程序中周期性更新计数器。\n硬件看门狗：单独的看门狗芯片（eg:tps3823），在单位时间内软件没进行喂狗操作看门狗芯\n片就会输出硬件复位信号到MCU芯片进行复位\n\n## 保护闲置程序存储区域\n在大多数应用中，程序存储空间并没有完全被用户代码占满。为了更强的安全性，如果你不想产\n生复位，可以使用代码填满闲置存储位置，这样会强制看门狗复位或者跳向已知的程序位置。 \n    即使程序计数器损坏，并且跳向闲置存储位置，这都将确保MCU恢复和返回到正常操作。在这个闲\n置区域，还可以跳转到恢复故障安全子程序，通过该子程序可恢复正常运行。\n    带有 ARM® Cortex®-M 内核的 STM32 微控制器使用故障异常，当系统遭受EMC干扰时， 它可\n以捕获可能发生的非法存储访问和非法编程行为。未定义的指令操作代码可以用来填充STM32微控制器的闲置存储，在程序计数器失控的情况下，提高故障异常使用率，使得故障安全程序从错误中恢复。\n\n## 闲置中断向量管理\n为了避免意外中断事件导致的问题（无论是什么来源），建议在相应的向量中加入一个有效的中\n断程序地址，以管理所有可能的中断来源。未使用的中断向量指向故障管理程序标签，该标签中填充了简单的 “ 从中断返回 ” 指令\n\nvoid exception_isr（void）\n{\n    //将异常中断记录或者如有可能显示\n    record_exception_isr（）;\n    //让程序一直在这里死循环，通过看门狗让系统自动重启\n    while（1）;\n}\n在可能的情况下将出现这种异常中断记录并显示，同时进入死循环，利用前面说的看门狗技术让系统重启，或者进入设备安全状态。\n\n## 谨慎IO策略\n为啥干扰会注入，下图就是一个直观的例子，干扰最终会在数字系统中引起输入脉冲，这是异常行为:\n输入通道**：包括开关量输入，模数采样输入，可以采用滤波策略。比如开关量输入在既有的硬件输入滤波措施的基础上，可以采用诸如多次检测去抖动策略。\n\n/*伪码描述一下思路*/\n#define FILTER_TIMES  6\n#define SAMPLE_TIMES  10\n#define GET_IO_BIT（X） PA##X //硬件体系不同，具体实现修改\nbool read_io（）\n{\n    uint8 counter = 0;\n    for（int i=0;i < SAMPLE_TIMES;i++）\n        counter += GET_IO_BIT（0）;\n    /*大于门限占比则认为是高电平状态*/\n    if（counter>=FILTER_TIMES）\n        return true;\n    else\n        return false;\n}\n这里仅仅描述一个思路，具体实现时，还需要考虑多次采样，中间是否需要加延时，你可以看成对开关量调整其采样率，进而做出合理判断。如果只读一次，则在干扰注入时，非常容易读取错误的信息。\n\n对于一个模数采样而言，可以利用数字滤波器技术滤除噪声，消除噪声对系统的影响，在一些资源相对有限的系统，推荐使用一阶数字滤波器或者移动均值滤波器去处理。当然使用时需要合理选择截至频率，防止将真实有用信号频率干掉，导致正常功能也无法使用\n\n输出通道：比如显示输出，比如LCD显示屏，可以增加刷新率，这样即使在某个瞬态设备被干扰了，由于刷新及时，那么外在显示就不会出现。人眼就可能无法识别，当然这是一个健壮措施。如果遇到这样的问题，还是建议从硬件上尽量将干扰切断或者降低注入的程度。\n\n## 掉电检测存储技术\n一个电子系统的供电最容易被干扰，因此可以结合硬件设计一个掉电检测及短时板级UPS电路，检测出系统单片机/DSP供电被干扰到可能将要重启时，电路将备用供电切上，同时将关键运行时参数马上存储在非易失介质中（比如EEPROM/FRAM），如果系统真的无法抵抗干扰导致设备重启，在系统上电时，检测重启原因以及数据，如果识别出是由于短时掉电重启的，将介质中数据导入，恢复现场，系统继续执行。\n\n## 冗余数据存储和交换\n数据在EMC场景下遭受磨坏，如果内部没有恢复机制，设备可能出现意想不到的表现。尤其在功能\n安全性要求很高行业，比如航空、医疗、汽车、工业等环境下。电子设备编程都会采用数据备份策略，对于关键安全功能链的内存数据都会强制要求采用备份数据机制，比如在IEC61508中就有强制要求。\n\n将关键功能对应的运行时参数（在内存中的全局变量），都做3个备份。并利用链接绑定技术，将\n这些参数存储在三片连续的内存区中。在写某个参数时，同时也写备份参数。然后在后台中去检查另外两块区域是否相等，如果不相等则可能发生了致命的错误，可以采集故障报警或者设备重启的策略\n\n## 健壮的通信协议设计\n电子系统或多或少都需要与其他设备进行通信，那么设计一个健壮的通信协议也是提高抗干扰措施的一个重要手段，比如增加CRC报文完整性检查，增加错误重传机制，通信故障检测机制等等\n\n## 留意低频信号\n比如系统中出现喇叭。RGB灯等相对系统来说比较高频率的信号需要特别留意。这些信号有可能会和安装和设计问题结合起来形成一个射频天线产生额外的辐射。这些高频信号应该及时提供给硬件工程师分析。\n\n# 总结\nEMC就是个无聊的游戏","source":"_posts/2023/05/提升EMC的软件编程策略.md","raw":"---\ntitle: 提升EMC的软件编程策略\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-05-09 09:02:29\npassword:\nsummary:\ntags:\n- EMC-EMI\ncategories:\n- Embedded system\nkeywords:\ndescription:\n---\n\n# EMC [简介](https://qian-qiang.github.io/2023/04/emc-emi.html)\n\n# 有哪些电磁失效可能？\n\n由于EMC干扰的注入，对于一个电子系统而言，可能会引起哪些功能失效呢？\n\n- 微控制器无响应 ：怎么会呢？比如因为干扰原因，软件采集的一个错误的输入值，导致进入了死锁。\n- PC指针失控，软件跑飞\n- 执行意外指令\n- 错误的地址指向，数据损坏或丢失\n- 子例程执行错误\n- 设备重启和/或外部异常中断\n- IP 配置损坏 \n- I/O表现异常，比如显示屏花屏，按键功能失效，继电器乱动，模数采样噪声增加，数模输出异常.......\n\n软件故障的后果示例：\n- 产品意外响应 \n- 上下文丢失\n- 进程中的意外分支 \n- 中断丢失 \n- 数据完整性缺失\n- 输入值误读\n\n# 软件编程策略\n\n## 使用硬件&软件看门狗\n为了确保MCU能够从软件失控故障中恢复，看门狗是最有效的可用工具。\n软件看门狗的原理：它是一个在计数结束时产生MCU复位的定时器。一旦看门狗启动，\n防止看门狗复位控制器的唯一方式就是在程序中周期性更新计数器。\n硬件看门狗：单独的看门狗芯片（eg:tps3823），在单位时间内软件没进行喂狗操作看门狗芯\n片就会输出硬件复位信号到MCU芯片进行复位\n\n## 保护闲置程序存储区域\n在大多数应用中，程序存储空间并没有完全被用户代码占满。为了更强的安全性，如果你不想产\n生复位，可以使用代码填满闲置存储位置，这样会强制看门狗复位或者跳向已知的程序位置。 \n    即使程序计数器损坏，并且跳向闲置存储位置，这都将确保MCU恢复和返回到正常操作。在这个闲\n置区域，还可以跳转到恢复故障安全子程序，通过该子程序可恢复正常运行。\n    带有 ARM® Cortex®-M 内核的 STM32 微控制器使用故障异常，当系统遭受EMC干扰时， 它可\n以捕获可能发生的非法存储访问和非法编程行为。未定义的指令操作代码可以用来填充STM32微控制器的闲置存储，在程序计数器失控的情况下，提高故障异常使用率，使得故障安全程序从错误中恢复。\n\n## 闲置中断向量管理\n为了避免意外中断事件导致的问题（无论是什么来源），建议在相应的向量中加入一个有效的中\n断程序地址，以管理所有可能的中断来源。未使用的中断向量指向故障管理程序标签，该标签中填充了简单的 “ 从中断返回 ” 指令\n\nvoid exception_isr（void）\n{\n    //将异常中断记录或者如有可能显示\n    record_exception_isr（）;\n    //让程序一直在这里死循环，通过看门狗让系统自动重启\n    while（1）;\n}\n在可能的情况下将出现这种异常中断记录并显示，同时进入死循环，利用前面说的看门狗技术让系统重启，或者进入设备安全状态。\n\n## 谨慎IO策略\n为啥干扰会注入，下图就是一个直观的例子，干扰最终会在数字系统中引起输入脉冲，这是异常行为:\n输入通道**：包括开关量输入，模数采样输入，可以采用滤波策略。比如开关量输入在既有的硬件输入滤波措施的基础上，可以采用诸如多次检测去抖动策略。\n\n/*伪码描述一下思路*/\n#define FILTER_TIMES  6\n#define SAMPLE_TIMES  10\n#define GET_IO_BIT（X） PA##X //硬件体系不同，具体实现修改\nbool read_io（）\n{\n    uint8 counter = 0;\n    for（int i=0;i < SAMPLE_TIMES;i++）\n        counter += GET_IO_BIT（0）;\n    /*大于门限占比则认为是高电平状态*/\n    if（counter>=FILTER_TIMES）\n        return true;\n    else\n        return false;\n}\n这里仅仅描述一个思路，具体实现时，还需要考虑多次采样，中间是否需要加延时，你可以看成对开关量调整其采样率，进而做出合理判断。如果只读一次，则在干扰注入时，非常容易读取错误的信息。\n\n对于一个模数采样而言，可以利用数字滤波器技术滤除噪声，消除噪声对系统的影响，在一些资源相对有限的系统，推荐使用一阶数字滤波器或者移动均值滤波器去处理。当然使用时需要合理选择截至频率，防止将真实有用信号频率干掉，导致正常功能也无法使用\n\n输出通道：比如显示输出，比如LCD显示屏，可以增加刷新率，这样即使在某个瞬态设备被干扰了，由于刷新及时，那么外在显示就不会出现。人眼就可能无法识别，当然这是一个健壮措施。如果遇到这样的问题，还是建议从硬件上尽量将干扰切断或者降低注入的程度。\n\n## 掉电检测存储技术\n一个电子系统的供电最容易被干扰，因此可以结合硬件设计一个掉电检测及短时板级UPS电路，检测出系统单片机/DSP供电被干扰到可能将要重启时，电路将备用供电切上，同时将关键运行时参数马上存储在非易失介质中（比如EEPROM/FRAM），如果系统真的无法抵抗干扰导致设备重启，在系统上电时，检测重启原因以及数据，如果识别出是由于短时掉电重启的，将介质中数据导入，恢复现场，系统继续执行。\n\n## 冗余数据存储和交换\n数据在EMC场景下遭受磨坏，如果内部没有恢复机制，设备可能出现意想不到的表现。尤其在功能\n安全性要求很高行业，比如航空、医疗、汽车、工业等环境下。电子设备编程都会采用数据备份策略，对于关键安全功能链的内存数据都会强制要求采用备份数据机制，比如在IEC61508中就有强制要求。\n\n将关键功能对应的运行时参数（在内存中的全局变量），都做3个备份。并利用链接绑定技术，将\n这些参数存储在三片连续的内存区中。在写某个参数时，同时也写备份参数。然后在后台中去检查另外两块区域是否相等，如果不相等则可能发生了致命的错误，可以采集故障报警或者设备重启的策略\n\n## 健壮的通信协议设计\n电子系统或多或少都需要与其他设备进行通信，那么设计一个健壮的通信协议也是提高抗干扰措施的一个重要手段，比如增加CRC报文完整性检查，增加错误重传机制，通信故障检测机制等等\n\n## 留意低频信号\n比如系统中出现喇叭。RGB灯等相对系统来说比较高频率的信号需要特别留意。这些信号有可能会和安装和设计问题结合起来形成一个射频天线产生额外的辐射。这些高频信号应该及时提供给硬件工程师分析。\n\n# 总结\nEMC就是个无聊的游戏","slug":"提升EMC的软件编程策略","published":1,"updated":"2023-05-12T06:06:20.020Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk69d1em0024jsrjkq133zl5","content":"<h1 id=\"EMC-简介\"><a href=\"#EMC-简介\" class=\"headerlink\" title=\"EMC 简介\"></a>EMC <a href=\"https://qian-qiang.github.io/2023/04/emc-emi.html\" target=\"_blank\" rel=\"noopener\">简介</a></h1><h1 id=\"有哪些电磁失效可能？\"><a href=\"#有哪些电磁失效可能？\" class=\"headerlink\" title=\"有哪些电磁失效可能？\"></a>有哪些电磁失效可能？</h1><p>由于EMC干扰的注入，对于一个电子系统而言，可能会引起哪些功能失效呢？</p>\n<ul>\n<li>微控制器无响应 ：怎么会呢？比如因为干扰原因，软件采集的一个错误的输入值，导致进入了死锁。</li>\n<li>PC指针失控，软件跑飞</li>\n<li>执行意外指令</li>\n<li>错误的地址指向，数据损坏或丢失</li>\n<li>子例程执行错误</li>\n<li>设备重启和/或外部异常中断</li>\n<li>IP 配置损坏 </li>\n<li>I/O表现异常，比如显示屏花屏，按键功能失效，继电器乱动，模数采样噪声增加，数模输出异常…….</li>\n</ul>\n<p>软件故障的后果示例：</p>\n<ul>\n<li>产品意外响应 </li>\n<li>上下文丢失</li>\n<li>进程中的意外分支 </li>\n<li>中断丢失 </li>\n<li>数据完整性缺失</li>\n<li>输入值误读</li>\n</ul>\n<h1 id=\"软件编程策略\"><a href=\"#软件编程策略\" class=\"headerlink\" title=\"软件编程策略\"></a>软件编程策略</h1><h2 id=\"使用硬件-amp-软件看门狗\"><a href=\"#使用硬件-amp-软件看门狗\" class=\"headerlink\" title=\"使用硬件&amp;软件看门狗\"></a>使用硬件&amp;软件看门狗</h2><p>为了确保MCU能够从软件失控故障中恢复，看门狗是最有效的可用工具。<br>软件看门狗的原理：它是一个在计数结束时产生MCU复位的定时器。一旦看门狗启动，<br>防止看门狗复位控制器的唯一方式就是在程序中周期性更新计数器。<br>硬件看门狗：单独的看门狗芯片（eg:tps3823），在单位时间内软件没进行喂狗操作看门狗芯<br>片就会输出硬件复位信号到MCU芯片进行复位</p>\n<h2 id=\"保护闲置程序存储区域\"><a href=\"#保护闲置程序存储区域\" class=\"headerlink\" title=\"保护闲置程序存储区域\"></a>保护闲置程序存储区域</h2><p>在大多数应用中，程序存储空间并没有完全被用户代码占满。为了更强的安全性，如果你不想产<br>生复位，可以使用代码填满闲置存储位置，这样会强制看门狗复位或者跳向已知的程序位置。<br>    即使程序计数器损坏，并且跳向闲置存储位置，这都将确保MCU恢复和返回到正常操作。在这个闲<br>置区域，还可以跳转到恢复故障安全子程序，通过该子程序可恢复正常运行。<br>    带有 ARM® Cortex®-M 内核的 STM32 微控制器使用故障异常，当系统遭受EMC干扰时， 它可<br>以捕获可能发生的非法存储访问和非法编程行为。未定义的指令操作代码可以用来填充STM32微控制器的闲置存储，在程序计数器失控的情况下，提高故障异常使用率，使得故障安全程序从错误中恢复。</p>\n<h2 id=\"闲置中断向量管理\"><a href=\"#闲置中断向量管理\" class=\"headerlink\" title=\"闲置中断向量管理\"></a>闲置中断向量管理</h2><p>为了避免意外中断事件导致的问题（无论是什么来源），建议在相应的向量中加入一个有效的中<br>断程序地址，以管理所有可能的中断来源。未使用的中断向量指向故障管理程序标签，该标签中填充了简单的 “ 从中断返回 ” 指令</p>\n<p>void exception_isr（void）<br>{<br>    //将异常中断记录或者如有可能显示<br>    record_exception_isr（）;<br>    //让程序一直在这里死循环，通过看门狗让系统自动重启<br>    while（1）;<br>}<br>在可能的情况下将出现这种异常中断记录并显示，同时进入死循环，利用前面说的看门狗技术让系统重启，或者进入设备安全状态。</p>\n<h2 id=\"谨慎IO策略\"><a href=\"#谨慎IO策略\" class=\"headerlink\" title=\"谨慎IO策略\"></a>谨慎IO策略</h2><p>为啥干扰会注入，下图就是一个直观的例子，干扰最终会在数字系统中引起输入脉冲，这是异常行为:<br>输入通道**：包括开关量输入，模数采样输入，可以采用滤波策略。比如开关量输入在既有的硬件输入滤波措施的基础上，可以采用诸如多次检测去抖动策略。</p>\n<p>/<em>伪码描述一下思路</em>/</p>\n<p>#define FILTER_TIMES  6</p>\n<p>#define SAMPLE_TIMES  10</p>\n<p>#define GET_IO_BIT（X） PA##X //硬件体系不同，具体实现修改<br>bool read_io（）<br>{<br>    uint8 counter = 0;<br>    for（int i=0;i &lt; SAMPLE_TIMES;i++）<br>        counter += GET_IO_BIT（0）;<br>    /<em>大于门限占比则认为是高电平状态</em>/<br>    if（counter&gt;=FILTER_TIMES）<br>        return true;<br>    else<br>        return false;<br>}<br>这里仅仅描述一个思路，具体实现时，还需要考虑多次采样，中间是否需要加延时，你可以看成对开关量调整其采样率，进而做出合理判断。如果只读一次，则在干扰注入时，非常容易读取错误的信息。</p>\n<p>对于一个模数采样而言，可以利用数字滤波器技术滤除噪声，消除噪声对系统的影响，在一些资源相对有限的系统，推荐使用一阶数字滤波器或者移动均值滤波器去处理。当然使用时需要合理选择截至频率，防止将真实有用信号频率干掉，导致正常功能也无法使用</p>\n<p>输出通道：比如显示输出，比如LCD显示屏，可以增加刷新率，这样即使在某个瞬态设备被干扰了，由于刷新及时，那么外在显示就不会出现。人眼就可能无法识别，当然这是一个健壮措施。如果遇到这样的问题，还是建议从硬件上尽量将干扰切断或者降低注入的程度。</p>\n<h2 id=\"掉电检测存储技术\"><a href=\"#掉电检测存储技术\" class=\"headerlink\" title=\"掉电检测存储技术\"></a>掉电检测存储技术</h2><p>一个电子系统的供电最容易被干扰，因此可以结合硬件设计一个掉电检测及短时板级UPS电路，检测出系统单片机/DSP供电被干扰到可能将要重启时，电路将备用供电切上，同时将关键运行时参数马上存储在非易失介质中（比如EEPROM/FRAM），如果系统真的无法抵抗干扰导致设备重启，在系统上电时，检测重启原因以及数据，如果识别出是由于短时掉电重启的，将介质中数据导入，恢复现场，系统继续执行。</p>\n<h2 id=\"冗余数据存储和交换\"><a href=\"#冗余数据存储和交换\" class=\"headerlink\" title=\"冗余数据存储和交换\"></a>冗余数据存储和交换</h2><p>数据在EMC场景下遭受磨坏，如果内部没有恢复机制，设备可能出现意想不到的表现。尤其在功能<br>安全性要求很高行业，比如航空、医疗、汽车、工业等环境下。电子设备编程都会采用数据备份策略，对于关键安全功能链的内存数据都会强制要求采用备份数据机制，比如在IEC61508中就有强制要求。</p>\n<p>将关键功能对应的运行时参数（在内存中的全局变量），都做3个备份。并利用链接绑定技术，将<br>这些参数存储在三片连续的内存区中。在写某个参数时，同时也写备份参数。然后在后台中去检查另外两块区域是否相等，如果不相等则可能发生了致命的错误，可以采集故障报警或者设备重启的策略</p>\n<h2 id=\"健壮的通信协议设计\"><a href=\"#健壮的通信协议设计\" class=\"headerlink\" title=\"健壮的通信协议设计\"></a>健壮的通信协议设计</h2><p>电子系统或多或少都需要与其他设备进行通信，那么设计一个健壮的通信协议也是提高抗干扰措施的一个重要手段，比如增加CRC报文完整性检查，增加错误重传机制，通信故障检测机制等等</p>\n<h2 id=\"留意低频信号\"><a href=\"#留意低频信号\" class=\"headerlink\" title=\"留意低频信号\"></a>留意低频信号</h2><p>比如系统中出现喇叭。RGB灯等相对系统来说比较高频率的信号需要特别留意。这些信号有可能会和安装和设计问题结合起来形成一个射频天线产生额外的辐射。这些高频信号应该及时提供给硬件工程师分析。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>EMC就是个无聊的游戏</p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<h1 id=\"EMC-简介\"><a href=\"#EMC-简介\" class=\"headerlink\" title=\"EMC 简介\"></a>EMC <a href=\"https://qian-qiang.github.io/2023/04/emc-emi.html\" target=\"_blank\" rel=\"noopener\">简介</a></h1><h1 id=\"有哪些电磁失效可能？\"><a href=\"#有哪些电磁失效可能？\" class=\"headerlink\" title=\"有哪些电磁失效可能？\"></a>有哪些电磁失效可能？</h1><p>由于EMC干扰的注入，对于一个电子系统而言，可能会引起哪些功能失效呢？</p>\n<ul>\n<li>微控制器无响应 ：怎么会呢？比如因为干扰原因，软件采集的一个错误的输入值，导致进入了死锁。</li>\n<li>PC指针失控，软件跑飞</li>\n<li>执行意外指令</li>\n<li>错误的地址指向，数据损坏或丢失</li>\n<li>子例程执行错误</li>\n<li>设备重启和/或外部异常中断</li>\n<li>IP 配置损坏 </li>\n<li>I/O表现异常，比如显示屏花屏，按键功能失效，继电器乱动，模数采样噪声增加，数模输出异常…….</li>\n</ul>\n<p>软件故障的后果示例：</p>\n<ul>\n<li>产品意外响应 </li>\n<li>上下文丢失</li>\n<li>进程中的意外分支 </li>\n<li>中断丢失 </li>\n<li>数据完整性缺失</li>\n<li>输入值误读</li>\n</ul>\n<h1 id=\"软件编程策略\"><a href=\"#软件编程策略\" class=\"headerlink\" title=\"软件编程策略\"></a>软件编程策略</h1><h2 id=\"使用硬件-amp-软件看门狗\"><a href=\"#使用硬件-amp-软件看门狗\" class=\"headerlink\" title=\"使用硬件&amp;软件看门狗\"></a>使用硬件&amp;软件看门狗</h2><p>为了确保MCU能够从软件失控故障中恢复，看门狗是最有效的可用工具。<br>软件看门狗的原理：它是一个在计数结束时产生MCU复位的定时器。一旦看门狗启动，<br>防止看门狗复位控制器的唯一方式就是在程序中周期性更新计数器。<br>硬件看门狗：单独的看门狗芯片（eg:tps3823），在单位时间内软件没进行喂狗操作看门狗芯<br>片就会输出硬件复位信号到MCU芯片进行复位</p>\n<h2 id=\"保护闲置程序存储区域\"><a href=\"#保护闲置程序存储区域\" class=\"headerlink\" title=\"保护闲置程序存储区域\"></a>保护闲置程序存储区域</h2><p>在大多数应用中，程序存储空间并没有完全被用户代码占满。为了更强的安全性，如果你不想产<br>生复位，可以使用代码填满闲置存储位置，这样会强制看门狗复位或者跳向已知的程序位置。<br>    即使程序计数器损坏，并且跳向闲置存储位置，这都将确保MCU恢复和返回到正常操作。在这个闲<br>置区域，还可以跳转到恢复故障安全子程序，通过该子程序可恢复正常运行。<br>    带有 ARM® Cortex®-M 内核的 STM32 微控制器使用故障异常，当系统遭受EMC干扰时， 它可<br>以捕获可能发生的非法存储访问和非法编程行为。未定义的指令操作代码可以用来填充STM32微控制器的闲置存储，在程序计数器失控的情况下，提高故障异常使用率，使得故障安全程序从错误中恢复。</p>\n<h2 id=\"闲置中断向量管理\"><a href=\"#闲置中断向量管理\" class=\"headerlink\" title=\"闲置中断向量管理\"></a>闲置中断向量管理</h2><p>为了避免意外中断事件导致的问题（无论是什么来源），建议在相应的向量中加入一个有效的中<br>断程序地址，以管理所有可能的中断来源。未使用的中断向量指向故障管理程序标签，该标签中填充了简单的 “ 从中断返回 ” 指令</p>\n<p>void exception_isr（void）<br>{<br>    //将异常中断记录或者如有可能显示<br>    record_exception_isr（）;<br>    //让程序一直在这里死循环，通过看门狗让系统自动重启<br>    while（1）;<br>}<br>在可能的情况下将出现这种异常中断记录并显示，同时进入死循环，利用前面说的看门狗技术让系统重启，或者进入设备安全状态。</p>\n<h2 id=\"谨慎IO策略\"><a href=\"#谨慎IO策略\" class=\"headerlink\" title=\"谨慎IO策略\"></a>谨慎IO策略</h2><p>为啥干扰会注入，下图就是一个直观的例子，干扰最终会在数字系统中引起输入脉冲，这是异常行为:<br>输入通道**：包括开关量输入，模数采样输入，可以采用滤波策略。比如开关量输入在既有的硬件输入滤波措施的基础上，可以采用诸如多次检测去抖动策略。</p>\n<p>/<em>伪码描述一下思路</em>/</p>\n<p>#define FILTER_TIMES  6</p>\n<p>#define SAMPLE_TIMES  10</p>\n<p>#define GET_IO_BIT（X） PA##X //硬件体系不同，具体实现修改<br>bool read_io（）<br>{<br>    uint8 counter = 0;<br>    for（int i=0;i &lt; SAMPLE_TIMES;i++）<br>        counter += GET_IO_BIT（0）;<br>    /<em>大于门限占比则认为是高电平状态</em>/<br>    if（counter&gt;=FILTER_TIMES）<br>        return true;<br>    else<br>        return false;<br>}<br>这里仅仅描述一个思路，具体实现时，还需要考虑多次采样，中间是否需要加延时，你可以看成对开关量调整其采样率，进而做出合理判断。如果只读一次，则在干扰注入时，非常容易读取错误的信息。</p>\n<p>对于一个模数采样而言，可以利用数字滤波器技术滤除噪声，消除噪声对系统的影响，在一些资源相对有限的系统，推荐使用一阶数字滤波器或者移动均值滤波器去处理。当然使用时需要合理选择截至频率，防止将真实有用信号频率干掉，导致正常功能也无法使用</p>\n<p>输出通道：比如显示输出，比如LCD显示屏，可以增加刷新率，这样即使在某个瞬态设备被干扰了，由于刷新及时，那么外在显示就不会出现。人眼就可能无法识别，当然这是一个健壮措施。如果遇到这样的问题，还是建议从硬件上尽量将干扰切断或者降低注入的程度。</p>\n<h2 id=\"掉电检测存储技术\"><a href=\"#掉电检测存储技术\" class=\"headerlink\" title=\"掉电检测存储技术\"></a>掉电检测存储技术</h2><p>一个电子系统的供电最容易被干扰，因此可以结合硬件设计一个掉电检测及短时板级UPS电路，检测出系统单片机/DSP供电被干扰到可能将要重启时，电路将备用供电切上，同时将关键运行时参数马上存储在非易失介质中（比如EEPROM/FRAM），如果系统真的无法抵抗干扰导致设备重启，在系统上电时，检测重启原因以及数据，如果识别出是由于短时掉电重启的，将介质中数据导入，恢复现场，系统继续执行。</p>\n<h2 id=\"冗余数据存储和交换\"><a href=\"#冗余数据存储和交换\" class=\"headerlink\" title=\"冗余数据存储和交换\"></a>冗余数据存储和交换</h2><p>数据在EMC场景下遭受磨坏，如果内部没有恢复机制，设备可能出现意想不到的表现。尤其在功能<br>安全性要求很高行业，比如航空、医疗、汽车、工业等环境下。电子设备编程都会采用数据备份策略，对于关键安全功能链的内存数据都会强制要求采用备份数据机制，比如在IEC61508中就有强制要求。</p>\n<p>将关键功能对应的运行时参数（在内存中的全局变量），都做3个备份。并利用链接绑定技术，将<br>这些参数存储在三片连续的内存区中。在写某个参数时，同时也写备份参数。然后在后台中去检查另外两块区域是否相等，如果不相等则可能发生了致命的错误，可以采集故障报警或者设备重启的策略</p>\n<h2 id=\"健壮的通信协议设计\"><a href=\"#健壮的通信协议设计\" class=\"headerlink\" title=\"健壮的通信协议设计\"></a>健壮的通信协议设计</h2><p>电子系统或多或少都需要与其他设备进行通信，那么设计一个健壮的通信协议也是提高抗干扰措施的一个重要手段，比如增加CRC报文完整性检查，增加错误重传机制，通信故障检测机制等等</p>\n<h2 id=\"留意低频信号\"><a href=\"#留意低频信号\" class=\"headerlink\" title=\"留意低频信号\"></a>留意低频信号</h2><p>比如系统中出现喇叭。RGB灯等相对系统来说比较高频率的信号需要特别留意。这些信号有可能会和安装和设计问题结合起来形成一个射频天线产生额外的辐射。这些高频信号应该及时提供给硬件工程师分析。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>EMC就是个无聊的游戏</p>\n"},{"title":"linux内核-tool目录","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-06-06T11:14:50.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"\n# Q：tool目录在linux内核中是干嘛的\n# A：顾名思义工具文件夹\n\n> 提示：我们的代码架构是不是应该也将工具集中在一个目录\n\n## tool目录结构\n![tool目录结构](linux内核-tool目录/tool目录.png)\n首先看下文件夹的makefile文件[链接](https://elixir.bootlin.com/linux/v4.3.6/source/tools/Makefile)\n文件内容：\n    1：help告诉你有哪些工具和编译删除的方法\n    2：各工具的编译命令\n\n## 编译命令解析\n### make -C tools/ acpi_install\n以 acpi 工具为例\nhelp提示编译命令为：make -C tools/ acpi_install\n就会执行makefile文件命令：\n```\nacpi: FORCE  \n    $(call descend,power/$@)\n```\n\ndescend是一个函数在tools/scripts/Makefile，\n根据提供的代码，`descend`函数的定义如下：\n\n```tools/scripts/Makefile.include\ndescend = \\\n    +mkdir -p $(OUTPUT)$(1) && \\\n    $(MAKE) $(COMMAND_O) subdir=$(if $(subdir),$(subdir)/$(1),$(1)) $(PRINT_DIR) -C $(1) $(2)\n```\n\n这个函数是一个Makefile的宏定义。它定义了一个命令序列，用于在指定的目录中执行进一步的构建操作。下面是对该函数的解释：\n\n1. `mkdir -p $(OUTPUT)$(1)`：创建目录`$(OUTPUT)$(1)`，如果该目录不存在。`$(OUTPUT)`是一个变量，表示输出目录的路径，`$(1)`表示传递给`descend`函数的第一个参数，即目录名。\n2. `$(MAKE) $(COMMAND_O)`：使用`$(MAKE)`命令调用Make工具，`$(COMMAND_O)`是一个变量，可能包含一些Make工具的选项或参数。\n3. `subdir=$(if $(subdir),$(subdir)/$(1),$(1))`：这行代码用于设置`subdir`变量的值。`subdir`可能是一个已定义的变量，如果它有值，则将其与`$(1)`（目录名）连接起来作为新的子目录路径。如果`subdir`没有定义，则将`$(1)`作为子目录路径。\n4. `$(PRINT_DIR)`：这个变量可能包含打印目录信息的选项或命令。\n5. `-C $(1)`：指定Make工具在目录`$(1)`中执行构建操作。\n6. `$(2)`：这个参数是传递给`descend`函数的第二个参数，可能包含其他的选项或命令。\n\n综上所述，通过调用`$(call descend, power/acpi)`，将执行以下操作：\n\n1. 创建目录`$(OUTPUT)power/acpi`，如果该目录不存在，即生成在tools/power/acpi目录下\n2. 在`power/acpi`目录中执行Make工具，并传递`subdir=power/acpi`和其他可能的选项或命令。\n\n### [tools/power/acpi/Makefile](https://elixir.bootlin.com/linux/v4.2.7/source/tools/power/acpi/Makefile)\n这个makefile文件跟简单就是编译链接相应的文件设置保存路径等最后生成acpidump可执行文件，再将可执行文件拷贝到开发板或则文件系统中即可使用\n\n### 工具介绍\n以下是对所列工具的简要介绍：\n\n1. ACPI工具（acpi）：提供与ACPI（高级配置和电源接口）相关的功能和信息，用于管理和监视系统的电源管理和配置。\n\n2. cgroup工具（cgroup）：用于管理和控制Linux控制组（cgroup）的工具，cgroup用于限制、分配和监控进程组的资源（如CPU、内存、磁盘I/O等）。\n\n3. cpupower（cpupower）：用于管理和调整x86 CPU功耗和性能的工具，可以控制CPU频率、功耗模式以及其他与CPU相关的设置。\n\n4. firewire工具（firewire）：用于IEEE-1394（FireWire）总线的用户空间工具，用于监视和分析IEEE-1394网络流量。\n\n5. hv工具（hv）：用于在Hyper-V客户端环境中使用的工具集，提供与Hyper-V虚拟化平台相关的功能和管理。\n\n6. lguest（lguest）：一个最小化的32位x86虚拟化平台，用于运行客户操作系统作为虚拟机。\n\n7. perf工具（perf）：Linux性能测量和分析工具，用于收集系统和应用程序的性能数据，进行性能分析和优化。\n\n8. selftests（selftests）：包含各种内核自测（self-test）工具和测试套件，用于测试和验证Linux内核的功能和稳定性。\n\n9. turbostat（turbostat）：用于报告Intel CPU空闲状态和频率的工具，提供有关CPU功耗、频率调节和性能的信息。\n\n10. USB测试工具（usb）：用于测试和诊断USB设备和功能的工具集，用于调试和分析USB相关问题。\n\n11. virtio（virtio）：用于虚拟化环境中的vhost测试模块，提供对虚拟I/O设备（如磁盘、网络等）的性能测试和评估。\n\n12. 网络工具（net）：包含各种杂项网络工具，用于网络配置、监视和故障排除，如网络接口管理、路由设置、网络诊断等。\n\n13. VM工具（vm）：包含各种杂项虚拟机（VM）工具，用于管理和操作虚拟机，如创建、配置、迁移虚拟机等。\n\n14. x86_energy_perf_policy（x86_energy_perf_policy）：英特尔能效策略工具，用于管理和优化英特尔CPU的能效策略设置。\n\n15. tmon工具（tmon）：用于热监视和调整的工具，用于监测系统温度、风扇速度和其他与热管理相关的参数，并进行热优化和调整。\n\n这些工具提供了一系列功能，用于管理、调整和监视不同方面的系统资源和配置，以及进行性能优化、调试和故障排除。具体使用方法可以参考各自工具的文档和手册。eg:man acpidump。\n\n### menuconfig配置\n![menuconfig配置方法](linux内核-tool目录/menuconfig.png)\n配置第一个即可 注意打开depends\n\n\n","source":"_posts/2023/06/linux内核-tool目录.md","raw":"---\ntitle: linux内核-tool目录\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-06-06 19:14:50\npassword:\nsummary:\ntags:\n- tool目录\n- linux\ncategories:\n- linux\nkeywords:\ndescription:\n---\n\n# Q：tool目录在linux内核中是干嘛的\n# A：顾名思义工具文件夹\n\n> 提示：我们的代码架构是不是应该也将工具集中在一个目录\n\n## tool目录结构\n![tool目录结构](linux内核-tool目录/tool目录.png)\n首先看下文件夹的makefile文件[链接](https://elixir.bootlin.com/linux/v4.3.6/source/tools/Makefile)\n文件内容：\n    1：help告诉你有哪些工具和编译删除的方法\n    2：各工具的编译命令\n\n## 编译命令解析\n### make -C tools/ acpi_install\n以 acpi 工具为例\nhelp提示编译命令为：make -C tools/ acpi_install\n就会执行makefile文件命令：\n```\nacpi: FORCE  \n    $(call descend,power/$@)\n```\n\ndescend是一个函数在tools/scripts/Makefile，\n根据提供的代码，`descend`函数的定义如下：\n\n```tools/scripts/Makefile.include\ndescend = \\\n    +mkdir -p $(OUTPUT)$(1) && \\\n    $(MAKE) $(COMMAND_O) subdir=$(if $(subdir),$(subdir)/$(1),$(1)) $(PRINT_DIR) -C $(1) $(2)\n```\n\n这个函数是一个Makefile的宏定义。它定义了一个命令序列，用于在指定的目录中执行进一步的构建操作。下面是对该函数的解释：\n\n1. `mkdir -p $(OUTPUT)$(1)`：创建目录`$(OUTPUT)$(1)`，如果该目录不存在。`$(OUTPUT)`是一个变量，表示输出目录的路径，`$(1)`表示传递给`descend`函数的第一个参数，即目录名。\n2. `$(MAKE) $(COMMAND_O)`：使用`$(MAKE)`命令调用Make工具，`$(COMMAND_O)`是一个变量，可能包含一些Make工具的选项或参数。\n3. `subdir=$(if $(subdir),$(subdir)/$(1),$(1))`：这行代码用于设置`subdir`变量的值。`subdir`可能是一个已定义的变量，如果它有值，则将其与`$(1)`（目录名）连接起来作为新的子目录路径。如果`subdir`没有定义，则将`$(1)`作为子目录路径。\n4. `$(PRINT_DIR)`：这个变量可能包含打印目录信息的选项或命令。\n5. `-C $(1)`：指定Make工具在目录`$(1)`中执行构建操作。\n6. `$(2)`：这个参数是传递给`descend`函数的第二个参数，可能包含其他的选项或命令。\n\n综上所述，通过调用`$(call descend, power/acpi)`，将执行以下操作：\n\n1. 创建目录`$(OUTPUT)power/acpi`，如果该目录不存在，即生成在tools/power/acpi目录下\n2. 在`power/acpi`目录中执行Make工具，并传递`subdir=power/acpi`和其他可能的选项或命令。\n\n### [tools/power/acpi/Makefile](https://elixir.bootlin.com/linux/v4.2.7/source/tools/power/acpi/Makefile)\n这个makefile文件跟简单就是编译链接相应的文件设置保存路径等最后生成acpidump可执行文件，再将可执行文件拷贝到开发板或则文件系统中即可使用\n\n### 工具介绍\n以下是对所列工具的简要介绍：\n\n1. ACPI工具（acpi）：提供与ACPI（高级配置和电源接口）相关的功能和信息，用于管理和监视系统的电源管理和配置。\n\n2. cgroup工具（cgroup）：用于管理和控制Linux控制组（cgroup）的工具，cgroup用于限制、分配和监控进程组的资源（如CPU、内存、磁盘I/O等）。\n\n3. cpupower（cpupower）：用于管理和调整x86 CPU功耗和性能的工具，可以控制CPU频率、功耗模式以及其他与CPU相关的设置。\n\n4. firewire工具（firewire）：用于IEEE-1394（FireWire）总线的用户空间工具，用于监视和分析IEEE-1394网络流量。\n\n5. hv工具（hv）：用于在Hyper-V客户端环境中使用的工具集，提供与Hyper-V虚拟化平台相关的功能和管理。\n\n6. lguest（lguest）：一个最小化的32位x86虚拟化平台，用于运行客户操作系统作为虚拟机。\n\n7. perf工具（perf）：Linux性能测量和分析工具，用于收集系统和应用程序的性能数据，进行性能分析和优化。\n\n8. selftests（selftests）：包含各种内核自测（self-test）工具和测试套件，用于测试和验证Linux内核的功能和稳定性。\n\n9. turbostat（turbostat）：用于报告Intel CPU空闲状态和频率的工具，提供有关CPU功耗、频率调节和性能的信息。\n\n10. USB测试工具（usb）：用于测试和诊断USB设备和功能的工具集，用于调试和分析USB相关问题。\n\n11. virtio（virtio）：用于虚拟化环境中的vhost测试模块，提供对虚拟I/O设备（如磁盘、网络等）的性能测试和评估。\n\n12. 网络工具（net）：包含各种杂项网络工具，用于网络配置、监视和故障排除，如网络接口管理、路由设置、网络诊断等。\n\n13. VM工具（vm）：包含各种杂项虚拟机（VM）工具，用于管理和操作虚拟机，如创建、配置、迁移虚拟机等。\n\n14. x86_energy_perf_policy（x86_energy_perf_policy）：英特尔能效策略工具，用于管理和优化英特尔CPU的能效策略设置。\n\n15. tmon工具（tmon）：用于热监视和调整的工具，用于监测系统温度、风扇速度和其他与热管理相关的参数，并进行热优化和调整。\n\n这些工具提供了一系列功能，用于管理、调整和监视不同方面的系统资源和配置，以及进行性能优化、调试和故障排除。具体使用方法可以参考各自工具的文档和手册。eg:man acpidump。\n\n### menuconfig配置\n![menuconfig配置方法](linux内核-tool目录/menuconfig.png)\n配置第一个即可 注意打开depends\n\n\n","slug":"linux内核-tool目录","published":1,"updated":"2023-06-28T01:06:19.407Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk69d1ep0027jsrjxiy9ecg0","content":"<h1 id=\"Q：tool目录在linux内核中是干嘛的\"><a href=\"#Q：tool目录在linux内核中是干嘛的\" class=\"headerlink\" title=\"Q：tool目录在linux内核中是干嘛的\"></a>Q：tool目录在linux内核中是干嘛的</h1><h1 id=\"A：顾名思义工具文件夹\"><a href=\"#A：顾名思义工具文件夹\" class=\"headerlink\" title=\"A：顾名思义工具文件夹\"></a>A：顾名思义工具文件夹</h1><blockquote>\n<p>提示：我们的代码架构是不是应该也将工具集中在一个目录</p>\n</blockquote>\n<h2 id=\"tool目录结构\"><a href=\"#tool目录结构\" class=\"headerlink\" title=\"tool目录结构\"></a>tool目录结构</h2><p><img src=\"/2023/06/linux-nei-he-tool-mu-lu/tool%E7%9B%AE%E5%BD%95.png\" alt=\"tool目录结构\"><br>首先看下文件夹的makefile文件<a href=\"https://elixir.bootlin.com/linux/v4.3.6/source/tools/Makefile\" target=\"_blank\" rel=\"noopener\">链接</a><br>文件内容：<br>    1：help告诉你有哪些工具和编译删除的方法<br>    2：各工具的编译命令</p>\n<h2 id=\"编译命令解析\"><a href=\"#编译命令解析\" class=\"headerlink\" title=\"编译命令解析\"></a>编译命令解析</h2><h3 id=\"make-C-tools-acpi-install\"><a href=\"#make-C-tools-acpi-install\" class=\"headerlink\" title=\"make -C tools/ acpi_install\"></a>make -C tools/ acpi_install</h3><p>以 acpi 工具为例<br>help提示编译命令为：make -C tools/ acpi_install<br>就会执行makefile文件命令：</p>\n<pre><code>acpi: FORCE  \n    $(call descend,power/$@)</code></pre><p>descend是一个函数在tools/scripts/Makefile，<br>根据提供的代码，<code>descend</code>函数的定义如下：</p>\n<pre class=\" language-tools/scripts/Makefile.include\"><code class=\"language-tools/scripts/Makefile.include\">descend = \\\n    +mkdir -p $(OUTPUT)$(1) && \\\n    $(MAKE) $(COMMAND_O) subdir=$(if $(subdir),$(subdir)/$(1),$(1)) $(PRINT_DIR) -C $(1) $(2)</code></pre>\n<p>这个函数是一个Makefile的宏定义。它定义了一个命令序列，用于在指定的目录中执行进一步的构建操作。下面是对该函数的解释：</p>\n<ol>\n<li><code>mkdir -p $(OUTPUT)$(1)</code>：创建目录<code>$(OUTPUT)$(1)</code>，如果该目录不存在。<code>$(OUTPUT)</code>是一个变量，表示输出目录的路径，<code>$(1)</code>表示传递给<code>descend</code>函数的第一个参数，即目录名。</li>\n<li><code>$(MAKE) $(COMMAND_O)</code>：使用<code>$(MAKE)</code>命令调用Make工具，<code>$(COMMAND_O)</code>是一个变量，可能包含一些Make工具的选项或参数。</li>\n<li><code>subdir=$(if $(subdir),$(subdir)/$(1),$(1))</code>：这行代码用于设置<code>subdir</code>变量的值。<code>subdir</code>可能是一个已定义的变量，如果它有值，则将其与<code>$(1)</code>（目录名）连接起来作为新的子目录路径。如果<code>subdir</code>没有定义，则将<code>$(1)</code>作为子目录路径。</li>\n<li><code>$(PRINT_DIR)</code>：这个变量可能包含打印目录信息的选项或命令。</li>\n<li><code>-C $(1)</code>：指定Make工具在目录<code>$(1)</code>中执行构建操作。</li>\n<li><code>$(2)</code>：这个参数是传递给<code>descend</code>函数的第二个参数，可能包含其他的选项或命令。</li>\n</ol>\n<p>综上所述，通过调用<code>$(call descend, power/acpi)</code>，将执行以下操作：</p>\n<ol>\n<li>创建目录<code>$(OUTPUT)power/acpi</code>，如果该目录不存在，即生成在tools/power/acpi目录下</li>\n<li>在<code>power/acpi</code>目录中执行Make工具，并传递<code>subdir=power/acpi</code>和其他可能的选项或命令。</li>\n</ol>\n<h3 id=\"tools-power-acpi-Makefile\"><a href=\"#tools-power-acpi-Makefile\" class=\"headerlink\" title=\"tools/power/acpi/Makefile\"></a><a href=\"https://elixir.bootlin.com/linux/v4.2.7/source/tools/power/acpi/Makefile\" target=\"_blank\" rel=\"noopener\">tools/power/acpi/Makefile</a></h3><p>这个makefile文件跟简单就是编译链接相应的文件设置保存路径等最后生成acpidump可执行文件，再将可执行文件拷贝到开发板或则文件系统中即可使用</p>\n<h3 id=\"工具介绍\"><a href=\"#工具介绍\" class=\"headerlink\" title=\"工具介绍\"></a>工具介绍</h3><p>以下是对所列工具的简要介绍：</p>\n<ol>\n<li><p>ACPI工具（acpi）：提供与ACPI（高级配置和电源接口）相关的功能和信息，用于管理和监视系统的电源管理和配置。</p>\n</li>\n<li><p>cgroup工具（cgroup）：用于管理和控制Linux控制组（cgroup）的工具，cgroup用于限制、分配和监控进程组的资源（如CPU、内存、磁盘I/O等）。</p>\n</li>\n<li><p>cpupower（cpupower）：用于管理和调整x86 CPU功耗和性能的工具，可以控制CPU频率、功耗模式以及其他与CPU相关的设置。</p>\n</li>\n<li><p>firewire工具（firewire）：用于IEEE-1394（FireWire）总线的用户空间工具，用于监视和分析IEEE-1394网络流量。</p>\n</li>\n<li><p>hv工具（hv）：用于在Hyper-V客户端环境中使用的工具集，提供与Hyper-V虚拟化平台相关的功能和管理。</p>\n</li>\n<li><p>lguest（lguest）：一个最小化的32位x86虚拟化平台，用于运行客户操作系统作为虚拟机。</p>\n</li>\n<li><p>perf工具（perf）：Linux性能测量和分析工具，用于收集系统和应用程序的性能数据，进行性能分析和优化。</p>\n</li>\n<li><p>selftests（selftests）：包含各种内核自测（self-test）工具和测试套件，用于测试和验证Linux内核的功能和稳定性。</p>\n</li>\n<li><p>turbostat（turbostat）：用于报告Intel CPU空闲状态和频率的工具，提供有关CPU功耗、频率调节和性能的信息。</p>\n</li>\n<li><p>USB测试工具（usb）：用于测试和诊断USB设备和功能的工具集，用于调试和分析USB相关问题。</p>\n</li>\n<li><p>virtio（virtio）：用于虚拟化环境中的vhost测试模块，提供对虚拟I/O设备（如磁盘、网络等）的性能测试和评估。</p>\n</li>\n<li><p>网络工具（net）：包含各种杂项网络工具，用于网络配置、监视和故障排除，如网络接口管理、路由设置、网络诊断等。</p>\n</li>\n<li><p>VM工具（vm）：包含各种杂项虚拟机（VM）工具，用于管理和操作虚拟机，如创建、配置、迁移虚拟机等。</p>\n</li>\n<li><p>x86_energy_perf_policy（x86_energy_perf_policy）：英特尔能效策略工具，用于管理和优化英特尔CPU的能效策略设置。</p>\n</li>\n<li><p>tmon工具（tmon）：用于热监视和调整的工具，用于监测系统温度、风扇速度和其他与热管理相关的参数，并进行热优化和调整。</p>\n</li>\n</ol>\n<p>这些工具提供了一系列功能，用于管理、调整和监视不同方面的系统资源和配置，以及进行性能优化、调试和故障排除。具体使用方法可以参考各自工具的文档和手册。eg:man acpidump。</p>\n<h3 id=\"menuconfig配置\"><a href=\"#menuconfig配置\" class=\"headerlink\" title=\"menuconfig配置\"></a>menuconfig配置</h3><p><img src=\"/2023/06/linux-nei-he-tool-mu-lu/menuconfig.png\" alt=\"menuconfig配置方法\"><br>配置第一个即可 注意打开depends</p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<h1 id=\"Q：tool目录在linux内核中是干嘛的\"><a href=\"#Q：tool目录在linux内核中是干嘛的\" class=\"headerlink\" title=\"Q：tool目录在linux内核中是干嘛的\"></a>Q：tool目录在linux内核中是干嘛的</h1><h1 id=\"A：顾名思义工具文件夹\"><a href=\"#A：顾名思义工具文件夹\" class=\"headerlink\" title=\"A：顾名思义工具文件夹\"></a>A：顾名思义工具文件夹</h1><blockquote>\n<p>提示：我们的代码架构是不是应该也将工具集中在一个目录</p>\n</blockquote>\n<h2 id=\"tool目录结构\"><a href=\"#tool目录结构\" class=\"headerlink\" title=\"tool目录结构\"></a>tool目录结构</h2><p><img src=\"/2023/06/linux-nei-he-tool-mu-lu/tool%E7%9B%AE%E5%BD%95.png\" alt=\"tool目录结构\"><br>首先看下文件夹的makefile文件<a href=\"https://elixir.bootlin.com/linux/v4.3.6/source/tools/Makefile\" target=\"_blank\" rel=\"noopener\">链接</a><br>文件内容：<br>    1：help告诉你有哪些工具和编译删除的方法<br>    2：各工具的编译命令</p>\n<h2 id=\"编译命令解析\"><a href=\"#编译命令解析\" class=\"headerlink\" title=\"编译命令解析\"></a>编译命令解析</h2><h3 id=\"make-C-tools-acpi-install\"><a href=\"#make-C-tools-acpi-install\" class=\"headerlink\" title=\"make -C tools/ acpi_install\"></a>make -C tools/ acpi_install</h3><p>以 acpi 工具为例<br>help提示编译命令为：make -C tools/ acpi_install<br>就会执行makefile文件命令：</p>\n<pre><code>acpi: FORCE  \n    $(call descend,power/$@)</code></pre><p>descend是一个函数在tools/scripts/Makefile，<br>根据提供的代码，<code>descend</code>函数的定义如下：</p>\n<pre><code class=\"tools/scripts/Makefile.include\">descend = \\\n    +mkdir -p $(OUTPUT)$(1) &amp;&amp; \\\n    $(MAKE) $(COMMAND_O) subdir=$(if $(subdir),$(subdir)/$(1),$(1)) $(PRINT_DIR) -C $(1) $(2)</code></pre>\n<p>这个函数是一个Makefile的宏定义。它定义了一个命令序列，用于在指定的目录中执行进一步的构建操作。下面是对该函数的解释：</p>\n<ol>\n<li><code>mkdir -p $(OUTPUT)$(1)</code>：创建目录<code>$(OUTPUT)$(1)</code>，如果该目录不存在。<code>$(OUTPUT)</code>是一个变量，表示输出目录的路径，<code>$(1)</code>表示传递给<code>descend</code>函数的第一个参数，即目录名。</li>\n<li><code>$(MAKE) $(COMMAND_O)</code>：使用<code>$(MAKE)</code>命令调用Make工具，<code>$(COMMAND_O)</code>是一个变量，可能包含一些Make工具的选项或参数。</li>\n<li><code>subdir=$(if $(subdir),$(subdir)/$(1),$(1))</code>：这行代码用于设置<code>subdir</code>变量的值。<code>subdir</code>可能是一个已定义的变量，如果它有值，则将其与<code>$(1)</code>（目录名）连接起来作为新的子目录路径。如果<code>subdir</code>没有定义，则将<code>$(1)</code>作为子目录路径。</li>\n<li><code>$(PRINT_DIR)</code>：这个变量可能包含打印目录信息的选项或命令。</li>\n<li><code>-C $(1)</code>：指定Make工具在目录<code>$(1)</code>中执行构建操作。</li>\n<li><code>$(2)</code>：这个参数是传递给<code>descend</code>函数的第二个参数，可能包含其他的选项或命令。</li>\n</ol>\n<p>综上所述，通过调用<code>$(call descend, power/acpi)</code>，将执行以下操作：</p>\n<ol>\n<li>创建目录<code>$(OUTPUT)power/acpi</code>，如果该目录不存在，即生成在tools/power/acpi目录下</li>\n<li>在<code>power/acpi</code>目录中执行Make工具，并传递<code>subdir=power/acpi</code>和其他可能的选项或命令。</li>\n</ol>\n<h3 id=\"tools-power-acpi-Makefile\"><a href=\"#tools-power-acpi-Makefile\" class=\"headerlink\" title=\"tools/power/acpi/Makefile\"></a><a href=\"https://elixir.bootlin.com/linux/v4.2.7/source/tools/power/acpi/Makefile\" target=\"_blank\" rel=\"noopener\">tools/power/acpi/Makefile</a></h3><p>这个makefile文件跟简单就是编译链接相应的文件设置保存路径等最后生成acpidump可执行文件，再将可执行文件拷贝到开发板或则文件系统中即可使用</p>\n<h3 id=\"工具介绍\"><a href=\"#工具介绍\" class=\"headerlink\" title=\"工具介绍\"></a>工具介绍</h3><p>以下是对所列工具的简要介绍：</p>\n<ol>\n<li><p>ACPI工具（acpi）：提供与ACPI（高级配置和电源接口）相关的功能和信息，用于管理和监视系统的电源管理和配置。</p>\n</li>\n<li><p>cgroup工具（cgroup）：用于管理和控制Linux控制组（cgroup）的工具，cgroup用于限制、分配和监控进程组的资源（如CPU、内存、磁盘I/O等）。</p>\n</li>\n<li><p>cpupower（cpupower）：用于管理和调整x86 CPU功耗和性能的工具，可以控制CPU频率、功耗模式以及其他与CPU相关的设置。</p>\n</li>\n<li><p>firewire工具（firewire）：用于IEEE-1394（FireWire）总线的用户空间工具，用于监视和分析IEEE-1394网络流量。</p>\n</li>\n<li><p>hv工具（hv）：用于在Hyper-V客户端环境中使用的工具集，提供与Hyper-V虚拟化平台相关的功能和管理。</p>\n</li>\n<li><p>lguest（lguest）：一个最小化的32位x86虚拟化平台，用于运行客户操作系统作为虚拟机。</p>\n</li>\n<li><p>perf工具（perf）：Linux性能测量和分析工具，用于收集系统和应用程序的性能数据，进行性能分析和优化。</p>\n</li>\n<li><p>selftests（selftests）：包含各种内核自测（self-test）工具和测试套件，用于测试和验证Linux内核的功能和稳定性。</p>\n</li>\n<li><p>turbostat（turbostat）：用于报告Intel CPU空闲状态和频率的工具，提供有关CPU功耗、频率调节和性能的信息。</p>\n</li>\n<li><p>USB测试工具（usb）：用于测试和诊断USB设备和功能的工具集，用于调试和分析USB相关问题。</p>\n</li>\n<li><p>virtio（virtio）：用于虚拟化环境中的vhost测试模块，提供对虚拟I/O设备（如磁盘、网络等）的性能测试和评估。</p>\n</li>\n<li><p>网络工具（net）：包含各种杂项网络工具，用于网络配置、监视和故障排除，如网络接口管理、路由设置、网络诊断等。</p>\n</li>\n<li><p>VM工具（vm）：包含各种杂项虚拟机（VM）工具，用于管理和操作虚拟机，如创建、配置、迁移虚拟机等。</p>\n</li>\n<li><p>x86_energy_perf_policy（x86_energy_perf_policy）：英特尔能效策略工具，用于管理和优化英特尔CPU的能效策略设置。</p>\n</li>\n<li><p>tmon工具（tmon）：用于热监视和调整的工具，用于监测系统温度、风扇速度和其他与热管理相关的参数，并进行热优化和调整。</p>\n</li>\n</ol>\n<p>这些工具提供了一系列功能，用于管理、调整和监视不同方面的系统资源和配置，以及进行性能优化、调试和故障排除。具体使用方法可以参考各自工具的文档和手册。eg:man acpidump。</p>\n<h3 id=\"menuconfig配置\"><a href=\"#menuconfig配置\" class=\"headerlink\" title=\"menuconfig配置\"></a>menuconfig配置</h3><p><img src=\"/2023/06/linux-nei-he-tool-mu-lu/menuconfig.png\" alt=\"menuconfig配置方法\"><br>配置第一个即可 注意打开depends</p>\n"},{"title":"ttymxx(UART)","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-06-27T11:04:26.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"\n#  Q：linux中如何控制串口？\n#  A：模块化设计\n\n## 第一步：设置设备树中关于串口的信息（设备树模块）\n```\n    uart1: serial@02020000 {\n        compatible = \"fsl,imx6ul-uart\",\n                    \"fsl,imx6q-uart\", \"fsl,imx21-uart\";\n        reg = <0x02020000 0x4000>;\n        interrupts = <GIC_SPI 26 IRQ_TYPE_LEVEL_HIGH>;\n        clocks = <&clks IMX6UL_CLK_UART1_IPG>,\n                <&clks IMX6UL_CLK_UART1_SERIAL>;\n        clock-names = \"ipg\", \"per\";\n        status = \"disabled\";\n    };\n    uart3: serial@021ec000 {\n        compatible = \"fsl,imx6ul-uart\",\n                    \"fsl,imx6q-uart\", \"fsl,imx21-uart\";\n        reg = <0x021ec000 0x4000>;\n        interrupts = <GIC_SPI 28 IRQ_TYPE_LEVEL_HIGH>;\n        clocks = <&clks IMX6UL_CLK_UART3_IPG>,\n                <&clks IMX6UL_CLK_UART3_SERIAL>;\n        clock-names = \"ipg\", \"per\";\n        dmas = <&sdma 29 4 0>, <&sdma 30 4 0>;\n        dma-names = \"rx\", \"tx\";\n        status = \"disabled\";\n    };   \n```\n\n## 第二步：驱动获取设备树生成设备（驱动模块）\n\ndrivers/tty/serial/imx.c文件中有如下内容：\n ```\nstatic struct platform_device_id imx_uart_devtype[] = {\n\t{\n\t\t.name = \"imx1-uart\",\n\t\t.driver_data = (kernel_ulong_t) &imx_uart_devdata[IMX1_UART],\n\t}, {\n\t\t.name = \"imx21-uart\",\n\t\t.driver_data = (kernel_ulong_t) &imx_uart_devdata[IMX21_UART],\n\t}, {\n\t\t.name = \"imx6q-uart\",\n\t\t.driver_data = (kernel_ulong_t) &imx_uart_devdata[IMX6Q_UART],\n\t}, {\n\t\t/* sentinel */\n\t}\n};\nMODULE_DEVICE_TABLE(platform, imx_uart_devtype);\n```\n\n```\nstatic struct uart_driver imx_reg = {\n\t.owner          = THIS_MODULE,\n\t.driver_name    = DRIVER_NAME,  //\"IMX-uart\"\n\t.dev_name       = DEV_NAME,     //\"ttymxc\"\n\t.major          = SERIAL_IMX_MAJOR, //207\n\t.minor          = MINOR_START,      //16\n\t.nr             = ARRAY_SIZE(imx_ports),    //8\n\t.cons           = IMX_CONSOLE,      //NULL\n};\n```\n\nplatform平台对比到相同的设备树中的compatible到驱动中的name的时候就执行probe函数：\n\n<details><summary>static int serial_imx_probe（struct platform_device *pdev）</summary>\n<pre><code>\n{\n\tstruct imx_port *sport;\n\tvoid __iomem *base;\n\tint ret = 0;\n\tstruct resource *res;\n\tint txirq, rxirq, rtsirq;\n\tsport = devm_kzalloc(&pdev->dev, sizeof(*sport), GFP_KERNEL);\n\tif (!sport)\n\t\treturn -ENOMEM;\n\tret = serial_imx_probe_dt(sport, pdev);\n\tif (ret > 0)\n\t\tserial_imx_probe_pdata(sport, pdev);\n\telse if (ret < 0)\n\t\treturn ret;\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tbase = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\trxirq = platform_get_irq(pdev, 0);\n\ttxirq = platform_get_irq(pdev, 1);\n\trtsirq = platform_get_irq(pdev, 2);\n\tsport->port.dev = &pdev->dev;\n\tsport->port.mapbase = res->start;\n\tsport->port.membase = base;\n\tsport->port.type = PORT_IMX,\n\tsport->port.iotype = UPIO_MEM;\n\tsport->port.irq = rxirq;\n\tsport->port.fifosize = 32;\n\tsport->port.ops = &imx_pops;\n\tsport->port.rs485_config = imx_rs485_config;\n\tsport->port.rs485.flags =\n\t\tSER_RS485_RTS_ON_SEND | SER_RS485_RX_DURING_TX;\n\tsport->port.flags = UPF_BOOT_AUTOCONF;\n\tinit_timer(&sport->timer);\n\tsport->timer.function = imx_timeout;\n\tsport->timer.data     = (unsigned long)sport;\n\tsport->clk_ipg = devm_clk_get(&pdev->dev, \"ipg\");\n\tif (IS_ERR(sport->clk_ipg)) {\n\t\tret = PTR_ERR(sport->clk_ipg);\n\t\tdev_err(&pdev->dev, \"failed to get ipg clk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tsport->clk_per = devm_clk_get(&pdev->dev, \"per\");\n\tif (IS_ERR(sport->clk_per)) {\n\t\tret = PTR_ERR(sport->clk_per);\n\t\tdev_err(&pdev->dev, \"failed to get per clk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tsport->port.uartclk = clk_get_rate(sport->clk_per);\n\tif (sport->port.uartclk > IMX_MODULE_MAX_CLK_RATE) {\n\t\tret = clk_set_rate(sport->clk_per, IMX_MODULE_MAX_CLK_RATE);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&pdev->dev, \"clk_set_rate() failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\tsport->port.uartclk = clk_get_rate(sport->clk_per);\n\tif (txirq > 0) {\n\t\tret = devm_request_irq(&pdev->dev, rxirq, imx_rxint, 0,\n\t\t\t\t       dev_name(&pdev->dev), sport);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = devm_request_irq(&pdev->dev, txirq, imx_txint, 0,\n\t\t\t\t       dev_name(&pdev->dev), sport);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tret = devm_request_irq(&pdev->dev, rxirq, imx_int, 0,\n\t\t\t\t       dev_name(&pdev->dev), sport);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\timx_ports[sport->port.line] = sport;\n\tplatform_set_drvdata(pdev, sport);\n\treturn uart_add_one_port(&imx_reg, &sport->port);\n}\n</code></pre></details>\n\n`serial_imx_probe`函数是针对i.MX系列平台设备的串口驱动的探测函数。该函数的功能是在系统启动时，当检测到与i.MX系列平台相关的串口设备时，自动初始化和注册相应的串口驱动程序。\n\n具体功能包括：\n\n1. 识别并验证与i.MX平台相关的串口设备资源。通过检查设备树（device tree）或其他平台特定的数据结构，确定该平台上的串口设备的物理地址、中断号、时钟等信息，并进行验证。\n\n2. 为每个串口设备分配和初始化相应的`struct uart_port`结构体。该结构体用于表示一个串口设备的相关参数和状态信息，如设备的基地址、中断号、波特率等。\n\n3. 注册串口驱动程序。调用`uart_add_one_port`函数将初始化好的`struct uart_port`结构体注册到串口子系统中，以便操作系统可以管理和操作该串口设备。\n\n4. 执行其他平台特定的初始化操作。根据i.MX平台的要求，可能需要进行其他特定于该平台的初始化步骤，如设置GPIO引脚、时钟源等。\n\n总而言之，`serial_imx_probe`函数的功能是在系统启动时，自动探测和初始化i.MX平台上的串口设备，并注册相应的串口驱动程序，以便后续操作系统和用户空间程序可以与这些串口设备进行通信和交互。\n\n数据结构的关系：\n内核串口驱动结构uart_driver（imx_reg）在 imx_serial_init 函数中向 Linux 内核注册了 imx_reg。\n当 UART 设备和驱动匹配成功以后 serial_imx_probe 函数就会执行，此函数的重点工作就\n是初始化 uart_port，然后将其添加到对应的 uart_driver 中。imx驱动自己创建了imx_port 结构体里面有一个成员就是uart_port，最后通过uart_add_one_port注册。\n\n所以在dev目录下就会有：![ls /dev](ttymxx-UART/ls-dev.png) 对应到uart1->ttymxc0和uart3->ttymxc2\n设备号：![设备号](ttymxx-UART/ttymxc.png)\n设备：![设备](ttymxx-UART/cat-proc-devices.png)\n\n## 第三步：使用串口（应用模块）\n通过串口发送数据到ttymxc2,执行cat /dev/ttymxc2：![ttymxc2](ttymxx-UART/cat-ttymxc2.png) 应该是和串口发送的十六进制数据是一样的。所以所有的操作都应该是基于此文件或则设备相关的硬件信号。\n\n### 方法一：轮询\n1. 打开串口\n```\nfd = open(port, O_RDWR | O_NOCTTY | O_NDELAY);\nif (fd == -1) \n{\n    perror(\"open_port: Unable to open serial port\");\n    return -1;\n}\n```\n2. 配置串口\n```\ntcgetattr(fd, &options);\ncfsetispeed(&options, B115200);\ncfsetospeed(&options, B115200);\noptions.c_cflag |= (CLOCAL | CREAD);\noptions.c_cflag &= ~PARENB;\noptions.c_cflag &= ~CSTOPB;\noptions.c_cflag &= ~CSIZE;\noptions.c_cflag |= CS8;\noptions.c_cflag &= ~CRTSCTS;\ntcsetattr(fd, TCSANOW, &options);\n```\n其中，tcgetattr 和 tcsetattr 函数用于获取和设置串口参数。cfsetispeed 和 cfsetospeed 函数用于设置串口的输入和输出波特率，这里设置为 115200。options.c_cflag 表示控制标志位，用于配置串口控制参数，具体含义如下：\n\n    CLOCAL：忽略调制解调器的状态线，只允许本地使用串口。\n\n    CREAD：允许从串口读取数据。\n\n    PARENB：启用奇偶校验。&= ~PARENB则为禁用校验。\n\n    CSTOPB：使用两个停止位而不是一个。&= ~CSTOPB停止位为1。\n\n    CSIZE：表示字符长度的位掩码。在这里设置为 0，表示使用默认的 8 位数据位。\n\n    CS8：表示使用 8 位数据位。\n\n    CRTSCTS：启用硬件流控制，即使用 RTS 和 CTS 状态线进行流控制。\n\n在示例程序中，我们将 CLOCAL 和 CREAD 标志位置为 1，表示允许本地使用串口，并允许从串口读取数据。我们将 PARENB、CSTOPB 和 CRTSCTS 标志位都设置为 0，表示不启用奇偶校验、使用一个停止位和禁用硬件流控制。最后，我们将 CSIZE 标志位设置为 0，然后将 CS8 标志位设置为 1，以表示使用 8 位数据位。\n3. 读写\n```\nread(fd, buf, sizeof(buf)); // 返回接收个数\nwrite(fd, buf, strlen(buf)); // 返回发送长度,负值表示发送失败\n```\n4. 关闭串口\n```\nclose(fd);\n```\n完整示例\n<details><summary>轮询code</summary>\n<pre><code>\n    int main()\n    {\n        int fd;\n        char buf[255];\n        int n;\n        fd = open_port(\"/dev/ttyUSB0\");\n        if (fd == -1) {\n\n            printf(\"open err\\n\");\n            exit(1);\n        }\n        while (1)\n        {\n            n = read(fd, buf, sizeof(buf));\n            if (n > 0) {\n                printf(\"Received: %.*s\\n\", n, buf);\n            }\n            strcpy(buf, \"Hello, world!\\n\");\n            n = write(fd, buf, strlen(buf));\n            if (n < 0) {\n                perror(\"write failed\\n\");\n            }\n            usleep(10 * 1000);\n        }\n        close(fd);\n        printf(\"close uart\\n\");\n        return 0;\n    }\n\n    int open_port(const char *port)\n    {\n        int fd;\n        struct termios options;\n        fd = open(port, O_RDWR | O_NOCTTY | O_NDELAY);\n        if (fd == -1) {\n            perror(\"open_port: Unable to open serial port\");\n            return -1;\n        }\n        tcgetattr(fd, &options);\n        cfsetispeed(&options, B115200);\n        cfsetospeed(&options, B115200);\n        options.c_cflag |= (CLOCAL | CREAD);\n        options.c_cflag &= ~PARENB;\n        options.c_cflag &= ~CSTOPB;\n        options.c_cflag &= ~CSIZE;\n        options.c_cflag |= CS8;\n        options.c_cflag &= ~CRTSCTS;\n        tcsetattr(fd, TCSANOW, &options);\n        return fd;\n    }\n</code></pre></details>\n\n### 方法二：中断读取示例\n上面给出的串口示例是使用轮询的方式读取串口数据，这种方式在某些场景下可能会占用大量 CPU 资源。实际上，对于 Linux 系统来说，还可以使用中断方式接收串口数据，这样可以大大减少 CPU 的占用率，并且能够更快地响应串口数据。\n\n要使用中断方式接收串口数据，可以使用 select 函数来监听串口文件描述符的可读事件。当串口数据可读时，select 函数将返回，并且可以调用 read 函数来读取串口数据。这种方式可以避免轮询操作，只有在串口数据可读时才会执行读取操作，因此能够减少 CPU 的占用率。\n\n以下是一个简单的使用中断方式接收串口数据的示例程序：\n<details><summary>中断读取code</summary>\n<pre><code>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <termios.h>\n#include <sys/select.h>\n\nint main() {\n    int fd;\n    struct termios options;\n    fd_set rfds;\n\n    // 打开串口设备\n    fd = open(\"/dev/ttyUSB0\", O_RDWR | O_NOCTTY);\n    if (fd < 0) {\n        perror(\"open\");\n        return -1;\n    }\n\n    // 配置串口参数\n    tcgetattr(fd, &options);\n    options.c_cflag = B9600 | CS8 | CLOCAL | CREAD;\n    options.c_iflag = IGNPAR;\n    options.c_oflag = 0;\n    options.c_lflag = 0;\n    options.c_cc[VTIME] = 0;\n    options.c_cc[VMIN] = 1;\n    tcsetattr(fd, TCSANOW, &options);\n\n    while (1) {\n        // 使用 select 函数监听串口文件描述符的可读事件\n        FD_ZERO(&rfds);\n        FD_SET(fd, &rfds);\n        select(fd + 1, &rfds, NULL, NULL, NULL);\n\n        // 读取串口数据\n        char buf[256];\n        int n = read(fd, buf, sizeof(buf));\n        if (n > 0) {\n            printf(\"Received data: %.*s\\n\", n, buf);\n        }\n    }\n\n    // 关闭串口设备\n    close(fd);\n\n    return 0;\n}\n</code></pre></details>\n需要注意的是，在使用中断方式接收串口数据时，需要对串口文件描述符设置为非阻塞模式，以便在 select 函数返回时立即读取串口数据。可以使用 fcntl 函数来设置文件描述符的标志位，如下所示：\n```\n// 设置串口文件描述符为非阻塞模式\nint flags = fcntl(fd, F_GETFL, 0);\nfcntl(fd, F_SETFL, flags | O_NONBLOCK);\n```\n\n### 方法三：信号的方式接收数据\n<details><summary>信号的方式接收code</summary>\n<pre><code>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <termios.h>\n#include <signal.h>\n\nint fd;\n\nvoid sigio_handler(int sig) {\n    char buf[256];\n    int n = read(fd, buf, sizeof(buf));\n    if (n > 0) {\n        printf(\"Received data: %.*s\\n\", n, buf);\n    }\n}\n\nint main() {\n    struct termios options;\n    struct sigaction sa;\n\n    // 打开串口设备\n    fd = open(\"/dev/ttyS0\", O_RDWR | O_NOCTTY);\n    if (fd < 0) {\n        perror(\"open\");\n        return -1;\n    }\n\n    // 配置串口参数\n    tcgetattr(fd, &options);\n    options.c_cflag = B9600 | CS8 | CLOCAL | CREAD;\n    options.c_iflag = IGNPAR;\n    options.c_oflag = 0;\n    options.c_lflag = 0;\n    options.c_cc[VTIME] = 0;\n    options.c_cc[VMIN] = 1;\n    tcsetattr(fd, TCSANOW, &options);\n\n    // 设置串口文件描述符为异步通知模式\n    /* 将串口文件描述符设置为当前进程的拥有者，从而接收该文件描述符相关的信号。*/\n    fcntl(fd, F_SETOWN, getpid()); \n    int flags = fcntl(fd, F_GETFL, 0); // 先获取当前配置, 下面只更改O_ASYNC标志\n    /* 将串口文件描述符设置为非阻塞模式，从而允许该文件描述符异步地接收数据和信号。*/\n    fcntl(fd, F_SETFL, flags | O_ASYNC);\n\n    // 设置 SIGIO 信号的处理函数\n    sa.sa_handler = sigio_handler;\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = 0;\n    /* 设置了 SIGIO 信号的处理函数为 sigio_handler，从而在该信号被触发时读取串口数据并进行处理。*/\n    sigaction(SIGIO, &sa, NULL);\n\n    while (1) {\n        // 等待 SIGIO 信号\n        sleep(1);\n    }\n\n    // 关闭串口设备\n    close(fd);\n\n    return 0;\n}\n</code></pre></details>\n上述代码中，使用了 fcntl 函数将串口文件描述符设置为异步通知模式，并使用 SIGIO 信号来通知程序串口数据已经可读。当程序接收到 SIGIO 信号时，会调用 sigio_handler 函数来读取并处理串口数据。\n\n在这段代码中，sigemptyset（&sa.sa_mask）;的作用是将信号处理函数在执行时要屏蔽的信号集合清空，即将其设置为空集。\n\n每个进程都有一个信号屏蔽字，它表示了当前被阻塞的信号集合。当一个信号被阻塞时，它将被加入到信号屏蔽字中，而当信号被解除阻塞时，它将被从信号屏蔽字中移除。如果信号处理函数在执行时需要屏蔽其他的信号，则可以使用sigaddset等函数将需要屏蔽的信号添加到信号屏蔽字中。但是，在本例中，我们需要处理的信号是SIGIO，它通常不需要被屏蔽，因此我们使用sigemptyset函数将信号屏蔽字清空，以确保在处理SIGIO信号时不会屏蔽任何其他信号。\n\n在Linux系统中，使用sigaction函数注册信号处理函数时，可以设置一些标志来指定信号处理的行为。例如，可以使用SA_RESTART标志来指定当系统调用被信号中断时自动重启该系统调用。在本例中，由于我们并不需要设置任何标志，因此将sa.sa_flags字段设置为0即可。这表示信号处理函数不需要任何特殊的行为，只需要按照默认的方式处理信号即可。\n\n### 方法四：使用线程接收串口数据\n<details><summary>使用线程接收code</summary>\n<pre><code>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <termios.h>\n#include <pthread.h>\n\nvoid *read_thread(void *arg) {\n    int fd = *(int *)arg;\n    char buf[256];\n    int n;\n\n    while (1) {\n        // 读取串口数据\n        n = read(fd, buf, sizeof(buf));\n        if (n > 0) {\n            printf(\"Received data: %.*s\\n\", n, buf);\n        }\n    }\n\n    return NULL;\n}\n\nint main() {\n    int fd;\n    struct termios options;\n    pthread_t tid;\n\n    // 打开串口设备\n    fd = open(\"/dev/ttyS0\", O_RDWR | O_NOCTTY);\n    if (fd < 0) {\n        perror(\"open\");\n        return -1;\n    }\n\n    // 配置串口参数\n    tcgetattr(fd, &options);\n    options.c_cflag = B9600 | CS8 | CLOCAL | CREAD;\n    options.c_iflag = IGNPAR;\n    options.c_oflag = 0;\n    options.c_lflag = 0;\n    options.c_cc[VTIME] = 0;\n    options.c_cc[VMIN] = 1;\n    tcsetattr(fd, TCSANOW, &options);\n\n    // 创建读取线程\n    if (pthread_create(&tid, NULL, read_thread, &fd) != 0) {\n        perror(\"pthread_create\");\n        return -1;\n    }\n\n    while (1) {\n        // 主线程的其他处理逻辑\n        sleep(1);\n    }\n\n    // 关闭串口设备\n    close(fd);\n\n    return 0;\n}\n</code></pre></details>\n上述代码中，创建了一个读取线程，不断读取串口数据并进行处理。主线程可以在读取线程运行的同时进行其他处理逻辑。","source":"_posts/2023/06/ttymxx-UART.md","raw":"---\ntitle: ttymxx(UART)\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-06-27 19:04:26\npassword:\nsummary:\ntags:\n- linux\ncategories:\n- linux\nkeywords:\ndescription:\n---\n\n#  Q：linux中如何控制串口？\n#  A：模块化设计\n\n## 第一步：设置设备树中关于串口的信息（设备树模块）\n```\n    uart1: serial@02020000 {\n        compatible = \"fsl,imx6ul-uart\",\n                    \"fsl,imx6q-uart\", \"fsl,imx21-uart\";\n        reg = <0x02020000 0x4000>;\n        interrupts = <GIC_SPI 26 IRQ_TYPE_LEVEL_HIGH>;\n        clocks = <&clks IMX6UL_CLK_UART1_IPG>,\n                <&clks IMX6UL_CLK_UART1_SERIAL>;\n        clock-names = \"ipg\", \"per\";\n        status = \"disabled\";\n    };\n    uart3: serial@021ec000 {\n        compatible = \"fsl,imx6ul-uart\",\n                    \"fsl,imx6q-uart\", \"fsl,imx21-uart\";\n        reg = <0x021ec000 0x4000>;\n        interrupts = <GIC_SPI 28 IRQ_TYPE_LEVEL_HIGH>;\n        clocks = <&clks IMX6UL_CLK_UART3_IPG>,\n                <&clks IMX6UL_CLK_UART3_SERIAL>;\n        clock-names = \"ipg\", \"per\";\n        dmas = <&sdma 29 4 0>, <&sdma 30 4 0>;\n        dma-names = \"rx\", \"tx\";\n        status = \"disabled\";\n    };   \n```\n\n## 第二步：驱动获取设备树生成设备（驱动模块）\n\ndrivers/tty/serial/imx.c文件中有如下内容：\n ```\nstatic struct platform_device_id imx_uart_devtype[] = {\n\t{\n\t\t.name = \"imx1-uart\",\n\t\t.driver_data = (kernel_ulong_t) &imx_uart_devdata[IMX1_UART],\n\t}, {\n\t\t.name = \"imx21-uart\",\n\t\t.driver_data = (kernel_ulong_t) &imx_uart_devdata[IMX21_UART],\n\t}, {\n\t\t.name = \"imx6q-uart\",\n\t\t.driver_data = (kernel_ulong_t) &imx_uart_devdata[IMX6Q_UART],\n\t}, {\n\t\t/* sentinel */\n\t}\n};\nMODULE_DEVICE_TABLE(platform, imx_uart_devtype);\n```\n\n```\nstatic struct uart_driver imx_reg = {\n\t.owner          = THIS_MODULE,\n\t.driver_name    = DRIVER_NAME,  //\"IMX-uart\"\n\t.dev_name       = DEV_NAME,     //\"ttymxc\"\n\t.major          = SERIAL_IMX_MAJOR, //207\n\t.minor          = MINOR_START,      //16\n\t.nr             = ARRAY_SIZE(imx_ports),    //8\n\t.cons           = IMX_CONSOLE,      //NULL\n};\n```\n\nplatform平台对比到相同的设备树中的compatible到驱动中的name的时候就执行probe函数：\n\n<details><summary>static int serial_imx_probe（struct platform_device *pdev）</summary>\n<pre><code>\n{\n\tstruct imx_port *sport;\n\tvoid __iomem *base;\n\tint ret = 0;\n\tstruct resource *res;\n\tint txirq, rxirq, rtsirq;\n\tsport = devm_kzalloc(&pdev->dev, sizeof(*sport), GFP_KERNEL);\n\tif (!sport)\n\t\treturn -ENOMEM;\n\tret = serial_imx_probe_dt(sport, pdev);\n\tif (ret > 0)\n\t\tserial_imx_probe_pdata(sport, pdev);\n\telse if (ret < 0)\n\t\treturn ret;\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tbase = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\trxirq = platform_get_irq(pdev, 0);\n\ttxirq = platform_get_irq(pdev, 1);\n\trtsirq = platform_get_irq(pdev, 2);\n\tsport->port.dev = &pdev->dev;\n\tsport->port.mapbase = res->start;\n\tsport->port.membase = base;\n\tsport->port.type = PORT_IMX,\n\tsport->port.iotype = UPIO_MEM;\n\tsport->port.irq = rxirq;\n\tsport->port.fifosize = 32;\n\tsport->port.ops = &imx_pops;\n\tsport->port.rs485_config = imx_rs485_config;\n\tsport->port.rs485.flags =\n\t\tSER_RS485_RTS_ON_SEND | SER_RS485_RX_DURING_TX;\n\tsport->port.flags = UPF_BOOT_AUTOCONF;\n\tinit_timer(&sport->timer);\n\tsport->timer.function = imx_timeout;\n\tsport->timer.data     = (unsigned long)sport;\n\tsport->clk_ipg = devm_clk_get(&pdev->dev, \"ipg\");\n\tif (IS_ERR(sport->clk_ipg)) {\n\t\tret = PTR_ERR(sport->clk_ipg);\n\t\tdev_err(&pdev->dev, \"failed to get ipg clk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tsport->clk_per = devm_clk_get(&pdev->dev, \"per\");\n\tif (IS_ERR(sport->clk_per)) {\n\t\tret = PTR_ERR(sport->clk_per);\n\t\tdev_err(&pdev->dev, \"failed to get per clk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tsport->port.uartclk = clk_get_rate(sport->clk_per);\n\tif (sport->port.uartclk > IMX_MODULE_MAX_CLK_RATE) {\n\t\tret = clk_set_rate(sport->clk_per, IMX_MODULE_MAX_CLK_RATE);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&pdev->dev, \"clk_set_rate() failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\tsport->port.uartclk = clk_get_rate(sport->clk_per);\n\tif (txirq > 0) {\n\t\tret = devm_request_irq(&pdev->dev, rxirq, imx_rxint, 0,\n\t\t\t\t       dev_name(&pdev->dev), sport);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = devm_request_irq(&pdev->dev, txirq, imx_txint, 0,\n\t\t\t\t       dev_name(&pdev->dev), sport);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tret = devm_request_irq(&pdev->dev, rxirq, imx_int, 0,\n\t\t\t\t       dev_name(&pdev->dev), sport);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\timx_ports[sport->port.line] = sport;\n\tplatform_set_drvdata(pdev, sport);\n\treturn uart_add_one_port(&imx_reg, &sport->port);\n}\n</code></pre></details>\n\n`serial_imx_probe`函数是针对i.MX系列平台设备的串口驱动的探测函数。该函数的功能是在系统启动时，当检测到与i.MX系列平台相关的串口设备时，自动初始化和注册相应的串口驱动程序。\n\n具体功能包括：\n\n1. 识别并验证与i.MX平台相关的串口设备资源。通过检查设备树（device tree）或其他平台特定的数据结构，确定该平台上的串口设备的物理地址、中断号、时钟等信息，并进行验证。\n\n2. 为每个串口设备分配和初始化相应的`struct uart_port`结构体。该结构体用于表示一个串口设备的相关参数和状态信息，如设备的基地址、中断号、波特率等。\n\n3. 注册串口驱动程序。调用`uart_add_one_port`函数将初始化好的`struct uart_port`结构体注册到串口子系统中，以便操作系统可以管理和操作该串口设备。\n\n4. 执行其他平台特定的初始化操作。根据i.MX平台的要求，可能需要进行其他特定于该平台的初始化步骤，如设置GPIO引脚、时钟源等。\n\n总而言之，`serial_imx_probe`函数的功能是在系统启动时，自动探测和初始化i.MX平台上的串口设备，并注册相应的串口驱动程序，以便后续操作系统和用户空间程序可以与这些串口设备进行通信和交互。\n\n数据结构的关系：\n内核串口驱动结构uart_driver（imx_reg）在 imx_serial_init 函数中向 Linux 内核注册了 imx_reg。\n当 UART 设备和驱动匹配成功以后 serial_imx_probe 函数就会执行，此函数的重点工作就\n是初始化 uart_port，然后将其添加到对应的 uart_driver 中。imx驱动自己创建了imx_port 结构体里面有一个成员就是uart_port，最后通过uart_add_one_port注册。\n\n所以在dev目录下就会有：![ls /dev](ttymxx-UART/ls-dev.png) 对应到uart1->ttymxc0和uart3->ttymxc2\n设备号：![设备号](ttymxx-UART/ttymxc.png)\n设备：![设备](ttymxx-UART/cat-proc-devices.png)\n\n## 第三步：使用串口（应用模块）\n通过串口发送数据到ttymxc2,执行cat /dev/ttymxc2：![ttymxc2](ttymxx-UART/cat-ttymxc2.png) 应该是和串口发送的十六进制数据是一样的。所以所有的操作都应该是基于此文件或则设备相关的硬件信号。\n\n### 方法一：轮询\n1. 打开串口\n```\nfd = open(port, O_RDWR | O_NOCTTY | O_NDELAY);\nif (fd == -1) \n{\n    perror(\"open_port: Unable to open serial port\");\n    return -1;\n}\n```\n2. 配置串口\n```\ntcgetattr(fd, &options);\ncfsetispeed(&options, B115200);\ncfsetospeed(&options, B115200);\noptions.c_cflag |= (CLOCAL | CREAD);\noptions.c_cflag &= ~PARENB;\noptions.c_cflag &= ~CSTOPB;\noptions.c_cflag &= ~CSIZE;\noptions.c_cflag |= CS8;\noptions.c_cflag &= ~CRTSCTS;\ntcsetattr(fd, TCSANOW, &options);\n```\n其中，tcgetattr 和 tcsetattr 函数用于获取和设置串口参数。cfsetispeed 和 cfsetospeed 函数用于设置串口的输入和输出波特率，这里设置为 115200。options.c_cflag 表示控制标志位，用于配置串口控制参数，具体含义如下：\n\n    CLOCAL：忽略调制解调器的状态线，只允许本地使用串口。\n\n    CREAD：允许从串口读取数据。\n\n    PARENB：启用奇偶校验。&= ~PARENB则为禁用校验。\n\n    CSTOPB：使用两个停止位而不是一个。&= ~CSTOPB停止位为1。\n\n    CSIZE：表示字符长度的位掩码。在这里设置为 0，表示使用默认的 8 位数据位。\n\n    CS8：表示使用 8 位数据位。\n\n    CRTSCTS：启用硬件流控制，即使用 RTS 和 CTS 状态线进行流控制。\n\n在示例程序中，我们将 CLOCAL 和 CREAD 标志位置为 1，表示允许本地使用串口，并允许从串口读取数据。我们将 PARENB、CSTOPB 和 CRTSCTS 标志位都设置为 0，表示不启用奇偶校验、使用一个停止位和禁用硬件流控制。最后，我们将 CSIZE 标志位设置为 0，然后将 CS8 标志位设置为 1，以表示使用 8 位数据位。\n3. 读写\n```\nread(fd, buf, sizeof(buf)); // 返回接收个数\nwrite(fd, buf, strlen(buf)); // 返回发送长度,负值表示发送失败\n```\n4. 关闭串口\n```\nclose(fd);\n```\n完整示例\n<details><summary>轮询code</summary>\n<pre><code>\n    int main()\n    {\n        int fd;\n        char buf[255];\n        int n;\n        fd = open_port(\"/dev/ttyUSB0\");\n        if (fd == -1) {\n\n            printf(\"open err\\n\");\n            exit(1);\n        }\n        while (1)\n        {\n            n = read(fd, buf, sizeof(buf));\n            if (n > 0) {\n                printf(\"Received: %.*s\\n\", n, buf);\n            }\n            strcpy(buf, \"Hello, world!\\n\");\n            n = write(fd, buf, strlen(buf));\n            if (n < 0) {\n                perror(\"write failed\\n\");\n            }\n            usleep(10 * 1000);\n        }\n        close(fd);\n        printf(\"close uart\\n\");\n        return 0;\n    }\n\n    int open_port(const char *port)\n    {\n        int fd;\n        struct termios options;\n        fd = open(port, O_RDWR | O_NOCTTY | O_NDELAY);\n        if (fd == -1) {\n            perror(\"open_port: Unable to open serial port\");\n            return -1;\n        }\n        tcgetattr(fd, &options);\n        cfsetispeed(&options, B115200);\n        cfsetospeed(&options, B115200);\n        options.c_cflag |= (CLOCAL | CREAD);\n        options.c_cflag &= ~PARENB;\n        options.c_cflag &= ~CSTOPB;\n        options.c_cflag &= ~CSIZE;\n        options.c_cflag |= CS8;\n        options.c_cflag &= ~CRTSCTS;\n        tcsetattr(fd, TCSANOW, &options);\n        return fd;\n    }\n</code></pre></details>\n\n### 方法二：中断读取示例\n上面给出的串口示例是使用轮询的方式读取串口数据，这种方式在某些场景下可能会占用大量 CPU 资源。实际上，对于 Linux 系统来说，还可以使用中断方式接收串口数据，这样可以大大减少 CPU 的占用率，并且能够更快地响应串口数据。\n\n要使用中断方式接收串口数据，可以使用 select 函数来监听串口文件描述符的可读事件。当串口数据可读时，select 函数将返回，并且可以调用 read 函数来读取串口数据。这种方式可以避免轮询操作，只有在串口数据可读时才会执行读取操作，因此能够减少 CPU 的占用率。\n\n以下是一个简单的使用中断方式接收串口数据的示例程序：\n<details><summary>中断读取code</summary>\n<pre><code>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <termios.h>\n#include <sys/select.h>\n\nint main() {\n    int fd;\n    struct termios options;\n    fd_set rfds;\n\n    // 打开串口设备\n    fd = open(\"/dev/ttyUSB0\", O_RDWR | O_NOCTTY);\n    if (fd < 0) {\n        perror(\"open\");\n        return -1;\n    }\n\n    // 配置串口参数\n    tcgetattr(fd, &options);\n    options.c_cflag = B9600 | CS8 | CLOCAL | CREAD;\n    options.c_iflag = IGNPAR;\n    options.c_oflag = 0;\n    options.c_lflag = 0;\n    options.c_cc[VTIME] = 0;\n    options.c_cc[VMIN] = 1;\n    tcsetattr(fd, TCSANOW, &options);\n\n    while (1) {\n        // 使用 select 函数监听串口文件描述符的可读事件\n        FD_ZERO(&rfds);\n        FD_SET(fd, &rfds);\n        select(fd + 1, &rfds, NULL, NULL, NULL);\n\n        // 读取串口数据\n        char buf[256];\n        int n = read(fd, buf, sizeof(buf));\n        if (n > 0) {\n            printf(\"Received data: %.*s\\n\", n, buf);\n        }\n    }\n\n    // 关闭串口设备\n    close(fd);\n\n    return 0;\n}\n</code></pre></details>\n需要注意的是，在使用中断方式接收串口数据时，需要对串口文件描述符设置为非阻塞模式，以便在 select 函数返回时立即读取串口数据。可以使用 fcntl 函数来设置文件描述符的标志位，如下所示：\n```\n// 设置串口文件描述符为非阻塞模式\nint flags = fcntl(fd, F_GETFL, 0);\nfcntl(fd, F_SETFL, flags | O_NONBLOCK);\n```\n\n### 方法三：信号的方式接收数据\n<details><summary>信号的方式接收code</summary>\n<pre><code>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <termios.h>\n#include <signal.h>\n\nint fd;\n\nvoid sigio_handler(int sig) {\n    char buf[256];\n    int n = read(fd, buf, sizeof(buf));\n    if (n > 0) {\n        printf(\"Received data: %.*s\\n\", n, buf);\n    }\n}\n\nint main() {\n    struct termios options;\n    struct sigaction sa;\n\n    // 打开串口设备\n    fd = open(\"/dev/ttyS0\", O_RDWR | O_NOCTTY);\n    if (fd < 0) {\n        perror(\"open\");\n        return -1;\n    }\n\n    // 配置串口参数\n    tcgetattr(fd, &options);\n    options.c_cflag = B9600 | CS8 | CLOCAL | CREAD;\n    options.c_iflag = IGNPAR;\n    options.c_oflag = 0;\n    options.c_lflag = 0;\n    options.c_cc[VTIME] = 0;\n    options.c_cc[VMIN] = 1;\n    tcsetattr(fd, TCSANOW, &options);\n\n    // 设置串口文件描述符为异步通知模式\n    /* 将串口文件描述符设置为当前进程的拥有者，从而接收该文件描述符相关的信号。*/\n    fcntl(fd, F_SETOWN, getpid()); \n    int flags = fcntl(fd, F_GETFL, 0); // 先获取当前配置, 下面只更改O_ASYNC标志\n    /* 将串口文件描述符设置为非阻塞模式，从而允许该文件描述符异步地接收数据和信号。*/\n    fcntl(fd, F_SETFL, flags | O_ASYNC);\n\n    // 设置 SIGIO 信号的处理函数\n    sa.sa_handler = sigio_handler;\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = 0;\n    /* 设置了 SIGIO 信号的处理函数为 sigio_handler，从而在该信号被触发时读取串口数据并进行处理。*/\n    sigaction(SIGIO, &sa, NULL);\n\n    while (1) {\n        // 等待 SIGIO 信号\n        sleep(1);\n    }\n\n    // 关闭串口设备\n    close(fd);\n\n    return 0;\n}\n</code></pre></details>\n上述代码中，使用了 fcntl 函数将串口文件描述符设置为异步通知模式，并使用 SIGIO 信号来通知程序串口数据已经可读。当程序接收到 SIGIO 信号时，会调用 sigio_handler 函数来读取并处理串口数据。\n\n在这段代码中，sigemptyset（&sa.sa_mask）;的作用是将信号处理函数在执行时要屏蔽的信号集合清空，即将其设置为空集。\n\n每个进程都有一个信号屏蔽字，它表示了当前被阻塞的信号集合。当一个信号被阻塞时，它将被加入到信号屏蔽字中，而当信号被解除阻塞时，它将被从信号屏蔽字中移除。如果信号处理函数在执行时需要屏蔽其他的信号，则可以使用sigaddset等函数将需要屏蔽的信号添加到信号屏蔽字中。但是，在本例中，我们需要处理的信号是SIGIO，它通常不需要被屏蔽，因此我们使用sigemptyset函数将信号屏蔽字清空，以确保在处理SIGIO信号时不会屏蔽任何其他信号。\n\n在Linux系统中，使用sigaction函数注册信号处理函数时，可以设置一些标志来指定信号处理的行为。例如，可以使用SA_RESTART标志来指定当系统调用被信号中断时自动重启该系统调用。在本例中，由于我们并不需要设置任何标志，因此将sa.sa_flags字段设置为0即可。这表示信号处理函数不需要任何特殊的行为，只需要按照默认的方式处理信号即可。\n\n### 方法四：使用线程接收串口数据\n<details><summary>使用线程接收code</summary>\n<pre><code>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <termios.h>\n#include <pthread.h>\n\nvoid *read_thread(void *arg) {\n    int fd = *(int *)arg;\n    char buf[256];\n    int n;\n\n    while (1) {\n        // 读取串口数据\n        n = read(fd, buf, sizeof(buf));\n        if (n > 0) {\n            printf(\"Received data: %.*s\\n\", n, buf);\n        }\n    }\n\n    return NULL;\n}\n\nint main() {\n    int fd;\n    struct termios options;\n    pthread_t tid;\n\n    // 打开串口设备\n    fd = open(\"/dev/ttyS0\", O_RDWR | O_NOCTTY);\n    if (fd < 0) {\n        perror(\"open\");\n        return -1;\n    }\n\n    // 配置串口参数\n    tcgetattr(fd, &options);\n    options.c_cflag = B9600 | CS8 | CLOCAL | CREAD;\n    options.c_iflag = IGNPAR;\n    options.c_oflag = 0;\n    options.c_lflag = 0;\n    options.c_cc[VTIME] = 0;\n    options.c_cc[VMIN] = 1;\n    tcsetattr(fd, TCSANOW, &options);\n\n    // 创建读取线程\n    if (pthread_create(&tid, NULL, read_thread, &fd) != 0) {\n        perror(\"pthread_create\");\n        return -1;\n    }\n\n    while (1) {\n        // 主线程的其他处理逻辑\n        sleep(1);\n    }\n\n    // 关闭串口设备\n    close(fd);\n\n    return 0;\n}\n</code></pre></details>\n上述代码中，创建了一个读取线程，不断读取串口数据并进行处理。主线程可以在读取线程运行的同时进行其他处理逻辑。","slug":"ttymxx-UART","published":1,"updated":"2023-06-28T02:19:44.448Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk69d1er002ajsrjjgcygu6e","content":"<h1 id=\"Q：linux中如何控制串口？\"><a href=\"#Q：linux中如何控制串口？\" class=\"headerlink\" title=\"Q：linux中如何控制串口？\"></a>Q：linux中如何控制串口？</h1><h1 id=\"A：模块化设计\"><a href=\"#A：模块化设计\" class=\"headerlink\" title=\"A：模块化设计\"></a>A：模块化设计</h1><h2 id=\"第一步：设置设备树中关于串口的信息（设备树模块）\"><a href=\"#第一步：设置设备树中关于串口的信息（设备树模块）\" class=\"headerlink\" title=\"第一步：设置设备树中关于串口的信息（设备树模块）\"></a>第一步：设置设备树中关于串口的信息（设备树模块）</h2><pre><code>    uart1: serial@02020000 {\n        compatible = &quot;fsl,imx6ul-uart&quot;,\n                    &quot;fsl,imx6q-uart&quot;, &quot;fsl,imx21-uart&quot;;\n        reg = &lt;0x02020000 0x4000&gt;;\n        interrupts = &lt;GIC_SPI 26 IRQ_TYPE_LEVEL_HIGH&gt;;\n        clocks = &lt;&amp;clks IMX6UL_CLK_UART1_IPG&gt;,\n                &lt;&amp;clks IMX6UL_CLK_UART1_SERIAL&gt;;\n        clock-names = &quot;ipg&quot;, &quot;per&quot;;\n        status = &quot;disabled&quot;;\n    };\n    uart3: serial@021ec000 {\n        compatible = &quot;fsl,imx6ul-uart&quot;,\n                    &quot;fsl,imx6q-uart&quot;, &quot;fsl,imx21-uart&quot;;\n        reg = &lt;0x021ec000 0x4000&gt;;\n        interrupts = &lt;GIC_SPI 28 IRQ_TYPE_LEVEL_HIGH&gt;;\n        clocks = &lt;&amp;clks IMX6UL_CLK_UART3_IPG&gt;,\n                &lt;&amp;clks IMX6UL_CLK_UART3_SERIAL&gt;;\n        clock-names = &quot;ipg&quot;, &quot;per&quot;;\n        dmas = &lt;&amp;sdma 29 4 0&gt;, &lt;&amp;sdma 30 4 0&gt;;\n        dma-names = &quot;rx&quot;, &quot;tx&quot;;\n        status = &quot;disabled&quot;;\n    };   </code></pre><h2 id=\"第二步：驱动获取设备树生成设备（驱动模块）\"><a href=\"#第二步：驱动获取设备树生成设备（驱动模块）\" class=\"headerlink\" title=\"第二步：驱动获取设备树生成设备（驱动模块）\"></a>第二步：驱动获取设备树生成设备（驱动模块）</h2><p>drivers/tty/serial/imx.c文件中有如下内容：</p>\n<pre><code>static struct platform_device_id imx_uart_devtype[] = {\n    {\n        .name = &quot;imx1-uart&quot;,\n        .driver_data = (kernel_ulong_t) &amp;imx_uart_devdata[IMX1_UART],\n    }, {\n        .name = &quot;imx21-uart&quot;,\n        .driver_data = (kernel_ulong_t) &amp;imx_uart_devdata[IMX21_UART],\n    }, {\n        .name = &quot;imx6q-uart&quot;,\n        .driver_data = (kernel_ulong_t) &amp;imx_uart_devdata[IMX6Q_UART],\n    }, {\n        /* sentinel */\n    }\n};\nMODULE_DEVICE_TABLE(platform, imx_uart_devtype);</code></pre><pre><code>static struct uart_driver imx_reg = {\n    .owner          = THIS_MODULE,\n    .driver_name    = DRIVER_NAME,  //&quot;IMX-uart&quot;\n    .dev_name       = DEV_NAME,     //&quot;ttymxc&quot;\n    .major          = SERIAL_IMX_MAJOR, //207\n    .minor          = MINOR_START,      //16\n    .nr             = ARRAY_SIZE(imx_ports),    //8\n    .cons           = IMX_CONSOLE,      //NULL\n};</code></pre><p>platform平台对比到相同的设备树中的compatible到驱动中的name的时候就执行probe函数：</p>\n<details><summary>static int serial_imx_probe（struct platform_device *pdev）</summary>\n<pre><code>\n{\n    struct imx_port *sport;\n    void __iomem *base;\n    int ret = 0;\n    struct resource *res;\n    int txirq, rxirq, rtsirq;\n    sport = devm_kzalloc(&pdev->dev, sizeof(*sport), GFP_KERNEL);\n    if (!sport)\n        return -ENOMEM;\n    ret = serial_imx_probe_dt(sport, pdev);\n    if (ret > 0)\n        serial_imx_probe_pdata(sport, pdev);\n    else if (ret < 0)\n        return ret;\n    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n    base = devm_ioremap_resource(&pdev->dev, res);\n    if (IS_ERR(base))\n        return PTR_ERR(base);\n    rxirq = platform_get_irq(pdev, 0);\n    txirq = platform_get_irq(pdev, 1);\n    rtsirq = platform_get_irq(pdev, 2);\n    sport->port.dev = &pdev->dev;\n    sport->port.mapbase = res->start;\n    sport->port.membase = base;\n    sport->port.type = PORT_IMX,\n    sport->port.iotype = UPIO_MEM;\n    sport->port.irq = rxirq;\n    sport->port.fifosize = 32;\n    sport->port.ops = &imx_pops;\n    sport->port.rs485_config = imx_rs485_config;\n    sport->port.rs485.flags =\n        SER_RS485_RTS_ON_SEND | SER_RS485_RX_DURING_TX;\n    sport->port.flags = UPF_BOOT_AUTOCONF;\n    init_timer(&sport->timer);\n    sport->timer.function = imx_timeout;\n    sport->timer.data     = (unsigned long)sport;\n    sport->clk_ipg = devm_clk_get(&pdev->dev, \"ipg\");\n    if (IS_ERR(sport->clk_ipg)) {\n        ret = PTR_ERR(sport->clk_ipg);\n        dev_err(&pdev->dev, \"failed to get ipg clk: %d\\n\", ret);\n        return ret;\n    }\n    sport->clk_per = devm_clk_get(&pdev->dev, \"per\");\n    if (IS_ERR(sport->clk_per)) {\n        ret = PTR_ERR(sport->clk_per);\n        dev_err(&pdev->dev, \"failed to get per clk: %d\\n\", ret);\n        return ret;\n    }\n    sport->port.uartclk = clk_get_rate(sport->clk_per);\n    if (sport->port.uartclk > IMX_MODULE_MAX_CLK_RATE) {\n        ret = clk_set_rate(sport->clk_per, IMX_MODULE_MAX_CLK_RATE);\n        if (ret < 0) {\n            dev_err(&pdev->dev, \"clk_set_rate() failed\\n\");\n            return ret;\n        }\n    }\n    sport->port.uartclk = clk_get_rate(sport->clk_per);\n    if (txirq > 0) {\n        ret = devm_request_irq(&pdev->dev, rxirq, imx_rxint, 0,\n                       dev_name(&pdev->dev), sport);\n        if (ret)\n            return ret;\n\n<pre><code>    ret = devm_request_irq(&amp;pdev-&gt;dev, txirq, imx_txint, 0,\n                   dev_name(&amp;pdev-&gt;dev), sport);\n    if (ret)\n        return ret;\n} else {\n    ret = devm_request_irq(&amp;pdev-&gt;dev, rxirq, imx_int, 0,\n                   dev_name(&amp;pdev-&gt;dev), sport);\n    if (ret)\n        return ret;\n}\nimx_ports[sport-&gt;port.line] = sport;\nplatform_set_drvdata(pdev, sport);\nreturn uart_add_one_port(&amp;imx_reg, &amp;sport-&gt;port);</code></pre><p>}<br></p></code></pre></details><p></p>\n<p><code>serial_imx_probe</code>函数是针对i.MX系列平台设备的串口驱动的探测函数。该函数的功能是在系统启动时，当检测到与i.MX系列平台相关的串口设备时，自动初始化和注册相应的串口驱动程序。</p>\n<p>具体功能包括：</p>\n<ol>\n<li><p>识别并验证与i.MX平台相关的串口设备资源。通过检查设备树（device tree）或其他平台特定的数据结构，确定该平台上的串口设备的物理地址、中断号、时钟等信息，并进行验证。</p>\n</li>\n<li><p>为每个串口设备分配和初始化相应的<code>struct uart_port</code>结构体。该结构体用于表示一个串口设备的相关参数和状态信息，如设备的基地址、中断号、波特率等。</p>\n</li>\n<li><p>注册串口驱动程序。调用<code>uart_add_one_port</code>函数将初始化好的<code>struct uart_port</code>结构体注册到串口子系统中，以便操作系统可以管理和操作该串口设备。</p>\n</li>\n<li><p>执行其他平台特定的初始化操作。根据i.MX平台的要求，可能需要进行其他特定于该平台的初始化步骤，如设置GPIO引脚、时钟源等。</p>\n</li>\n</ol>\n<p>总而言之，<code>serial_imx_probe</code>函数的功能是在系统启动时，自动探测和初始化i.MX平台上的串口设备，并注册相应的串口驱动程序，以便后续操作系统和用户空间程序可以与这些串口设备进行通信和交互。</p>\n<p>数据结构的关系：<br>内核串口驱动结构uart_driver（imx_reg）在 imx_serial_init 函数中向 Linux 内核注册了 imx_reg。<br>当 UART 设备和驱动匹配成功以后 serial_imx_probe 函数就会执行，此函数的重点工作就<br>是初始化 uart_port，然后将其添加到对应的 uart_driver 中。imx驱动自己创建了imx_port 结构体里面有一个成员就是uart_port，最后通过uart_add_one_port注册。</p>\n<p>所以在dev目录下就会有：<img src=\"/2023/06/ttymxx-uart/ls-dev.png\" alt=\"ls /dev\"> 对应到uart1-&gt;ttymxc0和uart3-&gt;ttymxc2<br>设备号：<img src=\"/2023/06/ttymxx-uart/ttymxc.png\" alt=\"设备号\"><br>设备：<img src=\"/2023/06/ttymxx-uart/cat-proc-devices.png\" alt=\"设备\"></p>\n<h2 id=\"第三步：使用串口（应用模块）\"><a href=\"#第三步：使用串口（应用模块）\" class=\"headerlink\" title=\"第三步：使用串口（应用模块）\"></a>第三步：使用串口（应用模块）</h2><p>通过串口发送数据到ttymxc2,执行cat /dev/ttymxc2：<img src=\"/2023/06/ttymxx-uart/cat-ttymxc2.png\" alt=\"ttymxc2\"> 应该是和串口发送的十六进制数据是一样的。所以所有的操作都应该是基于此文件或则设备相关的硬件信号。</p>\n<h3 id=\"方法一：轮询\"><a href=\"#方法一：轮询\" class=\"headerlink\" title=\"方法一：轮询\"></a>方法一：轮询</h3><ol>\n<li><p>打开串口</p>\n<pre><code>fd = open(port, O_RDWR | O_NOCTTY | O_NDELAY);\nif (fd == -1) \n{\n perror(&quot;open_port: Unable to open serial port&quot;);\n return -1;\n}</code></pre></li>\n<li><p>配置串口</p>\n<pre><code>tcgetattr(fd, &amp;options);\ncfsetispeed(&amp;options, B115200);\ncfsetospeed(&amp;options, B115200);\noptions.c_cflag |= (CLOCAL | CREAD);\noptions.c_cflag &amp;= ~PARENB;\noptions.c_cflag &amp;= ~CSTOPB;\noptions.c_cflag &amp;= ~CSIZE;\noptions.c_cflag |= CS8;\noptions.c_cflag &amp;= ~CRTSCTS;\ntcsetattr(fd, TCSANOW, &amp;options);</code></pre><p>其中，tcgetattr 和 tcsetattr 函数用于获取和设置串口参数。cfsetispeed 和 cfsetospeed 函数用于设置串口的输入和输出波特率，这里设置为 115200。options.c_cflag 表示控制标志位，用于配置串口控制参数，具体含义如下：</p>\n<p> CLOCAL：忽略调制解调器的状态线，只允许本地使用串口。</p>\n<p> CREAD：允许从串口读取数据。</p>\n<p> PARENB：启用奇偶校验。&amp;= ~PARENB则为禁用校验。</p>\n<p> CSTOPB：使用两个停止位而不是一个。&amp;= ~CSTOPB停止位为1。</p>\n<p> CSIZE：表示字符长度的位掩码。在这里设置为 0，表示使用默认的 8 位数据位。</p>\n<p> CS8：表示使用 8 位数据位。</p>\n<p> CRTSCTS：启用硬件流控制，即使用 RTS 和 CTS 状态线进行流控制。</p>\n</li>\n</ol>\n<p>在示例程序中，我们将 CLOCAL 和 CREAD 标志位置为 1，表示允许本地使用串口，并允许从串口读取数据。我们将 PARENB、CSTOPB 和 CRTSCTS 标志位都设置为 0，表示不启用奇偶校验、使用一个停止位和禁用硬件流控制。最后，我们将 CSIZE 标志位设置为 0，然后将 CS8 标志位设置为 1，以表示使用 8 位数据位。</p>\n<ol start=\"3\">\n<li><p>读写</p>\n<pre><code>read(fd, buf, sizeof(buf)); // 返回接收个数\nwrite(fd, buf, strlen(buf)); // 返回发送长度,负值表示发送失败</code></pre></li>\n<li><p>关闭串口</p>\n<pre><code>close(fd);</code></pre><p>完整示例</p>\n<details><summary>轮询code</summary>\n<pre><code>\n int main()\n {\n     int fd;\n     char buf[255];\n     int n;\n     fd = open_port(\"/dev/ttyUSB0\");\n     if (fd == -1) {\n\n<pre><code>     printf(&quot;open err\\n&quot;);\n     exit(1);\n }\n while (1)\n {\n     n = read(fd, buf, sizeof(buf));\n     if (n &gt; 0) {\n         printf(&quot;Received: %.*s\\n&quot;, n, buf);\n     }\n     strcpy(buf, &quot;Hello, world!\\n&quot;);\n     n = write(fd, buf, strlen(buf));\n     if (n &lt; 0) {\n         perror(&quot;write failed\\n&quot;);\n     }\n     usleep(10 * 1000);\n }\n close(fd);\n printf(&quot;close uart\\n&quot;);\n return 0;</code></pre><p> }</p>\n<p> int open_port(const char *port)<br> {</p>\n<pre><code> int fd;\n struct termios options;\n fd = open(port, O_RDWR | O_NOCTTY | O_NDELAY);\n if (fd == -1) {\n     perror(&quot;open_port: Unable to open serial port&quot;);\n     return -1;\n }\n tcgetattr(fd, &amp;options);\n cfsetispeed(&amp;options, B115200);\n cfsetospeed(&amp;options, B115200);\n options.c_cflag |= (CLOCAL | CREAD);\n options.c_cflag &amp;= ~PARENB;\n options.c_cflag &amp;= ~CSTOPB;\n options.c_cflag &amp;= ~CSIZE;\n options.c_cflag |= CS8;\n options.c_cflag &amp;= ~CRTSCTS;\n tcsetattr(fd, TCSANOW, &amp;options);\n return fd;</code></pre><p> }<br></p></code></pre></details><p></p>\n</li>\n</ol>\n<h3 id=\"方法二：中断读取示例\"><a href=\"#方法二：中断读取示例\" class=\"headerlink\" title=\"方法二：中断读取示例\"></a>方法二：中断读取示例</h3><p>上面给出的串口示例是使用轮询的方式读取串口数据，这种方式在某些场景下可能会占用大量 CPU 资源。实际上，对于 Linux 系统来说，还可以使用中断方式接收串口数据，这样可以大大减少 CPU 的占用率，并且能够更快地响应串口数据。</p>\n<p>要使用中断方式接收串口数据，可以使用 select 函数来监听串口文件描述符的可读事件。当串口数据可读时，select 函数将返回，并且可以调用 read 函数来读取串口数据。这种方式可以避免轮询操作，只有在串口数据可读时才会执行读取操作，因此能够减少 CPU 的占用率。</p>\n<p>以下是一个简单的使用中断方式接收串口数据的示例程序：</p>\n<details><summary>中断读取code</summary>\n<pre><code>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <termios.h>\n#include <sys select.h>\n\n<p>int main() {<br>    int fd;<br>    struct termios options;<br>    fd_set rfds;</p>\n<pre><code>// 打开串口设备\nfd = open(&quot;/dev/ttyUSB0&quot;, O_RDWR | O_NOCTTY);\nif (fd &lt; 0) {\n    perror(&quot;open&quot;);\n    return -1;\n}\n\n// 配置串口参数\ntcgetattr(fd, &amp;options);\noptions.c_cflag = B9600 | CS8 | CLOCAL | CREAD;\noptions.c_iflag = IGNPAR;\noptions.c_oflag = 0;\noptions.c_lflag = 0;\noptions.c_cc[VTIME] = 0;\noptions.c_cc[VMIN] = 1;\ntcsetattr(fd, TCSANOW, &amp;options);\n\nwhile (1) {\n    // 使用 select 函数监听串口文件描述符的可读事件\n    FD_ZERO(&amp;rfds);\n    FD_SET(fd, &amp;rfds);\n    select(fd + 1, &amp;rfds, NULL, NULL, NULL);\n\n    // 读取串口数据\n    char buf[256];\n    int n = read(fd, buf, sizeof(buf));\n    if (n &gt; 0) {\n        printf(&quot;Received data: %.*s\\n&quot;, n, buf);\n    }\n}\n\n// 关闭串口设备\nclose(fd);\n\nreturn 0;</code></pre><p>}<br></p></sys></termios.h></fcntl.h></unistd.h></stdlib.h></stdio.h></code></pre></details><br>需要注意的是，在使用中断方式接收串口数据时，需要对串口文件描述符设置为非阻塞模式，以便在 select 函数返回时立即读取串口数据。可以使用 fcntl 函数来设置文件描述符的标志位，如下所示：<p></p>\n<pre><code>// 设置串口文件描述符为非阻塞模式\nint flags = fcntl(fd, F_GETFL, 0);\nfcntl(fd, F_SETFL, flags | O_NONBLOCK);</code></pre><h3 id=\"方法三：信号的方式接收数据\"><a href=\"#方法三：信号的方式接收数据\" class=\"headerlink\" title=\"方法三：信号的方式接收数据\"></a>方法三：信号的方式接收数据</h3><details><summary>信号的方式接收code</summary>\n<pre><code>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <termios.h>\n#include <signal.h>\n\n<p>int fd;</p>\n<p>void sigio_handler(int sig) {<br>    char buf[256];<br>    int n = read(fd, buf, sizeof(buf));<br>    if (n &gt; 0) {<br>        printf(“Received data: %.*s\\n”, n, buf);<br>    }<br>}</p>\n<p>int main() {<br>    struct termios options;<br>    struct sigaction sa;</p>\n<pre><code>// 打开串口设备\nfd = open(&quot;/dev/ttyS0&quot;, O_RDWR | O_NOCTTY);\nif (fd &lt; 0) {\n    perror(&quot;open&quot;);\n    return -1;\n}\n\n// 配置串口参数\ntcgetattr(fd, &amp;options);\noptions.c_cflag = B9600 | CS8 | CLOCAL | CREAD;\noptions.c_iflag = IGNPAR;\noptions.c_oflag = 0;\noptions.c_lflag = 0;\noptions.c_cc[VTIME] = 0;\noptions.c_cc[VMIN] = 1;\ntcsetattr(fd, TCSANOW, &amp;options);\n\n// 设置串口文件描述符为异步通知模式\n/* 将串口文件描述符设置为当前进程的拥有者，从而接收该文件描述符相关的信号。*/\nfcntl(fd, F_SETOWN, getpid()); \nint flags = fcntl(fd, F_GETFL, 0); // 先获取当前配置, 下面只更改O_ASYNC标志\n/* 将串口文件描述符设置为非阻塞模式，从而允许该文件描述符异步地接收数据和信号。*/\nfcntl(fd, F_SETFL, flags | O_ASYNC);\n\n// 设置 SIGIO 信号的处理函数\nsa.sa_handler = sigio_handler;\nsigemptyset(&amp;sa.sa_mask);\nsa.sa_flags = 0;\n/* 设置了 SIGIO 信号的处理函数为 sigio_handler，从而在该信号被触发时读取串口数据并进行处理。*/\nsigaction(SIGIO, &amp;sa, NULL);\n\nwhile (1) {\n    // 等待 SIGIO 信号\n    sleep(1);\n}\n\n// 关闭串口设备\nclose(fd);\n\nreturn 0;</code></pre><p>}<br></p></signal.h></termios.h></fcntl.h></unistd.h></stdlib.h></stdio.h></code></pre></details><br>上述代码中，使用了 fcntl 函数将串口文件描述符设置为异步通知模式，并使用 SIGIO 信号来通知程序串口数据已经可读。当程序接收到 SIGIO 信号时，会调用 sigio_handler 函数来读取并处理串口数据。<p></p>\n<p>在这段代码中，sigemptyset（&amp;sa.sa_mask）;的作用是将信号处理函数在执行时要屏蔽的信号集合清空，即将其设置为空集。</p>\n<p>每个进程都有一个信号屏蔽字，它表示了当前被阻塞的信号集合。当一个信号被阻塞时，它将被加入到信号屏蔽字中，而当信号被解除阻塞时，它将被从信号屏蔽字中移除。如果信号处理函数在执行时需要屏蔽其他的信号，则可以使用sigaddset等函数将需要屏蔽的信号添加到信号屏蔽字中。但是，在本例中，我们需要处理的信号是SIGIO，它通常不需要被屏蔽，因此我们使用sigemptyset函数将信号屏蔽字清空，以确保在处理SIGIO信号时不会屏蔽任何其他信号。</p>\n<p>在Linux系统中，使用sigaction函数注册信号处理函数时，可以设置一些标志来指定信号处理的行为。例如，可以使用SA_RESTART标志来指定当系统调用被信号中断时自动重启该系统调用。在本例中，由于我们并不需要设置任何标志，因此将sa.sa_flags字段设置为0即可。这表示信号处理函数不需要任何特殊的行为，只需要按照默认的方式处理信号即可。</p>\n<h3 id=\"方法四：使用线程接收串口数据\"><a href=\"#方法四：使用线程接收串口数据\" class=\"headerlink\" title=\"方法四：使用线程接收串口数据\"></a>方法四：使用线程接收串口数据</h3><details><summary>使用线程接收code</summary>\n<pre><code>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <termios.h>\n#include <pthread.h>\n\n<p>void *read_thread(void *arg) {<br>    int fd = *(int *)arg;<br>    char buf[256];<br>    int n;</p>\n<pre><code>while (1) {\n    // 读取串口数据\n    n = read(fd, buf, sizeof(buf));\n    if (n &gt; 0) {\n        printf(&quot;Received data: %.*s\\n&quot;, n, buf);\n    }\n}\n\nreturn NULL;</code></pre><p>}</p>\n<p>int main() {<br>    int fd;<br>    struct termios options;<br>    pthread_t tid;</p>\n<pre><code>// 打开串口设备\nfd = open(&quot;/dev/ttyS0&quot;, O_RDWR | O_NOCTTY);\nif (fd &lt; 0) {\n    perror(&quot;open&quot;);\n    return -1;\n}\n\n// 配置串口参数\ntcgetattr(fd, &amp;options);\noptions.c_cflag = B9600 | CS8 | CLOCAL | CREAD;\noptions.c_iflag = IGNPAR;\noptions.c_oflag = 0;\noptions.c_lflag = 0;\noptions.c_cc[VTIME] = 0;\noptions.c_cc[VMIN] = 1;\ntcsetattr(fd, TCSANOW, &amp;options);\n\n// 创建读取线程\nif (pthread_create(&amp;tid, NULL, read_thread, &amp;fd) != 0) {\n    perror(&quot;pthread_create&quot;);\n    return -1;\n}\n\nwhile (1) {\n    // 主线程的其他处理逻辑\n    sleep(1);\n}\n\n// 关闭串口设备\nclose(fd);\n\nreturn 0;</code></pre><p>}<br></p></pthread.h></termios.h></fcntl.h></unistd.h></stdlib.h></stdio.h></code></pre></details><br>上述代码中，创建了一个读取线程，不断读取串口数据并进行处理。主线程可以在读取线程运行的同时进行其他处理逻辑。<p></p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<h1 id=\"Q：linux中如何控制串口？\"><a href=\"#Q：linux中如何控制串口？\" class=\"headerlink\" title=\"Q：linux中如何控制串口？\"></a>Q：linux中如何控制串口？</h1><h1 id=\"A：模块化设计\"><a href=\"#A：模块化设计\" class=\"headerlink\" title=\"A：模块化设计\"></a>A：模块化设计</h1><h2 id=\"第一步：设置设备树中关于串口的信息（设备树模块）\"><a href=\"#第一步：设置设备树中关于串口的信息（设备树模块）\" class=\"headerlink\" title=\"第一步：设置设备树中关于串口的信息（设备树模块）\"></a>第一步：设置设备树中关于串口的信息（设备树模块）</h2><pre><code>    uart1: serial@02020000 {\n        compatible = &quot;fsl,imx6ul-uart&quot;,\n                    &quot;fsl,imx6q-uart&quot;, &quot;fsl,imx21-uart&quot;;\n        reg = &lt;0x02020000 0x4000&gt;;\n        interrupts = &lt;GIC_SPI 26 IRQ_TYPE_LEVEL_HIGH&gt;;\n        clocks = &lt;&amp;clks IMX6UL_CLK_UART1_IPG&gt;,\n                &lt;&amp;clks IMX6UL_CLK_UART1_SERIAL&gt;;\n        clock-names = &quot;ipg&quot;, &quot;per&quot;;\n        status = &quot;disabled&quot;;\n    };\n    uart3: serial@021ec000 {\n        compatible = &quot;fsl,imx6ul-uart&quot;,\n                    &quot;fsl,imx6q-uart&quot;, &quot;fsl,imx21-uart&quot;;\n        reg = &lt;0x021ec000 0x4000&gt;;\n        interrupts = &lt;GIC_SPI 28 IRQ_TYPE_LEVEL_HIGH&gt;;\n        clocks = &lt;&amp;clks IMX6UL_CLK_UART3_IPG&gt;,\n                &lt;&amp;clks IMX6UL_CLK_UART3_SERIAL&gt;;\n        clock-names = &quot;ipg&quot;, &quot;per&quot;;\n        dmas = &lt;&amp;sdma 29 4 0&gt;, &lt;&amp;sdma 30 4 0&gt;;\n        dma-names = &quot;rx&quot;, &quot;tx&quot;;\n        status = &quot;disabled&quot;;\n    };   </code></pre><h2 id=\"第二步：驱动获取设备树生成设备（驱动模块）\"><a href=\"#第二步：驱动获取设备树生成设备（驱动模块）\" class=\"headerlink\" title=\"第二步：驱动获取设备树生成设备（驱动模块）\"></a>第二步：驱动获取设备树生成设备（驱动模块）</h2><p>drivers/tty/serial/imx.c文件中有如下内容：</p>\n<pre><code>static struct platform_device_id imx_uart_devtype[] = {\n    {\n        .name = &quot;imx1-uart&quot;,\n        .driver_data = (kernel_ulong_t) &amp;imx_uart_devdata[IMX1_UART],\n    }, {\n        .name = &quot;imx21-uart&quot;,\n        .driver_data = (kernel_ulong_t) &amp;imx_uart_devdata[IMX21_UART],\n    }, {\n        .name = &quot;imx6q-uart&quot;,\n        .driver_data = (kernel_ulong_t) &amp;imx_uart_devdata[IMX6Q_UART],\n    }, {\n        /* sentinel */\n    }\n};\nMODULE_DEVICE_TABLE(platform, imx_uart_devtype);</code></pre><pre><code>static struct uart_driver imx_reg = {\n    .owner          = THIS_MODULE,\n    .driver_name    = DRIVER_NAME,  //&quot;IMX-uart&quot;\n    .dev_name       = DEV_NAME,     //&quot;ttymxc&quot;\n    .major          = SERIAL_IMX_MAJOR, //207\n    .minor          = MINOR_START,      //16\n    .nr             = ARRAY_SIZE(imx_ports),    //8\n    .cons           = IMX_CONSOLE,      //NULL\n};</code></pre><p>platform平台对比到相同的设备树中的compatible到驱动中的name的时候就执行probe函数：</p>\n<details><summary>static int serial_imx_probe（struct platform_device *pdev）</summary>\n<pre><code>\n{\n    struct imx_port *sport;\n    void __iomem *base;\n    int ret = 0;\n    struct resource *res;\n    int txirq, rxirq, rtsirq;\n    sport = devm_kzalloc(&pdev->dev, sizeof(*sport), GFP_KERNEL);\n    if (!sport)\n        return -ENOMEM;\n    ret = serial_imx_probe_dt(sport, pdev);\n    if (ret > 0)\n        serial_imx_probe_pdata(sport, pdev);\n    else if (ret < 0)\n        return ret;\n    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n    base = devm_ioremap_resource(&pdev->dev, res);\n    if (IS_ERR(base))\n        return PTR_ERR(base);\n    rxirq = platform_get_irq(pdev, 0);\n    txirq = platform_get_irq(pdev, 1);\n    rtsirq = platform_get_irq(pdev, 2);\n    sport->port.dev = &pdev->dev;\n    sport->port.mapbase = res->start;\n    sport->port.membase = base;\n    sport->port.type = PORT_IMX,\n    sport->port.iotype = UPIO_MEM;\n    sport->port.irq = rxirq;\n    sport->port.fifosize = 32;\n    sport->port.ops = &imx_pops;\n    sport->port.rs485_config = imx_rs485_config;\n    sport->port.rs485.flags =\n        SER_RS485_RTS_ON_SEND | SER_RS485_RX_DURING_TX;\n    sport->port.flags = UPF_BOOT_AUTOCONF;\n    init_timer(&sport->timer);\n    sport->timer.function = imx_timeout;\n    sport->timer.data     = (unsigned long)sport;\n    sport->clk_ipg = devm_clk_get(&pdev->dev, \"ipg\");\n    if (IS_ERR(sport->clk_ipg)) {\n        ret = PTR_ERR(sport->clk_ipg);\n        dev_err(&pdev->dev, \"failed to get ipg clk: %d\\n\", ret);\n        return ret;\n    }\n    sport->clk_per = devm_clk_get(&pdev->dev, \"per\");\n    if (IS_ERR(sport->clk_per)) {\n        ret = PTR_ERR(sport->clk_per);\n        dev_err(&pdev->dev, \"failed to get per clk: %d\\n\", ret);\n        return ret;\n    }\n    sport->port.uartclk = clk_get_rate(sport->clk_per);\n    if (sport->port.uartclk > IMX_MODULE_MAX_CLK_RATE) {\n        ret = clk_set_rate(sport->clk_per, IMX_MODULE_MAX_CLK_RATE);\n        if (ret < 0) {\n            dev_err(&pdev->dev, \"clk_set_rate() failed\\n\");\n            return ret;\n        }\n    }\n    sport->port.uartclk = clk_get_rate(sport->clk_per);\n    if (txirq > 0) {\n        ret = devm_request_irq(&pdev->dev, rxirq, imx_rxint, 0,\n                       dev_name(&pdev->dev), sport);\n        if (ret)\n            return ret;\n\n<pre><code>    ret = devm_request_irq(&amp;pdev-&gt;dev, txirq, imx_txint, 0,\n                   dev_name(&amp;pdev-&gt;dev), sport);\n    if (ret)\n        return ret;\n} else {\n    ret = devm_request_irq(&amp;pdev-&gt;dev, rxirq, imx_int, 0,\n                   dev_name(&amp;pdev-&gt;dev), sport);\n    if (ret)\n        return ret;\n}\nimx_ports[sport-&gt;port.line] = sport;\nplatform_set_drvdata(pdev, sport);\nreturn uart_add_one_port(&amp;imx_reg, &amp;sport-&gt;port);</code></pre><p>}<br></p></code></pre></details><p></p>\n<p><code>serial_imx_probe</code>函数是针对i.MX系列平台设备的串口驱动的探测函数。该函数的功能是在系统启动时，当检测到与i.MX系列平台相关的串口设备时，自动初始化和注册相应的串口驱动程序。</p>\n<p>具体功能包括：</p>\n<ol>\n<li><p>识别并验证与i.MX平台相关的串口设备资源。通过检查设备树（device tree）或其他平台特定的数据结构，确定该平台上的串口设备的物理地址、中断号、时钟等信息，并进行验证。</p>\n</li>\n<li><p>为每个串口设备分配和初始化相应的<code>struct uart_port</code>结构体。该结构体用于表示一个串口设备的相关参数和状态信息，如设备的基地址、中断号、波特率等。</p>\n</li>\n<li><p>注册串口驱动程序。调用<code>uart_add_one_port</code>函数将初始化好的<code>struct uart_port</code>结构体注册到串口子系统中，以便操作系统可以管理和操作该串口设备。</p>\n</li>\n<li><p>执行其他平台特定的初始化操作。根据i.MX平台的要求，可能需要进行其他特定于该平台的初始化步骤，如设置GPIO引脚、时钟源等。</p>\n</li>\n</ol>\n<p>总而言之，<code>serial_imx_probe</code>函数的功能是在系统启动时，自动探测和初始化i.MX平台上的串口设备，并注册相应的串口驱动程序，以便后续操作系统和用户空间程序可以与这些串口设备进行通信和交互。</p>\n<p>数据结构的关系：<br>内核串口驱动结构uart_driver（imx_reg）在 imx_serial_init 函数中向 Linux 内核注册了 imx_reg。<br>当 UART 设备和驱动匹配成功以后 serial_imx_probe 函数就会执行，此函数的重点工作就<br>是初始化 uart_port，然后将其添加到对应的 uart_driver 中。imx驱动自己创建了imx_port 结构体里面有一个成员就是uart_port，最后通过uart_add_one_port注册。</p>\n<p>所以在dev目录下就会有：<img src=\"/2023/06/ttymxx-uart/ls-dev.png\" alt=\"ls /dev\"> 对应到uart1-&gt;ttymxc0和uart3-&gt;ttymxc2<br>设备号：<img src=\"/2023/06/ttymxx-uart/ttymxc.png\" alt=\"设备号\"><br>设备：<img src=\"/2023/06/ttymxx-uart/cat-proc-devices.png\" alt=\"设备\"></p>\n<h2 id=\"第三步：使用串口（应用模块）\"><a href=\"#第三步：使用串口（应用模块）\" class=\"headerlink\" title=\"第三步：使用串口（应用模块）\"></a>第三步：使用串口（应用模块）</h2><p>通过串口发送数据到ttymxc2,执行cat /dev/ttymxc2：<img src=\"/2023/06/ttymxx-uart/cat-ttymxc2.png\" alt=\"ttymxc2\"> 应该是和串口发送的十六进制数据是一样的。所以所有的操作都应该是基于此文件或则设备相关的硬件信号。</p>\n<h3 id=\"方法一：轮询\"><a href=\"#方法一：轮询\" class=\"headerlink\" title=\"方法一：轮询\"></a>方法一：轮询</h3><ol>\n<li><p>打开串口</p>\n<pre><code>fd = open(port, O_RDWR | O_NOCTTY | O_NDELAY);\nif (fd == -1) \n{\n perror(&quot;open_port: Unable to open serial port&quot;);\n return -1;\n}</code></pre></li>\n<li><p>配置串口</p>\n<pre><code>tcgetattr(fd, &amp;options);\ncfsetispeed(&amp;options, B115200);\ncfsetospeed(&amp;options, B115200);\noptions.c_cflag |= (CLOCAL | CREAD);\noptions.c_cflag &amp;= ~PARENB;\noptions.c_cflag &amp;= ~CSTOPB;\noptions.c_cflag &amp;= ~CSIZE;\noptions.c_cflag |= CS8;\noptions.c_cflag &amp;= ~CRTSCTS;\ntcsetattr(fd, TCSANOW, &amp;options);</code></pre><p>其中，tcgetattr 和 tcsetattr 函数用于获取和设置串口参数。cfsetispeed 和 cfsetospeed 函数用于设置串口的输入和输出波特率，这里设置为 115200。options.c_cflag 表示控制标志位，用于配置串口控制参数，具体含义如下：</p>\n<p> CLOCAL：忽略调制解调器的状态线，只允许本地使用串口。</p>\n<p> CREAD：允许从串口读取数据。</p>\n<p> PARENB：启用奇偶校验。&amp;= ~PARENB则为禁用校验。</p>\n<p> CSTOPB：使用两个停止位而不是一个。&amp;= ~CSTOPB停止位为1。</p>\n<p> CSIZE：表示字符长度的位掩码。在这里设置为 0，表示使用默认的 8 位数据位。</p>\n<p> CS8：表示使用 8 位数据位。</p>\n<p> CRTSCTS：启用硬件流控制，即使用 RTS 和 CTS 状态线进行流控制。</p>\n</li>\n</ol>\n<p>在示例程序中，我们将 CLOCAL 和 CREAD 标志位置为 1，表示允许本地使用串口，并允许从串口读取数据。我们将 PARENB、CSTOPB 和 CRTSCTS 标志位都设置为 0，表示不启用奇偶校验、使用一个停止位和禁用硬件流控制。最后，我们将 CSIZE 标志位设置为 0，然后将 CS8 标志位设置为 1，以表示使用 8 位数据位。</p>\n<ol start=\"3\">\n<li><p>读写</p>\n<pre><code>read(fd, buf, sizeof(buf)); // 返回接收个数\nwrite(fd, buf, strlen(buf)); // 返回发送长度,负值表示发送失败</code></pre></li>\n<li><p>关闭串口</p>\n<pre><code>close(fd);</code></pre><p>完整示例</p>\n<details><summary>轮询code</summary>\n<pre><code>\n int main()\n {\n     int fd;\n     char buf[255];\n     int n;\n     fd = open_port(\"/dev/ttyUSB0\");\n     if (fd == -1) {\n\n<pre><code>     printf(&quot;open err\\n&quot;);\n     exit(1);\n }\n while (1)\n {\n     n = read(fd, buf, sizeof(buf));\n     if (n &gt; 0) {\n         printf(&quot;Received: %.*s\\n&quot;, n, buf);\n     }\n     strcpy(buf, &quot;Hello, world!\\n&quot;);\n     n = write(fd, buf, strlen(buf));\n     if (n &lt; 0) {\n         perror(&quot;write failed\\n&quot;);\n     }\n     usleep(10 * 1000);\n }\n close(fd);\n printf(&quot;close uart\\n&quot;);\n return 0;</code></pre><p> }</p>\n<p> int open_port(const char *port)<br> {</p>\n<pre><code> int fd;\n struct termios options;\n fd = open(port, O_RDWR | O_NOCTTY | O_NDELAY);\n if (fd == -1) {\n     perror(&quot;open_port: Unable to open serial port&quot;);\n     return -1;\n }\n tcgetattr(fd, &amp;options);\n cfsetispeed(&amp;options, B115200);\n cfsetospeed(&amp;options, B115200);\n options.c_cflag |= (CLOCAL | CREAD);\n options.c_cflag &amp;= ~PARENB;\n options.c_cflag &amp;= ~CSTOPB;\n options.c_cflag &amp;= ~CSIZE;\n options.c_cflag |= CS8;\n options.c_cflag &amp;= ~CRTSCTS;\n tcsetattr(fd, TCSANOW, &amp;options);\n return fd;</code></pre><p> }<br></p></code></pre></details><p></p>\n</li>\n</ol>\n<h3 id=\"方法二：中断读取示例\"><a href=\"#方法二：中断读取示例\" class=\"headerlink\" title=\"方法二：中断读取示例\"></a>方法二：中断读取示例</h3><p>上面给出的串口示例是使用轮询的方式读取串口数据，这种方式在某些场景下可能会占用大量 CPU 资源。实际上，对于 Linux 系统来说，还可以使用中断方式接收串口数据，这样可以大大减少 CPU 的占用率，并且能够更快地响应串口数据。</p>\n<p>要使用中断方式接收串口数据，可以使用 select 函数来监听串口文件描述符的可读事件。当串口数据可读时，select 函数将返回，并且可以调用 read 函数来读取串口数据。这种方式可以避免轮询操作，只有在串口数据可读时才会执行读取操作，因此能够减少 CPU 的占用率。</p>\n<p>以下是一个简单的使用中断方式接收串口数据的示例程序：</p>\n<details><summary>中断读取code</summary>\n<pre><code>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <termios.h>\n#include <sys select.h>\n\n<p>int main() {<br>    int fd;<br>    struct termios options;<br>    fd_set rfds;</p>\n<pre><code>// 打开串口设备\nfd = open(&quot;/dev/ttyUSB0&quot;, O_RDWR | O_NOCTTY);\nif (fd &lt; 0) {\n    perror(&quot;open&quot;);\n    return -1;\n}\n\n// 配置串口参数\ntcgetattr(fd, &amp;options);\noptions.c_cflag = B9600 | CS8 | CLOCAL | CREAD;\noptions.c_iflag = IGNPAR;\noptions.c_oflag = 0;\noptions.c_lflag = 0;\noptions.c_cc[VTIME] = 0;\noptions.c_cc[VMIN] = 1;\ntcsetattr(fd, TCSANOW, &amp;options);\n\nwhile (1) {\n    // 使用 select 函数监听串口文件描述符的可读事件\n    FD_ZERO(&amp;rfds);\n    FD_SET(fd, &amp;rfds);\n    select(fd + 1, &amp;rfds, NULL, NULL, NULL);\n\n    // 读取串口数据\n    char buf[256];\n    int n = read(fd, buf, sizeof(buf));\n    if (n &gt; 0) {\n        printf(&quot;Received data: %.*s\\n&quot;, n, buf);\n    }\n}\n\n// 关闭串口设备\nclose(fd);\n\nreturn 0;</code></pre><p>}<br></p></sys></termios.h></fcntl.h></unistd.h></stdlib.h></stdio.h></code></pre></details><br>需要注意的是，在使用中断方式接收串口数据时，需要对串口文件描述符设置为非阻塞模式，以便在 select 函数返回时立即读取串口数据。可以使用 fcntl 函数来设置文件描述符的标志位，如下所示：<p></p>\n<pre><code>// 设置串口文件描述符为非阻塞模式\nint flags = fcntl(fd, F_GETFL, 0);\nfcntl(fd, F_SETFL, flags | O_NONBLOCK);</code></pre><h3 id=\"方法三：信号的方式接收数据\"><a href=\"#方法三：信号的方式接收数据\" class=\"headerlink\" title=\"方法三：信号的方式接收数据\"></a>方法三：信号的方式接收数据</h3><details><summary>信号的方式接收code</summary>\n<pre><code>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <termios.h>\n#include <signal.h>\n\n<p>int fd;</p>\n<p>void sigio_handler(int sig) {<br>    char buf[256];<br>    int n = read(fd, buf, sizeof(buf));<br>    if (n &gt; 0) {<br>        printf(“Received data: %.*s\\n”, n, buf);<br>    }<br>}</p>\n<p>int main() {<br>    struct termios options;<br>    struct sigaction sa;</p>\n<pre><code>// 打开串口设备\nfd = open(&quot;/dev/ttyS0&quot;, O_RDWR | O_NOCTTY);\nif (fd &lt; 0) {\n    perror(&quot;open&quot;);\n    return -1;\n}\n\n// 配置串口参数\ntcgetattr(fd, &amp;options);\noptions.c_cflag = B9600 | CS8 | CLOCAL | CREAD;\noptions.c_iflag = IGNPAR;\noptions.c_oflag = 0;\noptions.c_lflag = 0;\noptions.c_cc[VTIME] = 0;\noptions.c_cc[VMIN] = 1;\ntcsetattr(fd, TCSANOW, &amp;options);\n\n// 设置串口文件描述符为异步通知模式\n/* 将串口文件描述符设置为当前进程的拥有者，从而接收该文件描述符相关的信号。*/\nfcntl(fd, F_SETOWN, getpid()); \nint flags = fcntl(fd, F_GETFL, 0); // 先获取当前配置, 下面只更改O_ASYNC标志\n/* 将串口文件描述符设置为非阻塞模式，从而允许该文件描述符异步地接收数据和信号。*/\nfcntl(fd, F_SETFL, flags | O_ASYNC);\n\n// 设置 SIGIO 信号的处理函数\nsa.sa_handler = sigio_handler;\nsigemptyset(&amp;sa.sa_mask);\nsa.sa_flags = 0;\n/* 设置了 SIGIO 信号的处理函数为 sigio_handler，从而在该信号被触发时读取串口数据并进行处理。*/\nsigaction(SIGIO, &amp;sa, NULL);\n\nwhile (1) {\n    // 等待 SIGIO 信号\n    sleep(1);\n}\n\n// 关闭串口设备\nclose(fd);\n\nreturn 0;</code></pre><p>}<br></p></signal.h></termios.h></fcntl.h></unistd.h></stdlib.h></stdio.h></code></pre></details><br>上述代码中，使用了 fcntl 函数将串口文件描述符设置为异步通知模式，并使用 SIGIO 信号来通知程序串口数据已经可读。当程序接收到 SIGIO 信号时，会调用 sigio_handler 函数来读取并处理串口数据。<p></p>\n<p>在这段代码中，sigemptyset（&amp;sa.sa_mask）;的作用是将信号处理函数在执行时要屏蔽的信号集合清空，即将其设置为空集。</p>\n<p>每个进程都有一个信号屏蔽字，它表示了当前被阻塞的信号集合。当一个信号被阻塞时，它将被加入到信号屏蔽字中，而当信号被解除阻塞时，它将被从信号屏蔽字中移除。如果信号处理函数在执行时需要屏蔽其他的信号，则可以使用sigaddset等函数将需要屏蔽的信号添加到信号屏蔽字中。但是，在本例中，我们需要处理的信号是SIGIO，它通常不需要被屏蔽，因此我们使用sigemptyset函数将信号屏蔽字清空，以确保在处理SIGIO信号时不会屏蔽任何其他信号。</p>\n<p>在Linux系统中，使用sigaction函数注册信号处理函数时，可以设置一些标志来指定信号处理的行为。例如，可以使用SA_RESTART标志来指定当系统调用被信号中断时自动重启该系统调用。在本例中，由于我们并不需要设置任何标志，因此将sa.sa_flags字段设置为0即可。这表示信号处理函数不需要任何特殊的行为，只需要按照默认的方式处理信号即可。</p>\n<h3 id=\"方法四：使用线程接收串口数据\"><a href=\"#方法四：使用线程接收串口数据\" class=\"headerlink\" title=\"方法四：使用线程接收串口数据\"></a>方法四：使用线程接收串口数据</h3><details><summary>使用线程接收code</summary>\n<pre><code>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <termios.h>\n#include <pthread.h>\n\n<p>void *read_thread(void *arg) {<br>    int fd = *(int *)arg;<br>    char buf[256];<br>    int n;</p>\n<pre><code>while (1) {\n    // 读取串口数据\n    n = read(fd, buf, sizeof(buf));\n    if (n &gt; 0) {\n        printf(&quot;Received data: %.*s\\n&quot;, n, buf);\n    }\n}\n\nreturn NULL;</code></pre><p>}</p>\n<p>int main() {<br>    int fd;<br>    struct termios options;<br>    pthread_t tid;</p>\n<pre><code>// 打开串口设备\nfd = open(&quot;/dev/ttyS0&quot;, O_RDWR | O_NOCTTY);\nif (fd &lt; 0) {\n    perror(&quot;open&quot;);\n    return -1;\n}\n\n// 配置串口参数\ntcgetattr(fd, &amp;options);\noptions.c_cflag = B9600 | CS8 | CLOCAL | CREAD;\noptions.c_iflag = IGNPAR;\noptions.c_oflag = 0;\noptions.c_lflag = 0;\noptions.c_cc[VTIME] = 0;\noptions.c_cc[VMIN] = 1;\ntcsetattr(fd, TCSANOW, &amp;options);\n\n// 创建读取线程\nif (pthread_create(&amp;tid, NULL, read_thread, &amp;fd) != 0) {\n    perror(&quot;pthread_create&quot;);\n    return -1;\n}\n\nwhile (1) {\n    // 主线程的其他处理逻辑\n    sleep(1);\n}\n\n// 关闭串口设备\nclose(fd);\n\nreturn 0;</code></pre><p>}<br></p></pthread.h></termios.h></fcntl.h></unistd.h></stdlib.h></stdio.h></code></pre></details><br>上述代码中，创建了一个读取线程，不断读取串口数据并进行处理。主线程可以在读取线程运行的同时进行其他处理逻辑。<p></p>\n"},{"title":"url","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-06-19T11:28:58.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"\n# 学习网站\n1：[bash语法](https://www.gnu.org/software/bash/manual/bash.pdf)\n","source":"_posts/2023/06/url.md","raw":"---\ntitle: url\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-06-19 19:28:58\npassword:\nsummary:\ntags: \n- study\ncategories:\n- study\nkeywords:\ndescription:\n---\n\n# 学习网站\n1：[bash语法](https://www.gnu.org/software/bash/manual/bash.pdf)\n","slug":"url","published":1,"updated":"2023-06-20T01:33:32.336Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk69d1es002ejsrj0d2n51e2","content":"<h1 id=\"学习网站\"><a href=\"#学习网站\" class=\"headerlink\" title=\"学习网站\"></a>学习网站</h1><p>1：<a href=\"https://www.gnu.org/software/bash/manual/bash.pdf\" target=\"_blank\" rel=\"noopener\">bash语法</a></p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<h1 id=\"学习网站\"><a href=\"#学习网站\" class=\"headerlink\" title=\"学习网站\"></a>学习网站</h1><p>1：<a href=\"https://www.gnu.org/software/bash/manual/bash.pdf\" target=\"_blank\" rel=\"noopener\">bash语法</a></p>\n"},{"title":"linux-platform","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-07-05T12:35:21.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"\n#  Q：如果你的项目中出现大量的外设你会如何设接代码（外设>10000+）\n#  A：外设驱动分工+分层系统设计\n\n# 外设驱动分工\n先讨论分工，分工很简单不同职能的工程师输出自己部分的设备和驱动的代码，首先区分两个观点\n1：设备代码（include/linux/platform_device.h--> platform_device结构体）\n    这个结构体 `platform_device` 是用于描述平台设备的数据结构。它包含以下字段：\n\n    - `name`: 平台设备的名称。\n    - `id`: 平台设备的标识符。\n    - `id_auto`: 表示标识符是否自动分配的标志。\n    - `dev`: 嵌套的 `struct device` 结构，用于表示设备的通用属性和行为。\n    - `num_resources`: 平台设备所使用的资源数量。\n    - `resource`: 指向资源数组的指针，描述平台设备所需的资源。\n    - `id_entry`: 指向匹配平台设备的 id 表项的指针。\n    - `driver_override`: 强制指定驱动程序名称以进行匹配的字符串。\n    - `mfd_cell`: 指向多功能设备 (MFD) 单元的指针，如果该平台设备属于 MFD 子系统。\n    - `archdata`: 架构特定的数据，用于存储与特定架构相关的平台设备信息。\n\n2：驱动代码（include/linux/platform_device.h--> platform_driver结构体）\n    这个结构体 `platform_driver` 是用于描述平台驱动程序的数据结构。它包含以下字段：\n\n    - `probe`: 平台设备的探测函数，在设备与驱动程序匹配成功时调用，用于初始化和配置设备。\n    - `remove`: 平台设备的移除函数，在设备与驱动程序解绑时调用，用于清理和释放设备资源。\n    - `shutdown`: 平台设备的关机函数，在系统关机时调用，用于执行设备的关机处理。\n    - `suspend`: 平台设备的挂起函数，在设备进入挂起状态时调用，用于执行设备的挂起操作。\n    - `resume`: 平台设备的恢复函数，在设备从挂起状态恢复时调用，用于执行设备的恢复操作。\n    - `driver`: 嵌套的 `struct device_driver` 结构，用于表示驱动程序的通用属性和行为。\n    - `id_table`: 指向平台设备 id 表的指针，用于指定与该驱动程序匹配的平台设备。\n    - `prevent_deferred_probe`: 阻止延迟探测的标志，用于指示驱动程序是否允许延迟探测机制。\n\n这样就可以系统工程师输出代码的同时，驱动工程师同时输出驱动，如果系统已经定义好标准的设备接口的话。应用工程师就可以在没有驱动的情况也可以开始应用层的工作。前提是系统的接口定义的足够清晰，重点是对需求的理解透彻，分析出所有的需求结构。\n\n# 分层系统设计\n现在设备和设备的驱动有了，剩下就是系统工程师的事情了，系统采用分层的设计![分层](linux-platform/device-driver.png).剩下的就是你会如何去设计这条linux的总线，对设备和驱动的匹配。最简单的设计思路就是建立两条链表，设备链表和驱动链表，在设备和驱动中设置一个成员相同用于匹配上设备和驱动，匹配成功就将设备回调函数注册成驱动中的函数。基本是这么实现的不详细讨论，linux中很复杂还有一大堆其他的工作。下面贴出一张网图画得很清楚：![platform](linux-platform/platform.png)\n详细的代码注释可以看我的[github仓库](https://gitee.com/qian-qiang/imx6ull_linux)\n\n# 进阶设计：使用设备树作为设备代码\nplatform 驱动框架分为总线、设备和驱动，其中总线不需要我们这些驱动程序员去管理，这\n个是 Linux 内核提供的，我们在编写驱动的时候只要关注于设备和驱动的具体实现即可。在没\n有设备树的 Linux 内核下，我们需要分别编写并注册 platform_device 和 platform_driver，分别代\n表设备和驱动。在使用设备树的时候，设备的描述被放到了设备树中，因此 platform_device 就\n不需要我们去编写了，我们只需要实现 platform_driver 即可。在编写基于设备树的 platform 驱\n动的时候我们需要注意一下几点\n    1、在设备树中创建设备节点\n    2、编写 platform 驱动的时候要注意兼容属性\n    3、编写 platform 驱动","source":"_posts/2023/07/linux-platform.md","raw":"---\ntitle: linux-platform\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-07-05 20:35:21\npassword:\nsummary:\ntags:\n- platform\n- linux\ncategories:\n- linux\nkeywords:\ndescription:\n---\n\n#  Q：如果你的项目中出现大量的外设你会如何设接代码（外设>10000+）\n#  A：外设驱动分工+分层系统设计\n\n# 外设驱动分工\n先讨论分工，分工很简单不同职能的工程师输出自己部分的设备和驱动的代码，首先区分两个观点\n1：设备代码（include/linux/platform_device.h--> platform_device结构体）\n    这个结构体 `platform_device` 是用于描述平台设备的数据结构。它包含以下字段：\n\n    - `name`: 平台设备的名称。\n    - `id`: 平台设备的标识符。\n    - `id_auto`: 表示标识符是否自动分配的标志。\n    - `dev`: 嵌套的 `struct device` 结构，用于表示设备的通用属性和行为。\n    - `num_resources`: 平台设备所使用的资源数量。\n    - `resource`: 指向资源数组的指针，描述平台设备所需的资源。\n    - `id_entry`: 指向匹配平台设备的 id 表项的指针。\n    - `driver_override`: 强制指定驱动程序名称以进行匹配的字符串。\n    - `mfd_cell`: 指向多功能设备 (MFD) 单元的指针，如果该平台设备属于 MFD 子系统。\n    - `archdata`: 架构特定的数据，用于存储与特定架构相关的平台设备信息。\n\n2：驱动代码（include/linux/platform_device.h--> platform_driver结构体）\n    这个结构体 `platform_driver` 是用于描述平台驱动程序的数据结构。它包含以下字段：\n\n    - `probe`: 平台设备的探测函数，在设备与驱动程序匹配成功时调用，用于初始化和配置设备。\n    - `remove`: 平台设备的移除函数，在设备与驱动程序解绑时调用，用于清理和释放设备资源。\n    - `shutdown`: 平台设备的关机函数，在系统关机时调用，用于执行设备的关机处理。\n    - `suspend`: 平台设备的挂起函数，在设备进入挂起状态时调用，用于执行设备的挂起操作。\n    - `resume`: 平台设备的恢复函数，在设备从挂起状态恢复时调用，用于执行设备的恢复操作。\n    - `driver`: 嵌套的 `struct device_driver` 结构，用于表示驱动程序的通用属性和行为。\n    - `id_table`: 指向平台设备 id 表的指针，用于指定与该驱动程序匹配的平台设备。\n    - `prevent_deferred_probe`: 阻止延迟探测的标志，用于指示驱动程序是否允许延迟探测机制。\n\n这样就可以系统工程师输出代码的同时，驱动工程师同时输出驱动，如果系统已经定义好标准的设备接口的话。应用工程师就可以在没有驱动的情况也可以开始应用层的工作。前提是系统的接口定义的足够清晰，重点是对需求的理解透彻，分析出所有的需求结构。\n\n# 分层系统设计\n现在设备和设备的驱动有了，剩下就是系统工程师的事情了，系统采用分层的设计![分层](linux-platform/device-driver.png).剩下的就是你会如何去设计这条linux的总线，对设备和驱动的匹配。最简单的设计思路就是建立两条链表，设备链表和驱动链表，在设备和驱动中设置一个成员相同用于匹配上设备和驱动，匹配成功就将设备回调函数注册成驱动中的函数。基本是这么实现的不详细讨论，linux中很复杂还有一大堆其他的工作。下面贴出一张网图画得很清楚：![platform](linux-platform/platform.png)\n详细的代码注释可以看我的[github仓库](https://gitee.com/qian-qiang/imx6ull_linux)\n\n# 进阶设计：使用设备树作为设备代码\nplatform 驱动框架分为总线、设备和驱动，其中总线不需要我们这些驱动程序员去管理，这\n个是 Linux 内核提供的，我们在编写驱动的时候只要关注于设备和驱动的具体实现即可。在没\n有设备树的 Linux 内核下，我们需要分别编写并注册 platform_device 和 platform_driver，分别代\n表设备和驱动。在使用设备树的时候，设备的描述被放到了设备树中，因此 platform_device 就\n不需要我们去编写了，我们只需要实现 platform_driver 即可。在编写基于设备树的 platform 驱\n动的时候我们需要注意一下几点\n    1、在设备树中创建设备节点\n    2、编写 platform 驱动的时候要注意兼容属性\n    3、编写 platform 驱动","slug":"linux-platform","published":1,"updated":"2023-07-06T03:26:36.733Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk69d1et002hjsrj155s3jlv","content":"<h1 id=\"Q：如果你的项目中出现大量的外设你会如何设接代码（外设-gt-10000-）\"><a href=\"#Q：如果你的项目中出现大量的外设你会如何设接代码（外设-gt-10000-）\" class=\"headerlink\" title=\"Q：如果你的项目中出现大量的外设你会如何设接代码（外设&gt;10000+）\"></a>Q：如果你的项目中出现大量的外设你会如何设接代码（外设&gt;10000+）</h1><h1 id=\"A：外设驱动分工-分层系统设计\"><a href=\"#A：外设驱动分工-分层系统设计\" class=\"headerlink\" title=\"A：外设驱动分工+分层系统设计\"></a>A：外设驱动分工+分层系统设计</h1><h1 id=\"外设驱动分工\"><a href=\"#外设驱动分工\" class=\"headerlink\" title=\"外设驱动分工\"></a>外设驱动分工</h1><p>先讨论分工，分工很简单不同职能的工程师输出自己部分的设备和驱动的代码，首先区分两个观点<br>1：设备代码（include/linux/platform_device.h–&gt; platform_device结构体）<br>    这个结构体 <code>platform_device</code> 是用于描述平台设备的数据结构。它包含以下字段：</p>\n<pre><code>- `name`: 平台设备的名称。\n- `id`: 平台设备的标识符。\n- `id_auto`: 表示标识符是否自动分配的标志。\n- `dev`: 嵌套的 `struct device` 结构，用于表示设备的通用属性和行为。\n- `num_resources`: 平台设备所使用的资源数量。\n- `resource`: 指向资源数组的指针，描述平台设备所需的资源。\n- `id_entry`: 指向匹配平台设备的 id 表项的指针。\n- `driver_override`: 强制指定驱动程序名称以进行匹配的字符串。\n- `mfd_cell`: 指向多功能设备 (MFD) 单元的指针，如果该平台设备属于 MFD 子系统。\n- `archdata`: 架构特定的数据，用于存储与特定架构相关的平台设备信息。</code></pre><p>2：驱动代码（include/linux/platform_device.h–&gt; platform_driver结构体）<br>    这个结构体 <code>platform_driver</code> 是用于描述平台驱动程序的数据结构。它包含以下字段：</p>\n<pre><code>- `probe`: 平台设备的探测函数，在设备与驱动程序匹配成功时调用，用于初始化和配置设备。\n- `remove`: 平台设备的移除函数，在设备与驱动程序解绑时调用，用于清理和释放设备资源。\n- `shutdown`: 平台设备的关机函数，在系统关机时调用，用于执行设备的关机处理。\n- `suspend`: 平台设备的挂起函数，在设备进入挂起状态时调用，用于执行设备的挂起操作。\n- `resume`: 平台设备的恢复函数，在设备从挂起状态恢复时调用，用于执行设备的恢复操作。\n- `driver`: 嵌套的 `struct device_driver` 结构，用于表示驱动程序的通用属性和行为。\n- `id_table`: 指向平台设备 id 表的指针，用于指定与该驱动程序匹配的平台设备。\n- `prevent_deferred_probe`: 阻止延迟探测的标志，用于指示驱动程序是否允许延迟探测机制。</code></pre><p>这样就可以系统工程师输出代码的同时，驱动工程师同时输出驱动，如果系统已经定义好标准的设备接口的话。应用工程师就可以在没有驱动的情况也可以开始应用层的工作。前提是系统的接口定义的足够清晰，重点是对需求的理解透彻，分析出所有的需求结构。</p>\n<h1 id=\"分层系统设计\"><a href=\"#分层系统设计\" class=\"headerlink\" title=\"分层系统设计\"></a>分层系统设计</h1><p>现在设备和设备的驱动有了，剩下就是系统工程师的事情了，系统采用分层的设计<img src=\"/2023/07/linux-platform/device-driver.png\" alt=\"分层\">.剩下的就是你会如何去设计这条linux的总线，对设备和驱动的匹配。最简单的设计思路就是建立两条链表，设备链表和驱动链表，在设备和驱动中设置一个成员相同用于匹配上设备和驱动，匹配成功就将设备回调函数注册成驱动中的函数。基本是这么实现的不详细讨论，linux中很复杂还有一大堆其他的工作。下面贴出一张网图画得很清楚：<img src=\"/2023/07/linux-platform/platform.png\" alt=\"platform\"><br>详细的代码注释可以看我的<a href=\"https://gitee.com/qian-qiang/imx6ull_linux\" target=\"_blank\" rel=\"noopener\">github仓库</a></p>\n<h1 id=\"进阶设计：使用设备树作为设备代码\"><a href=\"#进阶设计：使用设备树作为设备代码\" class=\"headerlink\" title=\"进阶设计：使用设备树作为设备代码\"></a>进阶设计：使用设备树作为设备代码</h1><p>platform 驱动框架分为总线、设备和驱动，其中总线不需要我们这些驱动程序员去管理，这<br>个是 Linux 内核提供的，我们在编写驱动的时候只要关注于设备和驱动的具体实现即可。在没<br>有设备树的 Linux 内核下，我们需要分别编写并注册 platform_device 和 platform_driver，分别代<br>表设备和驱动。在使用设备树的时候，设备的描述被放到了设备树中，因此 platform_device 就<br>不需要我们去编写了，我们只需要实现 platform_driver 即可。在编写基于设备树的 platform 驱<br>动的时候我们需要注意一下几点<br>    1、在设备树中创建设备节点<br>    2、编写 platform 驱动的时候要注意兼容属性<br>    3、编写 platform 驱动</p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<h1 id=\"Q：如果你的项目中出现大量的外设你会如何设接代码（外设-gt-10000-）\"><a href=\"#Q：如果你的项目中出现大量的外设你会如何设接代码（外设-gt-10000-）\" class=\"headerlink\" title=\"Q：如果你的项目中出现大量的外设你会如何设接代码（外设&gt;10000+）\"></a>Q：如果你的项目中出现大量的外设你会如何设接代码（外设&gt;10000+）</h1><h1 id=\"A：外设驱动分工-分层系统设计\"><a href=\"#A：外设驱动分工-分层系统设计\" class=\"headerlink\" title=\"A：外设驱动分工+分层系统设计\"></a>A：外设驱动分工+分层系统设计</h1><h1 id=\"外设驱动分工\"><a href=\"#外设驱动分工\" class=\"headerlink\" title=\"外设驱动分工\"></a>外设驱动分工</h1><p>先讨论分工，分工很简单不同职能的工程师输出自己部分的设备和驱动的代码，首先区分两个观点<br>1：设备代码（include/linux/platform_device.h–&gt; platform_device结构体）<br>    这个结构体 <code>platform_device</code> 是用于描述平台设备的数据结构。它包含以下字段：</p>\n<pre><code>- `name`: 平台设备的名称。\n- `id`: 平台设备的标识符。\n- `id_auto`: 表示标识符是否自动分配的标志。\n- `dev`: 嵌套的 `struct device` 结构，用于表示设备的通用属性和行为。\n- `num_resources`: 平台设备所使用的资源数量。\n- `resource`: 指向资源数组的指针，描述平台设备所需的资源。\n- `id_entry`: 指向匹配平台设备的 id 表项的指针。\n- `driver_override`: 强制指定驱动程序名称以进行匹配的字符串。\n- `mfd_cell`: 指向多功能设备 (MFD) 单元的指针，如果该平台设备属于 MFD 子系统。\n- `archdata`: 架构特定的数据，用于存储与特定架构相关的平台设备信息。</code></pre><p>2：驱动代码（include/linux/platform_device.h–&gt; platform_driver结构体）<br>    这个结构体 <code>platform_driver</code> 是用于描述平台驱动程序的数据结构。它包含以下字段：</p>\n<pre><code>- `probe`: 平台设备的探测函数，在设备与驱动程序匹配成功时调用，用于初始化和配置设备。\n- `remove`: 平台设备的移除函数，在设备与驱动程序解绑时调用，用于清理和释放设备资源。\n- `shutdown`: 平台设备的关机函数，在系统关机时调用，用于执行设备的关机处理。\n- `suspend`: 平台设备的挂起函数，在设备进入挂起状态时调用，用于执行设备的挂起操作。\n- `resume`: 平台设备的恢复函数，在设备从挂起状态恢复时调用，用于执行设备的恢复操作。\n- `driver`: 嵌套的 `struct device_driver` 结构，用于表示驱动程序的通用属性和行为。\n- `id_table`: 指向平台设备 id 表的指针，用于指定与该驱动程序匹配的平台设备。\n- `prevent_deferred_probe`: 阻止延迟探测的标志，用于指示驱动程序是否允许延迟探测机制。</code></pre><p>这样就可以系统工程师输出代码的同时，驱动工程师同时输出驱动，如果系统已经定义好标准的设备接口的话。应用工程师就可以在没有驱动的情况也可以开始应用层的工作。前提是系统的接口定义的足够清晰，重点是对需求的理解透彻，分析出所有的需求结构。</p>\n<h1 id=\"分层系统设计\"><a href=\"#分层系统设计\" class=\"headerlink\" title=\"分层系统设计\"></a>分层系统设计</h1><p>现在设备和设备的驱动有了，剩下就是系统工程师的事情了，系统采用分层的设计<img src=\"/2023/07/linux-platform/device-driver.png\" alt=\"分层\">.剩下的就是你会如何去设计这条linux的总线，对设备和驱动的匹配。最简单的设计思路就是建立两条链表，设备链表和驱动链表，在设备和驱动中设置一个成员相同用于匹配上设备和驱动，匹配成功就将设备回调函数注册成驱动中的函数。基本是这么实现的不详细讨论，linux中很复杂还有一大堆其他的工作。下面贴出一张网图画得很清楚：<img src=\"/2023/07/linux-platform/platform.png\" alt=\"platform\"><br>详细的代码注释可以看我的<a href=\"https://gitee.com/qian-qiang/imx6ull_linux\" target=\"_blank\" rel=\"noopener\">github仓库</a></p>\n<h1 id=\"进阶设计：使用设备树作为设备代码\"><a href=\"#进阶设计：使用设备树作为设备代码\" class=\"headerlink\" title=\"进阶设计：使用设备树作为设备代码\"></a>进阶设计：使用设备树作为设备代码</h1><p>platform 驱动框架分为总线、设备和驱动，其中总线不需要我们这些驱动程序员去管理，这<br>个是 Linux 内核提供的，我们在编写驱动的时候只要关注于设备和驱动的具体实现即可。在没<br>有设备树的 Linux 内核下，我们需要分别编写并注册 platform_device 和 platform_driver，分别代<br>表设备和驱动。在使用设备树的时候，设备的描述被放到了设备树中，因此 platform_device 就<br>不需要我们去编写了，我们只需要实现 platform_driver 即可。在编写基于设备树的 platform 驱<br>动的时候我们需要注意一下几点<br>    1、在设备树中创建设备节点<br>    2、编写 platform 驱动的时候要注意兼容属性<br>    3、编写 platform 驱动</p>\n"},{"title":"嵌入式软件框架方案","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-07-15T13:54:34.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"\n| 文件类型               | 研发过程文档   | 机密等级 | 机密     |\n|------------------------|----------------|----------|----------|\n| 文件编号               |                | 版本     | V1.0     |\n| 撰 写 人               |                | 日期     |          |\n| 审 核 人               |                | 日期     |          |\n| 批 准 人               |                | 日期     |          |\n| 项目名称               | XXX开发        |          |          |\n| **嵌入式软件框架设计** |                |          |          |\n| **相 关 文 档**        |                |          |          |\n| 文件编号               | 文件名称       | 版本     |          |\n|                        | 产品需求       |          |          |\n|                        | 用户需求       |          |          |\n|                        | 嵌入式软件需求 |          |          |\n|                        |                |          |          |\n|                        |                |          |          |\n|                        |                |          |          |\n|                        |                |          |          |\n|                        |                |          |          |\n| **修 订 记 录**        |                |          |          |\n| 版本                   | 修订内容       | 修订人   | 修订日期 |\n| V1.0                   | 创建           |          |          |\n|                        |                |          |          |\n|                        |                |          |          |\n|                        |                |          |          |\n|                        |                |          |          |\n|                        |                |          |          |\n|                        |                |          |          |\n\n**目 录**\n\n[0 版本记录](#_Toc57747469)\n\n[1 引言](#引言)\n\n[1.1 目的](#_Toc57747471)\n\n[1.2 背景](#_Toc57747472)\n\n[1.3 项目概述](#_Toc57747473)\n\n[1.4 术语与缩略语](#_Toc57747474)\n\n[1.5 引用文件](#_Toc57747475)\n\n[2 架构目标与设计约束](#_Toc57747476)\n\n[2.1 目标产品/目标产品系列](#_Toc57747477)\n\n[2.2 功能需求](#_Toc57747478)\n\n[2.3 上下文图](#上下文图)\n\n[2.4 质量需求](#_Toc57747480)\n\n[2.5 来自技术路线的约束：开发与运行环境限制](#来自技术路线的约束开发与运行环境限制)\n\n[2.6 来自硬件设计的约束：嵌入式硬件变化分析](#_Toc57747482)\n\n[2.7 来自上游方案的约束：整机配置变化分析](#来自上游方案的约束整机配置变化分析)\n\n[2.8 来自上游方案的约束：方案部署变化分析](#_Toc57747484)\n\n[3 架构思想](#_Toc57747485)\n\n[3.1 思想一：避免瓶颈、提高性能 【强制，嵌入式软件必须】](#_Toc57747486)\n\n[3.2 思想二：XXXXX](#思想二模块设计)\n\n[3.3 思想三：XXXXX](#思想三子系统设计)\n\n[4 架构设计](#_Toc57747489)\n\n[4.1 逻辑视图](#_Toc57747490)\n\n[4.2 产品/平台分工开发视图](#产品平台分工开发视图)\n\n[4.3 运行视图](#运行视图)\n\n[4.4 物理视图](#物理视图)\n\n[5 接口设计](#接口设计)\n\n[5.1 对外接口总览](#_Toc57747495)\n\n[5.2 各模块间接口总览](#各模块间接口总览)\n\n[5.3 平台和设备间接口总览](#_Toc57747497)\n\n[5.4 接口列表](#接口列表)\n\n[5.5 XXXXX接口设计](#xxxxx接口设计)\n\n[5.6 XXXXX接口设计](#xxxxx接口设计-1)\n\n[6 关键功能的设计原理](#_Toc57747501)\n\n[6.1 XXXXX功能设计](#xxxxx功能设计)\n\n[6.2 XXXXX功能设计](#xxxxx功能设计-1)\n\n[7 关键质量的设计原理](#_Toc57747504)\n\n[7.1 XXXX设计](#_Toc57747505)\n\n[7.2 XXXX设计](#xxxx设计-1)\n\n[7.3 XXXX设计](#xxxx设计-2)\n\n[8 对CBB管理的影响](#_Toc57747508)\n\n[8.1 本设计重用的CBB](#_Toc57747509)\n\n[8.2 本设计贡献的新CBB](#_Toc57747510)\n\n[8.3 本设计对现有CBB的升级需求](#_Toc57747511)\n\n# 引言\n\n## 目的\n\n*简要说明本文档的编写目的、用途和适用范围。*\n\n*【注意项】本节写“文档目的”，并非“项目目的”。*\n\n*【示例】*\n\n*本架构设计说明书编写的目的是……。本说明书的预期读者为系统设计人员、软件开发人员、软件测试人员和项目评审人员。*\n\n## 背景\n\n*简要说明产业背景、企业立项本项目的背景。*\n\n## 项目概述\n\n*简要说明项目内容、特点。*\n\n*【注意项】本节十分简洁，待到后续“2.1 目标产品/目标产品系列”适当展开。*\n\n## 术语与缩略语\n\n*本节集中说明和解释文档涉及的行业词汇、专业术语、首字母缩略语，提高文档可读性。*\n\n*【注意项】本节不可不写。*\n\n| **词汇** | **解释** |\n|----------|----------|\n|          |          |\n|          |          |\n|          |          |\n\n## 引用文件\n\n*应列出本文档引用的所有文档的编号、标题、修订版本和日期，方便读者查阅参考。*\n\n*【注意项】文档编号为□□公司为文档赋予的唯一正规编号。文档编号、文档版本号，均必写。*\n\n| **文档编号** | **文档名称** | **版本号** | **文档日期** |\n|--------------|--------------|------------|--------------|\n|              |              |            |              |\n|              |              |            |              |\n|              |              |            |              |\n|              |              |            |              |\n\n# 架构目标与设计约束\n\n*对于XX厂商，影响嵌入式软件架构设计大方向的不仅有功能需求、更有接口需求、运行开销约束、配置形态需求等。*\n\n*此节对后续架构设计的具体展开，具有重大指导、和方向性影响。*\n\n## 目标产品/目标产品系列\n\n*设备软件的研发有何特点？*\n\n*架构设计期能不能更有作为？*\n\n*多个相似产品的架构设计能否重用？*\n\n*设备软件有明显的“产品系列”特点，企业更是希望提高软件通用性与设计复用性，从而降成本。因此，本节应明确认真地说明：*\n\n*A）本架构设计文档是针对具体的一个产品、还是由多个产品组成的产品系列。*\n\n*B）如果针对产品系列，应对比其中各产品的关键能力、关键指标的不同。使读者有大局观。*\n\n*【注意项】面向产品系列而设计的架构，文档后续注意通用性设计、适应性设计的描述。*\n\n*概述目标产品，可以表格方式说明*\n\n| **架构设计针对的目标产品** | **产品说明** |\n|----------------------------|--------------|\n| Xx产品                     |              |\n| Yy产品                     |              |\n| Zz产品                     |              |\n\n*对比产品不同，可以《产品系列对比表》形式说明*\n\n*![](media/e852708ffd1c78efd87949efa7b31592.png)*\n\n## 功能需求\n\n### 功能树/功能列表\n\n*本节以功能树、功能表格等方式描述功能范围。*\n\n*注意1：无需展开描述。*\n\n*注意2：全面涵盖待研发的嵌入式设备软件的功能范围。*\n\n*【示例】功能树*\n\n![](media/dc4e3ddfdab5a0456af40df7d0a9238b.png)\n\n### 产品系列功能对比表\n\n*针对 “目标产品系列”的架构文档，请提供产品系列功能对比表。*\n\n*【注意项】针对“单个目标产品”的文档，请写“本节无内容”。*\n\n*【示例】产品系列功能特性对比表*\n\n*![](media/2dd308b3411c41658cce041f8c230853.png)*\n\n### * *关键功能识别与问题单分析\n\n*【背景1】关键需求决定架构。当设计需要权衡时，照顾的是关键需求。方法！*\n\n*【背景2】企业的问题单数据库，记录了同类系统暴露过的重大问题。风险！*\n\n*本节督促架构师去分析历史问题、提高设计针对性、避免问题重演：*\n\n*A）列出关键功能。文档后续的“6关键功能的设计原理”一节，应分别展开每个功能的设计。*\n\n*B）列出对问题单的单号、描述、风险点分析。设计时解决之。*\n\n*推荐描述形式*\n\n| **关键功能** | **问题单分析** |              |              |\n|--------------|----------------|--------------|--------------|\n|              | **单号**       | **历史问题** | **设计风险** |\n|              | \\#n            |              |              |\n|              | \\#m            |              |              |\n|              | \\#n            |              |              |\n|              | \\#m            |              |              |\n|              | \\#n            |              |              |\n|              | \\#m            |              |              |\n|              | \\#n            |              |              |\n|              | \\#m            |              |              |\n\n## 上下文图\n\n*本节以顶层数据流图的形式，描述XX软件的上下文，即与外部哪些其他控制器、硬件单元、软件系统等有接口。*\n\n*【示例】*\n\n## 质量需求\n\n*本节内容：*\n\n1.  *TODO XX公司应制定《嵌入式软件质量属性标准》，本节包含哪些小节应当与之一一对应。类似XX公司的系统工程化设计要求的“五可”：可靠性、可测试性、可生产性、可安装性，可服务性。*\n2.  *本节应覆盖来自高层需求文档的全部“质量指标”。*\n3.  *本节求全，不求细。不写场景，不写因素分解。*\n\n*制定《嵌入式软件质量属性标准》的参考一：某质量分类标准*\n\n| *运行期质量属性*                                                                                                                                                                                       | *开发期质量属性*                                                                                                                                                         |\n|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| *性能（Performance）* *安全性（Security）* *易用性（Usability）* *持续可用性（Availability）* *可伸缩性（Scalability）* *互操作性（Interoperability）* *可靠性（Reliability）* *鲁棒性（Robustness）*  | *易理解性（Understandability）* *可扩展性（Extensibility）* *可重用性（Reusability）* *可测试性（Testability）* *可维护性（Maintainability）* *可移植性（Portability）*  |\n\n*制定《嵌入式软件质量属性标准》的参考二：性能五项*\n\n*![](media/6aadad4da134377249d84bab5dbdfa8d.png)*\n\n### XXXX\n\n*该项质量的文字简述。不展开。*\n\n### XXXX\n\n*该项质量的文字简述。不展开。*\n\n## 来自技术路线的约束：开发与运行环境限制\n\n*公司的技术路线与技术战略中，包含了软件研发类技术选型的考虑，具体产品的架构师往往没有权力任意改变技术选型。本节内容：*\n\n1.  *简述技术选型约束*\n2.  *分析技术选型对关键资源的开销*\n\n### 开发环境约定\n\n*简单列举嵌入式软件研发的公司约定：开发语言、编译环境、本公司开发平台等。*\n\n### 运行环境约定\n\n*简单列举嵌入式软件研发的公司约定：硬件要求、操作系统、关系数据、实时数据库等。*\n\n### 选型的资源开销分析：CPU资源\n\n*资源紧、效率关键是嵌入式开发的特点。本节分析上述技术选型带来的CPU资源开销：*\n\n-   *CPU占用率、*\n-   *最大最小值、*\n-   *可能的架构风险。*\n\n### 选型的资源开销分析：内存资源\n\n*资源紧、效率关键是嵌入式开发的特点。本节分析上述技术选型带来的内存资源开销：*\n\n-   *内存占用率、*\n-   *最大最小值、*\n-   *可能的架构风险。*\n\n### 选型的资源开销分析：Flash资源\n\n*资源紧、效率关键是嵌入式开发的特点。本节分析上述技术选型带来的存储空间资源开销：*\n\n-   *存储空间占用率、*\n-   *最大最小值、*\n-   *可能的架构风险。*\n\n*【例如】例如Log组件高频度存储日志会消耗极多存储空间。架构师应尽早考虑如下影响：*\n\n-   *对于软件包大小的限制*\n-   *其他软件包大小的规划*\n-   *LOG存储策略、存储频度的考虑*\n\n## 来自硬件设计的约束：嵌入式硬件变化分析\n\n*本节通过多个硬件结构框图，列出所有（即穷举）可能的嵌入式硬件结构。这对后续架构的驱动层设计有直接影响。*\n\n*【FAQ】如果硬件设计还未完成，我要如何穷举所有可能的嵌入式硬件结构？*\n\n*【答】架构设计开始较早，这决定了架构师和程序员的一个极大不同，即软件架构师“时刻保持和硬件设计师的直接沟通”、“不应等待正式的《硬件设计文档》发布后才开始设计”。这一点，和程序员“在正式《需求规格》发布后才编程”有极大不同。*\n\n*【示例1】*\n\n*![](media/32643a6fbe010dcc95af301416619164.png)*\n\n## 来自上游方案的约束：整机配置变化分析\n\n*整机配置，指一台整机设备内如下不同：*\n\n-   *背板总线类型*\n-   *主控板类型*\n-   *主控板是否有主备、是否有群集*\n-   *非主控板的数量*\n-   *非主控板的种类*\n\n*本节通过多个图，列出所有（即穷举）可能的整机配置。*\n\n*【示例】*\n\n*![](media/22c7469876239933b38a12a32e9c6f16.png)*\n\n# 架构思想\n\n*作为架构师，你在本节，应当重点突出地说明有价值、有独特性的2\\~3条设计思想。*\n\n-   *例如，嵌入式软件可用的CPU、内存等资源有限，你的规划思想规划原则是什么*\n-   *例如，你如何运用状态机处理核心硬件的复杂状态组合*\n-   *……*\n\n## 思想一：避免瓶颈、提高性能 【强制，嵌入式软件必须】\n\n*分析关键资源约束，并在此给出相应的设计准则：*\n\n-   *例如，如果CPU是瓶颈，应约定“最大线程数限制”等设计原则并具体说明*\n-   *例如，如果内存是瓶颈，应约定“限制Cache滥用”等设计原则并具体说明*\n-   *例如，如果Flash紧缺，应约定“限制Log存储频率”等设计原则并具体说明*\n\n## 思想二：模块设计\n\n*只需重点突出地说明有价值、有独特性的2\\~3条设计思想。*\n\n## 思想三：子系统设计\n\n*只需重点突出地说明有价值、有独特性的2\\~3条设计思想。*\n\n# 架构设计\n\n## 逻辑视图\n\n### 功能子系统划分\n\n*纵切：功能子系统*\n\n*列出或画出包含的功能子系统，并说明。*\n\n### 系统分层架构\n\n*横切：逻辑层*\n\n*此处描述分层架构，有时采用“*系统分层架构**+**每层所用技术*”的形式将重要技术选型也描述进来。*\n\n*【示例】*\n\n## 产品/平台分工开发视图\n\n**【开发视图 vs. 产品/平台分工开发视图】**\n\n*开发视图，5视图之一，是单一视图——产品开发单元的切分，没有涉及平台扩充。*\n\n*产品/平台分工开发视图，是混合视图——产品要开发，同时平台要生长扩充。*\n\n**【本节内容】**\n\n*首先，要说清功能需求映射到产品组件、还是平台组件。*\n\n*其次，要说明平台总共要增加哪些组件、增强哪些组件。*\n\n*最后，才是详细说明产品组件有哪些、又分别对应哪些代码工程。*\n\n### 需求映射 与 产品/平台组件识别\n\n*此前需求分析做过的工作，架构师不再重复。本节也不写。*\n\n1.  *分析本嵌入式设备上实现的业务场景*\n2.  *分解出多项功能需求*\n\n*本节，架构师需要做：*\n\n1.  *将功能需求映射到对应的嵌入式软件的具体组件，并区分它是产品组件还是平台组件。以表格形式呈现。*\n\n*推荐形式：功能与参与功能实现的组件的映射矩阵*\n\n*![](media/780552b6b4ceacfe274a8c687b74a569.png)*\n\n### 平台架构 与 新增/增强组件的位置 【平台侧】\n\n*画出平台架构图，平台尽量黑盒化，不变的组件尽量少体现，重点体现平台侧还要加强的组件，特别标出新增/增强组件的位置。*\n\n### 产品组件 与 各组件说明 【产品侧】\n\n*可采用多种方式：列表格、画UML组件图并辅以文字说明。*\n\n*【示例】*\n\n| *序号* | *模块名称*    | *子模块名称*       | *功能说明*                                                             |\n|--------|---------------|--------------------|------------------------------------------------------------------------|\n| *1*    |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n| *2*    | *MCU机电模块* | *机电通信模块*     | *实现NMU机电模块与K10主机的通信。*                                     |\n|        |               | *电子标签接口模块* | *实现背板EEPROM的电子信息写入和读出。*                                 |\n|        |               | *风扇接口模块*     | *通过风扇控制寄存器的访问接口。*                                       |\n|        |               | *风扇控制模块*     | *提供对风扇单元转速的控制接口，风扇单元的工作状态和告警信息读取接口。* |\n|        |               | *机电应用模块*     | *实现机电信息的收集处理和上报，接收、响应NMU指令。*                    |\n|        |               | *机电软件下载模块* | *建立与K10主机机电软件下载会话，实现机电软件模块切割分片传送。*        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n| *3*    |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n\n### 产品组件对应的代码工程 与 开发技术 【产品侧】\n\n*说明嵌入式软件（产品侧）包含的多个开发工程（Project）或Makefile。*\n\n*细致地说明，每个组件开发所需的三方库、框架。*\n\n*【示例】*\n\n## 运行视图\n\n### 嵌入式软件：运行架构总览\n\n*说明嵌入式软件运行态下，有哪些进程、线程、以及对应组件的功能简述。*\n\n*【示例】*\n\n| **进程** | **线程** | **组件** | **组件功能** |\n|----------|----------|----------|--------------|\n|          |          |          |              |\n|          |          |          |              |\n|          |          |          |              |\n|          |          |          |              |\n|          |          |          |              |\n|          |          |          |              |\n|          |          |          |              |\n|          |          |          |              |\n|          |          |          |              |\n\n### 嵌入式软件中的组件：能否创建线程的准则\n\n*说明嵌入式软件产品侧线程创建的准则：*\n\n-   *哪些情况可以创建线程*\n-   *哪些情况杜绝滥启线程★★★*\n\n*后续组件详细设计师必须严格遵守，杜绝线程泛滥拉低性能和易理解性。*\n\n## 物理视图\n\n### 运行环境\n\n*细致地说明，嵌入式的硬件配置。*\n\n*细致地说明操作系统、各种系统软件、中间件的种类和版本。*\n\n*【示例】*\n\n| *硬件环境* *主CPU扣板为P2041，底板核心交换芯片为Qumran的硬件板卡。* *硬件配置* *CPU型号: p2041* *CPU主频：1.5GHz* *CPU核数：4\\*e500mc核* *CPU位宽：32位* *内存：4096 MB* *操作系统* *Linux localhost 2.6.34.15-grsec-WR4.3.0.0_cgl \\#1 SMP PREEMPT Fri Nov 4 16:51:14 CST 2016 ppc ppc ppc GNU/Linux* |\n|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n\n### 发布包目录结构及目标路径定义\n\n*本节应描述：*\n\n*A）发布包的详细目录结构约定。*\n\n*B）发布包应该mount到的目标路径*\n\n*【示例】*\n\n*。。。。。。*\n\n### * *组件部署结构\n\n*嵌入式软件往往由许多组件组成，本节重点说明组件之间的上下游关系。*\n\n*【示例】*\n\n# 接口设计\n\n## 对外接口总览\n\n画图，概览本嵌入式软件的对外接口的位置。\n\n## 各模块间接口总览\n\n画图，概览嵌入式软件内部的做个组件之间接口的位置。\n\n## 平台和设备间接口总览\n\n画图，概览平台与设备间接口的位置。\n\n## 接口列表\n\n列出接口名称和功能，对外和内部分别罗列。\n\n## XXXXX接口设计\n\n接口=交互过程+技术选择+格式定义。交互过程用序列图刻画\n\n*【示例1】函数接口的格式定义*\n\n| **名称**                                                                                                                                                                                                                                                             | dhcm回调函数                                      |          |\n|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------|----------|\n| **用途**                                                                                                                                                                                                                                                             | **DHCM组件提供给DDA的回调接口**                   |          |\n| **声明**                                                                                                                                                                                                                                                             |                                                   |          |\n| typedef struct tag_dhcm_callback {  INT32 (\\*dcoi_board_init)(DCOI_BOARD_INIT_INFO \\*init_info);  UINT32 (\\*dcoi_get_support_card_flag)();  UINT32 (\\*dcoi_cmi_ready_cb)();  VOID (\\*dcoi_dhcs_ready)(DHCS_CARD_COMP_INFO_MSG_EN \\*card_comp_info);  }DHCM_CALLBACK; |                                                   |          |\n| **字段**                                                                                                                                                                                                                                                             | **含义**                                          | **说明** |\n| dcoi_board_init                                                                                                                                                                                                                                                      | 嵌入式初始化的调用，包含硬件初始化和软件初始化。  |          |\n| dcoi_get_support_card_flag                                                                                                                                                                                                                                           | 返回嵌入式是否支持子卡的信息                      |          |\n| dcoi_cmi_ready_cb                                                                                                                                                                                                                                                    | 判断组件cmi是否有值                               |          |\n| dcoi_dhcs_ready                                                                                                                                                                                                                                                      | 获取嵌入式建模信息，包含框/槽/子卡/板类型等信息。 |          |\n\n*【示例2】协议接口的格式定义*\n\n![](media/60a0b6815e87242adbc049d64b96e01b.png)\n\n## XXXXX接口设计\n\n接口=交互过程+技术选择+格式定义。交互过程用序列图刻画\n\n# 关键功能的设计原理\n\n*本节内容：*\n\n-   *典型功能的设计*\n-   *“2.2.3关键功能识别与问题单分析”节中每个关键功能的设计*\n\n## XXXXX功能设计\n\n*用“*协作图+文字说明*”的方式说明每个关键功能的设计原理。图可以是下列方式之一：*\n\n-   *序列图*\n-   *协作图*\n-   *涉及多进程多线程的，图中应刻画出“进程/线程”*\n-   *设计跨机器分布式的，图中应刻画出“机器/控制板”*\n-   *协作逻辑复杂的，图中标号，再针对每个标号进行文字说明*\n\n## XXXXX功能设计\n\n# 关键质量的设计原理\n\n## XXXX设计\n\n### 影响质量的因素分解表/质量因素树\n\n*本节的核心是运用分解思维、系统化思维，梳理影响质量的因素。可采用表格、树等形式。*\n\n### 目标-场景-决策表\n\n*本节的核心是运用场景思维、具体化思维，分析质量因素对系统的具体影响，并给出设计对策。*\n\n*【注意项】推荐使用目标-场景-决策表，表中场景按“质量场景规约”格式编写*\n\n*![](media/c7546c50623e8a8aa6ab33ead8fac6cb.png)*\n\n### 设计原理图\n\n【示例】![](media/e7176066eab77c0cf6e147aed0046ea7.png)\n\n## XXXX设计\n\n### 影响质量的因素分解表/质量因素树\n\n### 目标-场景-决策表\n\n### 设计原理图\n\n## XXXX设计\n\n### 影响质量的因素分解表/质量因素树\n\n### 目标-场景-决策表\n\n### 设计原理图\n\n# \n","source":"_posts/2023/07/嵌入式软件框架方案.md","raw":"---\ntitle: 嵌入式软件框架方案\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-07-15 21:54:34\npassword:\nsummary:\ntags:\n- Embedded system\ncategories:\n- Embedded system\nkeywords:\ndescription:\n---\n\n| 文件类型               | 研发过程文档   | 机密等级 | 机密     |\n|------------------------|----------------|----------|----------|\n| 文件编号               |                | 版本     | V1.0     |\n| 撰 写 人               |                | 日期     |          |\n| 审 核 人               |                | 日期     |          |\n| 批 准 人               |                | 日期     |          |\n| 项目名称               | XXX开发        |          |          |\n| **嵌入式软件框架设计** |                |          |          |\n| **相 关 文 档**        |                |          |          |\n| 文件编号               | 文件名称       | 版本     |          |\n|                        | 产品需求       |          |          |\n|                        | 用户需求       |          |          |\n|                        | 嵌入式软件需求 |          |          |\n|                        |                |          |          |\n|                        |                |          |          |\n|                        |                |          |          |\n|                        |                |          |          |\n|                        |                |          |          |\n| **修 订 记 录**        |                |          |          |\n| 版本                   | 修订内容       | 修订人   | 修订日期 |\n| V1.0                   | 创建           |          |          |\n|                        |                |          |          |\n|                        |                |          |          |\n|                        |                |          |          |\n|                        |                |          |          |\n|                        |                |          |          |\n|                        |                |          |          |\n\n**目 录**\n\n[0 版本记录](#_Toc57747469)\n\n[1 引言](#引言)\n\n[1.1 目的](#_Toc57747471)\n\n[1.2 背景](#_Toc57747472)\n\n[1.3 项目概述](#_Toc57747473)\n\n[1.4 术语与缩略语](#_Toc57747474)\n\n[1.5 引用文件](#_Toc57747475)\n\n[2 架构目标与设计约束](#_Toc57747476)\n\n[2.1 目标产品/目标产品系列](#_Toc57747477)\n\n[2.2 功能需求](#_Toc57747478)\n\n[2.3 上下文图](#上下文图)\n\n[2.4 质量需求](#_Toc57747480)\n\n[2.5 来自技术路线的约束：开发与运行环境限制](#来自技术路线的约束开发与运行环境限制)\n\n[2.6 来自硬件设计的约束：嵌入式硬件变化分析](#_Toc57747482)\n\n[2.7 来自上游方案的约束：整机配置变化分析](#来自上游方案的约束整机配置变化分析)\n\n[2.8 来自上游方案的约束：方案部署变化分析](#_Toc57747484)\n\n[3 架构思想](#_Toc57747485)\n\n[3.1 思想一：避免瓶颈、提高性能 【强制，嵌入式软件必须】](#_Toc57747486)\n\n[3.2 思想二：XXXXX](#思想二模块设计)\n\n[3.3 思想三：XXXXX](#思想三子系统设计)\n\n[4 架构设计](#_Toc57747489)\n\n[4.1 逻辑视图](#_Toc57747490)\n\n[4.2 产品/平台分工开发视图](#产品平台分工开发视图)\n\n[4.3 运行视图](#运行视图)\n\n[4.4 物理视图](#物理视图)\n\n[5 接口设计](#接口设计)\n\n[5.1 对外接口总览](#_Toc57747495)\n\n[5.2 各模块间接口总览](#各模块间接口总览)\n\n[5.3 平台和设备间接口总览](#_Toc57747497)\n\n[5.4 接口列表](#接口列表)\n\n[5.5 XXXXX接口设计](#xxxxx接口设计)\n\n[5.6 XXXXX接口设计](#xxxxx接口设计-1)\n\n[6 关键功能的设计原理](#_Toc57747501)\n\n[6.1 XXXXX功能设计](#xxxxx功能设计)\n\n[6.2 XXXXX功能设计](#xxxxx功能设计-1)\n\n[7 关键质量的设计原理](#_Toc57747504)\n\n[7.1 XXXX设计](#_Toc57747505)\n\n[7.2 XXXX设计](#xxxx设计-1)\n\n[7.3 XXXX设计](#xxxx设计-2)\n\n[8 对CBB管理的影响](#_Toc57747508)\n\n[8.1 本设计重用的CBB](#_Toc57747509)\n\n[8.2 本设计贡献的新CBB](#_Toc57747510)\n\n[8.3 本设计对现有CBB的升级需求](#_Toc57747511)\n\n# 引言\n\n## 目的\n\n*简要说明本文档的编写目的、用途和适用范围。*\n\n*【注意项】本节写“文档目的”，并非“项目目的”。*\n\n*【示例】*\n\n*本架构设计说明书编写的目的是……。本说明书的预期读者为系统设计人员、软件开发人员、软件测试人员和项目评审人员。*\n\n## 背景\n\n*简要说明产业背景、企业立项本项目的背景。*\n\n## 项目概述\n\n*简要说明项目内容、特点。*\n\n*【注意项】本节十分简洁，待到后续“2.1 目标产品/目标产品系列”适当展开。*\n\n## 术语与缩略语\n\n*本节集中说明和解释文档涉及的行业词汇、专业术语、首字母缩略语，提高文档可读性。*\n\n*【注意项】本节不可不写。*\n\n| **词汇** | **解释** |\n|----------|----------|\n|          |          |\n|          |          |\n|          |          |\n\n## 引用文件\n\n*应列出本文档引用的所有文档的编号、标题、修订版本和日期，方便读者查阅参考。*\n\n*【注意项】文档编号为□□公司为文档赋予的唯一正规编号。文档编号、文档版本号，均必写。*\n\n| **文档编号** | **文档名称** | **版本号** | **文档日期** |\n|--------------|--------------|------------|--------------|\n|              |              |            |              |\n|              |              |            |              |\n|              |              |            |              |\n|              |              |            |              |\n\n# 架构目标与设计约束\n\n*对于XX厂商，影响嵌入式软件架构设计大方向的不仅有功能需求、更有接口需求、运行开销约束、配置形态需求等。*\n\n*此节对后续架构设计的具体展开，具有重大指导、和方向性影响。*\n\n## 目标产品/目标产品系列\n\n*设备软件的研发有何特点？*\n\n*架构设计期能不能更有作为？*\n\n*多个相似产品的架构设计能否重用？*\n\n*设备软件有明显的“产品系列”特点，企业更是希望提高软件通用性与设计复用性，从而降成本。因此，本节应明确认真地说明：*\n\n*A）本架构设计文档是针对具体的一个产品、还是由多个产品组成的产品系列。*\n\n*B）如果针对产品系列，应对比其中各产品的关键能力、关键指标的不同。使读者有大局观。*\n\n*【注意项】面向产品系列而设计的架构，文档后续注意通用性设计、适应性设计的描述。*\n\n*概述目标产品，可以表格方式说明*\n\n| **架构设计针对的目标产品** | **产品说明** |\n|----------------------------|--------------|\n| Xx产品                     |              |\n| Yy产品                     |              |\n| Zz产品                     |              |\n\n*对比产品不同，可以《产品系列对比表》形式说明*\n\n*![](media/e852708ffd1c78efd87949efa7b31592.png)*\n\n## 功能需求\n\n### 功能树/功能列表\n\n*本节以功能树、功能表格等方式描述功能范围。*\n\n*注意1：无需展开描述。*\n\n*注意2：全面涵盖待研发的嵌入式设备软件的功能范围。*\n\n*【示例】功能树*\n\n![](media/dc4e3ddfdab5a0456af40df7d0a9238b.png)\n\n### 产品系列功能对比表\n\n*针对 “目标产品系列”的架构文档，请提供产品系列功能对比表。*\n\n*【注意项】针对“单个目标产品”的文档，请写“本节无内容”。*\n\n*【示例】产品系列功能特性对比表*\n\n*![](media/2dd308b3411c41658cce041f8c230853.png)*\n\n### * *关键功能识别与问题单分析\n\n*【背景1】关键需求决定架构。当设计需要权衡时，照顾的是关键需求。方法！*\n\n*【背景2】企业的问题单数据库，记录了同类系统暴露过的重大问题。风险！*\n\n*本节督促架构师去分析历史问题、提高设计针对性、避免问题重演：*\n\n*A）列出关键功能。文档后续的“6关键功能的设计原理”一节，应分别展开每个功能的设计。*\n\n*B）列出对问题单的单号、描述、风险点分析。设计时解决之。*\n\n*推荐描述形式*\n\n| **关键功能** | **问题单分析** |              |              |\n|--------------|----------------|--------------|--------------|\n|              | **单号**       | **历史问题** | **设计风险** |\n|              | \\#n            |              |              |\n|              | \\#m            |              |              |\n|              | \\#n            |              |              |\n|              | \\#m            |              |              |\n|              | \\#n            |              |              |\n|              | \\#m            |              |              |\n|              | \\#n            |              |              |\n|              | \\#m            |              |              |\n\n## 上下文图\n\n*本节以顶层数据流图的形式，描述XX软件的上下文，即与外部哪些其他控制器、硬件单元、软件系统等有接口。*\n\n*【示例】*\n\n## 质量需求\n\n*本节内容：*\n\n1.  *TODO XX公司应制定《嵌入式软件质量属性标准》，本节包含哪些小节应当与之一一对应。类似XX公司的系统工程化设计要求的“五可”：可靠性、可测试性、可生产性、可安装性，可服务性。*\n2.  *本节应覆盖来自高层需求文档的全部“质量指标”。*\n3.  *本节求全，不求细。不写场景，不写因素分解。*\n\n*制定《嵌入式软件质量属性标准》的参考一：某质量分类标准*\n\n| *运行期质量属性*                                                                                                                                                                                       | *开发期质量属性*                                                                                                                                                         |\n|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| *性能（Performance）* *安全性（Security）* *易用性（Usability）* *持续可用性（Availability）* *可伸缩性（Scalability）* *互操作性（Interoperability）* *可靠性（Reliability）* *鲁棒性（Robustness）*  | *易理解性（Understandability）* *可扩展性（Extensibility）* *可重用性（Reusability）* *可测试性（Testability）* *可维护性（Maintainability）* *可移植性（Portability）*  |\n\n*制定《嵌入式软件质量属性标准》的参考二：性能五项*\n\n*![](media/6aadad4da134377249d84bab5dbdfa8d.png)*\n\n### XXXX\n\n*该项质量的文字简述。不展开。*\n\n### XXXX\n\n*该项质量的文字简述。不展开。*\n\n## 来自技术路线的约束：开发与运行环境限制\n\n*公司的技术路线与技术战略中，包含了软件研发类技术选型的考虑，具体产品的架构师往往没有权力任意改变技术选型。本节内容：*\n\n1.  *简述技术选型约束*\n2.  *分析技术选型对关键资源的开销*\n\n### 开发环境约定\n\n*简单列举嵌入式软件研发的公司约定：开发语言、编译环境、本公司开发平台等。*\n\n### 运行环境约定\n\n*简单列举嵌入式软件研发的公司约定：硬件要求、操作系统、关系数据、实时数据库等。*\n\n### 选型的资源开销分析：CPU资源\n\n*资源紧、效率关键是嵌入式开发的特点。本节分析上述技术选型带来的CPU资源开销：*\n\n-   *CPU占用率、*\n-   *最大最小值、*\n-   *可能的架构风险。*\n\n### 选型的资源开销分析：内存资源\n\n*资源紧、效率关键是嵌入式开发的特点。本节分析上述技术选型带来的内存资源开销：*\n\n-   *内存占用率、*\n-   *最大最小值、*\n-   *可能的架构风险。*\n\n### 选型的资源开销分析：Flash资源\n\n*资源紧、效率关键是嵌入式开发的特点。本节分析上述技术选型带来的存储空间资源开销：*\n\n-   *存储空间占用率、*\n-   *最大最小值、*\n-   *可能的架构风险。*\n\n*【例如】例如Log组件高频度存储日志会消耗极多存储空间。架构师应尽早考虑如下影响：*\n\n-   *对于软件包大小的限制*\n-   *其他软件包大小的规划*\n-   *LOG存储策略、存储频度的考虑*\n\n## 来自硬件设计的约束：嵌入式硬件变化分析\n\n*本节通过多个硬件结构框图，列出所有（即穷举）可能的嵌入式硬件结构。这对后续架构的驱动层设计有直接影响。*\n\n*【FAQ】如果硬件设计还未完成，我要如何穷举所有可能的嵌入式硬件结构？*\n\n*【答】架构设计开始较早，这决定了架构师和程序员的一个极大不同，即软件架构师“时刻保持和硬件设计师的直接沟通”、“不应等待正式的《硬件设计文档》发布后才开始设计”。这一点，和程序员“在正式《需求规格》发布后才编程”有极大不同。*\n\n*【示例1】*\n\n*![](media/32643a6fbe010dcc95af301416619164.png)*\n\n## 来自上游方案的约束：整机配置变化分析\n\n*整机配置，指一台整机设备内如下不同：*\n\n-   *背板总线类型*\n-   *主控板类型*\n-   *主控板是否有主备、是否有群集*\n-   *非主控板的数量*\n-   *非主控板的种类*\n\n*本节通过多个图，列出所有（即穷举）可能的整机配置。*\n\n*【示例】*\n\n*![](media/22c7469876239933b38a12a32e9c6f16.png)*\n\n# 架构思想\n\n*作为架构师，你在本节，应当重点突出地说明有价值、有独特性的2\\~3条设计思想。*\n\n-   *例如，嵌入式软件可用的CPU、内存等资源有限，你的规划思想规划原则是什么*\n-   *例如，你如何运用状态机处理核心硬件的复杂状态组合*\n-   *……*\n\n## 思想一：避免瓶颈、提高性能 【强制，嵌入式软件必须】\n\n*分析关键资源约束，并在此给出相应的设计准则：*\n\n-   *例如，如果CPU是瓶颈，应约定“最大线程数限制”等设计原则并具体说明*\n-   *例如，如果内存是瓶颈，应约定“限制Cache滥用”等设计原则并具体说明*\n-   *例如，如果Flash紧缺，应约定“限制Log存储频率”等设计原则并具体说明*\n\n## 思想二：模块设计\n\n*只需重点突出地说明有价值、有独特性的2\\~3条设计思想。*\n\n## 思想三：子系统设计\n\n*只需重点突出地说明有价值、有独特性的2\\~3条设计思想。*\n\n# 架构设计\n\n## 逻辑视图\n\n### 功能子系统划分\n\n*纵切：功能子系统*\n\n*列出或画出包含的功能子系统，并说明。*\n\n### 系统分层架构\n\n*横切：逻辑层*\n\n*此处描述分层架构，有时采用“*系统分层架构**+**每层所用技术*”的形式将重要技术选型也描述进来。*\n\n*【示例】*\n\n## 产品/平台分工开发视图\n\n**【开发视图 vs. 产品/平台分工开发视图】**\n\n*开发视图，5视图之一，是单一视图——产品开发单元的切分，没有涉及平台扩充。*\n\n*产品/平台分工开发视图，是混合视图——产品要开发，同时平台要生长扩充。*\n\n**【本节内容】**\n\n*首先，要说清功能需求映射到产品组件、还是平台组件。*\n\n*其次，要说明平台总共要增加哪些组件、增强哪些组件。*\n\n*最后，才是详细说明产品组件有哪些、又分别对应哪些代码工程。*\n\n### 需求映射 与 产品/平台组件识别\n\n*此前需求分析做过的工作，架构师不再重复。本节也不写。*\n\n1.  *分析本嵌入式设备上实现的业务场景*\n2.  *分解出多项功能需求*\n\n*本节，架构师需要做：*\n\n1.  *将功能需求映射到对应的嵌入式软件的具体组件，并区分它是产品组件还是平台组件。以表格形式呈现。*\n\n*推荐形式：功能与参与功能实现的组件的映射矩阵*\n\n*![](media/780552b6b4ceacfe274a8c687b74a569.png)*\n\n### 平台架构 与 新增/增强组件的位置 【平台侧】\n\n*画出平台架构图，平台尽量黑盒化，不变的组件尽量少体现，重点体现平台侧还要加强的组件，特别标出新增/增强组件的位置。*\n\n### 产品组件 与 各组件说明 【产品侧】\n\n*可采用多种方式：列表格、画UML组件图并辅以文字说明。*\n\n*【示例】*\n\n| *序号* | *模块名称*    | *子模块名称*       | *功能说明*                                                             |\n|--------|---------------|--------------------|------------------------------------------------------------------------|\n| *1*    |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n| *2*    | *MCU机电模块* | *机电通信模块*     | *实现NMU机电模块与K10主机的通信。*                                     |\n|        |               | *电子标签接口模块* | *实现背板EEPROM的电子信息写入和读出。*                                 |\n|        |               | *风扇接口模块*     | *通过风扇控制寄存器的访问接口。*                                       |\n|        |               | *风扇控制模块*     | *提供对风扇单元转速的控制接口，风扇单元的工作状态和告警信息读取接口。* |\n|        |               | *机电应用模块*     | *实现机电信息的收集处理和上报，接收、响应NMU指令。*                    |\n|        |               | *机电软件下载模块* | *建立与K10主机机电软件下载会话，实现机电软件模块切割分片传送。*        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n| *3*    |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n\n### 产品组件对应的代码工程 与 开发技术 【产品侧】\n\n*说明嵌入式软件（产品侧）包含的多个开发工程（Project）或Makefile。*\n\n*细致地说明，每个组件开发所需的三方库、框架。*\n\n*【示例】*\n\n## 运行视图\n\n### 嵌入式软件：运行架构总览\n\n*说明嵌入式软件运行态下，有哪些进程、线程、以及对应组件的功能简述。*\n\n*【示例】*\n\n| **进程** | **线程** | **组件** | **组件功能** |\n|----------|----------|----------|--------------|\n|          |          |          |              |\n|          |          |          |              |\n|          |          |          |              |\n|          |          |          |              |\n|          |          |          |              |\n|          |          |          |              |\n|          |          |          |              |\n|          |          |          |              |\n|          |          |          |              |\n\n### 嵌入式软件中的组件：能否创建线程的准则\n\n*说明嵌入式软件产品侧线程创建的准则：*\n\n-   *哪些情况可以创建线程*\n-   *哪些情况杜绝滥启线程★★★*\n\n*后续组件详细设计师必须严格遵守，杜绝线程泛滥拉低性能和易理解性。*\n\n## 物理视图\n\n### 运行环境\n\n*细致地说明，嵌入式的硬件配置。*\n\n*细致地说明操作系统、各种系统软件、中间件的种类和版本。*\n\n*【示例】*\n\n| *硬件环境* *主CPU扣板为P2041，底板核心交换芯片为Qumran的硬件板卡。* *硬件配置* *CPU型号: p2041* *CPU主频：1.5GHz* *CPU核数：4\\*e500mc核* *CPU位宽：32位* *内存：4096 MB* *操作系统* *Linux localhost 2.6.34.15-grsec-WR4.3.0.0_cgl \\#1 SMP PREEMPT Fri Nov 4 16:51:14 CST 2016 ppc ppc ppc GNU/Linux* |\n|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n\n### 发布包目录结构及目标路径定义\n\n*本节应描述：*\n\n*A）发布包的详细目录结构约定。*\n\n*B）发布包应该mount到的目标路径*\n\n*【示例】*\n\n*。。。。。。*\n\n### * *组件部署结构\n\n*嵌入式软件往往由许多组件组成，本节重点说明组件之间的上下游关系。*\n\n*【示例】*\n\n# 接口设计\n\n## 对外接口总览\n\n画图，概览本嵌入式软件的对外接口的位置。\n\n## 各模块间接口总览\n\n画图，概览嵌入式软件内部的做个组件之间接口的位置。\n\n## 平台和设备间接口总览\n\n画图，概览平台与设备间接口的位置。\n\n## 接口列表\n\n列出接口名称和功能，对外和内部分别罗列。\n\n## XXXXX接口设计\n\n接口=交互过程+技术选择+格式定义。交互过程用序列图刻画\n\n*【示例1】函数接口的格式定义*\n\n| **名称**                                                                                                                                                                                                                                                             | dhcm回调函数                                      |          |\n|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------|----------|\n| **用途**                                                                                                                                                                                                                                                             | **DHCM组件提供给DDA的回调接口**                   |          |\n| **声明**                                                                                                                                                                                                                                                             |                                                   |          |\n| typedef struct tag_dhcm_callback {  INT32 (\\*dcoi_board_init)(DCOI_BOARD_INIT_INFO \\*init_info);  UINT32 (\\*dcoi_get_support_card_flag)();  UINT32 (\\*dcoi_cmi_ready_cb)();  VOID (\\*dcoi_dhcs_ready)(DHCS_CARD_COMP_INFO_MSG_EN \\*card_comp_info);  }DHCM_CALLBACK; |                                                   |          |\n| **字段**                                                                                                                                                                                                                                                             | **含义**                                          | **说明** |\n| dcoi_board_init                                                                                                                                                                                                                                                      | 嵌入式初始化的调用，包含硬件初始化和软件初始化。  |          |\n| dcoi_get_support_card_flag                                                                                                                                                                                                                                           | 返回嵌入式是否支持子卡的信息                      |          |\n| dcoi_cmi_ready_cb                                                                                                                                                                                                                                                    | 判断组件cmi是否有值                               |          |\n| dcoi_dhcs_ready                                                                                                                                                                                                                                                      | 获取嵌入式建模信息，包含框/槽/子卡/板类型等信息。 |          |\n\n*【示例2】协议接口的格式定义*\n\n![](media/60a0b6815e87242adbc049d64b96e01b.png)\n\n## XXXXX接口设计\n\n接口=交互过程+技术选择+格式定义。交互过程用序列图刻画\n\n# 关键功能的设计原理\n\n*本节内容：*\n\n-   *典型功能的设计*\n-   *“2.2.3关键功能识别与问题单分析”节中每个关键功能的设计*\n\n## XXXXX功能设计\n\n*用“*协作图+文字说明*”的方式说明每个关键功能的设计原理。图可以是下列方式之一：*\n\n-   *序列图*\n-   *协作图*\n-   *涉及多进程多线程的，图中应刻画出“进程/线程”*\n-   *设计跨机器分布式的，图中应刻画出“机器/控制板”*\n-   *协作逻辑复杂的，图中标号，再针对每个标号进行文字说明*\n\n## XXXXX功能设计\n\n# 关键质量的设计原理\n\n## XXXX设计\n\n### 影响质量的因素分解表/质量因素树\n\n*本节的核心是运用分解思维、系统化思维，梳理影响质量的因素。可采用表格、树等形式。*\n\n### 目标-场景-决策表\n\n*本节的核心是运用场景思维、具体化思维，分析质量因素对系统的具体影响，并给出设计对策。*\n\n*【注意项】推荐使用目标-场景-决策表，表中场景按“质量场景规约”格式编写*\n\n*![](media/c7546c50623e8a8aa6ab33ead8fac6cb.png)*\n\n### 设计原理图\n\n【示例】![](media/e7176066eab77c0cf6e147aed0046ea7.png)\n\n## XXXX设计\n\n### 影响质量的因素分解表/质量因素树\n\n### 目标-场景-决策表\n\n### 设计原理图\n\n## XXXX设计\n\n### 影响质量的因素分解表/质量因素树\n\n### 目标-场景-决策表\n\n### 设计原理图\n\n# \n","slug":"嵌入式软件框架方案","published":1,"updated":"2023-07-17T01:50:31.576Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk69d1et002mjsrjxfanbqpt","content":"<table>\n<thead>\n<tr>\n<th>文件类型</th>\n<th>研发过程文档</th>\n<th>机密等级</th>\n<th>机密</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>文件编号</td>\n<td></td>\n<td>版本</td>\n<td>V1.0</td>\n</tr>\n<tr>\n<td>撰 写 人</td>\n<td></td>\n<td>日期</td>\n<td></td>\n</tr>\n<tr>\n<td>审 核 人</td>\n<td></td>\n<td>日期</td>\n<td></td>\n</tr>\n<tr>\n<td>批 准 人</td>\n<td></td>\n<td>日期</td>\n<td></td>\n</tr>\n<tr>\n<td>项目名称</td>\n<td>XXX开发</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>嵌入式软件框架设计</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>相 关 文 档</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>文件编号</td>\n<td>文件名称</td>\n<td>版本</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>产品需求</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>用户需求</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>嵌入式软件需求</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>修 订 记 录</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>版本</td>\n<td>修订内容</td>\n<td>修订人</td>\n<td>修订日期</td>\n</tr>\n<tr>\n<td>V1.0</td>\n<td>创建</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p><strong>目 录</strong></p>\n<p><a href=\"#_Toc57747469\">0 版本记录</a></p>\n<p><a href=\"#引言\">1 引言</a></p>\n<p><a href=\"#_Toc57747471\">1.1 目的</a></p>\n<p><a href=\"#_Toc57747472\">1.2 背景</a></p>\n<p><a href=\"#_Toc57747473\">1.3 项目概述</a></p>\n<p><a href=\"#_Toc57747474\">1.4 术语与缩略语</a></p>\n<p><a href=\"#_Toc57747475\">1.5 引用文件</a></p>\n<p><a href=\"#_Toc57747476\">2 架构目标与设计约束</a></p>\n<p><a href=\"#_Toc57747477\">2.1 目标产品/目标产品系列</a></p>\n<p><a href=\"#_Toc57747478\">2.2 功能需求</a></p>\n<p><a href=\"#上下文图\">2.3 上下文图</a></p>\n<p><a href=\"#_Toc57747480\">2.4 质量需求</a></p>\n<p><a href=\"#来自技术路线的约束开发与运行环境限制\">2.5 来自技术路线的约束：开发与运行环境限制</a></p>\n<p><a href=\"#_Toc57747482\">2.6 来自硬件设计的约束：嵌入式硬件变化分析</a></p>\n<p><a href=\"#来自上游方案的约束整机配置变化分析\">2.7 来自上游方案的约束：整机配置变化分析</a></p>\n<p><a href=\"#_Toc57747484\">2.8 来自上游方案的约束：方案部署变化分析</a></p>\n<p><a href=\"#_Toc57747485\">3 架构思想</a></p>\n<p><a href=\"#_Toc57747486\">3.1 思想一：避免瓶颈、提高性能 【强制，嵌入式软件必须】</a></p>\n<p><a href=\"#思想二模块设计\">3.2 思想二：XXXXX</a></p>\n<p><a href=\"#思想三子系统设计\">3.3 思想三：XXXXX</a></p>\n<p><a href=\"#_Toc57747489\">4 架构设计</a></p>\n<p><a href=\"#_Toc57747490\">4.1 逻辑视图</a></p>\n<p><a href=\"#产品平台分工开发视图\">4.2 产品/平台分工开发视图</a></p>\n<p><a href=\"#运行视图\">4.3 运行视图</a></p>\n<p><a href=\"#物理视图\">4.4 物理视图</a></p>\n<p><a href=\"#接口设计\">5 接口设计</a></p>\n<p><a href=\"#_Toc57747495\">5.1 对外接口总览</a></p>\n<p><a href=\"#各模块间接口总览\">5.2 各模块间接口总览</a></p>\n<p><a href=\"#_Toc57747497\">5.3 平台和设备间接口总览</a></p>\n<p><a href=\"#接口列表\">5.4 接口列表</a></p>\n<p><a href=\"#xxxxx接口设计\">5.5 XXXXX接口设计</a></p>\n<p><a href=\"#xxxxx接口设计-1\">5.6 XXXXX接口设计</a></p>\n<p><a href=\"#_Toc57747501\">6 关键功能的设计原理</a></p>\n<p><a href=\"#xxxxx功能设计\">6.1 XXXXX功能设计</a></p>\n<p><a href=\"#xxxxx功能设计-1\">6.2 XXXXX功能设计</a></p>\n<p><a href=\"#_Toc57747504\">7 关键质量的设计原理</a></p>\n<p><a href=\"#_Toc57747505\">7.1 XXXX设计</a></p>\n<p><a href=\"#xxxx设计-1\">7.2 XXXX设计</a></p>\n<p><a href=\"#xxxx设计-2\">7.3 XXXX设计</a></p>\n<p><a href=\"#_Toc57747508\">8 对CBB管理的影响</a></p>\n<p><a href=\"#_Toc57747509\">8.1 本设计重用的CBB</a></p>\n<p><a href=\"#_Toc57747510\">8.2 本设计贡献的新CBB</a></p>\n<p><a href=\"#_Toc57747511\">8.3 本设计对现有CBB的升级需求</a></p>\n<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><h2 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h2><p><em>简要说明本文档的编写目的、用途和适用范围。</em></p>\n<p><em>【注意项】本节写“文档目的”，并非“项目目的”。</em></p>\n<p><em>【示例】</em></p>\n<p><em>本架构设计说明书编写的目的是……。本说明书的预期读者为系统设计人员、软件开发人员、软件测试人员和项目评审人员。</em></p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p><em>简要说明产业背景、企业立项本项目的背景。</em></p>\n<h2 id=\"项目概述\"><a href=\"#项目概述\" class=\"headerlink\" title=\"项目概述\"></a>项目概述</h2><p><em>简要说明项目内容、特点。</em></p>\n<p><em>【注意项】本节十分简洁，待到后续“2.1 目标产品/目标产品系列”适当展开。</em></p>\n<h2 id=\"术语与缩略语\"><a href=\"#术语与缩略语\" class=\"headerlink\" title=\"术语与缩略语\"></a>术语与缩略语</h2><p><em>本节集中说明和解释文档涉及的行业词汇、专业术语、首字母缩略语，提高文档可读性。</em></p>\n<p><em>【注意项】本节不可不写。</em></p>\n<table>\n<thead>\n<tr>\n<th><strong>词汇</strong></th>\n<th><strong>解释</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"引用文件\"><a href=\"#引用文件\" class=\"headerlink\" title=\"引用文件\"></a>引用文件</h2><p><em>应列出本文档引用的所有文档的编号、标题、修订版本和日期，方便读者查阅参考。</em></p>\n<p><em>【注意项】文档编号为□□公司为文档赋予的唯一正规编号。文档编号、文档版本号，均必写。</em></p>\n<table>\n<thead>\n<tr>\n<th><strong>文档编号</strong></th>\n<th><strong>文档名称</strong></th>\n<th><strong>版本号</strong></th>\n<th><strong>文档日期</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"架构目标与设计约束\"><a href=\"#架构目标与设计约束\" class=\"headerlink\" title=\"架构目标与设计约束\"></a>架构目标与设计约束</h1><p><em>对于XX厂商，影响嵌入式软件架构设计大方向的不仅有功能需求、更有接口需求、运行开销约束、配置形态需求等。</em></p>\n<p><em>此节对后续架构设计的具体展开，具有重大指导、和方向性影响。</em></p>\n<h2 id=\"目标产品-目标产品系列\"><a href=\"#目标产品-目标产品系列\" class=\"headerlink\" title=\"目标产品/目标产品系列\"></a>目标产品/目标产品系列</h2><p><em>设备软件的研发有何特点？</em></p>\n<p><em>架构设计期能不能更有作为？</em></p>\n<p><em>多个相似产品的架构设计能否重用？</em></p>\n<p><em>设备软件有明显的“产品系列”特点，企业更是希望提高软件通用性与设计复用性，从而降成本。因此，本节应明确认真地说明：</em></p>\n<p><em>A）本架构设计文档是针对具体的一个产品、还是由多个产品组成的产品系列。</em></p>\n<p><em>B）如果针对产品系列，应对比其中各产品的关键能力、关键指标的不同。使读者有大局观。</em></p>\n<p><em>【注意项】面向产品系列而设计的架构，文档后续注意通用性设计、适应性设计的描述。</em></p>\n<p><em>概述目标产品，可以表格方式说明</em></p>\n<table>\n<thead>\n<tr>\n<th><strong>架构设计针对的目标产品</strong></th>\n<th><strong>产品说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Xx产品</td>\n<td></td>\n</tr>\n<tr>\n<td>Yy产品</td>\n<td></td>\n</tr>\n<tr>\n<td>Zz产品</td>\n<td></td>\n</tr>\n</tbody></table>\n<p><em>对比产品不同，可以《产品系列对比表》形式说明</em></p>\n<p><em><img src=\"/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/e852708ffd1c78efd87949efa7b31592.png\" alt></em></p>\n<h2 id=\"功能需求\"><a href=\"#功能需求\" class=\"headerlink\" title=\"功能需求\"></a>功能需求</h2><h3 id=\"功能树-功能列表\"><a href=\"#功能树-功能列表\" class=\"headerlink\" title=\"功能树/功能列表\"></a>功能树/功能列表</h3><p><em>本节以功能树、功能表格等方式描述功能范围。</em></p>\n<p><em>注意1：无需展开描述。</em></p>\n<p><em>注意2：全面涵盖待研发的嵌入式设备软件的功能范围。</em></p>\n<p><em>【示例】功能树</em></p>\n<p><img src=\"/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/dc4e3ddfdab5a0456af40df7d0a9238b.png\" alt></p>\n<h3 id=\"产品系列功能对比表\"><a href=\"#产品系列功能对比表\" class=\"headerlink\" title=\"产品系列功能对比表\"></a>产品系列功能对比表</h3><p><em>针对 “目标产品系列”的架构文档，请提供产品系列功能对比表。</em></p>\n<p><em>【注意项】针对“单个目标产品”的文档，请写“本节无内容”。</em></p>\n<p><em>【示例】产品系列功能特性对比表</em></p>\n<p><em><img src=\"/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/2dd308b3411c41658cce041f8c230853.png\" alt></em></p>\n<h3 id=\"关键功能识别与问题单分析\"><a href=\"#关键功能识别与问题单分析\" class=\"headerlink\" title=\"* *关键功能识别与问题单分析\"></a>* *关键功能识别与问题单分析</h3><p><em>【背景1】关键需求决定架构。当设计需要权衡时，照顾的是关键需求。方法！</em></p>\n<p><em>【背景2】企业的问题单数据库，记录了同类系统暴露过的重大问题。风险！</em></p>\n<p><em>本节督促架构师去分析历史问题、提高设计针对性、避免问题重演：</em></p>\n<p><em>A）列出关键功能。文档后续的“6关键功能的设计原理”一节，应分别展开每个功能的设计。</em></p>\n<p><em>B）列出对问题单的单号、描述、风险点分析。设计时解决之。</em></p>\n<p><em>推荐描述形式</em></p>\n<table>\n<thead>\n<tr>\n<th><strong>关键功能</strong></th>\n<th><strong>问题单分析</strong></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td><strong>单号</strong></td>\n<td><strong>历史问题</strong></td>\n<td><strong>设计风险</strong></td>\n</tr>\n<tr>\n<td></td>\n<td>#n</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>#m</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>#n</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>#m</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>#n</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>#m</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>#n</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>#m</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"上下文图\"><a href=\"#上下文图\" class=\"headerlink\" title=\"上下文图\"></a>上下文图</h2><p><em>本节以顶层数据流图的形式，描述XX软件的上下文，即与外部哪些其他控制器、硬件单元、软件系统等有接口。</em></p>\n<p><em>【示例】</em></p>\n<h2 id=\"质量需求\"><a href=\"#质量需求\" class=\"headerlink\" title=\"质量需求\"></a>质量需求</h2><p><em>本节内容：</em></p>\n<ol>\n<li><em>TODO XX公司应制定《嵌入式软件质量属性标准》，本节包含哪些小节应当与之一一对应。类似XX公司的系统工程化设计要求的“五可”：可靠性、可测试性、可生产性、可安装性，可服务性。</em></li>\n<li><em>本节应覆盖来自高层需求文档的全部“质量指标”。</em></li>\n<li><em>本节求全，不求细。不写场景，不写因素分解。</em></li>\n</ol>\n<p><em>制定《嵌入式软件质量属性标准》的参考一：某质量分类标准</em></p>\n<table>\n<thead>\n<tr>\n<th><em>运行期质量属性</em></th>\n<th><em>开发期质量属性</em></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><em>性能（Performance）</em> <em>安全性（Security）</em> <em>易用性（Usability）</em> <em>持续可用性（Availability）</em> <em>可伸缩性（Scalability）</em> <em>互操作性（Interoperability）</em> <em>可靠性（Reliability）</em> <em>鲁棒性（Robustness）</em></td>\n<td><em>易理解性（Understandability）</em> <em>可扩展性（Extensibility）</em> <em>可重用性（Reusability）</em> <em>可测试性（Testability）</em> <em>可维护性（Maintainability）</em> <em>可移植性（Portability）</em></td>\n</tr>\n</tbody></table>\n<p><em>制定《嵌入式软件质量属性标准》的参考二：性能五项</em></p>\n<p><em><img src=\"/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/6aadad4da134377249d84bab5dbdfa8d.png\" alt></em></p>\n<h3 id=\"XXXX\"><a href=\"#XXXX\" class=\"headerlink\" title=\"XXXX\"></a>XXXX</h3><p><em>该项质量的文字简述。不展开。</em></p>\n<h3 id=\"XXXX-1\"><a href=\"#XXXX-1\" class=\"headerlink\" title=\"XXXX\"></a>XXXX</h3><p><em>该项质量的文字简述。不展开。</em></p>\n<h2 id=\"来自技术路线的约束：开发与运行环境限制\"><a href=\"#来自技术路线的约束：开发与运行环境限制\" class=\"headerlink\" title=\"来自技术路线的约束：开发与运行环境限制\"></a>来自技术路线的约束：开发与运行环境限制</h2><p><em>公司的技术路线与技术战略中，包含了软件研发类技术选型的考虑，具体产品的架构师往往没有权力任意改变技术选型。本节内容：</em></p>\n<ol>\n<li><em>简述技术选型约束</em></li>\n<li><em>分析技术选型对关键资源的开销</em></li>\n</ol>\n<h3 id=\"开发环境约定\"><a href=\"#开发环境约定\" class=\"headerlink\" title=\"开发环境约定\"></a>开发环境约定</h3><p><em>简单列举嵌入式软件研发的公司约定：开发语言、编译环境、本公司开发平台等。</em></p>\n<h3 id=\"运行环境约定\"><a href=\"#运行环境约定\" class=\"headerlink\" title=\"运行环境约定\"></a>运行环境约定</h3><p><em>简单列举嵌入式软件研发的公司约定：硬件要求、操作系统、关系数据、实时数据库等。</em></p>\n<h3 id=\"选型的资源开销分析：CPU资源\"><a href=\"#选型的资源开销分析：CPU资源\" class=\"headerlink\" title=\"选型的资源开销分析：CPU资源\"></a>选型的资源开销分析：CPU资源</h3><p><em>资源紧、效率关键是嵌入式开发的特点。本节分析上述技术选型带来的CPU资源开销：</em></p>\n<ul>\n<li><em>CPU占用率、</em></li>\n<li><em>最大最小值、</em></li>\n<li><em>可能的架构风险。</em></li>\n</ul>\n<h3 id=\"选型的资源开销分析：内存资源\"><a href=\"#选型的资源开销分析：内存资源\" class=\"headerlink\" title=\"选型的资源开销分析：内存资源\"></a>选型的资源开销分析：内存资源</h3><p><em>资源紧、效率关键是嵌入式开发的特点。本节分析上述技术选型带来的内存资源开销：</em></p>\n<ul>\n<li><em>内存占用率、</em></li>\n<li><em>最大最小值、</em></li>\n<li><em>可能的架构风险。</em></li>\n</ul>\n<h3 id=\"选型的资源开销分析：Flash资源\"><a href=\"#选型的资源开销分析：Flash资源\" class=\"headerlink\" title=\"选型的资源开销分析：Flash资源\"></a>选型的资源开销分析：Flash资源</h3><p><em>资源紧、效率关键是嵌入式开发的特点。本节分析上述技术选型带来的存储空间资源开销：</em></p>\n<ul>\n<li><em>存储空间占用率、</em></li>\n<li><em>最大最小值、</em></li>\n<li><em>可能的架构风险。</em></li>\n</ul>\n<p><em>【例如】例如Log组件高频度存储日志会消耗极多存储空间。架构师应尽早考虑如下影响：</em></p>\n<ul>\n<li><em>对于软件包大小的限制</em></li>\n<li><em>其他软件包大小的规划</em></li>\n<li><em>LOG存储策略、存储频度的考虑</em></li>\n</ul>\n<h2 id=\"来自硬件设计的约束：嵌入式硬件变化分析\"><a href=\"#来自硬件设计的约束：嵌入式硬件变化分析\" class=\"headerlink\" title=\"来自硬件设计的约束：嵌入式硬件变化分析\"></a>来自硬件设计的约束：嵌入式硬件变化分析</h2><p><em>本节通过多个硬件结构框图，列出所有（即穷举）可能的嵌入式硬件结构。这对后续架构的驱动层设计有直接影响。</em></p>\n<p><em>【FAQ】如果硬件设计还未完成，我要如何穷举所有可能的嵌入式硬件结构？</em></p>\n<p><em>【答】架构设计开始较早，这决定了架构师和程序员的一个极大不同，即软件架构师“时刻保持和硬件设计师的直接沟通”、“不应等待正式的《硬件设计文档》发布后才开始设计”。这一点，和程序员“在正式《需求规格》发布后才编程”有极大不同。</em></p>\n<p><em>【示例1】</em></p>\n<p><em><img src=\"/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/32643a6fbe010dcc95af301416619164.png\" alt></em></p>\n<h2 id=\"来自上游方案的约束：整机配置变化分析\"><a href=\"#来自上游方案的约束：整机配置变化分析\" class=\"headerlink\" title=\"来自上游方案的约束：整机配置变化分析\"></a>来自上游方案的约束：整机配置变化分析</h2><p><em>整机配置，指一台整机设备内如下不同：</em></p>\n<ul>\n<li><em>背板总线类型</em></li>\n<li><em>主控板类型</em></li>\n<li><em>主控板是否有主备、是否有群集</em></li>\n<li><em>非主控板的数量</em></li>\n<li><em>非主控板的种类</em></li>\n</ul>\n<p><em>本节通过多个图，列出所有（即穷举）可能的整机配置。</em></p>\n<p><em>【示例】</em></p>\n<p><em><img src=\"/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/22c7469876239933b38a12a32e9c6f16.png\" alt></em></p>\n<h1 id=\"架构思想\"><a href=\"#架构思想\" class=\"headerlink\" title=\"架构思想\"></a>架构思想</h1><p><em>作为架构师，你在本节，应当重点突出地说明有价值、有独特性的2~3条设计思想。</em></p>\n<ul>\n<li><em>例如，嵌入式软件可用的CPU、内存等资源有限，你的规划思想规划原则是什么</em></li>\n<li><em>例如，你如何运用状态机处理核心硬件的复杂状态组合</em></li>\n<li><em>……</em></li>\n</ul>\n<h2 id=\"思想一：避免瓶颈、提高性能-【强制，嵌入式软件必须】\"><a href=\"#思想一：避免瓶颈、提高性能-【强制，嵌入式软件必须】\" class=\"headerlink\" title=\"思想一：避免瓶颈、提高性能 【强制，嵌入式软件必须】\"></a>思想一：避免瓶颈、提高性能 【强制，嵌入式软件必须】</h2><p><em>分析关键资源约束，并在此给出相应的设计准则：</em></p>\n<ul>\n<li><em>例如，如果CPU是瓶颈，应约定“最大线程数限制”等设计原则并具体说明</em></li>\n<li><em>例如，如果内存是瓶颈，应约定“限制Cache滥用”等设计原则并具体说明</em></li>\n<li><em>例如，如果Flash紧缺，应约定“限制Log存储频率”等设计原则并具体说明</em></li>\n</ul>\n<h2 id=\"思想二：模块设计\"><a href=\"#思想二：模块设计\" class=\"headerlink\" title=\"思想二：模块设计\"></a>思想二：模块设计</h2><p><em>只需重点突出地说明有价值、有独特性的2~3条设计思想。</em></p>\n<h2 id=\"思想三：子系统设计\"><a href=\"#思想三：子系统设计\" class=\"headerlink\" title=\"思想三：子系统设计\"></a>思想三：子系统设计</h2><p><em>只需重点突出地说明有价值、有独特性的2~3条设计思想。</em></p>\n<h1 id=\"架构设计\"><a href=\"#架构设计\" class=\"headerlink\" title=\"架构设计\"></a>架构设计</h1><h2 id=\"逻辑视图\"><a href=\"#逻辑视图\" class=\"headerlink\" title=\"逻辑视图\"></a>逻辑视图</h2><h3 id=\"功能子系统划分\"><a href=\"#功能子系统划分\" class=\"headerlink\" title=\"功能子系统划分\"></a>功能子系统划分</h3><p><em>纵切：功能子系统</em></p>\n<p><em>列出或画出包含的功能子系统，并说明。</em></p>\n<h3 id=\"系统分层架构\"><a href=\"#系统分层架构\" class=\"headerlink\" title=\"系统分层架构\"></a>系统分层架构</h3><p><em>横切：逻辑层</em></p>\n<p><em>此处描述分层架构，有时采用“<em>系统分层架构*</em>+*<em>每层所用技术</em>”的形式将重要技术选型也描述进来。</em></p>\n<p><em>【示例】</em></p>\n<h2 id=\"产品-平台分工开发视图\"><a href=\"#产品-平台分工开发视图\" class=\"headerlink\" title=\"产品/平台分工开发视图\"></a>产品/平台分工开发视图</h2><p><strong>【开发视图 vs. 产品/平台分工开发视图】</strong></p>\n<p><em>开发视图，5视图之一，是单一视图——产品开发单元的切分，没有涉及平台扩充。</em></p>\n<p><em>产品/平台分工开发视图，是混合视图——产品要开发，同时平台要生长扩充。</em></p>\n<p><strong>【本节内容】</strong></p>\n<p><em>首先，要说清功能需求映射到产品组件、还是平台组件。</em></p>\n<p><em>其次，要说明平台总共要增加哪些组件、增强哪些组件。</em></p>\n<p><em>最后，才是详细说明产品组件有哪些、又分别对应哪些代码工程。</em></p>\n<h3 id=\"需求映射-与-产品-平台组件识别\"><a href=\"#需求映射-与-产品-平台组件识别\" class=\"headerlink\" title=\"需求映射 与 产品/平台组件识别\"></a>需求映射 与 产品/平台组件识别</h3><p><em>此前需求分析做过的工作，架构师不再重复。本节也不写。</em></p>\n<ol>\n<li><em>分析本嵌入式设备上实现的业务场景</em></li>\n<li><em>分解出多项功能需求</em></li>\n</ol>\n<p><em>本节，架构师需要做：</em></p>\n<ol>\n<li><em>将功能需求映射到对应的嵌入式软件的具体组件，并区分它是产品组件还是平台组件。以表格形式呈现。</em></li>\n</ol>\n<p><em>推荐形式：功能与参与功能实现的组件的映射矩阵</em></p>\n<p><em><img src=\"/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/780552b6b4ceacfe274a8c687b74a569.png\" alt></em></p>\n<h3 id=\"平台架构-与-新增-增强组件的位置-【平台侧】\"><a href=\"#平台架构-与-新增-增强组件的位置-【平台侧】\" class=\"headerlink\" title=\"平台架构 与 新增/增强组件的位置 【平台侧】\"></a>平台架构 与 新增/增强组件的位置 【平台侧】</h3><p><em>画出平台架构图，平台尽量黑盒化，不变的组件尽量少体现，重点体现平台侧还要加强的组件，特别标出新增/增强组件的位置。</em></p>\n<h3 id=\"产品组件-与-各组件说明-【产品侧】\"><a href=\"#产品组件-与-各组件说明-【产品侧】\" class=\"headerlink\" title=\"产品组件 与 各组件说明 【产品侧】\"></a>产品组件 与 各组件说明 【产品侧】</h3><p><em>可采用多种方式：列表格、画UML组件图并辅以文字说明。</em></p>\n<p><em>【示例】</em></p>\n<table>\n<thead>\n<tr>\n<th><em>序号</em></th>\n<th><em>模块名称</em></th>\n<th><em>子模块名称</em></th>\n<th><em>功能说明</em></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><em>1</em></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><em>2</em></td>\n<td><em>MCU机电模块</em></td>\n<td><em>机电通信模块</em></td>\n<td><em>实现NMU机电模块与K10主机的通信。</em></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><em>电子标签接口模块</em></td>\n<td><em>实现背板EEPROM的电子信息写入和读出。</em></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><em>风扇接口模块</em></td>\n<td><em>通过风扇控制寄存器的访问接口。</em></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><em>风扇控制模块</em></td>\n<td><em>提供对风扇单元转速的控制接口，风扇单元的工作状态和告警信息读取接口。</em></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><em>机电应用模块</em></td>\n<td><em>实现机电信息的收集处理和上报，接收、响应NMU指令。</em></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><em>机电软件下载模块</em></td>\n<td><em>建立与K10主机机电软件下载会话，实现机电软件模块切割分片传送。</em></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><em>3</em></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"产品组件对应的代码工程-与-开发技术-【产品侧】\"><a href=\"#产品组件对应的代码工程-与-开发技术-【产品侧】\" class=\"headerlink\" title=\"产品组件对应的代码工程 与 开发技术 【产品侧】\"></a>产品组件对应的代码工程 与 开发技术 【产品侧】</h3><p><em>说明嵌入式软件（产品侧）包含的多个开发工程（Project）或Makefile。</em></p>\n<p><em>细致地说明，每个组件开发所需的三方库、框架。</em></p>\n<p><em>【示例】</em></p>\n<h2 id=\"运行视图\"><a href=\"#运行视图\" class=\"headerlink\" title=\"运行视图\"></a>运行视图</h2><h3 id=\"嵌入式软件：运行架构总览\"><a href=\"#嵌入式软件：运行架构总览\" class=\"headerlink\" title=\"嵌入式软件：运行架构总览\"></a>嵌入式软件：运行架构总览</h3><p><em>说明嵌入式软件运行态下，有哪些进程、线程、以及对应组件的功能简述。</em></p>\n<p><em>【示例】</em></p>\n<table>\n<thead>\n<tr>\n<th><strong>进程</strong></th>\n<th><strong>线程</strong></th>\n<th><strong>组件</strong></th>\n<th><strong>组件功能</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"嵌入式软件中的组件：能否创建线程的准则\"><a href=\"#嵌入式软件中的组件：能否创建线程的准则\" class=\"headerlink\" title=\"嵌入式软件中的组件：能否创建线程的准则\"></a>嵌入式软件中的组件：能否创建线程的准则</h3><p><em>说明嵌入式软件产品侧线程创建的准则：</em></p>\n<ul>\n<li><em>哪些情况可以创建线程</em></li>\n<li><em>哪些情况杜绝滥启线程★★★</em></li>\n</ul>\n<p><em>后续组件详细设计师必须严格遵守，杜绝线程泛滥拉低性能和易理解性。</em></p>\n<h2 id=\"物理视图\"><a href=\"#物理视图\" class=\"headerlink\" title=\"物理视图\"></a>物理视图</h2><h3 id=\"运行环境\"><a href=\"#运行环境\" class=\"headerlink\" title=\"运行环境\"></a>运行环境</h3><p><em>细致地说明，嵌入式的硬件配置。</em></p>\n<p><em>细致地说明操作系统、各种系统软件、中间件的种类和版本。</em></p>\n<p><em>【示例】</em></p>\n<table>\n<thead>\n<tr>\n<th><em>硬件环境</em> <em>主CPU扣板为P2041，底板核心交换芯片为Qumran的硬件板卡。</em> <em>硬件配置</em> <em>CPU型号: p2041</em> <em>CPU主频：1.5GHz</em> <em>CPU核数：4*e500mc核</em> <em>CPU位宽：32位</em> <em>内存：4096 MB</em> <em>操作系统</em> <em>Linux localhost 2.6.34.15-grsec-WR4.3.0.0_cgl #1 SMP PREEMPT Fri Nov 4 16:51:14 CST 2016 ppc ppc ppc GNU/Linux</em></th>\n</tr>\n</thead>\n</table>\n<h3 id=\"发布包目录结构及目标路径定义\"><a href=\"#发布包目录结构及目标路径定义\" class=\"headerlink\" title=\"发布包目录结构及目标路径定义\"></a>发布包目录结构及目标路径定义</h3><p><em>本节应描述：</em></p>\n<p><em>A）发布包的详细目录结构约定。</em></p>\n<p><em>B）发布包应该mount到的目标路径</em></p>\n<p><em>【示例】</em></p>\n<p><em>。。。。。。</em></p>\n<h3 id=\"组件部署结构\"><a href=\"#组件部署结构\" class=\"headerlink\" title=\"* *组件部署结构\"></a>* *组件部署结构</h3><p><em>嵌入式软件往往由许多组件组成，本节重点说明组件之间的上下游关系。</em></p>\n<p><em>【示例】</em></p>\n<h1 id=\"接口设计\"><a href=\"#接口设计\" class=\"headerlink\" title=\"接口设计\"></a>接口设计</h1><h2 id=\"对外接口总览\"><a href=\"#对外接口总览\" class=\"headerlink\" title=\"对外接口总览\"></a>对外接口总览</h2><p>画图，概览本嵌入式软件的对外接口的位置。</p>\n<h2 id=\"各模块间接口总览\"><a href=\"#各模块间接口总览\" class=\"headerlink\" title=\"各模块间接口总览\"></a>各模块间接口总览</h2><p>画图，概览嵌入式软件内部的做个组件之间接口的位置。</p>\n<h2 id=\"平台和设备间接口总览\"><a href=\"#平台和设备间接口总览\" class=\"headerlink\" title=\"平台和设备间接口总览\"></a>平台和设备间接口总览</h2><p>画图，概览平台与设备间接口的位置。</p>\n<h2 id=\"接口列表\"><a href=\"#接口列表\" class=\"headerlink\" title=\"接口列表\"></a>接口列表</h2><p>列出接口名称和功能，对外和内部分别罗列。</p>\n<h2 id=\"XXXXX接口设计\"><a href=\"#XXXXX接口设计\" class=\"headerlink\" title=\"XXXXX接口设计\"></a>XXXXX接口设计</h2><p>接口=交互过程+技术选择+格式定义。交互过程用序列图刻画</p>\n<p><em>【示例1】函数接口的格式定义</em></p>\n<table>\n<thead>\n<tr>\n<th><strong>名称</strong></th>\n<th>dhcm回调函数</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>用途</strong></td>\n<td><strong>DHCM组件提供给DDA的回调接口</strong></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>声明</strong></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>typedef struct tag_dhcm_callback {  INT32 (*dcoi_board_init)(DCOI_BOARD_INIT_INFO *init_info);  UINT32 (*dcoi_get_support_card_flag)();  UINT32 (*dcoi_cmi_ready_cb)();  VOID (*dcoi_dhcs_ready)(DHCS_CARD_COMP_INFO_MSG_EN *card_comp_info);  }DHCM_CALLBACK;</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>字段</strong></td>\n<td><strong>含义</strong></td>\n<td><strong>说明</strong></td>\n</tr>\n<tr>\n<td>dcoi_board_init</td>\n<td>嵌入式初始化的调用，包含硬件初始化和软件初始化。</td>\n<td></td>\n</tr>\n<tr>\n<td>dcoi_get_support_card_flag</td>\n<td>返回嵌入式是否支持子卡的信息</td>\n<td></td>\n</tr>\n<tr>\n<td>dcoi_cmi_ready_cb</td>\n<td>判断组件cmi是否有值</td>\n<td></td>\n</tr>\n<tr>\n<td>dcoi_dhcs_ready</td>\n<td>获取嵌入式建模信息，包含框/槽/子卡/板类型等信息。</td>\n<td></td>\n</tr>\n</tbody></table>\n<p><em>【示例2】协议接口的格式定义</em></p>\n<p><img src=\"/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/60a0b6815e87242adbc049d64b96e01b.png\" alt></p>\n<h2 id=\"XXXXX接口设计-1\"><a href=\"#XXXXX接口设计-1\" class=\"headerlink\" title=\"XXXXX接口设计\"></a>XXXXX接口设计</h2><p>接口=交互过程+技术选择+格式定义。交互过程用序列图刻画</p>\n<h1 id=\"关键功能的设计原理\"><a href=\"#关键功能的设计原理\" class=\"headerlink\" title=\"关键功能的设计原理\"></a>关键功能的设计原理</h1><p><em>本节内容：</em></p>\n<ul>\n<li><em>典型功能的设计</em></li>\n<li><em>“2.2.3关键功能识别与问题单分析”节中每个关键功能的设计</em></li>\n</ul>\n<h2 id=\"XXXXX功能设计\"><a href=\"#XXXXX功能设计\" class=\"headerlink\" title=\"XXXXX功能设计\"></a>XXXXX功能设计</h2><p><em>用“<em>协作图+文字说明</em>”的方式说明每个关键功能的设计原理。图可以是下列方式之一：</em></p>\n<ul>\n<li><em>序列图</em></li>\n<li><em>协作图</em></li>\n<li><em>涉及多进程多线程的，图中应刻画出“进程/线程”</em></li>\n<li><em>设计跨机器分布式的，图中应刻画出“机器/控制板”</em></li>\n<li><em>协作逻辑复杂的，图中标号，再针对每个标号进行文字说明</em></li>\n</ul>\n<h2 id=\"XXXXX功能设计-1\"><a href=\"#XXXXX功能设计-1\" class=\"headerlink\" title=\"XXXXX功能设计\"></a>XXXXX功能设计</h2><h1 id=\"关键质量的设计原理\"><a href=\"#关键质量的设计原理\" class=\"headerlink\" title=\"关键质量的设计原理\"></a>关键质量的设计原理</h1><h2 id=\"XXXX设计\"><a href=\"#XXXX设计\" class=\"headerlink\" title=\"XXXX设计\"></a>XXXX设计</h2><h3 id=\"影响质量的因素分解表-质量因素树\"><a href=\"#影响质量的因素分解表-质量因素树\" class=\"headerlink\" title=\"影响质量的因素分解表/质量因素树\"></a>影响质量的因素分解表/质量因素树</h3><p><em>本节的核心是运用分解思维、系统化思维，梳理影响质量的因素。可采用表格、树等形式。</em></p>\n<h3 id=\"目标-场景-决策表\"><a href=\"#目标-场景-决策表\" class=\"headerlink\" title=\"目标-场景-决策表\"></a>目标-场景-决策表</h3><p><em>本节的核心是运用场景思维、具体化思维，分析质量因素对系统的具体影响，并给出设计对策。</em></p>\n<p><em>【注意项】推荐使用目标-场景-决策表，表中场景按“质量场景规约”格式编写</em></p>\n<p><em><img src=\"/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/c7546c50623e8a8aa6ab33ead8fac6cb.png\" alt></em></p>\n<h3 id=\"设计原理图\"><a href=\"#设计原理图\" class=\"headerlink\" title=\"设计原理图\"></a>设计原理图</h3><p>【示例】<img src=\"/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/e7176066eab77c0cf6e147aed0046ea7.png\" alt></p>\n<h2 id=\"XXXX设计-1\"><a href=\"#XXXX设计-1\" class=\"headerlink\" title=\"XXXX设计\"></a>XXXX设计</h2><h3 id=\"影响质量的因素分解表-质量因素树-1\"><a href=\"#影响质量的因素分解表-质量因素树-1\" class=\"headerlink\" title=\"影响质量的因素分解表/质量因素树\"></a>影响质量的因素分解表/质量因素树</h3><h3 id=\"目标-场景-决策表-1\"><a href=\"#目标-场景-决策表-1\" class=\"headerlink\" title=\"目标-场景-决策表\"></a>目标-场景-决策表</h3><h3 id=\"设计原理图-1\"><a href=\"#设计原理图-1\" class=\"headerlink\" title=\"设计原理图\"></a>设计原理图</h3><h2 id=\"XXXX设计-2\"><a href=\"#XXXX设计-2\" class=\"headerlink\" title=\"XXXX设计\"></a>XXXX设计</h2><h3 id=\"影响质量的因素分解表-质量因素树-2\"><a href=\"#影响质量的因素分解表-质量因素树-2\" class=\"headerlink\" title=\"影响质量的因素分解表/质量因素树\"></a>影响质量的因素分解表/质量因素树</h3><h3 id=\"目标-场景-决策表-2\"><a href=\"#目标-场景-决策表-2\" class=\"headerlink\" title=\"目标-场景-决策表\"></a>目标-场景-决策表</h3><h3 id=\"设计原理图-2\"><a href=\"#设计原理图-2\" class=\"headerlink\" title=\"设计原理图\"></a>设计原理图</h3><p># </p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<table>\n<thead>\n<tr>\n<th>文件类型</th>\n<th>研发过程文档</th>\n<th>机密等级</th>\n<th>机密</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>文件编号</td>\n<td></td>\n<td>版本</td>\n<td>V1.0</td>\n</tr>\n<tr>\n<td>撰 写 人</td>\n<td></td>\n<td>日期</td>\n<td></td>\n</tr>\n<tr>\n<td>审 核 人</td>\n<td></td>\n<td>日期</td>\n<td></td>\n</tr>\n<tr>\n<td>批 准 人</td>\n<td></td>\n<td>日期</td>\n<td></td>\n</tr>\n<tr>\n<td>项目名称</td>\n<td>XXX开发</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>嵌入式软件框架设计</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>相 关 文 档</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>文件编号</td>\n<td>文件名称</td>\n<td>版本</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>产品需求</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>用户需求</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>嵌入式软件需求</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>修 订 记 录</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>版本</td>\n<td>修订内容</td>\n<td>修订人</td>\n<td>修订日期</td>\n</tr>\n<tr>\n<td>V1.0</td>\n<td>创建</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p><strong>目 录</strong></p>\n<p><a href=\"#_Toc57747469\">0 版本记录</a></p>\n<p><a href=\"#引言\">1 引言</a></p>\n<p><a href=\"#_Toc57747471\">1.1 目的</a></p>\n<p><a href=\"#_Toc57747472\">1.2 背景</a></p>\n<p><a href=\"#_Toc57747473\">1.3 项目概述</a></p>\n<p><a href=\"#_Toc57747474\">1.4 术语与缩略语</a></p>\n<p><a href=\"#_Toc57747475\">1.5 引用文件</a></p>\n<p><a href=\"#_Toc57747476\">2 架构目标与设计约束</a></p>\n<p><a href=\"#_Toc57747477\">2.1 目标产品/目标产品系列</a></p>\n<p><a href=\"#_Toc57747478\">2.2 功能需求</a></p>\n<p><a href=\"#上下文图\">2.3 上下文图</a></p>\n<p><a href=\"#_Toc57747480\">2.4 质量需求</a></p>\n<p><a href=\"#来自技术路线的约束开发与运行环境限制\">2.5 来自技术路线的约束：开发与运行环境限制</a></p>\n<p><a href=\"#_Toc57747482\">2.6 来自硬件设计的约束：嵌入式硬件变化分析</a></p>\n<p><a href=\"#来自上游方案的约束整机配置变化分析\">2.7 来自上游方案的约束：整机配置变化分析</a></p>\n<p><a href=\"#_Toc57747484\">2.8 来自上游方案的约束：方案部署变化分析</a></p>\n<p><a href=\"#_Toc57747485\">3 架构思想</a></p>\n<p><a href=\"#_Toc57747486\">3.1 思想一：避免瓶颈、提高性能 【强制，嵌入式软件必须】</a></p>\n<p><a href=\"#思想二模块设计\">3.2 思想二：XXXXX</a></p>\n<p><a href=\"#思想三子系统设计\">3.3 思想三：XXXXX</a></p>\n<p><a href=\"#_Toc57747489\">4 架构设计</a></p>\n<p><a href=\"#_Toc57747490\">4.1 逻辑视图</a></p>\n<p><a href=\"#产品平台分工开发视图\">4.2 产品/平台分工开发视图</a></p>\n<p><a href=\"#运行视图\">4.3 运行视图</a></p>\n<p><a href=\"#物理视图\">4.4 物理视图</a></p>\n<p><a href=\"#接口设计\">5 接口设计</a></p>\n<p><a href=\"#_Toc57747495\">5.1 对外接口总览</a></p>\n<p><a href=\"#各模块间接口总览\">5.2 各模块间接口总览</a></p>\n<p><a href=\"#_Toc57747497\">5.3 平台和设备间接口总览</a></p>\n<p><a href=\"#接口列表\">5.4 接口列表</a></p>\n<p><a href=\"#xxxxx接口设计\">5.5 XXXXX接口设计</a></p>\n<p><a href=\"#xxxxx接口设计-1\">5.6 XXXXX接口设计</a></p>\n<p><a href=\"#_Toc57747501\">6 关键功能的设计原理</a></p>\n<p><a href=\"#xxxxx功能设计\">6.1 XXXXX功能设计</a></p>\n<p><a href=\"#xxxxx功能设计-1\">6.2 XXXXX功能设计</a></p>\n<p><a href=\"#_Toc57747504\">7 关键质量的设计原理</a></p>\n<p><a href=\"#_Toc57747505\">7.1 XXXX设计</a></p>\n<p><a href=\"#xxxx设计-1\">7.2 XXXX设计</a></p>\n<p><a href=\"#xxxx设计-2\">7.3 XXXX设计</a></p>\n<p><a href=\"#_Toc57747508\">8 对CBB管理的影响</a></p>\n<p><a href=\"#_Toc57747509\">8.1 本设计重用的CBB</a></p>\n<p><a href=\"#_Toc57747510\">8.2 本设计贡献的新CBB</a></p>\n<p><a href=\"#_Toc57747511\">8.3 本设计对现有CBB的升级需求</a></p>\n<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><h2 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h2><p><em>简要说明本文档的编写目的、用途和适用范围。</em></p>\n<p><em>【注意项】本节写“文档目的”，并非“项目目的”。</em></p>\n<p><em>【示例】</em></p>\n<p><em>本架构设计说明书编写的目的是……。本说明书的预期读者为系统设计人员、软件开发人员、软件测试人员和项目评审人员。</em></p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p><em>简要说明产业背景、企业立项本项目的背景。</em></p>\n<h2 id=\"项目概述\"><a href=\"#项目概述\" class=\"headerlink\" title=\"项目概述\"></a>项目概述</h2><p><em>简要说明项目内容、特点。</em></p>\n<p><em>【注意项】本节十分简洁，待到后续“2.1 目标产品/目标产品系列”适当展开。</em></p>\n<h2 id=\"术语与缩略语\"><a href=\"#术语与缩略语\" class=\"headerlink\" title=\"术语与缩略语\"></a>术语与缩略语</h2><p><em>本节集中说明和解释文档涉及的行业词汇、专业术语、首字母缩略语，提高文档可读性。</em></p>\n<p><em>【注意项】本节不可不写。</em></p>\n<table>\n<thead>\n<tr>\n<th><strong>词汇</strong></th>\n<th><strong>解释</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"引用文件\"><a href=\"#引用文件\" class=\"headerlink\" title=\"引用文件\"></a>引用文件</h2><p><em>应列出本文档引用的所有文档的编号、标题、修订版本和日期，方便读者查阅参考。</em></p>\n<p><em>【注意项】文档编号为□□公司为文档赋予的唯一正规编号。文档编号、文档版本号，均必写。</em></p>\n<table>\n<thead>\n<tr>\n<th><strong>文档编号</strong></th>\n<th><strong>文档名称</strong></th>\n<th><strong>版本号</strong></th>\n<th><strong>文档日期</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"架构目标与设计约束\"><a href=\"#架构目标与设计约束\" class=\"headerlink\" title=\"架构目标与设计约束\"></a>架构目标与设计约束</h1><p><em>对于XX厂商，影响嵌入式软件架构设计大方向的不仅有功能需求、更有接口需求、运行开销约束、配置形态需求等。</em></p>\n<p><em>此节对后续架构设计的具体展开，具有重大指导、和方向性影响。</em></p>\n<h2 id=\"目标产品-目标产品系列\"><a href=\"#目标产品-目标产品系列\" class=\"headerlink\" title=\"目标产品/目标产品系列\"></a>目标产品/目标产品系列</h2><p><em>设备软件的研发有何特点？</em></p>\n<p><em>架构设计期能不能更有作为？</em></p>\n<p><em>多个相似产品的架构设计能否重用？</em></p>\n<p><em>设备软件有明显的“产品系列”特点，企业更是希望提高软件通用性与设计复用性，从而降成本。因此，本节应明确认真地说明：</em></p>\n<p><em>A）本架构设计文档是针对具体的一个产品、还是由多个产品组成的产品系列。</em></p>\n<p><em>B）如果针对产品系列，应对比其中各产品的关键能力、关键指标的不同。使读者有大局观。</em></p>\n<p><em>【注意项】面向产品系列而设计的架构，文档后续注意通用性设计、适应性设计的描述。</em></p>\n<p><em>概述目标产品，可以表格方式说明</em></p>\n<table>\n<thead>\n<tr>\n<th><strong>架构设计针对的目标产品</strong></th>\n<th><strong>产品说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Xx产品</td>\n<td></td>\n</tr>\n<tr>\n<td>Yy产品</td>\n<td></td>\n</tr>\n<tr>\n<td>Zz产品</td>\n<td></td>\n</tr>\n</tbody></table>\n<p><em>对比产品不同，可以《产品系列对比表》形式说明</em></p>\n<p><em><img src=\"/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/e852708ffd1c78efd87949efa7b31592.png\" alt></em></p>\n<h2 id=\"功能需求\"><a href=\"#功能需求\" class=\"headerlink\" title=\"功能需求\"></a>功能需求</h2><h3 id=\"功能树-功能列表\"><a href=\"#功能树-功能列表\" class=\"headerlink\" title=\"功能树/功能列表\"></a>功能树/功能列表</h3><p><em>本节以功能树、功能表格等方式描述功能范围。</em></p>\n<p><em>注意1：无需展开描述。</em></p>\n<p><em>注意2：全面涵盖待研发的嵌入式设备软件的功能范围。</em></p>\n<p><em>【示例】功能树</em></p>\n<p><img src=\"/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/dc4e3ddfdab5a0456af40df7d0a9238b.png\" alt></p>\n<h3 id=\"产品系列功能对比表\"><a href=\"#产品系列功能对比表\" class=\"headerlink\" title=\"产品系列功能对比表\"></a>产品系列功能对比表</h3><p><em>针对 “目标产品系列”的架构文档，请提供产品系列功能对比表。</em></p>\n<p><em>【注意项】针对“单个目标产品”的文档，请写“本节无内容”。</em></p>\n<p><em>【示例】产品系列功能特性对比表</em></p>\n<p><em><img src=\"/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/2dd308b3411c41658cce041f8c230853.png\" alt></em></p>\n<h3 id=\"关键功能识别与问题单分析\"><a href=\"#关键功能识别与问题单分析\" class=\"headerlink\" title=\"* *关键功能识别与问题单分析\"></a>* *关键功能识别与问题单分析</h3><p><em>【背景1】关键需求决定架构。当设计需要权衡时，照顾的是关键需求。方法！</em></p>\n<p><em>【背景2】企业的问题单数据库，记录了同类系统暴露过的重大问题。风险！</em></p>\n<p><em>本节督促架构师去分析历史问题、提高设计针对性、避免问题重演：</em></p>\n<p><em>A）列出关键功能。文档后续的“6关键功能的设计原理”一节，应分别展开每个功能的设计。</em></p>\n<p><em>B）列出对问题单的单号、描述、风险点分析。设计时解决之。</em></p>\n<p><em>推荐描述形式</em></p>\n<table>\n<thead>\n<tr>\n<th><strong>关键功能</strong></th>\n<th><strong>问题单分析</strong></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td><strong>单号</strong></td>\n<td><strong>历史问题</strong></td>\n<td><strong>设计风险</strong></td>\n</tr>\n<tr>\n<td></td>\n<td>#n</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>#m</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>#n</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>#m</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>#n</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>#m</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>#n</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>#m</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"上下文图\"><a href=\"#上下文图\" class=\"headerlink\" title=\"上下文图\"></a>上下文图</h2><p><em>本节以顶层数据流图的形式，描述XX软件的上下文，即与外部哪些其他控制器、硬件单元、软件系统等有接口。</em></p>\n<p><em>【示例】</em></p>\n<h2 id=\"质量需求\"><a href=\"#质量需求\" class=\"headerlink\" title=\"质量需求\"></a>质量需求</h2><p><em>本节内容：</em></p>\n<ol>\n<li><em>TODO XX公司应制定《嵌入式软件质量属性标准》，本节包含哪些小节应当与之一一对应。类似XX公司的系统工程化设计要求的“五可”：可靠性、可测试性、可生产性、可安装性，可服务性。</em></li>\n<li><em>本节应覆盖来自高层需求文档的全部“质量指标”。</em></li>\n<li><em>本节求全，不求细。不写场景，不写因素分解。</em></li>\n</ol>\n<p><em>制定《嵌入式软件质量属性标准》的参考一：某质量分类标准</em></p>\n<table>\n<thead>\n<tr>\n<th><em>运行期质量属性</em></th>\n<th><em>开发期质量属性</em></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><em>性能（Performance）</em> <em>安全性（Security）</em> <em>易用性（Usability）</em> <em>持续可用性（Availability）</em> <em>可伸缩性（Scalability）</em> <em>互操作性（Interoperability）</em> <em>可靠性（Reliability）</em> <em>鲁棒性（Robustness）</em></td>\n<td><em>易理解性（Understandability）</em> <em>可扩展性（Extensibility）</em> <em>可重用性（Reusability）</em> <em>可测试性（Testability）</em> <em>可维护性（Maintainability）</em> <em>可移植性（Portability）</em></td>\n</tr>\n</tbody></table>\n<p><em>制定《嵌入式软件质量属性标准》的参考二：性能五项</em></p>\n<p><em><img src=\"/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/6aadad4da134377249d84bab5dbdfa8d.png\" alt></em></p>\n<h3 id=\"XXXX\"><a href=\"#XXXX\" class=\"headerlink\" title=\"XXXX\"></a>XXXX</h3><p><em>该项质量的文字简述。不展开。</em></p>\n<h3 id=\"XXXX-1\"><a href=\"#XXXX-1\" class=\"headerlink\" title=\"XXXX\"></a>XXXX</h3><p><em>该项质量的文字简述。不展开。</em></p>\n<h2 id=\"来自技术路线的约束：开发与运行环境限制\"><a href=\"#来自技术路线的约束：开发与运行环境限制\" class=\"headerlink\" title=\"来自技术路线的约束：开发与运行环境限制\"></a>来自技术路线的约束：开发与运行环境限制</h2><p><em>公司的技术路线与技术战略中，包含了软件研发类技术选型的考虑，具体产品的架构师往往没有权力任意改变技术选型。本节内容：</em></p>\n<ol>\n<li><em>简述技术选型约束</em></li>\n<li><em>分析技术选型对关键资源的开销</em></li>\n</ol>\n<h3 id=\"开发环境约定\"><a href=\"#开发环境约定\" class=\"headerlink\" title=\"开发环境约定\"></a>开发环境约定</h3><p><em>简单列举嵌入式软件研发的公司约定：开发语言、编译环境、本公司开发平台等。</em></p>\n<h3 id=\"运行环境约定\"><a href=\"#运行环境约定\" class=\"headerlink\" title=\"运行环境约定\"></a>运行环境约定</h3><p><em>简单列举嵌入式软件研发的公司约定：硬件要求、操作系统、关系数据、实时数据库等。</em></p>\n<h3 id=\"选型的资源开销分析：CPU资源\"><a href=\"#选型的资源开销分析：CPU资源\" class=\"headerlink\" title=\"选型的资源开销分析：CPU资源\"></a>选型的资源开销分析：CPU资源</h3><p><em>资源紧、效率关键是嵌入式开发的特点。本节分析上述技术选型带来的CPU资源开销：</em></p>\n<ul>\n<li><em>CPU占用率、</em></li>\n<li><em>最大最小值、</em></li>\n<li><em>可能的架构风险。</em></li>\n</ul>\n<h3 id=\"选型的资源开销分析：内存资源\"><a href=\"#选型的资源开销分析：内存资源\" class=\"headerlink\" title=\"选型的资源开销分析：内存资源\"></a>选型的资源开销分析：内存资源</h3><p><em>资源紧、效率关键是嵌入式开发的特点。本节分析上述技术选型带来的内存资源开销：</em></p>\n<ul>\n<li><em>内存占用率、</em></li>\n<li><em>最大最小值、</em></li>\n<li><em>可能的架构风险。</em></li>\n</ul>\n<h3 id=\"选型的资源开销分析：Flash资源\"><a href=\"#选型的资源开销分析：Flash资源\" class=\"headerlink\" title=\"选型的资源开销分析：Flash资源\"></a>选型的资源开销分析：Flash资源</h3><p><em>资源紧、效率关键是嵌入式开发的特点。本节分析上述技术选型带来的存储空间资源开销：</em></p>\n<ul>\n<li><em>存储空间占用率、</em></li>\n<li><em>最大最小值、</em></li>\n<li><em>可能的架构风险。</em></li>\n</ul>\n<p><em>【例如】例如Log组件高频度存储日志会消耗极多存储空间。架构师应尽早考虑如下影响：</em></p>\n<ul>\n<li><em>对于软件包大小的限制</em></li>\n<li><em>其他软件包大小的规划</em></li>\n<li><em>LOG存储策略、存储频度的考虑</em></li>\n</ul>\n<h2 id=\"来自硬件设计的约束：嵌入式硬件变化分析\"><a href=\"#来自硬件设计的约束：嵌入式硬件变化分析\" class=\"headerlink\" title=\"来自硬件设计的约束：嵌入式硬件变化分析\"></a>来自硬件设计的约束：嵌入式硬件变化分析</h2><p><em>本节通过多个硬件结构框图，列出所有（即穷举）可能的嵌入式硬件结构。这对后续架构的驱动层设计有直接影响。</em></p>\n<p><em>【FAQ】如果硬件设计还未完成，我要如何穷举所有可能的嵌入式硬件结构？</em></p>\n<p><em>【答】架构设计开始较早，这决定了架构师和程序员的一个极大不同，即软件架构师“时刻保持和硬件设计师的直接沟通”、“不应等待正式的《硬件设计文档》发布后才开始设计”。这一点，和程序员“在正式《需求规格》发布后才编程”有极大不同。</em></p>\n<p><em>【示例1】</em></p>\n<p><em><img src=\"/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/32643a6fbe010dcc95af301416619164.png\" alt></em></p>\n<h2 id=\"来自上游方案的约束：整机配置变化分析\"><a href=\"#来自上游方案的约束：整机配置变化分析\" class=\"headerlink\" title=\"来自上游方案的约束：整机配置变化分析\"></a>来自上游方案的约束：整机配置变化分析</h2><p><em>整机配置，指一台整机设备内如下不同：</em></p>\n<ul>\n<li><em>背板总线类型</em></li>\n<li><em>主控板类型</em></li>\n<li><em>主控板是否有主备、是否有群集</em></li>\n<li><em>非主控板的数量</em></li>\n<li><em>非主控板的种类</em></li>\n</ul>\n<p><em>本节通过多个图，列出所有（即穷举）可能的整机配置。</em></p>\n<p><em>【示例】</em></p>\n<p><em><img src=\"/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/22c7469876239933b38a12a32e9c6f16.png\" alt></em></p>\n<h1 id=\"架构思想\"><a href=\"#架构思想\" class=\"headerlink\" title=\"架构思想\"></a>架构思想</h1><p><em>作为架构师，你在本节，应当重点突出地说明有价值、有独特性的2~3条设计思想。</em></p>\n<ul>\n<li><em>例如，嵌入式软件可用的CPU、内存等资源有限，你的规划思想规划原则是什么</em></li>\n<li><em>例如，你如何运用状态机处理核心硬件的复杂状态组合</em></li>\n<li><em>……</em></li>\n</ul>\n<h2 id=\"思想一：避免瓶颈、提高性能-【强制，嵌入式软件必须】\"><a href=\"#思想一：避免瓶颈、提高性能-【强制，嵌入式软件必须】\" class=\"headerlink\" title=\"思想一：避免瓶颈、提高性能 【强制，嵌入式软件必须】\"></a>思想一：避免瓶颈、提高性能 【强制，嵌入式软件必须】</h2><p><em>分析关键资源约束，并在此给出相应的设计准则：</em></p>\n<ul>\n<li><em>例如，如果CPU是瓶颈，应约定“最大线程数限制”等设计原则并具体说明</em></li>\n<li><em>例如，如果内存是瓶颈，应约定“限制Cache滥用”等设计原则并具体说明</em></li>\n<li><em>例如，如果Flash紧缺，应约定“限制Log存储频率”等设计原则并具体说明</em></li>\n</ul>\n<h2 id=\"思想二：模块设计\"><a href=\"#思想二：模块设计\" class=\"headerlink\" title=\"思想二：模块设计\"></a>思想二：模块设计</h2><p><em>只需重点突出地说明有价值、有独特性的2~3条设计思想。</em></p>\n<h2 id=\"思想三：子系统设计\"><a href=\"#思想三：子系统设计\" class=\"headerlink\" title=\"思想三：子系统设计\"></a>思想三：子系统设计</h2><p><em>只需重点突出地说明有价值、有独特性的2~3条设计思想。</em></p>\n<h1 id=\"架构设计\"><a href=\"#架构设计\" class=\"headerlink\" title=\"架构设计\"></a>架构设计</h1><h2 id=\"逻辑视图\"><a href=\"#逻辑视图\" class=\"headerlink\" title=\"逻辑视图\"></a>逻辑视图</h2><h3 id=\"功能子系统划分\"><a href=\"#功能子系统划分\" class=\"headerlink\" title=\"功能子系统划分\"></a>功能子系统划分</h3><p><em>纵切：功能子系统</em></p>\n<p><em>列出或画出包含的功能子系统，并说明。</em></p>\n<h3 id=\"系统分层架构\"><a href=\"#系统分层架构\" class=\"headerlink\" title=\"系统分层架构\"></a>系统分层架构</h3><p><em>横切：逻辑层</em></p>\n<p><em>此处描述分层架构，有时采用“<em>系统分层架构*</em>+*<em>每层所用技术</em>”的形式将重要技术选型也描述进来。</em></p>\n<p><em>【示例】</em></p>\n<h2 id=\"产品-平台分工开发视图\"><a href=\"#产品-平台分工开发视图\" class=\"headerlink\" title=\"产品/平台分工开发视图\"></a>产品/平台分工开发视图</h2><p><strong>【开发视图 vs. 产品/平台分工开发视图】</strong></p>\n<p><em>开发视图，5视图之一，是单一视图——产品开发单元的切分，没有涉及平台扩充。</em></p>\n<p><em>产品/平台分工开发视图，是混合视图——产品要开发，同时平台要生长扩充。</em></p>\n<p><strong>【本节内容】</strong></p>\n<p><em>首先，要说清功能需求映射到产品组件、还是平台组件。</em></p>\n<p><em>其次，要说明平台总共要增加哪些组件、增强哪些组件。</em></p>\n<p><em>最后，才是详细说明产品组件有哪些、又分别对应哪些代码工程。</em></p>\n<h3 id=\"需求映射-与-产品-平台组件识别\"><a href=\"#需求映射-与-产品-平台组件识别\" class=\"headerlink\" title=\"需求映射 与 产品/平台组件识别\"></a>需求映射 与 产品/平台组件识别</h3><p><em>此前需求分析做过的工作，架构师不再重复。本节也不写。</em></p>\n<ol>\n<li><em>分析本嵌入式设备上实现的业务场景</em></li>\n<li><em>分解出多项功能需求</em></li>\n</ol>\n<p><em>本节，架构师需要做：</em></p>\n<ol>\n<li><em>将功能需求映射到对应的嵌入式软件的具体组件，并区分它是产品组件还是平台组件。以表格形式呈现。</em></li>\n</ol>\n<p><em>推荐形式：功能与参与功能实现的组件的映射矩阵</em></p>\n<p><em><img src=\"/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/780552b6b4ceacfe274a8c687b74a569.png\" alt></em></p>\n<h3 id=\"平台架构-与-新增-增强组件的位置-【平台侧】\"><a href=\"#平台架构-与-新增-增强组件的位置-【平台侧】\" class=\"headerlink\" title=\"平台架构 与 新增/增强组件的位置 【平台侧】\"></a>平台架构 与 新增/增强组件的位置 【平台侧】</h3><p><em>画出平台架构图，平台尽量黑盒化，不变的组件尽量少体现，重点体现平台侧还要加强的组件，特别标出新增/增强组件的位置。</em></p>\n<h3 id=\"产品组件-与-各组件说明-【产品侧】\"><a href=\"#产品组件-与-各组件说明-【产品侧】\" class=\"headerlink\" title=\"产品组件 与 各组件说明 【产品侧】\"></a>产品组件 与 各组件说明 【产品侧】</h3><p><em>可采用多种方式：列表格、画UML组件图并辅以文字说明。</em></p>\n<p><em>【示例】</em></p>\n<table>\n<thead>\n<tr>\n<th><em>序号</em></th>\n<th><em>模块名称</em></th>\n<th><em>子模块名称</em></th>\n<th><em>功能说明</em></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><em>1</em></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><em>2</em></td>\n<td><em>MCU机电模块</em></td>\n<td><em>机电通信模块</em></td>\n<td><em>实现NMU机电模块与K10主机的通信。</em></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><em>电子标签接口模块</em></td>\n<td><em>实现背板EEPROM的电子信息写入和读出。</em></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><em>风扇接口模块</em></td>\n<td><em>通过风扇控制寄存器的访问接口。</em></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><em>风扇控制模块</em></td>\n<td><em>提供对风扇单元转速的控制接口，风扇单元的工作状态和告警信息读取接口。</em></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><em>机电应用模块</em></td>\n<td><em>实现机电信息的收集处理和上报，接收、响应NMU指令。</em></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><em>机电软件下载模块</em></td>\n<td><em>建立与K10主机机电软件下载会话，实现机电软件模块切割分片传送。</em></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><em>3</em></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"产品组件对应的代码工程-与-开发技术-【产品侧】\"><a href=\"#产品组件对应的代码工程-与-开发技术-【产品侧】\" class=\"headerlink\" title=\"产品组件对应的代码工程 与 开发技术 【产品侧】\"></a>产品组件对应的代码工程 与 开发技术 【产品侧】</h3><p><em>说明嵌入式软件（产品侧）包含的多个开发工程（Project）或Makefile。</em></p>\n<p><em>细致地说明，每个组件开发所需的三方库、框架。</em></p>\n<p><em>【示例】</em></p>\n<h2 id=\"运行视图\"><a href=\"#运行视图\" class=\"headerlink\" title=\"运行视图\"></a>运行视图</h2><h3 id=\"嵌入式软件：运行架构总览\"><a href=\"#嵌入式软件：运行架构总览\" class=\"headerlink\" title=\"嵌入式软件：运行架构总览\"></a>嵌入式软件：运行架构总览</h3><p><em>说明嵌入式软件运行态下，有哪些进程、线程、以及对应组件的功能简述。</em></p>\n<p><em>【示例】</em></p>\n<table>\n<thead>\n<tr>\n<th><strong>进程</strong></th>\n<th><strong>线程</strong></th>\n<th><strong>组件</strong></th>\n<th><strong>组件功能</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"嵌入式软件中的组件：能否创建线程的准则\"><a href=\"#嵌入式软件中的组件：能否创建线程的准则\" class=\"headerlink\" title=\"嵌入式软件中的组件：能否创建线程的准则\"></a>嵌入式软件中的组件：能否创建线程的准则</h3><p><em>说明嵌入式软件产品侧线程创建的准则：</em></p>\n<ul>\n<li><em>哪些情况可以创建线程</em></li>\n<li><em>哪些情况杜绝滥启线程★★★</em></li>\n</ul>\n<p><em>后续组件详细设计师必须严格遵守，杜绝线程泛滥拉低性能和易理解性。</em></p>\n<h2 id=\"物理视图\"><a href=\"#物理视图\" class=\"headerlink\" title=\"物理视图\"></a>物理视图</h2><h3 id=\"运行环境\"><a href=\"#运行环境\" class=\"headerlink\" title=\"运行环境\"></a>运行环境</h3><p><em>细致地说明，嵌入式的硬件配置。</em></p>\n<p><em>细致地说明操作系统、各种系统软件、中间件的种类和版本。</em></p>\n<p><em>【示例】</em></p>\n<table>\n<thead>\n<tr>\n<th><em>硬件环境</em> <em>主CPU扣板为P2041，底板核心交换芯片为Qumran的硬件板卡。</em> <em>硬件配置</em> <em>CPU型号: p2041</em> <em>CPU主频：1.5GHz</em> <em>CPU核数：4*e500mc核</em> <em>CPU位宽：32位</em> <em>内存：4096 MB</em> <em>操作系统</em> <em>Linux localhost 2.6.34.15-grsec-WR4.3.0.0_cgl #1 SMP PREEMPT Fri Nov 4 16:51:14 CST 2016 ppc ppc ppc GNU/Linux</em></th>\n</tr>\n</thead>\n</table>\n<h3 id=\"发布包目录结构及目标路径定义\"><a href=\"#发布包目录结构及目标路径定义\" class=\"headerlink\" title=\"发布包目录结构及目标路径定义\"></a>发布包目录结构及目标路径定义</h3><p><em>本节应描述：</em></p>\n<p><em>A）发布包的详细目录结构约定。</em></p>\n<p><em>B）发布包应该mount到的目标路径</em></p>\n<p><em>【示例】</em></p>\n<p><em>。。。。。。</em></p>\n<h3 id=\"组件部署结构\"><a href=\"#组件部署结构\" class=\"headerlink\" title=\"* *组件部署结构\"></a>* *组件部署结构</h3><p><em>嵌入式软件往往由许多组件组成，本节重点说明组件之间的上下游关系。</em></p>\n<p><em>【示例】</em></p>\n<h1 id=\"接口设计\"><a href=\"#接口设计\" class=\"headerlink\" title=\"接口设计\"></a>接口设计</h1><h2 id=\"对外接口总览\"><a href=\"#对外接口总览\" class=\"headerlink\" title=\"对外接口总览\"></a>对外接口总览</h2><p>画图，概览本嵌入式软件的对外接口的位置。</p>\n<h2 id=\"各模块间接口总览\"><a href=\"#各模块间接口总览\" class=\"headerlink\" title=\"各模块间接口总览\"></a>各模块间接口总览</h2><p>画图，概览嵌入式软件内部的做个组件之间接口的位置。</p>\n<h2 id=\"平台和设备间接口总览\"><a href=\"#平台和设备间接口总览\" class=\"headerlink\" title=\"平台和设备间接口总览\"></a>平台和设备间接口总览</h2><p>画图，概览平台与设备间接口的位置。</p>\n<h2 id=\"接口列表\"><a href=\"#接口列表\" class=\"headerlink\" title=\"接口列表\"></a>接口列表</h2><p>列出接口名称和功能，对外和内部分别罗列。</p>\n<h2 id=\"XXXXX接口设计\"><a href=\"#XXXXX接口设计\" class=\"headerlink\" title=\"XXXXX接口设计\"></a>XXXXX接口设计</h2><p>接口=交互过程+技术选择+格式定义。交互过程用序列图刻画</p>\n<p><em>【示例1】函数接口的格式定义</em></p>\n<table>\n<thead>\n<tr>\n<th><strong>名称</strong></th>\n<th>dhcm回调函数</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>用途</strong></td>\n<td><strong>DHCM组件提供给DDA的回调接口</strong></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>声明</strong></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>typedef struct tag_dhcm_callback {  INT32 (*dcoi_board_init)(DCOI_BOARD_INIT_INFO *init_info);  UINT32 (*dcoi_get_support_card_flag)();  UINT32 (*dcoi_cmi_ready_cb)();  VOID (*dcoi_dhcs_ready)(DHCS_CARD_COMP_INFO_MSG_EN *card_comp_info);  }DHCM_CALLBACK;</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>字段</strong></td>\n<td><strong>含义</strong></td>\n<td><strong>说明</strong></td>\n</tr>\n<tr>\n<td>dcoi_board_init</td>\n<td>嵌入式初始化的调用，包含硬件初始化和软件初始化。</td>\n<td></td>\n</tr>\n<tr>\n<td>dcoi_get_support_card_flag</td>\n<td>返回嵌入式是否支持子卡的信息</td>\n<td></td>\n</tr>\n<tr>\n<td>dcoi_cmi_ready_cb</td>\n<td>判断组件cmi是否有值</td>\n<td></td>\n</tr>\n<tr>\n<td>dcoi_dhcs_ready</td>\n<td>获取嵌入式建模信息，包含框/槽/子卡/板类型等信息。</td>\n<td></td>\n</tr>\n</tbody></table>\n<p><em>【示例2】协议接口的格式定义</em></p>\n<p><img src=\"/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/60a0b6815e87242adbc049d64b96e01b.png\" alt></p>\n<h2 id=\"XXXXX接口设计-1\"><a href=\"#XXXXX接口设计-1\" class=\"headerlink\" title=\"XXXXX接口设计\"></a>XXXXX接口设计</h2><p>接口=交互过程+技术选择+格式定义。交互过程用序列图刻画</p>\n<h1 id=\"关键功能的设计原理\"><a href=\"#关键功能的设计原理\" class=\"headerlink\" title=\"关键功能的设计原理\"></a>关键功能的设计原理</h1><p><em>本节内容：</em></p>\n<ul>\n<li><em>典型功能的设计</em></li>\n<li><em>“2.2.3关键功能识别与问题单分析”节中每个关键功能的设计</em></li>\n</ul>\n<h2 id=\"XXXXX功能设计\"><a href=\"#XXXXX功能设计\" class=\"headerlink\" title=\"XXXXX功能设计\"></a>XXXXX功能设计</h2><p><em>用“<em>协作图+文字说明</em>”的方式说明每个关键功能的设计原理。图可以是下列方式之一：</em></p>\n<ul>\n<li><em>序列图</em></li>\n<li><em>协作图</em></li>\n<li><em>涉及多进程多线程的，图中应刻画出“进程/线程”</em></li>\n<li><em>设计跨机器分布式的，图中应刻画出“机器/控制板”</em></li>\n<li><em>协作逻辑复杂的，图中标号，再针对每个标号进行文字说明</em></li>\n</ul>\n<h2 id=\"XXXXX功能设计-1\"><a href=\"#XXXXX功能设计-1\" class=\"headerlink\" title=\"XXXXX功能设计\"></a>XXXXX功能设计</h2><h1 id=\"关键质量的设计原理\"><a href=\"#关键质量的设计原理\" class=\"headerlink\" title=\"关键质量的设计原理\"></a>关键质量的设计原理</h1><h2 id=\"XXXX设计\"><a href=\"#XXXX设计\" class=\"headerlink\" title=\"XXXX设计\"></a>XXXX设计</h2><h3 id=\"影响质量的因素分解表-质量因素树\"><a href=\"#影响质量的因素分解表-质量因素树\" class=\"headerlink\" title=\"影响质量的因素分解表/质量因素树\"></a>影响质量的因素分解表/质量因素树</h3><p><em>本节的核心是运用分解思维、系统化思维，梳理影响质量的因素。可采用表格、树等形式。</em></p>\n<h3 id=\"目标-场景-决策表\"><a href=\"#目标-场景-决策表\" class=\"headerlink\" title=\"目标-场景-决策表\"></a>目标-场景-决策表</h3><p><em>本节的核心是运用场景思维、具体化思维，分析质量因素对系统的具体影响，并给出设计对策。</em></p>\n<p><em>【注意项】推荐使用目标-场景-决策表，表中场景按“质量场景规约”格式编写</em></p>\n<p><em><img src=\"/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/c7546c50623e8a8aa6ab33ead8fac6cb.png\" alt></em></p>\n<h3 id=\"设计原理图\"><a href=\"#设计原理图\" class=\"headerlink\" title=\"设计原理图\"></a>设计原理图</h3><p>【示例】<img src=\"/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/e7176066eab77c0cf6e147aed0046ea7.png\" alt></p>\n<h2 id=\"XXXX设计-1\"><a href=\"#XXXX设计-1\" class=\"headerlink\" title=\"XXXX设计\"></a>XXXX设计</h2><h3 id=\"影响质量的因素分解表-质量因素树-1\"><a href=\"#影响质量的因素分解表-质量因素树-1\" class=\"headerlink\" title=\"影响质量的因素分解表/质量因素树\"></a>影响质量的因素分解表/质量因素树</h3><h3 id=\"目标-场景-决策表-1\"><a href=\"#目标-场景-决策表-1\" class=\"headerlink\" title=\"目标-场景-决策表\"></a>目标-场景-决策表</h3><h3 id=\"设计原理图-1\"><a href=\"#设计原理图-1\" class=\"headerlink\" title=\"设计原理图\"></a>设计原理图</h3><h2 id=\"XXXX设计-2\"><a href=\"#XXXX设计-2\" class=\"headerlink\" title=\"XXXX设计\"></a>XXXX设计</h2><h3 id=\"影响质量的因素分解表-质量因素树-2\"><a href=\"#影响质量的因素分解表-质量因素树-2\" class=\"headerlink\" title=\"影响质量的因素分解表/质量因素树\"></a>影响质量的因素分解表/质量因素树</h3><h3 id=\"目标-场景-决策表-2\"><a href=\"#目标-场景-决策表-2\" class=\"headerlink\" title=\"目标-场景-决策表\"></a>目标-场景-决策表</h3><h3 id=\"设计原理图-2\"><a href=\"#设计原理图-2\" class=\"headerlink\" title=\"设计原理图\"></a>设计原理图</h3><p># </p>\n"}],"PostAsset":[{"_id":"source/_posts/2022/01/IMX6ull-移植-lVGL总结/2909691-20220928152209724-1097250473.png","slug":"2909691-20220928152209724-1097250473.png","post":"clk69d1cr0008jsrjzpyi2nkr","modified":1,"renderable":0},{"_id":"source/_posts/2022/01/IMX6ull-移植-lVGL总结/2909691-20220928152945955-899676295.png","slug":"2909691-20220928152945955-899676295.png","post":"clk69d1cr0008jsrjzpyi2nkr","modified":1,"renderable":0},{"_id":"source/_posts/2022/01/IMX6ull-移植-lVGL总结/2909691-20220928153305849-1048335725.png","slug":"2909691-20220928153305849-1048335725.png","post":"clk69d1cr0008jsrjzpyi2nkr","modified":1,"renderable":0},{"_id":"source/_posts/2022/01/Linux-input子系统/2909691-20220819093409715-1604400596.png","slug":"2909691-20220819093409715-1604400596.png","post":"clk69d1co0007jsrjueopeg9z","modified":1,"renderable":0},{"_id":"source/_posts/2022/01/python使用百度翻译的API/20200302113313981.png","slug":"20200302113313981.png","post":"clk69d1cu000bjsrjmbcr74d8","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/北京/IMG_6716.JPG","slug":"IMG_6716.JPG","post":"clk69d1e6001qjsrjfcp6k092","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/新疆/1b706b934fc955412e3ed163fd0b7cbc2.JPG","slug":"1b706b934fc955412e3ed163fd0b7cbc2.JPG","post":"clk69d1e7001sjsrjsn0ti7kd","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/新疆/89c05a76a9273811c585c395890c9f522.JPG","slug":"89c05a76a9273811c585c395890c9f522.JPG","post":"clk69d1e7001sjsrjsn0ti7kd","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/衡山/20230403161419.jpg","slug":"20230403161419.jpg","post":"clk69d1ec001wjsrjchy36da6","modified":1,"renderable":0},{"_id":"source/_posts/2023/05/PIN-GPIO/gpio.png","slug":"gpio.png","post":"clk69d1ei0022jsrjqqynsrnr","modified":1,"renderable":0},{"_id":"source/_posts/2022/01/python使用百度翻译的API/20200302112847600.png","slug":"20200302112847600.png","post":"clk69d1cu000bjsrjmbcr74d8","modified":1,"renderable":0},{"_id":"source/_posts/2022/01/中华通史-上古史-夏/20210703111602157.png","slug":"20210703111602157.png","post":"clk69d1cx000djsrjj0t7n5ku","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/EMC-EMI/2023-04-04_19-34-25.png","slug":"2023-04-04_19-34-25.png","post":"clk69d1d5000ljsrjyo1w1f2c","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/业务功能-业务流程-业务规则分析/探索分支.png","slug":"探索分支.png","post":"clk69d1e6001pjsrjtf8tagtq","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/北京/IMG_6717.JPG","slug":"IMG_6717.JPG","post":"clk69d1e6001qjsrjfcp6k092","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/深圳梧桐山-毛棉杜鹃/2b135a37c965e856f04d4a5faf8d2f2b2.JPG","slug":"2b135a37c965e856f04d4a5faf8d2f2b2.JPG","post":"clk69d1e9001ujsrje4323ru4","modified":1,"renderable":0},{"_id":"source/_posts/2023/06/ttymxx-UART/cat-ttymxc2.png","slug":"cat-ttymxc2.png","post":"clk69d1er002ajsrjjgcygu6e","modified":1,"renderable":0},{"_id":"source/_posts/2022/01/中华通史-上古史-夏/20210703105815619.png","slug":"20210703105815619.png","post":"clk69d1cx000djsrjj0t7n5ku","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/业务功能-业务流程-业务规则分析/业务规则.png","slug":"业务规则.png","post":"clk69d1e6001pjsrjtf8tagtq","modified":1,"renderable":0},{"_id":"source/_posts/2022/01/超详细解析python爬取外网图片/20200302110709393.png","slug":"20200302110709393.png","post":"clk69d1d2000hjsrjijp5qtey","modified":1,"renderable":0},{"_id":"source/_posts/2022/01/超详细解析python爬取外网图片/20200302111109517.png","slug":"20200302111109517.png","post":"clk69d1d2000hjsrjijp5qtey","modified":1,"renderable":0},{"_id":"source/_posts/2022/01/linux线程/2909691-20221018201940242-320806714.png","post":"clk69d1cw000cjsrjbdvppaad","slug":"2909691-20221018201940242-320806714.png","modified":1,"renderable":1},{"_id":"source/_posts/2022/01/linux线程/2909691-20221018202536805-171723429.png","post":"clk69d1cw000cjsrjbdvppaad","slug":"2909691-20221018202536805-171723429.png","modified":1,"renderable":1},{"_id":"source/_posts/2022/01/linux线程/2909691-20221018204634847-2097816257.png","post":"clk69d1cw000cjsrjbdvppaad","slug":"2909691-20221018204634847-2097816257.png","modified":1,"renderable":1},{"_id":"source/_posts/2022/01/Linux-input子系统/2909691-20220819094250974-180404869.webp","post":"clk69d1co0007jsrjueopeg9z","slug":"2909691-20220819094250974-180404869.webp","modified":1,"renderable":1},{"_id":"source/_posts/2022/01/Linux-input子系统/2909691-20220819102740731-2036281828.png","post":"clk69d1co0007jsrjueopeg9z","slug":"2909691-20220819102740731-2036281828.png","modified":1,"renderable":1},{"_id":"source/_posts/2022/01/Linux-input子系统/input_logical.png","post":"clk69d1co0007jsrjueopeg9z","slug":"input_logical.png","modified":1,"renderable":1},{"_id":"source/_posts/2022/01/中华通史-上古史-夏/20210703105831609.png","post":"clk69d1cx000djsrjj0t7n5ku","slug":"20210703105831609.png","modified":1,"renderable":1},{"_id":"source/_posts/2022/01/中华通史-上古史-夏/20210703105920999.png","post":"clk69d1cx000djsrjj0t7n5ku","slug":"20210703105920999.png","modified":1,"renderable":1},{"_id":"source/_posts/2023/04/上海/20230403160752.jpg","slug":"20230403160752.jpg","post":"clk69d1d9000tjsrjllaqn27b","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/上海/20230403160809.jpg","slug":"20230403160809.jpg","post":"clk69d1d9000tjsrjllaqn27b","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/上海/20230403160815.jpg","slug":"20230403160815.jpg","post":"clk69d1d9000tjsrjllaqn27b","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/上海/20230403160820.jpg","slug":"20230403160820.jpg","post":"clk69d1d9000tjsrjllaqn27b","modified":1,"renderable":0},{"_id":"source/_posts/2022/01/python使用百度翻译的API/20200302112753932.png","slug":"20200302112753932.png","post":"clk69d1cu000bjsrjmbcr74d8","modified":1,"renderable":0},{"_id":"source/_posts/2022/01/python使用百度翻译的API/20200302113654396.png","post":"clk69d1cu000bjsrjmbcr74d8","slug":"20200302113654396.png","modified":1,"renderable":1},{"_id":"source/_posts/2022/01/python使用百度翻译的API/20200302115943813.png","post":"clk69d1cu000bjsrjmbcr74d8","slug":"20200302115943813.png","modified":1,"renderable":1},{"_id":"source/_posts/2022/01/python使用百度翻译的API/20200302120105912.png","post":"clk69d1cu000bjsrjmbcr74d8","slug":"20200302120105912.png","modified":1,"renderable":1},{"_id":"source/_posts/2022/01/IMX6ull-移植-lVGL总结/2909691-20220928151916481-1456634923.png","post":"clk69d1cr0008jsrjzpyi2nkr","slug":"2909691-20220928151916481-1456634923.png","modified":1,"renderable":1},{"_id":"source/_posts/2022/01/IMX6ull-移植-lVGL总结/2909691-20220928152922659-1842915282.png","slug":"2909691-20220928152922659-1842915282.png","post":"clk69d1cr0008jsrjzpyi2nkr","modified":1,"renderable":0},{"_id":"source/_posts/2022/01/IMX6ull-移植-lVGL总结/2909691-20220928152957065-501054685.png","post":"clk69d1cr0008jsrjzpyi2nkr","slug":"2909691-20220928152957065-501054685.png","modified":1,"renderable":1},{"_id":"source/_posts/2022/01/IMX6ull-移植-lVGL总结/2909691-20220928153140065-1807119912.png","post":"clk69d1cr0008jsrjzpyi2nkr","slug":"2909691-20220928153140065-1807119912.png","modified":1,"renderable":1},{"_id":"source/_posts/2022/01/IMX6ull-移植-lVGL总结/2909691-20220928153451220-1274979267.png","post":"clk69d1cr0008jsrjzpyi2nkr","slug":"2909691-20220928153451220-1274979267.png","modified":1,"renderable":1},{"_id":"source/_posts/2023/04/EMC-EMI/2023-04-04_19-28-04.png","post":"clk69d1d5000ljsrjyo1w1f2c","slug":"2023-04-04_19-28-04.png","modified":1,"renderable":1},{"_id":"source/_posts/2023/04/EMC-EMI/2023-04-04_19-30-08.png","slug":"2023-04-04_19-30-08.png","post":"clk69d1d5000ljsrjyo1w1f2c","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/EMC-EMI/2023-04-04_19-31-27.png","slug":"2023-04-04_19-31-27.png","post":"clk69d1d5000ljsrjyo1w1f2c","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/EMC-EMI/2023-04-04_19-32-29.png","post":"clk69d1d5000ljsrjyo1w1f2c","slug":"2023-04-04_19-32-29.png","modified":1,"renderable":1},{"_id":"source/_posts/2023/04/EMC-EMI/2023-04-04_19-32-59.png","slug":"2023-04-04_19-32-59.png","post":"clk69d1d5000ljsrjyo1w1f2c","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/EMC-EMI/2023-04-04_19-33-05.png","post":"clk69d1d5000ljsrjyo1w1f2c","slug":"2023-04-04_19-33-05.png","modified":1,"renderable":1},{"_id":"source/_posts/2023/04/EMC-EMI/2023-04-04_19-33-48.png","post":"clk69d1d5000ljsrjyo1w1f2c","slug":"2023-04-04_19-33-48.png","modified":1,"renderable":1},{"_id":"source/_posts/2023/04/EMC-EMI/2023-04-04_19-35-03.png","slug":"2023-04-04_19-35-03.png","post":"clk69d1d5000ljsrjyo1w1f2c","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/ten-ge-li/1.jpg","slug":"1.jpg","post":"clk69d1d7000ojsrjakxhwll9","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/ten-ge-li/2.jpg","slug":"2.jpg","post":"clk69d1d7000ojsrjakxhwll9","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/ten-ge-li/3.jpg","slug":"3.jpg","post":"clk69d1d7000ojsrjakxhwll9","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/ten-ge-li/4.jpg","slug":"4.jpg","post":"clk69d1d7000ojsrjakxhwll9","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/ten-ge-li/5.jpg","slug":"5.jpg","post":"clk69d1d7000ojsrjakxhwll9","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/ten-ge-li/6.jpg","slug":"6.jpg","post":"clk69d1d7000ojsrjakxhwll9","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/ten-ge-li/IMG_6899.JPG","slug":"IMG_6899.JPG","post":"clk69d1d7000ojsrjakxhwll9","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/ten-ge-li/IMG_6912.JPG","slug":"IMG_6912.JPG","post":"clk69d1d7000ojsrjakxhwll9","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/ten-ge-li/IMG_7069.JPG","slug":"IMG_7069.JPG","post":"clk69d1d7000ojsrjakxhwll9","modified":1,"renderable":0},{"_id":"source/_posts/2022/01/菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329193127889.jpg","post":"clk69d1d0000gjsrj2eem4h0i","slug":"20210329193127889.jpg","modified":1,"renderable":1},{"_id":"source/_posts/2022/01/菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329195920218.jpg","post":"clk69d1d0000gjsrj2eem4h0i","slug":"20210329195920218.jpg","modified":1,"renderable":1},{"_id":"source/_posts/2022/01/菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329200632579.png","post":"clk69d1d0000gjsrj2eem4h0i","slug":"20210329200632579.png","modified":1,"renderable":1},{"_id":"source/_posts/2022/01/菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329201443609.png","slug":"20210329201443609.png","post":"clk69d1d0000gjsrj2eem4h0i","modified":1,"renderable":0},{"_id":"source/_posts/2022/01/菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329201646615.png","post":"clk69d1d0000gjsrj2eem4h0i","slug":"20210329201646615.png","modified":1,"renderable":1},{"_id":"source/_posts/2022/01/菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329202358795.png","post":"clk69d1d0000gjsrj2eem4h0i","slug":"20210329202358795.png","modified":1,"renderable":1},{"_id":"source/_posts/2022/01/菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329202548677.png","post":"clk69d1d0000gjsrj2eem4h0i","slug":"20210329202548677.png","modified":1,"renderable":1},{"_id":"source/_posts/2022/01/菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329203021908.png","post":"clk69d1d0000gjsrj2eem4h0i","slug":"20210329203021908.png","modified":1,"renderable":1},{"_id":"source/_posts/2022/01/菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329203335481.png","post":"clk69d1d0000gjsrj2eem4h0i","slug":"20210329203335481.png","modified":1,"renderable":1},{"_id":"source/_posts/2022/01/菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329203626594.png","post":"clk69d1d0000gjsrj2eem4h0i","slug":"20210329203626594.png","modified":1,"renderable":1},{"_id":"source/_posts/2023/04/新疆/5d0b74a8910a3abba7e860149b9d40e12.JPG","slug":"5d0b74a8910a3abba7e860149b9d40e12.JPG","post":"clk69d1e7001sjsrjsn0ti7kd","modified":1,"renderable":0},{"_id":"source/_posts/2023/06/linux内核-tool目录/menuconfig.png","post":"clk69d1ep0027jsrjxiy9ecg0","slug":"menuconfig.png","modified":1,"renderable":1},{"_id":"source/_posts/2023/06/linux内核-tool目录/tool目录.png","post":"clk69d1ep0027jsrjxiy9ecg0","slug":"tool目录.png","modified":1,"renderable":1},{"_id":"source/_posts/2023/07/linux-platform/device-driver.png","post":"clk69d1et002hjsrj155s3jlv","slug":"device-driver.png","modified":1,"renderable":1},{"_id":"source/_posts/2023/07/linux-platform/platform.png","slug":"platform.png","post":"clk69d1et002hjsrj155s3jlv","modified":1,"renderable":0},{"_id":"source/_posts/2023/06/ttymxx-UART/cat-proc-devices.png","post":"clk69d1er002ajsrjjgcygu6e","slug":"cat-proc-devices.png","modified":1,"renderable":1},{"_id":"source/_posts/2023/06/ttymxx-UART/ls-dev.png","post":"clk69d1er002ajsrjjgcygu6e","slug":"ls-dev.png","modified":1,"renderable":1},{"_id":"source/_posts/2023/06/ttymxx-UART/ttymxc.png","slug":"ttymxc.png","post":"clk69d1er002ajsrjjgcygu6e","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/深圳梧桐山-毛棉杜鹃/0a32e20ee914cca207bd5e0446eca332.JPG","slug":"0a32e20ee914cca207bd5e0446eca332.JPG","post":"clk69d1e9001ujsrje4323ru4","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/深圳梧桐山-毛棉杜鹃/6f19a8a8bff80c030eeba535032db0f6.JPG","slug":"6f19a8a8bff80c030eeba535032db0f6.JPG","post":"clk69d1e9001ujsrje4323ru4","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/深圳梧桐山-毛棉杜鹃/7d011510a39a8f6e23429fa828448a7c2.JPG","slug":"7d011510a39a8f6e23429fa828448a7c2.JPG","post":"clk69d1e9001ujsrje4323ru4","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/深圳梧桐山-毛棉杜鹃/d2a7004a2e039c3f37d5fef10c7cc28a2.JPG","slug":"d2a7004a2e039c3f37d5fef10c7cc28a2.JPG","post":"clk69d1e9001ujsrje4323ru4","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/深圳梧桐山-毛棉杜鹃/f4e3370968454b29062472df853b648e.JPG","slug":"f4e3370968454b29062472df853b648e.JPG","post":"clk69d1e9001ujsrje4323ru4","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/衡山/20230403161331.jpg","post":"clk69d1ec001wjsrjchy36da6","slug":"20230403161331.jpg","modified":1,"renderable":1},{"_id":"source/_posts/2023/04/衡山/20230403161404.jpg","post":"clk69d1ec001wjsrjchy36da6","slug":"20230403161404.jpg","modified":1,"renderable":1},{"_id":"source/_posts/2023/04/衡山/20230403161412.jpg","post":"clk69d1ec001wjsrjchy36da6","slug":"20230403161412.jpg","modified":1,"renderable":1},{"_id":"source/_posts/2023/04/衡山/20230403161427.jpg","slug":"20230403161427.jpg","post":"clk69d1ec001wjsrjchy36da6","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/衡山/20230403161434.jpg","slug":"20230403161434.jpg","post":"clk69d1ec001wjsrjchy36da6","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/衡山/20230403161440.jpg","slug":"20230403161440.jpg","post":"clk69d1ec001wjsrjchy36da6","modified":1,"renderable":0},{"_id":"source/_posts/2023/05/PIN-GPIO/Pinctrl.png","post":"clk69d1ei0022jsrjqqynsrnr","slug":"Pinctrl.png","modified":1,"renderable":1},{"_id":"source/_posts/2023/05/PIN-GPIO/imx6ull pinctrl.png","post":"clk69d1ei0022jsrjqqynsrnr","slug":"imx6ull pinctrl.png","modified":1,"renderable":1},{"_id":"source/_posts/2023/05/PIN-GPIO/iomuxc.png","post":"clk69d1ei0022jsrjqqynsrnr","slug":"iomuxc.png","modified":1,"renderable":1},{"_id":"source/_posts/2023/05/PIN-GPIO/pinctrl struct.png","slug":"pinctrl struct.png","post":"clk69d1ei0022jsrjqqynsrnr","modified":1,"renderable":0},{"_id":"source/_posts/2023/05/PIN-GPIO/pinctrl_system.png","post":"clk69d1ei0022jsrjqqynsrnr","slug":"pinctrl_system.png","modified":1,"renderable":1},{"_id":"source/_posts/2023/05/PIN-GPIO/probe.png","post":"clk69d1ei0022jsrjqqynsrnr","slug":"probe.png","modified":1,"renderable":1},{"_id":"source/_posts/2023/04/业务功能-业务流程-业务规则分析/业务规则上.png","post":"clk69d1e6001pjsrjtf8tagtq","slug":"业务规则上.png","modified":1,"renderable":1},{"_id":"source/_posts/2023/04/业务功能-业务流程-业务规则分析/业务规则下.png","slug":"业务规则下.png","post":"clk69d1e6001pjsrjtf8tagtq","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/业务功能-业务流程-业务规则分析/主干流程.png","post":"clk69d1e6001pjsrjtf8tagtq","slug":"主干流程.png","modified":1,"renderable":1},{"_id":"source/_posts/2023/04/业务功能-业务流程-业务规则分析/分析起步.png","post":"clk69d1e6001pjsrjtf8tagtq","slug":"分析起步.png","modified":1,"renderable":1},{"_id":"source/_posts/2023/04/业务功能-业务流程-业务规则分析/模板.png","post":"clk69d1e6001pjsrjtf8tagtq","slug":"模板.png","modified":1,"renderable":1},{"_id":"source/_posts/2023/04/业务功能-业务流程-业务规则分析/穷尽分支.png","slug":"穷尽分支.png","post":"clk69d1e6001pjsrjtf8tagtq","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/北京/DSC01645.JPG","slug":"DSC01645.JPG","post":"clk69d1e6001qjsrjfcp6k092","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/北京/DSC01687.JPG","slug":"DSC01687.JPG","post":"clk69d1e6001qjsrjfcp6k092","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/北京/DSC01697.JPG","slug":"DSC01697.JPG","post":"clk69d1e6001qjsrjfcp6k092","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/北京/DSC01699.JPG","slug":"DSC01699.JPG","post":"clk69d1e6001qjsrjfcp6k092","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/北京/DSC01722.JPG","slug":"DSC01722.JPG","post":"clk69d1e6001qjsrjfcp6k092","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/北京/DSC01755.JPG","slug":"DSC01755.JPG","post":"clk69d1e6001qjsrjfcp6k092","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/北京/DSC01821.JPG","slug":"DSC01821.JPG","post":"clk69d1e6001qjsrjfcp6k092","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/北京/DSC01827.JPG","slug":"DSC01827.JPG","post":"clk69d1e6001qjsrjfcp6k092","modified":1,"renderable":0},{"_id":"source/_posts/2023/07/嵌入式软件框架方案/22c7469876239933b38a12a32e9c6f16.png","post":"clk69d1et002mjsrjxfanbqpt","slug":"22c7469876239933b38a12a32e9c6f16.png","modified":1,"renderable":1},{"_id":"source/_posts/2023/07/嵌入式软件框架方案/2dd308b3411c41658cce041f8c230853.png","post":"clk69d1et002mjsrjxfanbqpt","slug":"2dd308b3411c41658cce041f8c230853.png","modified":1,"renderable":1},{"_id":"source/_posts/2023/07/嵌入式软件框架方案/32643a6fbe010dcc95af301416619164.png","post":"clk69d1et002mjsrjxfanbqpt","slug":"32643a6fbe010dcc95af301416619164.png","modified":1,"renderable":1},{"_id":"source/_posts/2023/07/嵌入式软件框架方案/60a0b6815e87242adbc049d64b96e01b.png","post":"clk69d1et002mjsrjxfanbqpt","slug":"60a0b6815e87242adbc049d64b96e01b.png","modified":1,"renderable":1},{"_id":"source/_posts/2023/07/嵌入式软件框架方案/6aadad4da134377249d84bab5dbdfa8d.png","post":"clk69d1et002mjsrjxfanbqpt","slug":"6aadad4da134377249d84bab5dbdfa8d.png","modified":1,"renderable":1},{"_id":"source/_posts/2023/07/嵌入式软件框架方案/780552b6b4ceacfe274a8c687b74a569.png","post":"clk69d1et002mjsrjxfanbqpt","slug":"780552b6b4ceacfe274a8c687b74a569.png","modified":1,"renderable":1},{"_id":"source/_posts/2023/07/嵌入式软件框架方案/c7546c50623e8a8aa6ab33ead8fac6cb.png","slug":"c7546c50623e8a8aa6ab33ead8fac6cb.png","post":"clk69d1et002mjsrjxfanbqpt","modified":1,"renderable":0},{"_id":"source/_posts/2023/07/嵌入式软件框架方案/dc4e3ddfdab5a0456af40df7d0a9238b.png","post":"clk69d1et002mjsrjxfanbqpt","slug":"dc4e3ddfdab5a0456af40df7d0a9238b.png","modified":1,"renderable":1},{"_id":"source/_posts/2023/07/嵌入式软件框架方案/e7176066eab77c0cf6e147aed0046ea7.png","post":"clk69d1et002mjsrjxfanbqpt","slug":"e7176066eab77c0cf6e147aed0046ea7.png","modified":1,"renderable":1},{"_id":"source/_posts/2023/07/嵌入式软件框架方案/e852708ffd1c78efd87949efa7b31592.png","slug":"e852708ffd1c78efd87949efa7b31592.png","post":"clk69d1et002mjsrjxfanbqpt","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/新疆/76d386e1b8eeeb85abab758cefc855e0.JPG","post":"clk69d1e7001sjsrjsn0ti7kd","slug":"76d386e1b8eeeb85abab758cefc855e0.JPG","modified":1,"renderable":1},{"_id":"source/_posts/2023/04/新疆/254bc46a6128338402204fa78f54b3e12.PNG","slug":"254bc46a6128338402204fa78f54b3e12.PNG","post":"clk69d1e7001sjsrjsn0ti7kd","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/新疆/2d25bdf0ce35910c874badcedff928002.JPG","post":"clk69d1e7001sjsrjsn0ti7kd","slug":"2d25bdf0ce35910c874badcedff928002.JPG","modified":1,"renderable":1},{"_id":"source/_posts/2023/04/新疆/50f3a54d039eb642be22bc25607e11ca2.PNG","slug":"50f3a54d039eb642be22bc25607e11ca2.PNG","post":"clk69d1e7001sjsrjsn0ti7kd","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/新疆/6d0c92b575f36108df2062fda3b1e4ba2.PNG","slug":"6d0c92b575f36108df2062fda3b1e4ba2.PNG","post":"clk69d1e7001sjsrjsn0ti7kd","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/新疆/88a98ae85a4705294439aca39ae07d672.JPG","slug":"88a98ae85a4705294439aca39ae07d672.JPG","post":"clk69d1e7001sjsrjsn0ti7kd","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/新疆/95d557eb4ef2235d74a45743be1b05842.JPG","slug":"95d557eb4ef2235d74a45743be1b05842.JPG","post":"clk69d1e7001sjsrjsn0ti7kd","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/新疆/ANKG1449.JPG","slug":"ANKG1449.JPG","post":"clk69d1e7001sjsrjsn0ti7kd","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/新疆/AQSR2937.JPG","slug":"AQSR2937.JPG","post":"clk69d1e7001sjsrjsn0ti7kd","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/新疆/AZQE3071.JPG","slug":"AZQE3071.JPG","post":"clk69d1e7001sjsrjsn0ti7kd","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/新疆/BBND3773.PNG","slug":"BBND3773.PNG","post":"clk69d1e7001sjsrjsn0ti7kd","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/新疆/BBOD4958.JPG","slug":"BBOD4958.JPG","post":"clk69d1e7001sjsrjsn0ti7kd","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/新疆/IGAX1811.JPG","slug":"IGAX1811.JPG","post":"clk69d1e7001sjsrjsn0ti7kd","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/新疆/KNLN1045.PNG","slug":"KNLN1045.PNG","post":"clk69d1e7001sjsrjsn0ti7kd","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/新疆/MOVG5083.JPG","slug":"MOVG5083.JPG","post":"clk69d1e7001sjsrjsn0ti7kd","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/新疆/XRBQ0574.JPG","slug":"XRBQ0574.JPG","post":"clk69d1e7001sjsrjsn0ti7kd","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/新疆/YJUM1401.JPG","slug":"YJUM1401.JPG","post":"clk69d1e7001sjsrjsn0ti7kd","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/新疆/a2a9265c2707c16b5a1ca704a4d0856d.JPG","slug":"a2a9265c2707c16b5a1ca704a4d0856d.JPG","post":"clk69d1e7001sjsrjsn0ti7kd","modified":1,"renderable":0},{"_id":"source/_posts/2023/04/新疆/a51d80549e7edc0d1ba69a885aa946ff2.JPG","slug":"a51d80549e7edc0d1ba69a885aa946ff2.JPG","post":"clk69d1e7001sjsrjsn0ti7kd","modified":1,"renderable":0}],"PostCategory":[{"post_id":"clk69d1cw000cjsrjbdvppaad","category_id":"clk69d1ct0009jsrj4ao2gxrz","_id":"clk69d1d3000ijsrj5ndhze3v"},{"post_id":"clk69d1co0007jsrjueopeg9z","category_id":"clk69d1ct0009jsrj4ao2gxrz","_id":"clk69d1d5000mjsrjcnzd4wou"},{"post_id":"clk69d1cr0008jsrjzpyi2nkr","category_id":"clk69d1ct0009jsrj4ao2gxrz","_id":"clk69d1d7000pjsrj7z4zxg6n"},{"post_id":"clk69d1cu000bjsrjmbcr74d8","category_id":"clk69d1d3000jjsrjv0k2d4j4","_id":"clk69d1db000ujsrjub3aovje"},{"post_id":"clk69d1cx000djsrjj0t7n5ku","category_id":"clk69d1d7000rjsrjot4rwcwg","_id":"clk69d1dg000zjsrjiwcsj8sk"},{"post_id":"clk69d1d0000gjsrj2eem4h0i","category_id":"clk69d1dc000vjsrjz9pk2tsw","_id":"clk69d1di0014jsrjqqja3ujn"},{"post_id":"clk69d1d2000hjsrjijp5qtey","category_id":"clk69d1d3000jjsrjv0k2d4j4","_id":"clk69d1di0017jsrjx89kt0rn"},{"post_id":"clk69d1d5000ljsrjyo1w1f2c","category_id":"clk69d1di0013jsrj9x2cvxop","_id":"clk69d1dj001cjsrjslamiwui"},{"post_id":"clk69d1d7000ojsrjakxhwll9","category_id":"clk69d1di0019jsrjafpvi4d6","_id":"clk69d1dk001gjsrjsgufwvhh"},{"post_id":"clk69d1d9000tjsrjllaqn27b","category_id":"clk69d1di0019jsrjafpvi4d6","_id":"clk69d1dl001jjsrj1wlj8xwv"},{"post_id":"clk69d1e6001pjsrjtf8tagtq","category_id":"clk69d1dc000vjsrjz9pk2tsw","_id":"clk69d1ea001vjsrj3wonnu7c"},{"post_id":"clk69d1e6001qjsrjfcp6k092","category_id":"clk69d1di0019jsrjafpvi4d6","_id":"clk69d1ec001xjsrjpwgpodf8"},{"post_id":"clk69d1e7001sjsrjsn0ti7kd","category_id":"clk69d1di0019jsrjafpvi4d6","_id":"clk69d1eg0020jsrjtbsqanlx"},{"post_id":"clk69d1e9001ujsrje4323ru4","category_id":"clk69d1di0019jsrjafpvi4d6","_id":"clk69d1ei0023jsrjlyndlevb"},{"post_id":"clk69d1ec001wjsrjchy36da6","category_id":"clk69d1di0019jsrjafpvi4d6","_id":"clk69d1em0025jsrjx7fu19ou"},{"post_id":"clk69d1ef001yjsrj9go321lj","category_id":"clk69d1dc000vjsrjz9pk2tsw","_id":"clk69d1ep0029jsrj6cosqcn9"},{"post_id":"clk69d1ei0022jsrjqqynsrnr","category_id":"clk69d1ct0009jsrj4ao2gxrz","_id":"clk69d1er002cjsrjcsdns29z"},{"post_id":"clk69d1em0024jsrjkq133zl5","category_id":"clk69d1dc000vjsrjz9pk2tsw","_id":"clk69d1es002fjsrjupam4by3"},{"post_id":"clk69d1ep0027jsrjxiy9ecg0","category_id":"clk69d1ct0009jsrj4ao2gxrz","_id":"clk69d1et002ijsrjt4kyt6h1"},{"post_id":"clk69d1er002ajsrjjgcygu6e","category_id":"clk69d1ct0009jsrj4ao2gxrz","_id":"clk69d1eu002njsrjidpoqcg2"},{"post_id":"clk69d1et002hjsrj155s3jlv","category_id":"clk69d1ct0009jsrj4ao2gxrz","_id":"clk69d1ex002qjsrjtw3xi4dt"},{"post_id":"clk69d1et002mjsrjxfanbqpt","category_id":"clk69d1dc000vjsrjz9pk2tsw","_id":"clk69d1f0002tjsrjad3azk4o"},{"post_id":"clk69d1es002ejsrj0d2n51e2","category_id":"clk69d1et002kjsrjmnt4gqxo","_id":"clk69d1f3002ujsrj64fnpxno"}],"PostTag":[{"post_id":"clk69d1co0007jsrjueopeg9z","tag_id":"clk69d1cu000ajsrjg2v5yc2p","_id":"clk69d1d5000njsrjmjwibejq"},{"post_id":"clk69d1co0007jsrjueopeg9z","tag_id":"clk69d1cy000fjsrjpwwn3d9k","_id":"clk69d1d7000qjsrjzn7vmfis"},{"post_id":"clk69d1cr0008jsrjzpyi2nkr","tag_id":"clk69d1cu000ajsrjg2v5yc2p","_id":"clk69d1dd000xjsrjoohbu1en"},{"post_id":"clk69d1cr0008jsrjzpyi2nkr","tag_id":"clk69d1d7000sjsrjnvyfsw3l","_id":"clk69d1de000yjsrjsjjo6xl1"},{"post_id":"clk69d1cu000bjsrjmbcr74d8","tag_id":"clk69d1dc000wjsrjqlgrbblx","_id":"clk69d1dh0012jsrjsr2t3f16"},{"post_id":"clk69d1cw000cjsrjbdvppaad","tag_id":"clk69d1cu000ajsrjg2v5yc2p","_id":"clk69d1di0016jsrj410xa4rd"},{"post_id":"clk69d1cw000cjsrjbdvppaad","tag_id":"clk69d1dg0011jsrj2m7kz321","_id":"clk69d1di0018jsrjl2av0afs"},{"post_id":"clk69d1cx000djsrjj0t7n5ku","tag_id":"clk69d1di0015jsrjz9ku1n3q","_id":"clk69d1dj001bjsrjyxxrlkma"},{"post_id":"clk69d1d0000gjsrj2eem4h0i","tag_id":"clk69d1dj001ajsrjlmj99la4","_id":"clk69d1dk001fjsrjlzbfm8l4"},{"post_id":"clk69d1d2000hjsrjijp5qtey","tag_id":"clk69d1dc000wjsrjqlgrbblx","_id":"clk69d1dl001ijsrjkbk7rttc"},{"post_id":"clk69d1d5000ljsrjyo1w1f2c","tag_id":"clk69d1dk001hjsrjyji00op0","_id":"clk69d1dl001ljsrjghtwfiv1"},{"post_id":"clk69d1d7000ojsrjakxhwll9","tag_id":"clk69d1dl001kjsrjzxju3k8h","_id":"clk69d1dm001njsrjpv81zwsm"},{"post_id":"clk69d1d9000tjsrjllaqn27b","tag_id":"clk69d1dl001mjsrj44psdza9","_id":"clk69d1dm001ojsrj971cf51i"},{"post_id":"clk69d1e6001pjsrjtf8tagtq","tag_id":"clk69d1dj001ajsrjlmj99la4","_id":"clk69d1e7001rjsrj8mzdb62t"},{"post_id":"clk69d1e6001qjsrjfcp6k092","tag_id":"clk69d1e9001tjsrjj0sym7dx","_id":"clk69d1ei0021jsrjgruhbik2"},{"post_id":"clk69d1e7001sjsrjsn0ti7kd","tag_id":"clk69d1ef001zjsrjpkeduipd","_id":"clk69d1ep0028jsrj22si2mnp"},{"post_id":"clk69d1em0024jsrjkq133zl5","tag_id":"clk69d1dk001hjsrjyji00op0","_id":"clk69d1er002bjsrjvybzj03m"},{"post_id":"clk69d1e9001ujsrje4323ru4","tag_id":"clk69d1en0026jsrjl8l76yx8","_id":"clk69d1es002gjsrjocg8r2zp"},{"post_id":"clk69d1er002ajsrjjgcygu6e","tag_id":"clk69d1cu000ajsrjg2v5yc2p","_id":"clk69d1et002jjsrjshs0jke3"},{"post_id":"clk69d1ec001wjsrjchy36da6","tag_id":"clk69d1es002djsrjz9kke1w7","_id":"clk69d1eu002ojsrjzwcn98y2"},{"post_id":"clk69d1et002mjsrjxfanbqpt","tag_id":"clk69d1dj001ajsrjlmj99la4","_id":"clk69d1ex002pjsrjzuihsvin"},{"post_id":"clk69d1ef001yjsrj9go321lj","tag_id":"clk69d1et002ljsrj66eb6u8g","_id":"clk69d1f0002sjsrj55kzqlh5"},{"post_id":"clk69d1ei0022jsrjqqynsrnr","tag_id":"clk69d1ex002rjsrj0ql4v1eo","_id":"clk69d1f5002wjsrjbzuvmmww"},{"post_id":"clk69d1ei0022jsrjqqynsrnr","tag_id":"clk69d1cu000ajsrjg2v5yc2p","_id":"clk69d1f6002xjsrjcow2d557"},{"post_id":"clk69d1ep0027jsrjxiy9ecg0","tag_id":"clk69d1f3002vjsrjn298omb1","_id":"clk69d1f6002zjsrjrkj0euik"},{"post_id":"clk69d1ep0027jsrjxiy9ecg0","tag_id":"clk69d1cu000ajsrjg2v5yc2p","_id":"clk69d1f60030jsrj49hcaxit"},{"post_id":"clk69d1es002ejsrj0d2n51e2","tag_id":"clk69d1f6002yjsrjm6td1yaq","_id":"clk69d1f60032jsrj6yfvby43"},{"post_id":"clk69d1et002hjsrj155s3jlv","tag_id":"clk69d1f60031jsrjkfycwu2e","_id":"clk69d1f60033jsrjozotddvg"},{"post_id":"clk69d1et002hjsrj155s3jlv","tag_id":"clk69d1cu000ajsrjg2v5yc2p","_id":"clk69d1f60034jsrjole71lig"}],"Tag":[{"name":"linux","_id":"clk69d1cu000ajsrjg2v5yc2p"},{"name":"input","_id":"clk69d1cy000fjsrjpwwn3d9k"},{"name":"imx6ull","_id":"clk69d1d7000sjsrjnvyfsw3l"},{"name":"python","_id":"clk69d1dc000wjsrjqlgrbblx"},{"name":"thread","_id":"clk69d1dg0011jsrj2m7kz321"},{"name":"history","_id":"clk69d1di0015jsrjz9ku1n3q"},{"name":"Embedded system","_id":"clk69d1dj001ajsrjlmj99la4"},{"name":"EMC-EMI","_id":"clk69d1dk001hjsrjyji00op0"},{"name":"gallery-腾格里","_id":"clk69d1dl001kjsrjzxju3k8h"},{"name":"gallery-上海","_id":"clk69d1dl001mjsrj44psdza9"},{"name":"gallery-北京","_id":"clk69d1e9001tjsrjj0sym7dx"},{"name":"gallery-新疆","_id":"clk69d1ef001zjsrjpkeduipd"},{"name":"gallery-深圳梧桐山-毛棉杜鹃","_id":"clk69d1en0026jsrjl8l76yx8"},{"name":"gallery-衡山","_id":"clk69d1es002djsrjz9kke1w7"},{"name":"模块","_id":"clk69d1et002ljsrj66eb6u8g"},{"name":"PIN GPIO","_id":"clk69d1ex002rjsrj0ql4v1eo"},{"name":"tool目录","_id":"clk69d1f3002vjsrjn298omb1"},{"name":"study","_id":"clk69d1f6002yjsrjm6td1yaq"},{"name":"platform","_id":"clk69d1f60031jsrjkfycwu2e"}]}}