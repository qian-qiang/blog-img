{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/robots.txt","path":"robots.txt","modified":0,"renderable":0},{"_id":"themes/matery/source/css/gitment.css","path":"css/gitment.css","modified":0,"renderable":1},{"_id":"themes/matery/source/css/my-gitalk.css","path":"css/my-gitalk.css","modified":0,"renderable":1},{"_id":"themes/matery/source/css/matery.css","path":"css/matery.css","modified":0,"renderable":1},{"_id":"themes/matery/source/css/my.css","path":"css/my.css","modified":0,"renderable":1},{"_id":"themes/matery/source/js/click_show_text.js","path":"js/click_show_text.js","modified":0,"renderable":1},{"_id":"themes/matery/source/js/matery.js","path":"js/matery.js","modified":0,"renderable":1},{"_id":"themes/matery/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/loading.svg","path":"medias/loading.svg","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/aos/aos.css","path":"libs/aos/aos.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/animate/animate.min.css","path":"libs/animate/animate.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/aos/aos.js","path":"libs/aos/aos.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.js","path":"libs/aplayer/APlayer.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.css","path":"libs/aplayer/APlayer.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/codeCopy.js","path":"libs/codeBlock/codeCopy.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/codeBlockFuction.js","path":"libs/codeBlock/codeBlockFuction.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/codeLang.js","path":"libs/codeBlock/codeLang.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/codeShrink.js","path":"libs/codeBlock/codeShrink.js","modified":0,"renderable":1},{"_id":"themes/matery/source/favicon.png","path":"favicon.png","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/clipboard.min.js","path":"libs/codeBlock/clipboard.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/gitalk/gitalk.css","path":"libs/gitalk/gitalk.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/cryptojs/crypto-js.min.js","path":"libs/cryptojs/crypto-js.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.css","path":"libs/dplayer/DPlayer.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/gitment/gitment-default.css","path":"libs/gitment/gitment-default.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","path":"libs/jqcloud/jqcloud-1.0.4.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/jqcloud/jqcloud.css","path":"libs/jqcloud/jqcloud.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/masonry/masonry.pkgd.min.js","path":"libs/masonry/masonry.pkgd.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/others/busuanzi.pure.mini.js","path":"libs/others/busuanzi.pure.mini.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/others/clicklove.js","path":"libs/others/clicklove.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/others/explosion.min.js","path":"libs/others/explosion.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/others/text.js","path":"libs/others/text.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/others/fireworks.js","path":"libs/others/fireworks.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/others/snow.js","path":"libs/others/snow.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/scrollprogress/scrollProgress.min.js","path":"libs/scrollprogress/scrollProgress.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/tocbot/tocbot.css","path":"libs/tocbot/tocbot.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/tocbot/tocbot.min.js","path":"libs/tocbot/tocbot.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/csdn.ico","path":"medias/avatars/csdn.ico","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/9.jpg","path":"medias/featureimages/9.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.js","path":"libs/dplayer/DPlayer.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/gitment/gitment.js","path":"libs/gitment/gitment.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/jquery/jquery-2.2.0.min.js","path":"libs/jquery/jquery-2.2.0.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/valine/Valine.min.js","path":"libs/valine/Valine.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/14.jpg","path":"medias/featureimages/14.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/15.jpg","path":"medias/featureimages/15.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/21.jpg","path":"medias/featureimages/21.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/27.jpg","path":"medias/featureimages/27.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/35.jpg","path":"medias/featureimages/35.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/37.jpg","path":"medias/featureimages/37.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/38.jpg","path":"medias/featureimages/38.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/36.jpg","path":"medias/featureimages/36.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/47.jpg","path":"medias/featureimages/47.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/css/lightgallery.min.css","path":"libs/lightGallery/css/lightgallery.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.eot","path":"libs/lightGallery/fonts/lg.eot","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.ttf","path":"libs/lightGallery/fonts/lg.ttf","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.svg","path":"libs/lightGallery/fonts/lg.svg","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.woff","path":"libs/lightGallery/fonts/lg.woff","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/video-play.png","path":"libs/lightGallery/img/video-play.png","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/materialize/materialize.min.js","path":"libs/materialize/materialize.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/youtube-play.png","path":"libs/lightGallery/img/youtube-play.png","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/materialize/materialize.min.css","path":"libs/materialize/materialize.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/css/share.min.css","path":"libs/share/css/share.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/vimeo-play.png","path":"libs/lightGallery/img/vimeo-play.png","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.eot","path":"libs/share/fonts/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/js/lightgallery-all.min.js","path":"libs/lightGallery/js/lightgallery-all.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.svg","path":"libs/share/fonts/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/js/jquery.share.min.js","path":"libs/share/js/jquery.share.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.woff","path":"libs/share/fonts/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/valine/av-min.js","path":"libs/valine/av-min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/js/social-share.min.js","path":"libs/share/js/social-share.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.ttf","path":"libs/share/fonts/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/1.jpg","path":"medias/featureimages/1.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/0.jpg","path":"medias/featureimages/0.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/10.jpg","path":"medias/featureimages/10.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/11.jpg","path":"medias/featureimages/11.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/16.jpg","path":"medias/featureimages/16.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/2.jpg","path":"medias/featureimages/2.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/20.jpg","path":"medias/featureimages/20.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/24.jpg","path":"medias/featureimages/24.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/29.jpg","path":"medias/featureimages/29.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/28.jpg","path":"medias/featureimages/28.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/31.jpg","path":"medias/featureimages/31.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/23.jpg","path":"medias/featureimages/23.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/30.jpg","path":"medias/featureimages/30.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/33.jpg","path":"medias/featureimages/33.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/39.jpg","path":"medias/featureimages/39.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/43.jpg","path":"medias/featureimages/43.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/41.jpg","path":"medias/featureimages/41.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/46.jpg","path":"medias/featureimages/46.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/6.jpg","path":"medias/featureimages/6.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/music/avatars/不见就散-周深.jpg","path":"medias/music/avatars/不见就散-周深.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/music/avatars/平凡之路-朴树.jpg","path":"medias/music/avatars/平凡之路-朴树.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/8.jpg","path":"medias/featureimages/8.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/reward/wechat.jpg","path":"medias/reward/wechat.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/awesome/css/font-awesome.min.css","path":"libs/awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff2","path":"libs/awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/loading.gif","path":"libs/lightGallery/img/loading.gif","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/5.jpg","path":"medias/banner/5.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/13.jpg","path":"medias/featureimages/13.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/26.jpg","path":"medias/featureimages/26.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/25.jpg","path":"medias/featureimages/25.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/3.jpg","path":"medias/featureimages/3.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/32.jpg","path":"medias/featureimages/32.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/34.jpg","path":"medias/featureimages/34.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/4.jpg","path":"medias/featureimages/4.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/45.jpg","path":"medias/featureimages/45.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/7.jpg","path":"medias/featureimages/7.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/5.jpg","path":"medias/featureimages/5.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/48.jpg","path":"medias/featureimages/48.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/logo.png","path":"medias/logo.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/reward/alipay.jpg","path":"medias/reward/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/FontAwesome.otf","path":"libs/awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff","path":"libs/awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/22.jpg","path":"medias/featureimages/22.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.eot","path":"libs/awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/6.jpg","path":"medias/banner/6.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/18.jpg","path":"medias/featureimages/18.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/17.jpg","path":"medias/featureimages/17.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/44.jpg","path":"medias/featureimages/44.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/42.jpg","path":"medias/featureimages/42.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/1.jpg","path":"medias/banner/1.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/2.jpg","path":"medias/banner/2.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/4.jpg","path":"medias/banner/4.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/0.jpg","path":"medias/banner/0.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/12.jpg","path":"medias/featureimages/12.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/40.jpg","path":"medias/featureimages/40.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/music/avatars/每天爱你多一些.jpg","path":"medias/music/avatars/每天爱你多一些.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.ttf","path":"libs/awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/myzhihu.png","path":"medias/avatars/myzhihu.png","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.svg","path":"libs/awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/echarts/echarts.min.js","path":"libs/echarts/echarts.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/49.jpg","path":"medias/featureimages/49.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/gitalk/gitalk.min.js","path":"libs/gitalk/gitalk.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/3.jpg","path":"medias/banner/3.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/music/不见就散-周深.mp3","path":"medias/music/不见就散-周深.mp3","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/music/每天爱你多一些-张学友.mp3","path":"medias/music/每天爱你多一些-张学友.mp3","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/music/平凡之路-朴树.mp3","path":"medias/music/平凡之路-朴树.mp3","modified":0,"renderable":1}],"Cache":[{"_id":"source/404.md","hash":"d97f69ff63501de89cfd341c68e4d6ed5c8a5b3a","modified":1704442339068},{"_id":"source/CNAME","hash":"4740c94df1240b26efd774d065f3ae8ef5c24b7c","modified":1704442339068},{"_id":"source/robots.txt","hash":"66078f56462509b9624be31d3e78ae2b62a33b60","modified":1704442339888},{"_id":"themes/matery/.gitignore","hash":"eaa3d84cb77d92a21b111fd1e37f53edc1ff9de0","modified":1704442339889},{"_id":"themes/matery/LICENSE","hash":"b314c7ebb7d599944981908b7f3ed33a30e78f3a","modified":1704442339889},{"_id":"themes/matery/_config.yml","hash":"3ce77c10b8c00ae71d885033e2549c3c469c00c7","modified":1704509068665},{"_id":"source/_data/musics.json","hash":"a71f3c0d7d26198c603f31f9330689f588c5ce7c","modified":1704442339069},{"_id":"source/about/index.md","hash":"96d9476c3fe43e256a6905c2207b9f0297a99759","modified":1704442339886},{"_id":"source/archives/index.md","hash":"44f160ecdfe402aa2f95a4ef60a148455546510f","modified":1704442339886},{"_id":"source/categories/index.md","hash":"233719b02b933f94997afb6b8fd923c64628f14a","modified":1704442339887},{"_id":"source/contact/index.md","hash":"fa30c3540f4dfd0cc24e6668295bd1e96cd25273","modified":1704442339887},{"_id":"source/gallery/index.md","hash":"fa1dd55c15f711e184f79e62a0148394a31cf726","modified":1704442339887},{"_id":"source/tags/index.md","hash":"43197f904879a562e29b5fc45278b4f23d4e2449","modified":1704442339888},{"_id":"themes/matery/languages/default.yml","hash":"71b8537cb25e733d599f84d5c23374fda5e8b0b3","modified":1704442339890},{"_id":"themes/matery/languages/zh-CN.yml","hash":"ad6cbb7a6be43e2458370f39d36e2c2cc957122e","modified":1704442339891},{"_id":"themes/matery/layout/404.ejs","hash":"f08a0f507b36f3652520a41381f71167488405c7","modified":1704442339891},{"_id":"themes/matery/layout/about.ejs","hash":"e87752e59f021b5139b1155a264da11ab469a9aa","modified":1704442339906},{"_id":"themes/matery/layout/archive.ejs","hash":"1b5023571894404d75caffa28128fc9c49f9095d","modified":1704442339906},{"_id":"themes/matery/layout/category.ejs","hash":"2d421e10c3b8fd2c4f725e5eaa967c4a1429c707","modified":1704442339907},{"_id":"themes/matery/layout/gallery.ejs","hash":"3b84306e561620fd5b46d70fd22e1927f2a87c00","modified":1704442339908},{"_id":"themes/matery/layout/categories.ejs","hash":"c431e772d0f7700592228bbd9502793bdc28a893","modified":1704442339906},{"_id":"themes/matery/layout/contact.ejs","hash":"1513c5a40b7cc0b6e5854cf8c3253958bcb486cb","modified":1704442339908},{"_id":"themes/matery/layout/index.ejs","hash":"eeefbe57221a50e048efec133b626067d1453493","modified":1704442339908},{"_id":"themes/matery/layout/layout.ejs","hash":"e0570e96251c219e7d973739b41a8b3accbbfa82","modified":1704442339909},{"_id":"themes/matery/layout/tag.ejs","hash":"5cdf3a1d72f54285ee9cb826fd0e4a0449093215","modified":1704442339909},{"_id":"themes/matery/layout/post.ejs","hash":"f1a35f32e5901e167ae9a750e7cb3635549cea2e","modified":1704442339909},{"_id":"themes/matery/layout/tags.ejs","hash":"851c0ee599e91e7b1d657673859e8b6ff79cf50b","modified":1704442339910},{"_id":"themes/matery/layout/_partial/back-top.ejs","hash":"cb99dc352397ec5d0765794d7b8884972e61973b","modified":1704442339892},{"_id":"themes/matery/layout/_partial/bg-cover.ejs","hash":"d5a7b9bb96e04c0a3485dd873748f19c50a6a04f","modified":1704442339893},{"_id":"themes/matery/layout/_partial/disqus.ejs","hash":"42dda8e67f7f09d148347887e52f18aea546df26","modified":1704442339893},{"_id":"themes/matery/layout/_partial/footer.ejs","hash":"4fd2d22639101ca608086f710a18557dce4e8bf4","modified":1704442339893},{"_id":"themes/matery/layout/_partial/gitalk.ejs","hash":"a3a140e6aeeb6f289e4b821a577ef548267f3de1","modified":1704442339893},{"_id":"themes/matery/layout/_partial/gitment.ejs","hash":"d8c40dbc8106b5bc53ceb727ad968c1d8f234261","modified":1704442339894},{"_id":"themes/matery/layout/_partial/google-analytics.ejs","hash":"890c8f04c1f4905dfceb3ea9fd6efdd040d79c01","modified":1704442339894},{"_id":"themes/matery/layout/_partial/bg-cover-content.ejs","hash":"d6f4bcc03b6c7479302b655dc0f359fd0b5fd166","modified":1704442339892},{"_id":"themes/matery/layout/_partial/github-link.ejs","hash":"fd4034bca2eb3987dcf113e6477260bee97eb1e7","modified":1704442339894},{"_id":"themes/matery/layout/_partial/header.ejs","hash":"821e1af65990521c9e0288178d8e5b18c73a9cab","modified":1704442339895},{"_id":"themes/matery/layout/_partial/head.ejs","hash":"c0f1bb86251e1d1c80fee9bea7b23c35449931ba","modified":1704442339895},{"_id":"themes/matery/layout/_partial/livere.ejs","hash":"42728561c09589f79b698eb059ab4def53ed3642","modified":1704442339895},{"_id":"themes/matery/layout/_partial/index-cover.ejs","hash":"d4042e5521ceb5f3255cd4455ac7ccd227fee6df","modified":1704442339895},{"_id":"themes/matery/layout/_partial/mobile-nav.ejs","hash":"df566e67777682043d7dcae74db74773edf98b26","modified":1704442339896},{"_id":"themes/matery/layout/_partial/navigation.ejs","hash":"12de964b0ba9821b2dec881d28716e3c50c92c98","modified":1704442339896},{"_id":"themes/matery/layout/_partial/paging.ejs","hash":"dfdeea9c59d157acb851d4bf44bf95f81787523c","modified":1704442339896},{"_id":"themes/matery/layout/_partial/post-cover.ejs","hash":"166c0b9753f3f913bd801e82ad5b268004be198d","modified":1704442339896},{"_id":"themes/matery/layout/_partial/post-detail-toc.ejs","hash":"82cb8090cde663fa7ad67418a802997b3057e957","modified":1704442339897},{"_id":"themes/matery/layout/_partial/post-detail.ejs","hash":"3f208f33e4e12becdb8323e6e64e20ad60c3fb2a","modified":1704442339897},{"_id":"themes/matery/layout/_partial/post-statis.ejs","hash":"3b42900247d5ea4ea5b68e2be44420a0d54785ad","modified":1704442339897},{"_id":"themes/matery/layout/_partial/search.ejs","hash":"e859fe6e0259e0c123cb7ceda6e4cac836318ffc","modified":1704442339900},{"_id":"themes/matery/layout/_partial/share.ejs","hash":"0f2e1e27d21492cf228e786daead985b1e1dcea4","modified":1704442339900},{"_id":"themes/matery/layout/_partial/prev-next.ejs","hash":"4e73f10eacb5d00a0681cb44fe5c039cd8ab03cd","modified":1704442339898},{"_id":"themes/matery/layout/_partial/reprint-statement.ejs","hash":"f85a222ec3f9bc27eb7978015e63a16514b38791","modified":1704442339898},{"_id":"themes/matery/layout/_partial/reward.ejs","hash":"73624d9db81e87ff0c12310bb873fbd0b5221021","modified":1704442339898},{"_id":"themes/matery/layout/_partial/social-link.ejs","hash":"a0c1d6a79e085392d8c46db3081a162b4e9b362a","modified":1704442339901},{"_id":"themes/matery/layout/_partial/valine.ejs","hash":"be0717a664172ec1e903d654fa6153a8468a7e47","modified":1704442339901},{"_id":"themes/matery/layout/_widget/category-cloud.ejs","hash":"b2b22d4fc4e46b051f67216c391f629f4ff552b5","modified":1704442339901},{"_id":"themes/matery/layout/_widget/dream.ejs","hash":"6ae58a57b83a5999d0b6a737ec868f084d208f89","modified":1704442339902},{"_id":"themes/matery/layout/_widget/category-radar.ejs","hash":"5284712d84bbaa4f0d88026ac3ec5a8c13e00056","modified":1704442339902},{"_id":"themes/matery/layout/_widget/gallery-wordcloud.ejs","hash":"e822ad2371ec9c884ece5cee38c55549131998fc","modified":1704442339902},{"_id":"themes/matery/layout/_widget/music.ejs","hash":"fc50cb4bbc1f4d0e4c9f5941f1c3c74bea742db7","modified":1704442339902},{"_id":"themes/matery/layout/_widget/my-gallery.ejs","hash":"9ea672db65f1e5b8fad1ffafb1614f25adc97e63","modified":1704442339903},{"_id":"themes/matery/layout/_widget/my-projects.ejs","hash":"785cb588a31215876f6737213054ba0e8552fff0","modified":1704442339904},{"_id":"themes/matery/layout/_widget/my-skills.ejs","hash":"c6f713316ce75ad08ac5d1587bd8ce42e894e9ae","modified":1704442339904},{"_id":"themes/matery/layout/_widget/post-calendar.ejs","hash":"4608af6151f0e32f668c89f09343748340021478","modified":1704442339904},{"_id":"themes/matery/layout/_widget/post-charts.ejs","hash":"0aaf0a111b9aa07ff37f6286eeac5506283f47f8","modified":1704442339904},{"_id":"themes/matery/layout/_widget/recommend.ejs","hash":"d439d86818de179d64965d4f7f5fa56147fd9221","modified":1704442339905},{"_id":"themes/matery/layout/_widget/tag-cloud.ejs","hash":"a4f13bb4d6e6ded29ded8da4cff3ca444d38d242","modified":1704442339905},{"_id":"themes/matery/layout/_widget/tag-wordcloud.ejs","hash":"bf604fe9c435f0fb9a559cac9c35772579b590e8","modified":1704442339905},{"_id":"themes/matery/layout/_widget/video.ejs","hash":"05f5e2acace5730cdf7bed650375ad88f6b5d1b7","modified":1704442339906},{"_id":"themes/matery/source/css/gitment.css","hash":"d5ef623065d1fbc897119f7b70ccf7563e329917","modified":1704442339911},{"_id":"themes/matery/source/css/my-gitalk.css","hash":"4e3e855767ac5a48b13af1d6a42df13d8975e03f","modified":1704442339912},{"_id":"themes/matery/source/css/matery.css","hash":"8f3296db41c70bf585b81e4c02a01fd7aaec9c43","modified":1704442339911},{"_id":"themes/matery/source/css/my.css","hash":"9ea83dca2da8263cfc40d683d3ecd7d91009dc1d","modified":1704442339912},{"_id":"themes/matery/source/js/click_show_text.js","hash":"7064ddfbcff292b79a3da070f62077dc484c1cfc","modified":1704442339915},{"_id":"themes/matery/source/js/matery.js","hash":"e688f9cf87aa5ff6655c3140817de3fb4c3a9ae7","modified":1704442339915},{"_id":"themes/matery/source/js/search.js","hash":"77ecae23dd3edd8ad962c5b12954652bb2f7a1b6","modified":1704442339915},{"_id":"themes/matery/source/medias/loading.svg","hash":"ba1375eb3d08353e70f8349eb586da9601355c9e","modified":1704442340045},{"_id":"source/_posts/2022/01/IMX6ull-移植-lVGL总结.md","hash":"83de5c166bdcc5e131b8a2c0c9de67fd6c5bdc23","modified":1704442339070},{"_id":"source/_posts/2022/01/Linux-input子系统.md","hash":"c3ca4c98483ca6a6ec2db99ff9748d3899fc1d91","modified":1704442339080},{"_id":"source/_posts/2022/01/linux线程.md","hash":"3ef62faf021ffaa2490b258f0337d10149ec4384","modified":1704442339084},{"_id":"source/_posts/2022/01/python使用百度翻译的API.md","hash":"b58d665f8356e305884600747c1f7540d82c95ca","modified":1704442339086},{"_id":"source/_posts/2022/01/中华通史-上古史-夏.md","hash":"7b5b90dda0f3021904f7c67000cf3979f496797b","modified":1704442339094},{"_id":"source/_posts/2022/01/菜鸟应该如何开始设计一个项目的嵌入式软件架构.md","hash":"67419d88593364383c4205d9d65379fea6d095e8","modified":1704442339101},{"_id":"source/_posts/2022/01/超详细解析python爬取外网图片.md","hash":"30f26a8fa211c6ee8b784b075cdeab3f7ee45bdd","modified":1704442339110},{"_id":"source/_posts/2023/04/EMC-EMI.md","hash":"ca38201dad6d279be92598c994b2db5cbc0e9c1b","modified":1704442339122},{"_id":"source/_posts/2023/04/ten-ge-li.md","hash":"329ac45115c598ef60c852f792126578d0417e4c","modified":1704442339138},{"_id":"source/_posts/2023/04/上海.md","hash":"5121691bd416c8f2f19c7d96aa21667749c30369","modified":1704442339338},{"_id":"source/_posts/2023/04/业务功能-业务流程-业务规则分析.md","hash":"9b7cc4b7b75a8b482f5131d29ac75ef2ca3f23cd","modified":1704442339467},{"_id":"source/_posts/2023/04/北京.md","hash":"cc049e56b755a5f85afcc1dc5fec4151ecbac25b","modified":1704442339483},{"_id":"source/_posts/2023/04/新疆.md","hash":"7cdf1eeeba468c3e63e36911f034ddea564b83fb","modified":1704442339518},{"_id":"source/_posts/2023/04/深圳梧桐山-毛棉杜鹃.md","hash":"7a514a8e5304b9890672f735c41dbfad72ee1106","modified":1704442339710},{"_id":"source/_posts/2023/04/衡山.md","hash":"042251a8f68edcdb10037604991f9c126ad5fd48","modified":1704442339738},{"_id":"source/_posts/2023/05/PIN-GPIO.md","hash":"4f10171c37663d9c7acb3db8437acaea03d12dfa","modified":1704442339754},{"_id":"source/_posts/2023/05/单链表-报警模块.md","hash":"bef735284a562f11233716ee60868efa7432ef57","modified":1704442339764},{"_id":"source/_posts/2023/05/提升EMC的软件编程策略.md","hash":"6543299ce3811032f75629e54a7e7ac7708d1beb","modified":1704442339764},{"_id":"source/_posts/2023/06/linux内核-tool目录.md","hash":"fefd5e19008c25e4a2e7fca95b16eca95392298e","modified":1704442339765},{"_id":"source/_posts/2023/06/ttymxx-UART.md","hash":"235f8ae389c5d62c18fb5e70d4637d3406d27d34","modified":1704442339767},{"_id":"source/_posts/2023/06/url.md","hash":"d8212a6bf40a983c628a0abdd8686b661b7acb57","modified":1704442339774},{"_id":"source/_posts/2023/07/linux-platform.md","hash":"727d10cf9132a3897235782a4a413b4f6b5d90e0","modified":1704442339775},{"_id":"source/_posts/2023/07/嵌入式软件框架方案.md","hash":"6b63af9e2779b4cce7091cbb2b6b49be0b4db9be","modified":1704442339791},{"_id":"source/_posts/2023/08/kill命令.md","hash":"9c6349dfa29131b0e06b4a81b111344ddf16227e","modified":1704442339803},{"_id":"source/_posts/2023/08/process-dbus-daemon.md","hash":"16724bca310dacf2f88d81be835584de5cec86ef","modified":1704442339803},{"_id":"source/_posts/2023/08/process-init.md","hash":"33507d8de48a9b61b4982e6f86d1c9d922349796","modified":1704442339806},{"_id":"source/_posts/2023/08/process-ksoftirqd.md","hash":"e7b231bdbaf4e25d23c506485299091ca266a73b","modified":1704442339806},{"_id":"source/_posts/2023/08/process-kthreadd.md","hash":"f8e348f1dd83611f5e87f334e94dff74047804ef","modified":1704442339808},{"_id":"source/_posts/2023/08/process-kworker.md","hash":"50463b3c90b1dbc3a3c1a86e4655104be4287c02","modified":1704442339808},{"_id":"source/_posts/2023/08/process-udev.md","hash":"41636cfdb3e9959979411b8b8cd6a3037fb6c263","modified":1704442339809},{"_id":"source/_posts/2023/08/process-syslogd-klogd.md","hash":"67843cf620ef5a9b8bc16ccf36dec6a3f0d36ab3","modified":1704442339809},{"_id":"source/_posts/2023/08/process-watchdog.md","hash":"7000426f481e7a39cca1803dac52cb14d5fc22e7","modified":1704442339810},{"_id":"source/_posts/2023/08/语法指导翻译器.md","hash":"8ca3dcb0526ad8465567ea0865f22892d0c89034","modified":1704442339810},{"_id":"source/_posts/2023/09/Design-Inputs-Outputs-for-Medical-Device.md","hash":"95af0a1412eaa1270892b2d01105f7cc24697580","modified":1704442339837},{"_id":"source/_posts/2023/09/Medical-device-registration-standards.md","hash":"7e1d4dc7e0f9e2b2d8b778609b947683d6da3604","modified":1704442339847},{"_id":"source/_posts/2023/09/process-dropbear.md","hash":"71d5d6238166b98484c90a45a4209eabcacbdf28","modified":1704442339869},{"_id":"source/_posts/2023/09/日落.md","hash":"18c9c9f60fb4aacfcc6730453eb79e3557af1c3b","modified":1704442339870},{"_id":"source/_posts/2024/01/FPGA基本单元.md","hash":"87b1db53f1a004671d96a747e4eb409982474ab8","modified":1706236952548},{"_id":"source/_posts/2024/01/I2C半高电平.md","hash":"37823d6c9b04cdaa9f4c4d9e97d8b58d2f5360fa","modified":1704528760396},{"_id":"source/_posts/2024/01/Quartus-FPGA-Debug.md","hash":"0a25c363ccd2c955366e50600c823b79663d635d","modified":1704507121807},{"_id":"source/_posts/2024/01/时序约束整理.md","hash":"108042273b1e4fa8d40191bc64e9df6a21786e57","modified":1705393977656},{"_id":"themes/matery/source/libs/aos/aos.css","hash":"ded9739f803d114c9168d3351fded72b3b478b4c","modified":1704442339917},{"_id":"themes/matery/source/libs/animate/animate.min.css","hash":"5dfcbcee866e9dc564916416281885f3e320871e","modified":1704442339916},{"_id":"themes/matery/source/libs/aos/aos.js","hash":"5a8e6d07ffa55642418ab3fd4b263aa08284b77a","modified":1704442339917},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.js","hash":"70c0c4a9bf698747b7c058c21287ad617355e5dd","modified":1704442339919},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.css","hash":"7f4f8913f2d46ade2def5134e2cc8684a4b87939","modified":1704442339918},{"_id":"themes/matery/source/libs/codeBlock/codeCopy.js","hash":"d54f6205b35dceba1d66da761c00ff9fad9cf857","modified":1704442339932},{"_id":"themes/matery/source/libs/codeBlock/codeBlockFuction.js","hash":"a8133367d48199e7505c2d831ca848b4202b9ba6","modified":1704442339931},{"_id":"themes/matery/source/libs/codeBlock/codeLang.js","hash":"6ad8984746f0ff4e2fc81f0c04f12874fa752683","modified":1704442339932},{"_id":"themes/matery/source/libs/codeBlock/codeShrink.js","hash":"743114dcd6f3addc973778b1b248f88d42b05278","modified":1704442339932},{"_id":"themes/matery/source/favicon.png","hash":"6fee8f6cf28858211c47939cb172633b18d1eee1","modified":1704442339914},{"_id":"themes/matery/source/libs/codeBlock/clipboard.min.js","hash":"98f626d784a94ebe653b13f3a4c79e483264cae7","modified":1704442339931},{"_id":"themes/matery/source/libs/gitalk/gitalk.css","hash":"021898a16279ac2ffe75af4f902fab2a0a39f11a","modified":1704442339940},{"_id":"themes/matery/source/libs/cryptojs/crypto-js.min.js","hash":"33810b2b757fc4327bc1d3b83bb5e0d3dc1fec5b","modified":1704442339933},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.css","hash":"5d52d3b34fceb9d7e11f1beaf7ed380b4249dec4","modified":1704442339934},{"_id":"themes/matery/source/libs/gitment/gitment-default.css","hash":"a0625d8b432af8bdc820f8768d36cde439e7257c","modified":1704442339944},{"_id":"themes/matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"26849509f196a2d21bbfd15696e5d5153163b8f1","modified":1704442339945},{"_id":"themes/matery/source/libs/jqcloud/jqcloud.css","hash":"4e6538c8312aeeab845d361c37a8c1a0931241f0","modified":1704442339946},{"_id":"themes/matery/source/libs/masonry/masonry.pkgd.min.js","hash":"f81cd7bfcf7aa2d043bd3e6077df42656fc44b82","modified":1704442339952},{"_id":"themes/matery/source/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1704442339955},{"_id":"themes/matery/source/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1704442339955},{"_id":"themes/matery/source/libs/others/explosion.min.js","hash":"5b76fa72a85cfb27d54b00128393ece773d65386","modified":1704442339955},{"_id":"themes/matery/source/libs/others/text.js","hash":"fdf18f65977e4bc358dfb5fb0b7c98492ae72efd","modified":1704442339956},{"_id":"themes/matery/source/libs/others/fireworks.js","hash":"e9c74f2dd3953d4d8dec44e9977574d00702e84d","modified":1704442339956},{"_id":"themes/matery/source/libs/others/snow.js","hash":"b393f069781eef788a0ae66b2681cece8fea2851","modified":1704442339956},{"_id":"themes/matery/source/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1704442339957},{"_id":"themes/matery/source/libs/tocbot/tocbot.css","hash":"f646f2bb75bcd1eb65b2788ac7bf15d4fd243ce9","modified":1704442339962},{"_id":"themes/matery/source/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1704442339963},{"_id":"themes/matery/source/medias/avatars/csdn.ico","hash":"fff55f10e98084a888ac0b346ccdf0dbaad2ccb1","modified":1704442339966},{"_id":"themes/matery/source/medias/featureimages/9.jpg","hash":"2e1ac235e6a6d80dbed651f993f319c1ed4b5925","modified":1704442340043},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.js","hash":"82276be41d2001e820020a219b90ad5b026302d1","modified":1704442339934},{"_id":"themes/matery/source/libs/gitment/gitment.js","hash":"5a13983930b019450e4fe01a407c64b3dd316be4","modified":1704442339945},{"_id":"themes/matery/source/libs/jquery/jquery-2.2.0.min.js","hash":"7a551393b8360731104fdef1af36a6f3638f5855","modified":1704442339947},{"_id":"themes/matery/source/libs/valine/Valine.min.js","hash":"f1558f12d96a352e490166d543a8e821dd3bb2bc","modified":1704442339964},{"_id":"themes/matery/source/medias/featureimages/14.jpg","hash":"164bda04d4ef6ae75f149c2e822d0d0f0b79e15c","modified":1704442339995},{"_id":"themes/matery/source/medias/featureimages/15.jpg","hash":"867c9882842f84290ba173292d551a626106a45d","modified":1704442339996},{"_id":"themes/matery/source/medias/featureimages/21.jpg","hash":"9ad4b78782e69f0ace50f76daa7a4bd687738332","modified":1704442340003},{"_id":"themes/matery/source/medias/featureimages/27.jpg","hash":"ea65367dab59059c343cd0a211f41ca4bd0dc2c9","modified":1704442340009},{"_id":"themes/matery/source/medias/featureimages/35.jpg","hash":"2f001a7d045a952ba059eb3575664347ebbf4d1f","modified":1704442340019},{"_id":"themes/matery/source/medias/featureimages/37.jpg","hash":"515fd43e0acddf316a5753ea1cdc259c9571eec6","modified":1704442340021},{"_id":"themes/matery/source/medias/featureimages/38.jpg","hash":"fc728ac4c69d06e911bbc4d6cba9c9ef1b158b9f","modified":1704442340022},{"_id":"themes/matery/source/medias/featureimages/36.jpg","hash":"a71a869c98c68123e94706fa970333235990f0ab","modified":1704442340020},{"_id":"themes/matery/source/medias/featureimages/47.jpg","hash":"ee4de6373759e67d96c0fe7237620ccdd190f188","modified":1704442340033},{"_id":"source/_posts/2022/01/IMX6ull-移植-lVGL总结/2909691-20220928153140065-1807119912.png","hash":"81814544b47e2371c6174d2d78a40c6dc1ec97ee","modified":1704442339077},{"_id":"source/_posts/2022/01/IMX6ull-移植-lVGL总结/2909691-20220928153451220-1274979267.png","hash":"38e44ea1bf27b199f03e40d3fbb31ca92a9560b1","modified":1704442339079},{"_id":"source/_posts/2022/01/Linux-input子系统/2909691-20220819094250974-180404869.webp","hash":"f2c6a92fb8d6c71167d08db4814ac8978264f149","modified":1704442339082},{"_id":"source/_posts/2022/01/Linux-input子系统/2909691-20220819102740731-2036281828.png","hash":"620ca1c5e896674be2123b19c639bc542af82caf","modified":1704442339083},{"_id":"source/_posts/2022/01/Linux-input子系统/input_logical.png","hash":"745413f59d688e5a390a23fc26d5cbba1bee74bf","modified":1704442339083},{"_id":"source/_posts/2022/01/linux线程/2909691-20221018201940242-320806714.png","hash":"e303ca7352b7cb92f2f9a6e68a42a53f40f0a5e0","modified":1704442339085},{"_id":"source/_posts/2022/01/linux线程/2909691-20221018202536805-171723429.png","hash":"19ee436b75c2365a5d9b0fe3692a743a6e49c952","modified":1704442339085},{"_id":"source/_posts/2022/01/linux线程/2909691-20221018204634847-2097816257.png","hash":"11e873440e4adc189ebe3f537f9ef2e5e95e30ba","modified":1704442339085},{"_id":"source/_posts/2022/01/python使用百度翻译的API/20200302115943813.png","hash":"d732381420174bf2f792dc34b3f5b3b56bfc2fe8","modified":1704442339093},{"_id":"source/_posts/2022/01/python使用百度翻译的API/20200302120105912.png","hash":"60d73aec104782b1e3626b0ae5b695e6b2f44134","modified":1704442339093},{"_id":"source/_posts/2022/01/菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329193127889.jpg","hash":"7a0511fab61dec9617ff13e3e30955a7b37f0930","modified":1704442339102},{"_id":"source/_posts/2022/01/菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329195920218.jpg","hash":"20699b111e09083edc68e80f86e2238c4c5b703d","modified":1704442339102},{"_id":"source/_posts/2022/01/菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329200632579.png","hash":"cd08c7532ef0acf9b9406d0794195926408d8b0a","modified":1704442339103},{"_id":"source/_posts/2022/01/菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329202358795.png","hash":"cdfc62f3ea8e38679c1a804d2aad822b1bcc1a36","modified":1704442339107},{"_id":"source/_posts/2022/01/菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329202548677.png","hash":"af1c46bdb03c03fa55002639807e158ac3ab6868","modified":1704442339107},{"_id":"source/_posts/2022/01/菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329203335481.png","hash":"d8ae5f3ea833f6f627c8d7006a0a886753a3b908","modified":1704442339109},{"_id":"source/_posts/2023/04/EMC-EMI/2023-04-04_19-32-29.png","hash":"5cf52b16fc4970dd256fb8ab707a8988e6fea828","modified":1704442339129},{"_id":"source/_posts/2023/04/EMC-EMI/2023-04-04_19-33-48.png","hash":"e5f260152656763228b8ef179d47a2ad485802f9","modified":1704442339133},{"_id":"source/_posts/2023/04/业务功能-业务流程-业务规则分析/分析起步.png","hash":"f597a655cc0aff1ed6aaf5a19380957ba362fde6","modified":1704442339477},{"_id":"source/_posts/2023/04/业务功能-业务流程-业务规则分析/模板.png","hash":"e67a71845dfd7a98e4959b97df24d50a8da41177","modified":1704442339480},{"_id":"source/_posts/2023/04/新疆/2d25bdf0ce35910c874badcedff928002.JPG","hash":"dfb9275edaa0886abb505911f112165b5aea21e1","modified":1704442339526},{"_id":"source/_posts/2023/06/linux内核-tool目录/tool目录.png","hash":"e0941cce6adf15e087d9484b4e126716ae2549f6","modified":1704442339767},{"_id":"source/_posts/2023/07/linux-platform/device-driver.png","hash":"d1a74b75fbd655681620df04a09a2a81e07060e2","modified":1704442339775},{"_id":"source/_posts/2023/07/嵌入式软件框架方案/22c7469876239933b38a12a32e9c6f16.png","hash":"e0ac3751ad221d95718ae7ff26ebf073bb9594f1","modified":1704442339792},{"_id":"source/_posts/2023/07/嵌入式软件框架方案/60a0b6815e87242adbc049d64b96e01b.png","hash":"d57950b2bab69769bd372eb0ab86a71f7cb28d27","modified":1704442339794},{"_id":"source/_posts/2023/07/嵌入式软件框架方案/780552b6b4ceacfe274a8c687b74a569.png","hash":"579c26e4342cdae2ba4404f04781a4b4839e4dc7","modified":1704442339796},{"_id":"source/_posts/2023/07/嵌入式软件框架方案/dc4e3ddfdab5a0456af40df7d0a9238b.png","hash":"782eae366eeb181d32de302b4d0f4416a6fefbfc","modified":1704442339799},{"_id":"source/_posts/2023/07/嵌入式软件框架方案/e7176066eab77c0cf6e147aed0046ea7.png","hash":"63576e1bd997584873acae29976472105d199fdb","modified":1704442339800},{"_id":"source/_posts/2023/09/Design-Inputs-Outputs-for-Medical-Device/2023-09-13_17-08-45.png","hash":"37c5926ce3237d710110c276af89efdaf38fb887","modified":1704442339838},{"_id":"source/_posts/2023/09/Design-Inputs-Outputs-for-Medical-Device/2023-09-13_17-14-12.png","hash":"84e25bad9a455064645a029b0d4c18437059a743","modified":1704442339838},{"_id":"source/_posts/2023/09/日落/微信图片_20230912150610.jpg","hash":"127d4aa98cfb06b83ffb05514efae72740a15a67","modified":1704442339881},{"_id":"source/_posts/2024/01/FPGA基本单元/direct_link_connection.png","hash":"290aca378d4dcd6bc8308854ed289a4f16d55441","modified":1706235369404},{"_id":"source/_posts/2024/01/I2C半高电平/picture3.jpg","hash":"3665d2c4aa7146fa4806dc977e8e11482fe2dc25","modified":1704444268890},{"_id":"source/_posts/2024/01/I2C半高电平/picture4.jpg","hash":"c3c5abe541214c9b12a9e169b2c0ca83761f1a2b","modified":1704444326149},{"_id":"source/_posts/2024/01/时序约束整理/FourPathConstraints.png","hash":"cc2cdce9638ecd8178591ddb16797dfae6e7926c","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/DataArrivalTimeHold.png","hash":"92ddfd9af047e7e1c88422f1814e5cf49dfd5b37","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/DataPathRequirementCalculation.png","hash":"87142b4c14e57a2180cb4e57202adc71dc3afae2","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/GeneratedClcokConstraints.png","hash":"b8085cccbfc14dc10b1ae3677b5992632d61b0b8","modified":1605600614000},{"_id":"source/_posts/2024/01/I2C半高电平/picture5.jpg","hash":"d066721bd06414aa6c4e338a3352c3c8e504dcbd","modified":1704444394167},{"_id":"source/_posts/2024/01/时序约束整理/GeneratedClcokPath.png","hash":"3464c15c671d54a1aab04028c4c57554036fe806","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/GeneratedClockEdgeShiftConstraints.png","hash":"2af04b3e906bc7987cde6b8828d3972df6250239","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/GeneratedClockEdgeShiftPath.png","hash":"fb504b1b563b7df2ec6a9ceddfe296d0addcbc86","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/GeneratedClockSourceClock.png","hash":"5dc47958daf1ad06096eb3a1312a6f7b1f86096d","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/HoldPathRequirement.png","hash":"36c2059852796d17f131ec06ccea145c0f1652d6","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/HoldupExample.png","hash":"9b067ebf2a432ea950606ac8632c4792e02736a8","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/Min_Input_Delay.png","hash":"df8f91b9d3f5eb48b26bf45a72bcc1bb570a6be7","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/LaunchEdgeCaptureEdge.png","hash":"39fa93dc64cc873871c644b420dd25cc51c3defa","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/PrimaryClockConstraints.png","hash":"d1f3b126a602a8a819d37461b1e9ad3955183f28","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/PrimaryClockConstraints2.png","hash":"b5599991d88c6cde89f58e21e418f1b78b5286c8","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/PrimaryClockPath2.png","hash":"3d89833353ad9b2ea902f70ac316ee759d17779e","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/PrimaryClockPath.png","hash":"2d963d5cb1ff4ea164f9406a6d09b886773c2932","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/PrimaryClockConstraintsFromSerdes.png","hash":"95360bc3da4fc3594320a5474149902e723d2bf3","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/PrimaryClockPathFromSerdes.png","hash":"56505396bdd6b9f801b51d2783116450e88745f0","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/RequireTimeRecovery.png","hash":"f56469d2bb4b359392a35b15d07c6a5b169dfcdd","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/RequireTimeRemoval.png","hash":"babcd255f1b307500da8e3cb6ddfa190f3304b44","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/SlackHold.png","hash":"6eee5f50cfbd770dac405183a75b39c74f6fff3d","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/SetupRequirement与实际不符.png","hash":"a5e4b8723095f4ba36ddeb4fd86f96f9092ea9dc","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/Tco的由来.png","hash":"c461a55e3fe65859650a2739c7ed2ee331bcd299","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/Th的由来.png","hash":"c461a55e3fe65859650a2739c7ed2ee331bcd299","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/TimeQuestHoldupSlack.png","hash":"731f02c2bc8881d95c1eaa49de62c8ab3513a72e","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/TimeQuestRecovery.png","hash":"cae5feccd40bef629a3b1351bfc21a00169e09db","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/TimeQuestRemoval.png","hash":"69908aaa45bf103d34e2e3d6b94666339036cd21","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/TimeQuest时序分析Setup2.png","hash":"a3542ea9c4c4f43a7b768bed00975e655b2cca7b","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/clk_skew很大.png","hash":"2956c2e9aba553ee4cbe68102e2f31563df6f550","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/TsetupThold的由来.png","hash":"5c4a6a940bb0086c45f9f30730f792d5c1fe2470","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/holdTimeRequirement.png","hash":"b7a27f095321574ef11348bcb569d525b3da2a3f","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/Tlogic很大.png","hash":"b5e509dfb743ce22bb53b63241c0f1048cea9843","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/dataRequiredTimeHold.png","hash":"1a29529d3c87124ba6e270f2698b36a61fc499b1","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/input_delay.png","hash":"8c322a4fcb064498c6c8f8a30fa91604d8125909","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/input_delay_constraints1.png","hash":"116578dbaeac14d5c0915a0a2f24372b8b72284f","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/input_delay_path1.png","hash":"ad87e6446551f8f0870b806eb9ba0cc9532a0a82","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/input_delay_constraints2.png","hash":"d79c8bbaafd45711ec1461321268fdd62c65b059","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/input_delay_constraints3.png","hash":"d45e6bdd55f51d3713ccc652c9718a1d2e586704","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/input_delay_path2.png","hash":"59429805245eb19c5f8537b80e0ccaadec645e40","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/max_output_delay.png","hash":"e8dc90d4ce0973559eac19373362e9c9e6e30550","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/max_input_delay.png","hash":"814b526008237d9cdac5045c7c17a4c8cad7a48c","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/multicycle_path_rtl_diagram.png","hash":"616131424958e7c82a87c07ab785997282a9e75a","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/min_output_delay.png","hash":"2e06c9091259f2b87ebde365d944ade32516eb3a","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/multicycle_path_same_clock.png","hash":"f2abda9b7d7b8599c938f1f55862c6c4e8de1c41","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/multicycle_path_same_clock_timing.png","hash":"2ae328bcff8f9bfe1781c78d8074f5ea9217cdb9","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/output_delay_constraints1.png","hash":"bffc5fd0c20f0420444507d57ec4e5099606b7cf","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/output_delay.png","hash":"a356d0fa26afa3d3b27142a49816296abbdb6ae4","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/output_delay_constraints2.png","hash":"f3dbd6e6cdcfce1826fad0f5a4b58b5717ff9873","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/output_delay_path1.png","hash":"355692a6cc0fa3741becc4f6dda9f65990f8baf0","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/output_delay_path2.png","hash":"ad715d88b45abca3aadbfff2790d8920f5ce761e","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/set_clock_group_command.png","hash":"e09940c2daec6745fe78f033c3349bd592ad7813","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/set_clock_group_path.png","hash":"332cf2834ccffc76b192ceb2f54afc7407d15889","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/set_clock_group_command2.png","hash":"b56a5e70c43ef426794b550c1957901ad0b3632c","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/set_false_path_a2b_single.png","hash":"5286ac0655dc45aae95ca6ae32d7fe8769427e12","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/set_false_path_a2b_dual.png","hash":"34d50212afccda164beeea93af06a742f174c792","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/set_false_path_command.png","hash":"7b1c7a1f2f10cbeea1b14da239ef62ef047bc58c","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/set_false_path_reset.png","hash":"cf11ac648c88890d7f26d419961cce02961cd913","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/set_false_path_through_command.png","hash":"b5d52d9febe82b5f3d884cc40b844557b8689886","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/set_false_path_through_diagram.png","hash":"f042677ae27671d2855f216dd81f9cc448f22fb7","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path.png","hash":"4d725db13da7c051533a381d93275f4e5f0acdc6","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_hold_4.png","hash":"c02f54e93ee8fb97124e2beadede6ddf37c2ac12","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path_4_timing.png","hash":"43b87d0f6dfe4fc96649093b2d7dd5370ccf32dc","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path_fast2slow_setup_hold_command.png","hash":"0df63e49cbe00077b185b00239274ab3952343ec","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path_fast2slow_setup_hold_timing.png","hash":"f98cdd07b367204e0044d18fa4975f9e2879f39a","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path_fast2slow.png","hash":"729df4bf5e079a72421f3e5fb6d4d5cf7ddedb95","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path_fast2slow_timing.png","hash":"04ed022e79d86a8aac4ec43ba5383afcf2560ed0","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path_holdup_timing.png","hash":"7a438c5656b97926c6bf661232d4505809cf55cf","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path_holdup_adjust.png","hash":"2cfc0786cae6a0ce3d8f8ef1417fe9dc0c46d884","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path_just_setup_timing.png","hash":"a00a0b6af011ca6a296e1d35e89d84056ae9bc35","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path_just_setup.png","hash":"ba7ed483f430b9064b6dbb0951181958806cc50b","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path_minus_shift.png","hash":"825c54187e934be24488d95753b5da8f2af220d3","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path_minus_shift_timing.png","hash":"fe88ee2e225bd8b088c81304ff23366e71eb6337","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path_same_clk_timing2.png","hash":"4833f3bef23cbabd9dc94edb501d0034dc326223","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path_same_clk_timing.png","hash":"2e7f77dc543ae3a8886022b86fc56c7e6ee627bb","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path_slow2fast.png","hash":"63157ca830c24471b016f5adfc9618b2cd3b6aea","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path_slow2fast_just_setup_command.png","hash":"d0c3d823b428896349ff7947a59daf136abf1fbb","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path_slow2fast_just_setup_timing.png","hash":"f6dbf25497c9904571beb634908df7f921d73b8b","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path_slow2fast_holdup_command.png","hash":"57d3a133bb994165038d0bd4ce42ab3b45e2c15d","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path_slow2fast_holdup_timing.png","hash":"9bdf041af4a3c387ff25149165caba4073f66d85","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path_slow2fast_timing.png","hash":"1406c1526fa73e232c4488a77808bbe09c8d21ae","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path_source_destination_clock.png","hash":"a45fc8307e821acc077c57f0950900f60c79445a","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path_start_end.png","hash":"6db762eab8c3c71d5d23a4c00b01d3a589ea9520","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path_timeshift0.3_timing.png","hash":"74f2e29291333fb095a4ff51873ab0306fa40fb1","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path_timeshift0.3.png","hash":"825c54187e934be24488d95753b5da8f2af220d3","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_setup_timeshift_timing.png","hash":"b8393693c77215c18e8bee085e05207c76671fe8","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_setup_timeshift.png","hash":"1caaed8778f2dfbdd28736648dbe4fd64b5a50e4","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/set_multicyclye_path_same_clk_command2.png","hash":"350df7b518946cc82c98c678478e9f0fd5bb1581","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/set_multicyclye_path_same_clk_command.png","hash":"55d64ad21b41621f3cfc2ebbc782a22ece8f6099","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/setup分析data_arrival_time.png","hash":"9879f593035b406506adb889f1e0e5757b498280","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/setup_time.png","hash":"22294eb4e8bbf3c8bbcd73792da0d315a387e832","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/setup分析data_require_time.png","hash":"589e4edb8fd1e306ad6222803220309bdb223d68","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/setup分析setup_slack.png","hash":"f70079bccdb96063bddd8272462b0f8ffa57c398","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/三要素.png","hash":"94701a41a9378452c58f7ca5436266d90bb1579e","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/single_bit_cdc_diagram.png","hash":"dc94a657bc4a8d9efae3c143052b0975f522025e","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/建立时间计算Setup的裕量.png","hash":"90ac1cd5cc08bb51bf8a88c0d50ff3fd6e643b00","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/建立时间计算数据的到达时间.png","hash":"d3559ada0225362e4f488f8d1265caddda909c5f","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/时序分析.png","hash":"7065f95d4c2aac13ca88aca919dd1aee6c0a2c25","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/确定建立时间要求计算.png","hash":"10c50005fce5682c0677607c2c2a038bd4bb91f2","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/确定建立时间要求.png","hash":"7187f4711ed43b2eb52888174f62cced58d29d3a","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/建立时间计算数据的需求时间.png","hash":"172d10944be2c4a878bcc51ddda74c28c7d6adeb","modified":1605600614000},{"_id":"themes/matery/source/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1704442339947},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1704442339948},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1704442339949},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.svg","hash":"3480f00d284c812d623ed16a9e0ead3fb964c72e","modified":1704442339948},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1704442339949},{"_id":"themes/matery/source/libs/lightGallery/img/video-play.png","hash":"fbfdbe06aebf7d0c00da175a4810cf888d128f11","modified":1704442339950},{"_id":"themes/matery/source/libs/materialize/materialize.min.js","hash":"c843f0dc497314574c608ca28cc742bb041786d5","modified":1704442339954},{"_id":"themes/matery/source/libs/lightGallery/img/youtube-play.png","hash":"39150b45ec5fc03155b7ebeaa44f1829281788e2","modified":1704442339951},{"_id":"themes/matery/source/libs/materialize/materialize.min.css","hash":"2c27939768606603bee3b5e6c8a722596a667e60","modified":1704442339953},{"_id":"themes/matery/source/libs/share/css/share.min.css","hash":"7126de5cec8371e580b7b1f22512da0985cc39e5","modified":1704442339957},{"_id":"themes/matery/source/libs/lightGallery/img/vimeo-play.png","hash":"1142b47de219dddfba2e712cd3189dec0c8b7bee","modified":1704442339951},{"_id":"themes/matery/source/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1704442339958},{"_id":"themes/matery/source/libs/lightGallery/js/lightgallery-all.min.js","hash":"f8cd48e1fff82ecd54a7ce3e69de8dba7c92d113","modified":1704442339952},{"_id":"themes/matery/source/libs/share/fonts/iconfont.svg","hash":"337b4f156f6d8f4beb32c32a3db46fef361cff74","modified":1704442339958},{"_id":"themes/matery/source/libs/share/js/jquery.share.min.js","hash":"16ce82901ca0e302cf47a35fb10f59009a5e7eb9","modified":1704442339961},{"_id":"themes/matery/source/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1704442339960},{"_id":"themes/matery/source/libs/valine/av-min.js","hash":"04c6b2782ce4610c429563110f6a20a47432fc4c","modified":1704442339965},{"_id":"themes/matery/source/libs/share/js/social-share.min.js","hash":"4df722bafde2c5d8faaace0d1f894798385a8793","modified":1704442339961},{"_id":"themes/matery/source/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1704442339959},{"_id":"themes/matery/source/medias/featureimages/1.jpg","hash":"aaf5863bed7563a86a6da15cef0b5d44740e449c","modified":1704442339989},{"_id":"themes/matery/source/medias/featureimages/0.jpg","hash":"4e9f83cbe1575a44fe9315f937e7505ed05b6920","modified":1704442339988},{"_id":"themes/matery/source/medias/featureimages/10.jpg","hash":"53f3eb05edab87ee07c889f26fc550e9b5e5cb91","modified":1704442339990},{"_id":"themes/matery/source/medias/featureimages/11.jpg","hash":"4e4ed3d6f8466b3362cbaaa04dc31b8859d3e202","modified":1704442339991},{"_id":"themes/matery/source/medias/featureimages/16.jpg","hash":"87100d52e5077c77f9e74856a1c5330d81708ae3","modified":1704442339997},{"_id":"themes/matery/source/medias/featureimages/2.jpg","hash":"8567da47271a81b74ca341d170e057bb42f42bf5","modified":1704442340001},{"_id":"themes/matery/source/medias/featureimages/20.jpg","hash":"e854df6ea24c22c999216db611dfd3785b76b834","modified":1704442340002},{"_id":"themes/matery/source/medias/featureimages/24.jpg","hash":"33fc0af42186fa2c0e41712d5e45c716dd47bce6","modified":1704442340006},{"_id":"themes/matery/source/medias/featureimages/29.jpg","hash":"a8ff01c7f29be6d703040fad7889f5afba1eb844","modified":1704442340011},{"_id":"themes/matery/source/medias/featureimages/28.jpg","hash":"565fb296d8e4e2e520d6f15985f1de33d7bd98c8","modified":1704442340010},{"_id":"themes/matery/source/medias/featureimages/31.jpg","hash":"50eedc29287470f333612e6f71d88c3121357257","modified":1704442340014},{"_id":"themes/matery/source/medias/featureimages/23.jpg","hash":"c2f1f9387db7dd99d3c0e4df42a160d482dde5bd","modified":1704442340005},{"_id":"themes/matery/source/medias/featureimages/30.jpg","hash":"6dfe6d277ec3ef36e8c958a71712702a5be3e4d8","modified":1704442340013},{"_id":"themes/matery/source/medias/featureimages/33.jpg","hash":"851fadf999b21c4e42d7a5e4114a10abd21f81cd","modified":1704442340016},{"_id":"themes/matery/source/medias/featureimages/39.jpg","hash":"2b914a3b098aa874f68b4fcda7c85613140c6420","modified":1704442340023},{"_id":"themes/matery/source/medias/featureimages/43.jpg","hash":"76bf6095d8e92aa5d6a4e2dff4c2d710c61da07e","modified":1704442340028},{"_id":"themes/matery/source/medias/featureimages/41.jpg","hash":"51ccac5c36201f1c04f66e5d54babbb21cf5dc5f","modified":1704442340027},{"_id":"themes/matery/source/medias/featureimages/46.jpg","hash":"1e73f8ed0bd91c4443c4f7e57d2ea5cf94d419c6","modified":1704442340032},{"_id":"themes/matery/source/medias/featureimages/6.jpg","hash":"e0eb036bf77aacc91dffea2d75f590f9f1b2b961","modified":1704442340041},{"_id":"themes/matery/source/medias/music/avatars/不见就散-周深.jpg","hash":"c0611b3db7a0acb91c8d1972e6ffe99545289bc8","modified":1704442340048},{"_id":"themes/matery/source/medias/music/avatars/平凡之路-朴树.jpg","hash":"70d026f8ff9df7a5427e75e58c4b8bc6c637d85f","modified":1704442340049},{"_id":"themes/matery/source/medias/featureimages/8.jpg","hash":"b04f9b49261b2486260e64e6543da45689e272de","modified":1704442340043},{"_id":"source/_posts/2022/01/IMX6ull-移植-lVGL总结/2909691-20220928151916481-1456634923.png","hash":"1a6e87f307777f98d725943978c00efb4090c0ba","modified":1704442339071},{"_id":"source/_posts/2022/01/IMX6ull-移植-lVGL总结/2909691-20220928152957065-501054685.png","hash":"02e70dd300ead042177d527aebf566eb8ebec4fc","modified":1704442339077},{"_id":"source/_posts/2022/01/python使用百度翻译的API/20200302113654396.png","hash":"0eb46311fe5eee6803493cec10c082d2acef996b","modified":1704442339092},{"_id":"themes/matery/source/medias/reward/wechat.jpg","hash":"010a7b4eaf2113af7660fab39f7b7d2dc2fb314e","modified":1704442340138},{"_id":"source/_posts/2022/01/中华通史-上古史-夏/20210703105920999.png","hash":"e6a74917abe403a8adca2103d264f2b532765b96","modified":1704442339097},{"_id":"source/_posts/2022/01/中华通史-上古史-夏/20210703105831609.png","hash":"6f74b0d301ff93d020a051b598c1843023c8a60f","modified":1704442339097},{"_id":"source/_posts/2022/01/菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329201646615.png","hash":"33a6c6a068648814992c82eaeab0d798cd05258e","modified":1704442339106},{"_id":"source/_posts/2022/01/菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329203021908.png","hash":"0648ca9586b7a83463ad4f12efc003231171b681","modified":1704442339108},{"_id":"source/_posts/2022/01/菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329203626594.png","hash":"3e9af02ca14cc9e5098b1b148583dee50e0a28b8","modified":1704442339110},{"_id":"source/_posts/2023/04/EMC-EMI/2023-04-04_19-28-04.png","hash":"e95e091152fa0c866d73f5014c48cf5a62f54719","modified":1704442339123},{"_id":"source/_posts/2023/04/EMC-EMI/2023-04-04_19-33-05.png","hash":"7477c974bab91a2621066e5f826da10bf3f970c9","modified":1704442339132},{"_id":"source/_posts/2023/04/业务功能-业务流程-业务规则分析/主干流程.png","hash":"f4a5350223b0e86788af65ad517ef1302feed1e7","modified":1704442339477},{"_id":"source/_posts/2023/04/衡山/20230403161331.jpg","hash":"a452aeceed392945bd8cf528b00b0f6475a6f7cd","modified":1704442339739},{"_id":"source/_posts/2023/04/衡山/20230403161404.jpg","hash":"1c641d5779759d0d48bd33a9e4c2020b7c51cde7","modified":1704442339740},{"_id":"source/_posts/2023/04/衡山/20230403161412.jpg","hash":"525c7afb118f1c0052078119b3ca24df7d5101f4","modified":1704442339741},{"_id":"source/_posts/2023/05/PIN-GPIO/Pinctrl.png","hash":"9bdf584dbb8e6fb33546aa917b3bd76790337d3b","modified":1704442339755},{"_id":"source/_posts/2023/05/PIN-GPIO/iomuxc.png","hash":"d0d101818eb5c21c45e6ed4a033de957e1cb9795","modified":1704442339758},{"_id":"source/_posts/2023/05/PIN-GPIO/imx6ull pinctrl.png","hash":"28d5e0d8c17c46bff684820293b1028d8e8752b5","modified":1704442339757},{"_id":"source/_posts/2023/05/PIN-GPIO/pinctrl_system.png","hash":"8a57a4a6e04e1171f13fcedb6d0fac2fe58fbd5f","modified":1704442339762},{"_id":"source/_posts/2023/05/PIN-GPIO/probe.png","hash":"9d21cfe994d9a48e7442f91f0fb6e59fea403795","modified":1704442339764},{"_id":"source/_posts/2023/06/linux内核-tool目录/menuconfig.png","hash":"d9715c99899d7d2ec1557e648f00a36d55032858","modified":1704442339766},{"_id":"source/_posts/2023/07/嵌入式软件框架方案/32643a6fbe010dcc95af301416619164.png","hash":"cdbf520cd2419b7cdc97569c1d38e81ea6c2186e","modified":1704442339794},{"_id":"source/_posts/2023/07/嵌入式软件框架方案/2dd308b3411c41658cce041f8c230853.png","hash":"4c66e0a781c7319210351bef8458dce004c1d3df","modified":1704442339793},{"_id":"source/_posts/2023/07/嵌入式软件框架方案/6aadad4da134377249d84bab5dbdfa8d.png","hash":"74983111bde7189cb23f4ee194c3d6e3e0ddde3f","modified":1704442339796},{"_id":"source/_posts/2023/08/process-dbus-daemon/1.png","hash":"7544cb54cbd15240ed0ee0d34379fdf0dd202859","modified":1704442339804},{"_id":"source/_posts/2023/09/Design-Inputs-Outputs-for-Medical-Device/2023-09-14_09-16-16.png","hash":"9f1a6bfbf9752a3630b4ebc8e44726783b44b189","modified":1704442339839},{"_id":"source/_posts/2023/09/Design-Inputs-Outputs-for-Medical-Device/2023-09-14_9-14-12.png","hash":"09181a48656197cd2e5ae2c7a7fc0c3cd570e1a4","modified":1704442339847},{"_id":"source/_posts/2023/09/日落/微信图片_20230912150554.jpg","hash":"e3cc8da2ca9c9d5919681d9982dfb702fd9e7a0e","modified":1704442339877},{"_id":"source/_posts/2023/09/日落/微信图片_20230912150558.jpg","hash":"94a6956302dffb50dc1d13e91a3940fe956dabe3","modified":1704442339878},{"_id":"source/_posts/2023/09/日落/微信图片_20230912150602.jpg","hash":"3c142dfc86d8bcb90a2b7956911584be1139704c","modified":1704442339879},{"_id":"source/_posts/2024/01/FPGA基本单元/Cyclone_IV_dEVICES_LEs.png","hash":"16c96e701acfb91ef708059851df44958426e40f","modified":1706233342017},{"_id":"source/_posts/2024/01/FPGA基本单元/LAB_control_signal_generation_circuit.png","hash":"5487de5fefa5bcfa1d513d937563b63d819c96d5","modified":1706236230497},{"_id":"source/_posts/2024/01/FPGA基本单元/LAB_structure_for_Cyclone_IV_devices.png","hash":"f3ca3716e79ac7f94992fa4650e87948855c143e","modified":1706235182537},{"_id":"source/_posts/2024/01/FPGA基本单元/LEs_in_arithmetic_mode.png","hash":"a84a9a14a75b9345093e8947996b8e99d89b1260","modified":1706234853869},{"_id":"source/_posts/2024/01/FPGA基本单元/shows_LEs_in_normal_mode.png","hash":"18cd1cc357507e273de3b440d70991946eec12d2","modified":1706234685968},{"_id":"source/_posts/2024/01/时序约束整理/Tco_Th很大.png","hash":"19e03bcf6870d445a5f64a12d5b26a50a1334769","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/TimeQuest时序分析Setup1.png","hash":"2d3f0eeab54169b9fc0a41bd2d5a0372683bd1d2","modified":1605600614000},{"_id":"source/_posts/2024/01/时序约束整理/四种路径.png","hash":"370c6ba22dd25bb19893f8618bb2e6229b56fdbf","modified":1705385408380},{"_id":"themes/matery/source/libs/awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1704442339920},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1704442339930},{"_id":"themes/matery/source/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1704442339950},{"_id":"themes/matery/source/medias/banner/5.jpg","hash":"38272cddbb09c70c7785aed877f6c9b45a61262a","modified":1704442339984},{"_id":"themes/matery/source/medias/featureimages/13.jpg","hash":"1eed284202ae51c4f3051d943b3d97a7602a9fc6","modified":1704442339994},{"_id":"themes/matery/source/medias/featureimages/26.jpg","hash":"9c2eaf5aff8abdc4e215af96002c8525be9ddd06","modified":1704442340008},{"_id":"themes/matery/source/medias/featureimages/25.jpg","hash":"97930cf52f9e68ccf24d26b383704ca4724dae34","modified":1704442340007},{"_id":"themes/matery/source/medias/featureimages/3.jpg","hash":"4cabac02df559a5eb1b9abc8a0359fe6573a738b","modified":1704442340012},{"_id":"themes/matery/source/medias/featureimages/32.jpg","hash":"e440f9bdcdff7c181904b26b2774c48632e4d24a","modified":1704442340015},{"_id":"themes/matery/source/medias/featureimages/34.jpg","hash":"6fca10e13cae2a089909ea266fa6be510e57a2bd","modified":1704442340018},{"_id":"themes/matery/source/medias/featureimages/4.jpg","hash":"d7139f883aad272d619ce181ebcd86672a2a7bdc","modified":1704442340024},{"_id":"themes/matery/source/medias/featureimages/45.jpg","hash":"5c22e8d627f763ebae1d080025aee103383a8460","modified":1704442340030},{"_id":"themes/matery/source/medias/featureimages/7.jpg","hash":"26833abcdd65e10c48e8d0553cb3543d3e0ca4d8","modified":1704442340042},{"_id":"themes/matery/source/medias/featureimages/5.jpg","hash":"38272cddbb09c70c7785aed877f6c9b45a61262a","modified":1704442340040},{"_id":"themes/matery/source/medias/featureimages/48.jpg","hash":"13754e6efc8f6db46088d736ed2c290b0d9bfb33","modified":1704442340034},{"_id":"themes/matery/source/medias/logo.png","hash":"6fee8f6cf28858211c47939cb172633b18d1eee1","modified":1704442340048},{"_id":"source/_posts/2022/01/IMX6ull-移植-lVGL总结/2909691-20220928152209724-1097250473.png","hash":"05d498f7f30591101a53a8c5c95924ff1a84001d","modified":1704442339072},{"_id":"source/_posts/2022/01/IMX6ull-移植-lVGL总结/2909691-20220928152945955-899676295.png","hash":"9714cee9d41e446e660bc06e1908adad5edd6258","modified":1704442339076},{"_id":"themes/matery/source/medias/reward/alipay.jpg","hash":"bf966a223684650a6c5f1bc5df6d571493e922f3","modified":1704442340137},{"_id":"source/_posts/2022/01/python使用百度翻译的API/20200302113313981.png","hash":"a3bc848fc823b39cb9304360dabc4113a61ebb40","modified":1704442339091},{"_id":"source/_posts/2022/01/中华通史-上古史-夏/20210703105815619.png","hash":"ed38e99ca771a664503c1fc241b65609b190a652","modified":1704442339096},{"_id":"source/_posts/2023/04/业务功能-业务流程-业务规则分析/业务规则上.png","hash":"106e7b83de735bd1506057f05bded3f5b3f5fd1f","modified":1704442339471},{"_id":"source/_posts/2023/04/业务功能-业务流程-业务规则分析/探索分支.png","hash":"3cf5793d9bf2b409bd939c0e485c6e23c7f3d28a","modified":1704442339479},{"_id":"source/_posts/2023/04/北京/IMG_6716.JPG","hash":"99ff60c734012614ac5407d15ead6311fc76c8fb","modified":1704442339516},{"_id":"source/_posts/2023/04/新疆/1b706b934fc955412e3ed163fd0b7cbc2.JPG","hash":"197d9abf8cb2a83ba7f92192e339ebdef533f956","modified":1704442339519},{"_id":"source/_posts/2023/04/新疆/89c05a76a9273811c585c395890c9f522.JPG","hash":"acd08647f23bdbabb1f68cc061086d71df0dccd8","modified":1704442339547},{"_id":"source/_posts/2023/04/衡山/20230403161419.jpg","hash":"d52eba8c569ccd38a42589d5feccbad599bdb78e","modified":1704442339742},{"_id":"source/_posts/2023/05/PIN-GPIO/gpio.png","hash":"bad8a6af0e809665e3d511cf24ab38f173abf2d0","modified":1704442339756},{"_id":"source/_posts/2023/06/ttymxx-UART/cat-proc-devices.png","hash":"d7b01cb33a859dca9532928d23f626d7e9406c71","modified":1704442339769},{"_id":"source/_posts/2023/06/ttymxx-UART/ls-dev.png","hash":"b568d5d4f2dd4c06497e8bf3fd2c9c114cb807b7","modified":1704442339772},{"_id":"source/_posts/2023/08/语法指导翻译器/语法制导翻译.png","hash":"902f47f8cc6dc63e4f74dde3187bef5569a77ee0","modified":1704442339833},{"_id":"source/_posts/2023/09/日落/微信图片_20230912150606.jpg","hash":"8245afc282aa75441b905a0328565a1bf7f9f4fe","modified":1704442339880},{"_id":"source/_posts/2023/09/日落/微信图片_20230912150614.jpg","hash":"6d91b0d98fb205d1b72d17c6592c9623df2bfb53","modified":1704442339882},{"_id":"source/_posts/2024/01/I2C半高电平/picture2.jpg","hash":"f2eb183fad3124674ab1183a7792f895ac978724","modified":1704444047537},{"_id":"themes/matery/source/libs/awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1704442339921},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1704442339929},{"_id":"themes/matery/source/medias/featureimages/22.jpg","hash":"2beb56f529f0ce49f36a84d55890b7c0de3d7705","modified":1704442340004},{"_id":"source/_posts/2022/01/Linux-input子系统/2909691-20220819093409715-1604400596.png","hash":"55b9667906c85b6e35a8306dec17b969ece62590","modified":1704442339082},{"_id":"source/_posts/2023/04/EMC-EMI/2023-04-04_19-34-25.png","hash":"7dcff810f530ee4d40ee76651268a3c473f7d5ed","modified":1704442339135},{"_id":"source/_posts/2023/04/北京/IMG_6717.JPG","hash":"9bfb74c92dc7ea4217d2dd03624ef50acf2e5d38","modified":1704442339518},{"_id":"source/_posts/2023/04/深圳梧桐山-毛棉杜鹃/2b135a37c965e856f04d4a5faf8d2f2b2.JPG","hash":"f4165d53241b101e85fad7128831f04d684ad00a","modified":1704442339716},{"_id":"source/_posts/2023/06/ttymxx-UART/cat-ttymxc2.png","hash":"5847a4ae7a6b9dc2e40b772d68e265417b69cebc","modified":1704442339770},{"_id":"source/_posts/2023/09/日落/微信图片_20230912150619.jpg","hash":"49118eb3b5234d91bd41dbd7a8ea92fb866bd506","modified":1704442339884},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1704442339924},{"_id":"themes/matery/source/medias/banner/6.jpg","hash":"5be9274e63d6ac02607e3d659fd32532291385fa","modified":1704442339987},{"_id":"themes/matery/source/medias/featureimages/18.jpg","hash":"b8108799fbf3eadf0462fba04034a277a462018b","modified":1704442340000},{"_id":"themes/matery/source/medias/featureimages/17.jpg","hash":"4cbd4926b13132903c465685a127c577b56b2b8b","modified":1704442339999},{"_id":"themes/matery/source/medias/featureimages/44.jpg","hash":"6bca5b340c7e16350e3040da2416f6184ccd64a4","modified":1704442340029},{"_id":"themes/matery/source/medias/featureimages/42.jpg","hash":"c05648a22e1f083d13f40e76fed535f027fae0b6","modified":1704442340027},{"_id":"source/_posts/2022/01/IMX6ull-移植-lVGL总结/2909691-20220928153305849-1048335725.png","hash":"aeee98d5b5d62bc471f881b6482100864635f667","modified":1704442339079},{"_id":"source/_posts/2022/01/中华通史-上古史-夏/20210703111602157.png","hash":"eed4aad178595cbb24f9d33be2b6b893d29ebe07","modified":1704442339101},{"_id":"source/_posts/2023/04/业务功能-业务流程-业务规则分析/业务规则.png","hash":"9096eaf502a8c77966e2ddba42aeca3d42a30c59","modified":1704442339470},{"_id":"source/_posts/2023/08/process-dbus-daemon/2.png","hash":"f682ea3446e17801aecb40fbeca58373ac1e9263","modified":1704442339806},{"_id":"source/_posts/2023/09/日落/微信图片_20230912150536.jpg","hash":"9ea183b71aedb6d5bdb481e4b704d246952a564e","modified":1704442339876},{"_id":"source/_posts/2024/01/I2C半高电平/picture1.jpg","hash":"40165e2cdbe010e9a7cf691b8a9c4a8e168e6f3c","modified":1704432979327},{"_id":"source/_posts/2024/01/时序约束整理/set_max_delay_diagram.png","hash":"ab134fb201c7619ec1eb28596c87d89491feae0b","modified":1605600614000},{"_id":"themes/matery/source/medias/banner/1.jpg","hash":"cd3fc47d2042a3277e4b375ad084365abdc28f5d","modified":1704442339972},{"_id":"themes/matery/source/medias/banner/2.jpg","hash":"c2980f75f2c047d0957e3c8227b3f8d84e67f752","modified":1704442339974},{"_id":"themes/matery/source/medias/banner/4.jpg","hash":"4d6f31f86966584360bcdbfecb6f6a2ec94f944d","modified":1704442339983},{"_id":"themes/matery/source/medias/banner/0.jpg","hash":"73bae0e6812c46509b91e3155bd12ce8640b245a","modified":1704442339971},{"_id":"themes/matery/source/medias/featureimages/12.jpg","hash":"29f884076a7fbed6900a1a05c41ffd3ce122a123","modified":1704442339992},{"_id":"themes/matery/source/medias/featureimages/40.jpg","hash":"7a69b037ce05312d9322fe3f11c4d645b88645aa","modified":1704442340025},{"_id":"themes/matery/source/medias/music/avatars/每天爱你多一些.jpg","hash":"2beb56f529f0ce49f36a84d55890b7c0de3d7705","modified":1704442340051},{"_id":"source/_posts/2022/01/IMX6ull-移植-lVGL总结/2909691-20220928152922659-1842915282.png","hash":"3e599491c205ce9c2473c7cb88ae34ffe5ed810c","modified":1704442339074},{"_id":"source/_posts/2022/01/python使用百度翻译的API/20200302112847600.png","hash":"7826ff6dbdf5ff34629750ce22b0e94cccadef69","modified":1704442339090},{"_id":"source/_posts/2023/04/EMC-EMI/2023-04-04_19-30-08.png","hash":"4affe9d70ae0f96d3e097dedefeb4d8c2255f202","modified":1704442339126},{"_id":"source/_posts/2023/04/EMC-EMI/2023-04-04_19-32-59.png","hash":"f87f697280797d30f0e2f288829d1ef1e01679c5","modified":1704442339131},{"_id":"source/_posts/2023/04/业务功能-业务流程-业务规则分析/穷尽分支.png","hash":"7af9f4b00d74e30e5821ba95a050baa41c7e37f9","modified":1704442339482},{"_id":"source/_posts/2023/04/新疆/5d0b74a8910a3abba7e860149b9d40e12.JPG","hash":"ec0e0cd928032ca04d666abf09e657b401f8c286","modified":1704442339534},{"_id":"source/_posts/2023/04/衡山/20230403161440.jpg","hash":"de330e0d5f878351e1c4e01fd03e6646f47b7cd7","modified":1704442339753},{"_id":"source/_posts/2023/05/PIN-GPIO/pinctrl struct.png","hash":"8fb5c14e3e7b5a3819fd16cc07cead5aef72dae1","modified":1704442339762},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1704442339928},{"_id":"themes/matery/source/medias/avatars/myzhihu.png","hash":"4a9aec7e236615e3b698adfd3b36bc34ec05e5c7","modified":1704442339968},{"_id":"source/_posts/2023/04/EMC-EMI/2023-04-04_19-31-27.png","hash":"a548cc6c623a27b9b1ef07bf747c2f5846a1b8ad","modified":1704442339128},{"_id":"source/_posts/2023/04/北京/DSC01699.JPG","hash":"88fd74c50d76197f25fcea4f145b0b7315afa381","modified":1704442339499},{"_id":"source/_posts/2023/04/新疆/76d386e1b8eeeb85abab758cefc855e0.JPG","hash":"b5263a0698617a32ddcab1602d590abea3061540","modified":1704442339542},{"_id":"source/_posts/2023/04/新疆/95d557eb4ef2235d74a45743be1b05842.JPG","hash":"4b854a6ecb431a313e93f8d48df7fd0044aa372c","modified":1704442339551},{"_id":"source/_posts/2023/06/ttymxx-UART/ttymxc.png","hash":"37188802f04a32b89f1bebec4b86cdf8df87472b","modified":1704442339774},{"_id":"source/_posts/2023/07/嵌入式软件框架方案/c7546c50623e8a8aa6ab33ead8fac6cb.png","hash":"a7316beb6a20159dfeb953c21713feeac78ac6ac","modified":1704442339799},{"_id":"source/_posts/2022/01/python使用百度翻译的API/20200302112753932.png","hash":"6f7c69b14491228187f0b0d593687015b1751112","modified":1704442339088},{"_id":"source/_posts/2022/01/超详细解析python爬取外网图片/20200302110709393.png","hash":"2ad2b400e4ac4b25e38c950980367bb6b7276066","modified":1704442339113},{"_id":"source/_posts/2023/09/日落/微信图片_20230912150622.jpg","hash":"b696a7b6c0a220fb02fbe911aee4def1f892612c","modified":1704442339885},{"_id":"source/_posts/2022/01/菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329201443609.png","hash":"58a7a16ec9b08da3d87fb952be7b90fa42d40b8a","modified":1704442339105},{"_id":"source/_posts/2023/04/EMC-EMI/2023-04-04_19-35-03.png","hash":"75a164a1aefb14493fd964ec6f1af67dad08dfad","modified":1704442339138},{"_id":"source/_posts/2023/04/北京/DSC01645.JPG","hash":"37aae358c05c3ebe858be7fde41a6d991c53ffac","modified":1704442339487},{"_id":"source/_posts/2023/04/新疆/a2a9265c2707c16b5a1ca704a4d0856d.JPG","hash":"32140a32efde0712248d80606354ef18c8bdca95","modified":1704442339705},{"_id":"source/_posts/2023/04/深圳梧桐山-毛棉杜鹃/7d011510a39a8f6e23429fa828448a7c2.JPG","hash":"e39b53d9c09ac1a17144d8bc8190636d516184fb","modified":1704442339726},{"_id":"source/_posts/2023/07/嵌入式软件框架方案/e852708ffd1c78efd87949efa7b31592.png","hash":"278cedda4410f27e589063fce68238de6ca46b43","modified":1704442339802},{"_id":"source/_posts/2023/09/Design-Inputs-Outputs-for-Medical-Device/2023-09-14_09-19-28.png","hash":"94508ac046819fc5a1216027197c42570e7f6b59","modified":1704442339842},{"_id":"source/_posts/2024/01/时序约束整理/复位结构.png","hash":"e4eef5c5a6c4454fd6714d1e0b1627bda96ff52a","modified":1605600614000},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1704442339927},{"_id":"source/_posts/2023/04/新疆/88a98ae85a4705294439aca39ae07d672.JPG","hash":"efaf4595479444c71cb33287f510e15a97023d5e","modified":1704442339546},{"_id":"source/_posts/2023/04/新疆/a51d80549e7edc0d1ba69a885aa946ff2.JPG","hash":"d035b1f8fc6fa4742360fa30519dc3c349c5eb9d","modified":1704442339709},{"_id":"source/_posts/2023/04/深圳梧桐山-毛棉杜鹃/0a32e20ee914cca207bd5e0446eca332.JPG","hash":"d8487b0b07b39733ff17269e2ab21b35290fc7d5","modified":1704442339714},{"_id":"source/_posts/2023/08/语法指导翻译器/简单语法制导定义.png","hash":"d8804dd13106bc160a54eb9d4608ae152771c85b","modified":1704442339822},{"_id":"source/_posts/2023/08/语法指导翻译器/语法定义.png","hash":"a533dc2a50c57ec6e94517ba335cfcb3efd640ad","modified":1704442339837},{"_id":"source/_posts/2023/09/日落/微信图片_20230912090924.png","hash":"0d9e6f9116dc04a762668fc98b0176078bc17bd5","modified":1704442339874},{"_id":"source/_posts/2023/04/业务功能-业务流程-业务规则分析/业务规则下.png","hash":"b2d1bd226e043c5a49cf997d195eab5828624e2e","modified":1704442339475},{"_id":"source/_posts/2023/04/衡山/20230403161427.jpg","hash":"edede76d7524dbff86198f9ed27af324e846a990","modified":1704442339746},{"_id":"source/_posts/2023/04/北京/DSC01821.JPG","hash":"427acd97f61076e72289f67d92116b5264d532b6","modified":1704442339511},{"_id":"source/_posts/2023/04/衡山/20230403161434.jpg","hash":"eb3aa00bd533848c1fcdc5b8978baa825c332a99","modified":1704442339751},{"_id":"source/_posts/2023/04/深圳梧桐山-毛棉杜鹃/f4e3370968454b29062472df853b648e.JPG","hash":"9527a20734ba33ad970d1c09e9c5af69148a9e36","modified":1704442339737},{"_id":"themes/matery/source/libs/echarts/echarts.min.js","hash":"8789b5e4daf0029a6c88f238f10e54d01c4fce82","modified":1704442339939},{"_id":"themes/matery/source/medias/featureimages/49.jpg","hash":"90ad50712c339a89402a363288dcd355e98d0fbb","modified":1704442340039},{"_id":"source/_posts/2023/04/深圳梧桐山-毛棉杜鹃/6f19a8a8bff80c030eeba535032db0f6.JPG","hash":"247ba6417dab25febabd897888b92c780012a972","modified":1704442339721},{"_id":"themes/matery/source/libs/gitalk/gitalk.min.js","hash":"1df59d7e5481ac2917c7043b28883393675dcaf9","modified":1704442339944},{"_id":"source/_posts/2023/04/北京/DSC01697.JPG","hash":"e2bdc7040260ef7a9fafaf623a3f980e69faec27","modified":1704442339495},{"_id":"source/_posts/2023/04/北京/DSC01755.JPG","hash":"45e044a7a2e818bc76bc695a2349c0220d2a6f43","modified":1704442339508},{"_id":"source/_posts/2023/04/北京/DSC01827.JPG","hash":"93f303dcf1cb66fc7c46f1912cb33edc4fcc7c0c","modified":1704442339514},{"_id":"source/_posts/2023/04/深圳梧桐山-毛棉杜鹃/d2a7004a2e039c3f37d5fef10c7cc28a2.JPG","hash":"21997245573176ef723eae80b8337f1710d4a552","modified":1704442339733},{"_id":"source/_posts/2023/04/北京/DSC01687.JPG","hash":"0ca6df7cba2538cc3df7566e7652696abcbff8cf","modified":1704442339490},{"_id":"source/_posts/2022/01/超详细解析python爬取外网图片/20200302111109517.png","hash":"3c1684024bc31494b116961152500c0109172a72","modified":1704442339121},{"_id":"source/_posts/2023/04/北京/DSC01722.JPG","hash":"a50dcaff1db6ca1e6c7c746a580a96edf3695b61","modified":1704442339503},{"_id":"source/_posts/2023/08/语法指导翻译器/文法定义.png","hash":"7a64dc003c476333af7f06cbe5e6669c2fcb5bf4","modified":1704442339818},{"_id":"source/_posts/2023/04/新疆/BBND3773.PNG","hash":"9d51e64746eaf562e333c0c58b1665c87b7e3c94","modified":1704442339621},{"_id":"source/_posts/2023/08/语法指导翻译器/语法分析树.png","hash":"14fa0001d480a283ac54305d5ed033bd991005d8","modified":1704442339831},{"_id":"source/_posts/2023/04/新疆/6d0c92b575f36108df2062fda3b1e4ba2.PNG","hash":"b1520fdd30b641aad9016617c32119cd8ed82a27","modified":1704442339540},{"_id":"source/_posts/2023/04/新疆/KNLN1045.PNG","hash":"9b81832789db7ed79eceb15cfd62958fe3c81f1e","modified":1704442339661},{"_id":"source/_posts/2023/04/新疆/254bc46a6128338402204fa78f54b3e12.PNG","hash":"e41e37de90a7768a13e2c5094c4b930aa03a47eb","modified":1704442339525},{"_id":"source/_posts/2023/04/ten-ge-li/6.jpg","hash":"7b0cbe85e3ac8f3bb07b151342332b577bf62c3b","modified":1704442339217},{"_id":"source/_posts/2023/04/新疆/50f3a54d039eb642be22bc25607e11ca2.PNG","hash":"81d8346d84e26f93cfdc42b386fcbe5346f645ea","modified":1704442339532},{"_id":"themes/matery/source/medias/banner/3.jpg","hash":"42a57b512acce7f09f122b6b8c4f85c3803cd438","modified":1704442339980},{"_id":"source/_posts/2023/04/ten-ge-li/5.jpg","hash":"8f369783db3afe07144f07bc27ab714853c3cfbb","modified":1704442339208},{"_id":"themes/matery/source/medias/music/不见就散-周深.mp3","hash":"c96c5ad02f4138acc75321d0651d776939a8410b","modified":1704442340065},{"_id":"themes/matery/source/medias/music/每天爱你多一些-张学友.mp3","hash":"c4c9d37ac5b8012f0650fc6e1d414160bb6cbd5e","modified":1704442340134},{"_id":"source/_posts/2023/04/ten-ge-li/1.jpg","hash":"aa5cc837537f2d220f140380d8aa4deb88ebc328","modified":1704442339155},{"_id":"source/_posts/2023/04/ten-ge-li/4.jpg","hash":"65423da6e9df83013372da9c0144723480560524","modified":1704442339195},{"_id":"source/_posts/2023/04/新疆/MOVG5083.JPG","hash":"d735c13bacae84426c35f79b31f0d76e56b5dbcb","modified":1704442339673},{"_id":"source/_posts/2023/04/ten-ge-li/3.jpg","hash":"ebdd58409be4f13114b49aca45a14587d6d33f7f","modified":1704442339182},{"_id":"source/_posts/2023/04/新疆/YJUM1401.JPG","hash":"2298f67966321b94c232d69b82a5d0c3725c250b","modified":1704442339701},{"_id":"source/_posts/2023/04/新疆/ANKG1449.JPG","hash":"5baaa1ab9105091d0118f76229cef42117d346d3","modified":1704442339566},{"_id":"source/_posts/2023/04/新疆/XRBQ0574.JPG","hash":"0a22babef32c3458bf6d3b132fc86fdb92df4ac1","modified":1704442339687},{"_id":"source/_posts/2023/07/linux-platform/platform.png","hash":"8bbaa84862913279d587bda57cb8cbe1f203a548","modified":1704442339790},{"_id":"source/_posts/2023/04/上海/20230403160809.jpg","hash":"c00d70be19d150a3e7852ba2bf0eb43d79b5af8e","modified":1704442339380},{"_id":"source/_posts/2023/04/ten-ge-li/2.jpg","hash":"a67afd08d4cfc6ad6f1df81d6b9f6799ddaf2b5d","modified":1704442339170},{"_id":"source/_posts/2023/04/新疆/IGAX1811.JPG","hash":"b28a4910831f07c5d9a24e7a89f1a13a89c4e499","modified":1704442339655},{"_id":"source/_posts/2023/09/Medical-device-registration-standards/2023-09-14_10-00-13.png","hash":"6adb3401596eb5483381e51c9353e26a40251591","modified":1704442339869},{"_id":"source/_posts/2023/04/ten-ge-li/IMG_6912.JPG","hash":"cf10a567bf3ebbe495dbefef9766d64f40838583","modified":1704442339282},{"_id":"source/_posts/2023/04/新疆/AZQE3071.JPG","hash":"ec500582aece897e57480cf258033db9afa09b4d","modified":1704442339615},{"_id":"source/_posts/2023/04/新疆/AQSR2937.JPG","hash":"803cbcd9795224d0fe0f955a183097d5841e7e4a","modified":1704442339581},{"_id":"source/_posts/2023/04/新疆/BBOD4958.JPG","hash":"d91a8e27fa87b395cf945e442e26b5afa5958529","modified":1704442339641},{"_id":"source/_posts/2023/04/ten-ge-li/IMG_6899.JPG","hash":"a83cb2a77b6e0783769e8db226b18ee12b684015","modified":1704442339252},{"_id":"source/_posts/2023/04/上海/20230403160820.jpg","hash":"67c97c223cf033355d5f224595e474000472c8ee","modified":1704442339466},{"_id":"themes/matery/source/medias/music/平凡之路-朴树.mp3","hash":"fab92512ec9c0cdc2ea41889f440084c86786e05","modified":1704442340118},{"_id":"source/_posts/2023/04/上海/20230403160752.jpg","hash":"1dd95e72274267e787dd795d8f25325365be8976","modified":1704442339367},{"_id":"source/_posts/2023/04/上海/20230403160815.jpg","hash":"4791996fab30c9e1b0a57b5362fa19252382924a","modified":1704442339432},{"_id":"source/_posts/2023/04/ten-ge-li/IMG_7069.JPG","hash":"54e10986b7f644c3f58d7231c4083ba7bf6b5934","modified":1704442339337},{"_id":"public/baidu_urls.txt","hash":"9d9ed1b2602f7f63cabd0099694097e06f1dc5da","modified":1706236986414},{"_id":"public/baidusitemap.xml","hash":"2376021cdc7ab234e52511854d61756d7fc367eb","modified":1706236986557},{"_id":"public/atom.xml","hash":"b5a73e0c1110e82657510a3847ed855ac2d43397","modified":1706236986558},{"_id":"public/search.xml","hash":"cd5a298cffa1d1fb9fb9cffaef8f2eaeef4941c3","modified":1706236991015},{"_id":"public/sitemap.xml","hash":"041f9767e0ed347ec4cff540ef7553ea9d5d12cf","modified":1706236991381},{"_id":"public/404.html","hash":"3a0a44f842ad00600b008370e190fb103b0f41e6","modified":1706236991433},{"_id":"public/archives/index.html","hash":"bdd3abfc6b851ee6931cb143f7d5b0d81053ffb4","modified":1706236991433},{"_id":"public/about/index.html","hash":"06bea796a7c0533abf85729de80a777b37fcef8e","modified":1706236991434},{"_id":"public/categories/index.html","hash":"8fdbe16c5cbbf85d9bacf60afba14972d0490959","modified":1706236991434},{"_id":"public/contact/index.html","hash":"c3faa55845c645a49a6e49489b17585d3c660f99","modified":1706236991434},{"_id":"public/gallery/index.html","hash":"2c547892293a2020864b4543174ae94ce27eafa7","modified":1706236991443},{"_id":"public/tags/index.html","hash":"bb7176971602f49cdf31ed563b0f39bf627b73a4","modified":1706236991443},{"_id":"public/2024/01/fpga-ji-ben-dan-yuan.html","hash":"6d9d17976239fbe2bffea461bceb21c257130b5f","modified":1706236991443},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li.html","hash":"0468de78265c4863bbfe3814a308825dcd72810a","modified":1706236991443},{"_id":"public/2024/01/quartus-fpga-debug.html","hash":"c775462f6e5e237c78db37a33411882ac496b884","modified":1706236991443},{"_id":"public/2024/01/i2c-ban-gao-dian-ping.html","hash":"1f4ef6d464db6a600d46cfa2cd7d7b280018b6d2","modified":1706236991443},{"_id":"public/2023/09/medical-device-registration-standards.html","hash":"698bce0ca0d41ace0aa734b524d6c73b31013a89","modified":1706236991443},{"_id":"public/2023/09/design-inputs-outputs-for-medical-device.html","hash":"cde851119e5febdc4234f505e2710adc003ffb16","modified":1706236991443},{"_id":"public/2023/09/ri-luo.html","hash":"e5789d923415d36fef9eae45090fc8a8354bba4f","modified":1706236991443},{"_id":"public/2023/09/process-dropbear.html","hash":"ace8938124e009b8b2aa0965214f95af80d72713","modified":1706236991443},{"_id":"public/2023/08/process-watchdog.html","hash":"baad940ae2b4e50bcca226ccba92c48c332c65db","modified":1706236991443},{"_id":"public/2023/08/process-syslogd-klogd.html","hash":"e602a6b19dba146e83ee025ad4939710fe052c44","modified":1706236991443},{"_id":"public/2023/08/process-dbus-daemon.html","hash":"ac93728f7a33d3f10969dcbf0210ae94e212170c","modified":1706236991443},{"_id":"public/2023/08/process-udev.html","hash":"96d0bf3882f355c2779a6b09a6056c6b5542711d","modified":1706236991444},{"_id":"public/2023/08/process-kworker.html","hash":"863f920f85f17ba90baf6ce11d64aacb2046d1ca","modified":1706236991444},{"_id":"public/2023/08/process-ksoftirqd.html","hash":"ebd866d48f2b529c3323c3faa75991bdaa181c6d","modified":1706236991444},{"_id":"public/2023/08/process-kthreadd.html","hash":"fbbbaa1144e37826545c6491cfbdf3c58a75d2f7","modified":1706236991444},{"_id":"public/2023/08/process-init.html","hash":"25fa12a8d8916fd2fe86a060b721211faf4f675f","modified":1706236991444},{"_id":"public/2023/08/yu-fa-zhi-dao-fan-yi-qi.html","hash":"303b2214438c829e8a5fed0211ee5ebd5e2b531e","modified":1706236991444},{"_id":"public/2023/08/kill-ming-ling.html","hash":"2e19653cb7964b22ff7fd50e6ab0b3b8c11af76c","modified":1706236991444},{"_id":"public/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an.html","hash":"f57690b1661e471c5c21d213ff343e17a510a7e4","modified":1706236991444},{"_id":"public/2023/07/linux-platform.html","hash":"b2a649d761f52c891d0d6087f7859fe6aae18b7c","modified":1706236991444},{"_id":"public/2023/06/ttymxx-uart.html","hash":"dee987af3cbd6c68fc192fe5041941628611c94f","modified":1706236991444},{"_id":"public/2023/06/url.html","hash":"0455aa4769a680541fceca37add74b8446beadc8","modified":1706236991444},{"_id":"public/2023/06/linux-nei-he-tool-mu-lu.html","hash":"a249570001a6b6f5939ddea5b2190d51c6297d33","modified":1706236991444},{"_id":"public/2023/05/pin-gpio.html","hash":"a0c0640894edd3708fb1a1cd7f5c75f981f8811f","modified":1706236991445},{"_id":"public/2023/05/ti-sheng-emc-de-ruan-jian-bian-cheng-ce-lue.html","hash":"2b41cc87a3e23ada6c1e82194b32050a13ca52a9","modified":1706236991445},{"_id":"public/2023/05/dan-lian-biao-bao-jing-mo-kuai.html","hash":"932bcfbf69b8426c3f47354fa50cfdc2c5e3610b","modified":1706236991445},{"_id":"public/2023/04/bei-jing.html","hash":"a8eb47467497778bb40b7c4d002cde7558ab73b3","modified":1706236991445},{"_id":"public/2023/04/ten-ge-li.html","hash":"a4382e2b7ddfa51f58292b8f937b4e255246672e","modified":1706236991445},{"_id":"public/2023/04/ye-wu-gong-neng-ye-wu-liu-cheng-ye-wu-gui-ze-fen-xi.html","hash":"96d5b30c0a4160258bf8749d73f381b35a113132","modified":1706236991445},{"_id":"public/2023/04/emc-emi.html","hash":"81d017866c1e23e55318f2d3d88cc8665f8172b7","modified":1706236991445},{"_id":"public/2023/04/heng-shan.html","hash":"5d1ef0f728d7662bccee64a6cc8f61fc32adede5","modified":1706236991445},{"_id":"public/2023/04/shen-zhen-wu-tong-shan-mao-mian-du-juan.html","hash":"ec83394ebf200d3b5ac36b7789289314958c7d4b","modified":1706236991445},{"_id":"public/2023/04/shang-hai.html","hash":"605f2c050fcc5f734372cdf98a72d9a5168bd771","modified":1706236991445},{"_id":"public/2023/04/xin-jiang.html","hash":"7c26859140d688fc0530c0fa4fc873eff893420f","modified":1706236991445},{"_id":"public/2022/01/linux-input-zi-xi-tong.html","hash":"f4ddc4d7f78f0843fabec1335685dbc59cb251ee","modified":1706236991445},{"_id":"public/2022/01/linux-xian-cheng.html","hash":"df3fe3227f9ce6565b277cb5d9e193c0356c2c73","modified":1706236991446},{"_id":"public/2022/01/imx6ull-yi-zhi-lvgl-zong-jie.html","hash":"87bf187dff5eec29424aae772724605a544cf310","modified":1706236991449},{"_id":"public/2022/01/zhong-hua-tong-shi-shang-gu-shi-xia.html","hash":"81494caa0416c6d37c31ff80b62790848a975ba4","modified":1706236991449},{"_id":"public/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou.html","hash":"3622f8d4cf4532169f4eeeeb02c90d34acb0f7b1","modified":1706236991449},{"_id":"public/2022/01/python-shi-yong-bai-du-fan-yi-de-api.html","hash":"73e4f109c6cb3f5618470d47cb6af9f0c9607cd3","modified":1706236991449},{"_id":"public/2022/01/chao-xiang-xi-jie-xi-python-pa-qu-wai-wang-tu-pian.html","hash":"f6e8bc224be860e530f0df46e7c5f6ccaca24265","modified":1706236991449},{"_id":"public/archives/page/2/index.html","hash":"d40538133f71e1d95ddc2f7460bbbfbffdbe6fc2","modified":1706236991449},{"_id":"public/archives/page/3/index.html","hash":"cd2cf17be6f9ba6d66cd49b781ab95834abae64a","modified":1706236991450},{"_id":"public/archives/page/4/index.html","hash":"ff9b6ac0c129edbf183b2fbae059e23c0ba7216d","modified":1706236991450},{"_id":"public/archives/2022/index.html","hash":"b2f6b14c052a2acb351a0501171f29d2564188de","modified":1706236991450},{"_id":"public/archives/2022/01/index.html","hash":"1c1e11e76b56f40eaec5a95315aca6489022abe5","modified":1706236991450},{"_id":"public/archives/2023/index.html","hash":"d1bf8a078613bf4a153d909ee6e579c551dd4ce6","modified":1706236991451},{"_id":"public/archives/2023/page/2/index.html","hash":"c101f2bf674f1796e4f7fe48ef5e239d42195fc7","modified":1706236991451},{"_id":"public/archives/2023/page/3/index.html","hash":"806bc9cb3a91042498ab88324e3021eae2dc60a6","modified":1706236991451},{"_id":"public/archives/2023/04/index.html","hash":"1cf4d8f7cf6b03097b09d7f77fdc04df5203baa2","modified":1706236991451},{"_id":"public/archives/2023/05/index.html","hash":"fce93a541935dfa240d41a424c2c9ea67543d94c","modified":1706236991451},{"_id":"public/archives/2023/06/index.html","hash":"5bc7818ca86cbf94dca3c106c453b7e04f89bee3","modified":1706236991451},{"_id":"public/archives/2023/07/index.html","hash":"43b5cdf708b57ef9e5626580735794a9e8fd282e","modified":1706236991451},{"_id":"public/archives/2023/08/index.html","hash":"08b06a19d94350a7df91b3abd6fa50397d45c62b","modified":1706236991451},{"_id":"public/archives/2023/09/index.html","hash":"e9ce7892d3565f655fab3d90e141b84bfa3496d1","modified":1706236991451},{"_id":"public/archives/2024/index.html","hash":"2e12ed44a196dd201ae6eb4bbe18c44274e7bc97","modified":1706236991451},{"_id":"public/archives/2024/01/index.html","hash":"7c94a14fea12ef325bd0c78388d222b0e4ea89b3","modified":1706236991451},{"_id":"public/categories/linux/index.html","hash":"dd308d1cfd2d318bf3a5792e75c892ee8ca4797e","modified":1706236991452},{"_id":"public/categories/python/index.html","hash":"3ef417acadc09933fc279a0c590cdfe576bc33f1","modified":1706236991452},{"_id":"public/categories/history/index.html","hash":"21f71a4ff0c37378f7216f6ab050819510c6e47a","modified":1706236991452},{"_id":"public/categories/Embedded-system/index.html","hash":"06af2d0eff394f1393ee38e9b6f687f87dd6890b","modified":1706236991452},{"_id":"public/categories/gallery/index.html","hash":"2e7dfbadfe9b3acf900ac5e244599525b858b298","modified":1706236991452},{"_id":"public/categories/硬件/index.html","hash":"38b0dbc672ecabf0e4e2e8b030c5f51bed10a723","modified":1706236991452},{"_id":"public/categories/study/index.html","hash":"adb6c1f6484dc93e621e2ce43d4a16c900b6adf2","modified":1706236991452},{"_id":"public/categories/process/index.html","hash":"d0b3c5492ddd83621fb51990b9104bee89a8441b","modified":1706236991452},{"_id":"public/categories/process/linux/index.html","hash":"d9a7b70ddd644793edb44b3c5e519b09ecf0343b","modified":1706236991453},{"_id":"public/categories/编译原理/index.html","hash":"830baddc576c12b9c72836930a1a96f5c39c7a83","modified":1706236991453},{"_id":"public/categories/FPGA/index.html","hash":"47ca47b18f5bc4b30ef112848ba74f1b668d671b","modified":1706236991453},{"_id":"public/index.html","hash":"080246f47db3a60b64aceba35a545d40fe6252ff","modified":1706236991453},{"_id":"public/page/2/index.html","hash":"7f4c8dd3aae439fdc105f72ac7cf15162c2db861","modified":1706236991453},{"_id":"public/page/3/index.html","hash":"2a7b43aefbbf203cb45835c17d1fec231ad5ac51","modified":1706236991453},{"_id":"public/page/4/index.html","hash":"bcd305728f50a89c3853430d16b0e000ae817962","modified":1706236991453},{"_id":"public/tags/linux/index.html","hash":"ad5fd5dd813b3b2cf37f6aae65c724eadf9aef77","modified":1706236991453},{"_id":"public/tags/linux/page/2/index.html","hash":"5cb0580f1e2f10adada83c7bfffd9f8716017c49","modified":1706236991453},{"_id":"public/tags/process/index.html","hash":"d96ef238930d79947b51d256847ec2e140394516","modified":1706236991453},{"_id":"public/tags/input/index.html","hash":"8cc2b6221ae202d182fdc0e805d18f9524a0b55e","modified":1706236991453},{"_id":"public/tags/python/index.html","hash":"2f4e85feabe7bfcfdc6f6764e0738c9a4cab9233","modified":1706236991453},{"_id":"public/tags/history/index.html","hash":"4334a2b60e61d68d8791c05818ff44f83366ceec","modified":1706236991454},{"_id":"public/tags/Embedded-system/index.html","hash":"83ea2eaaf1bff5c43c5183468518b899089ad1cb","modified":1706236991454},{"_id":"public/tags/imx6ull/index.html","hash":"b39735d80ad09c1ce5e1858eb0e0832b0d7bcb0b","modified":1706236991454},{"_id":"public/tags/gallery-腾格里/index.html","hash":"21f2116dcfda8fa4faba0b11113ad109de411ef7","modified":1706236991454},{"_id":"public/tags/EMC-EMI/index.html","hash":"4a9993879b86ec7cb53fe0f05436a7f0058ef397","modified":1706236991454},{"_id":"public/tags/gallery-上海/index.html","hash":"e22267ec59eb99b7bedfb9f464fb121c49aa9092","modified":1706236991454},{"_id":"public/tags/gallery-北京/index.html","hash":"693988b1b8f02f3dc38fbe5a8b280540220e1e99","modified":1706236991454},{"_id":"public/tags/gallery-新疆/index.html","hash":"94ada0db7d9319f7be6535001a86aefb8f163b0b","modified":1706236991454},{"_id":"public/tags/gallery-衡山/index.html","hash":"0a80cdf69ebb775a3be7c3cd9aeeb26bc716ef16","modified":1706236991454},{"_id":"public/tags/gallery-深圳梧桐山-毛棉杜鹃/index.html","hash":"a1aedeecf7166f99dbf78600311050ba52b7e130","modified":1706236991454},{"_id":"public/tags/PIN-GPIO/index.html","hash":"3c147ddc784d133ef81820341552236777bc67eb","modified":1706236991454},{"_id":"public/tags/tool目录/index.html","hash":"06cad2db43794dbdde180e08a83dc59d3edc4e2d","modified":1706236991455},{"_id":"public/tags/模块/index.html","hash":"3d011b8521e55cfb70da5380f58b1344b023b01f","modified":1706236991455},{"_id":"public/tags/study/index.html","hash":"2c641807e666e36652655d091c7226044eac5038","modified":1706236991455},{"_id":"public/tags/platform/index.html","hash":"95cdb780a27c0152751a2e225643a9a27af501c9","modified":1706236991455},{"_id":"public/tags/编译原理/index.html","hash":"2cdda2ef52042264bfe8a3714b5b526aa6332387","modified":1706236991455},{"_id":"public/tags/医疗器械软件/index.html","hash":"ce608658112270679d9845c26ef88423b1216650","modified":1706236991455},{"_id":"public/tags/gallery-日落/index.html","hash":"80bc9187966aedc99dec6ad2b18d53856208e3f5","modified":1706236991455},{"_id":"public/tags/FPGA/index.html","hash":"712bb856b818fc0dbcb81f393ce1f1ec0fc2b558","modified":1706236991455},{"_id":"public/CNAME","hash":"4740c94df1240b26efd774d065f3ae8ef5c24b7c","modified":1706236991531},{"_id":"public/robots.txt","hash":"66078f56462509b9624be31d3e78ae2b62a33b60","modified":1706236991531},{"_id":"public/medias/loading.svg","hash":"ba1375eb3d08353e70f8349eb586da9601355c9e","modified":1706236991531},{"_id":"public/medias/featureimages/9.jpg","hash":"2e1ac235e6a6d80dbed651f993f319c1ed4b5925","modified":1706236991531},{"_id":"public/medias/avatars/csdn.ico","hash":"fff55f10e98084a888ac0b346ccdf0dbaad2ccb1","modified":1706236991531},{"_id":"public/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1706236991531},{"_id":"public/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1706236991531},{"_id":"public/libs/lightGallery/fonts/lg.svg","hash":"3480f00d284c812d623ed16a9e0ead3fb964c72e","modified":1706236991531},{"_id":"public/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1706236991531},{"_id":"public/libs/lightGallery/img/video-play.png","hash":"fbfdbe06aebf7d0c00da175a4810cf888d128f11","modified":1706236991531},{"_id":"public/libs/lightGallery/img/vimeo-play.png","hash":"1142b47de219dddfba2e712cd3189dec0c8b7bee","modified":1706236991531},{"_id":"public/libs/lightGallery/img/youtube-play.png","hash":"39150b45ec5fc03155b7ebeaa44f1829281788e2","modified":1706236991531},{"_id":"public/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1706236991531},{"_id":"public/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1706236991531},{"_id":"public/libs/share/fonts/iconfont.svg","hash":"337b4f156f6d8f4beb32c32a3db46fef361cff74","modified":1706236991531},{"_id":"public/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1706236991531},{"_id":"public/medias/music/avatars/不见就散-周深.jpg","hash":"c0611b3db7a0acb91c8d1972e6ffe99545289bc8","modified":1706236991532},{"_id":"public/medias/music/avatars/平凡之路-朴树.jpg","hash":"70d026f8ff9df7a5427e75e58c4b8bc6c637d85f","modified":1706236991532},{"_id":"public/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1706236991532},{"_id":"public/2023/07/linux-platform/device-driver.png","hash":"d1a74b75fbd655681620df04a09a2a81e07060e2","modified":1706236991532},{"_id":"public/2023/06/linux-nei-he-tool-mu-lu/tool目录.png","hash":"e0941cce6adf15e087d9484b4e126716ae2549f6","modified":1706236991532},{"_id":"public/2022/01/linux-xian-cheng/2909691-20221018201940242-320806714.png","hash":"e303ca7352b7cb92f2f9a6e68a42a53f40f0a5e0","modified":1706236991532},{"_id":"public/2022/01/linux-xian-cheng/2909691-20221018202536805-171723429.png","hash":"19ee436b75c2365a5d9b0fe3692a743a6e49c952","modified":1706236991532},{"_id":"public/2022/01/linux-input-zi-xi-tong/input_logical.png","hash":"745413f59d688e5a390a23fc26d5cbba1bee74bf","modified":1706236991532},{"_id":"public/2022/01/linux-xian-cheng/2909691-20221018204634847-2097816257.png","hash":"11e873440e4adc189ebe3f537f9ef2e5e95e30ba","modified":1706236991532},{"_id":"public/2022/01/linux-input-zi-xi-tong/2909691-20220819094250974-180404869.webp","hash":"f2c6a92fb8d6c71167d08db4814ac8978264f149","modified":1706236991532},{"_id":"public/2022/01/linux-input-zi-xi-tong/2909691-20220819102740731-2036281828.png","hash":"620ca1c5e896674be2123b19c639bc542af82caf","modified":1706236991532},{"_id":"public/2024/01/i2c-ban-gao-dian-ping/picture3.jpg","hash":"3665d2c4aa7146fa4806dc977e8e11482fe2dc25","modified":1706236991532},{"_id":"public/2024/01/i2c-ban-gao-dian-ping/picture4.jpg","hash":"c3c5abe541214c9b12a9e169b2c0ca83761f1a2b","modified":1706236991532},{"_id":"public/2024/01/i2c-ban-gao-dian-ping/picture5.jpg","hash":"d066721bd06414aa6c4e338a3352c3c8e504dcbd","modified":1706236991532},{"_id":"public/2023/09/design-inputs-outputs-for-medical-device/2023-09-13_17-08-45.png","hash":"37c5926ce3237d710110c276af89efdaf38fb887","modified":1706236991532},{"_id":"public/2023/09/design-inputs-outputs-for-medical-device/2023-09-13_17-14-12.png","hash":"84e25bad9a455064645a029b0d4c18437059a743","modified":1706236991532},{"_id":"public/2022/01/python-shi-yong-bai-du-fan-yi-de-api/20200302115943813.png","hash":"d732381420174bf2f792dc34b3f5b3b56bfc2fe8","modified":1706236991532},{"_id":"public/2022/01/python-shi-yong-bai-du-fan-yi-de-api/20200302120105912.png","hash":"60d73aec104782b1e3626b0ae5b695e6b2f44134","modified":1706236991532},{"_id":"public/2024/01/fpga-ji-ben-dan-yuan/direct_link_connection.png","hash":"290aca378d4dcd6bc8308854ed289a4f16d55441","modified":1706236991532},{"_id":"public/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928153140065-1807119912.png","hash":"81814544b47e2371c6174d2d78a40c6dc1ec97ee","modified":1706236991532},{"_id":"public/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928153451220-1274979267.png","hash":"38e44ea1bf27b199f03e40d3fbb31ca92a9560b1","modified":1706236991532},{"_id":"public/2023/04/ye-wu-gong-neng-ye-wu-liu-cheng-ye-wu-gui-ze-fen-xi/分析起步.png","hash":"f597a655cc0aff1ed6aaf5a19380957ba362fde6","modified":1706236991532},{"_id":"public/2023/04/ye-wu-gong-neng-ye-wu-liu-cheng-ye-wu-gui-ze-fen-xi/模板.png","hash":"e67a71845dfd7a98e4959b97df24d50a8da41177","modified":1706236991532},{"_id":"public/2023/04/emc-emi/2023-04-04_19-32-29.png","hash":"5cf52b16fc4970dd256fb8ab707a8988e6fea828","modified":1706236991532},{"_id":"public/2023/04/emc-emi/2023-04-04_19-33-48.png","hash":"e5f260152656763228b8ef179d47a2ad485802f9","modified":1706236991532},{"_id":"public/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329193127889.jpg","hash":"7a0511fab61dec9617ff13e3e30955a7b37f0930","modified":1706236991532},{"_id":"public/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329195920218.jpg","hash":"20699b111e09083edc68e80f86e2238c4c5b703d","modified":1706236991533},{"_id":"public/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329200632579.png","hash":"cd08c7532ef0acf9b9406d0794195926408d8b0a","modified":1706236991533},{"_id":"public/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329202358795.png","hash":"cdfc62f3ea8e38679c1a804d2aad822b1bcc1a36","modified":1706236991533},{"_id":"public/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329202548677.png","hash":"af1c46bdb03c03fa55002639807e158ac3ab6868","modified":1706236991533},{"_id":"public/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329203335481.png","hash":"d8ae5f3ea833f6f627c8d7006a0a886753a3b908","modified":1706236991533},{"_id":"public/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/22c7469876239933b38a12a32e9c6f16.png","hash":"e0ac3751ad221d95718ae7ff26ebf073bb9594f1","modified":1706236991533},{"_id":"public/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/60a0b6815e87242adbc049d64b96e01b.png","hash":"d57950b2bab69769bd372eb0ab86a71f7cb28d27","modified":1706236991533},{"_id":"public/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/780552b6b4ceacfe274a8c687b74a569.png","hash":"579c26e4342cdae2ba4404f04781a4b4839e4dc7","modified":1706236991533},{"_id":"public/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/e7176066eab77c0cf6e147aed0046ea7.png","hash":"63576e1bd997584873acae29976472105d199fdb","modified":1706236991533},{"_id":"public/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/dc4e3ddfdab5a0456af40df7d0a9238b.png","hash":"782eae366eeb181d32de302b4d0f4416a6fefbfc","modified":1706236991533},{"_id":"public/2023/09/ri-luo/微信图片_20230912150610.jpg","hash":"127d4aa98cfb06b83ffb05514efae72740a15a67","modified":1706236991533},{"_id":"public/2023/04/xin-jiang/2d25bdf0ce35910c874badcedff928002.JPG","hash":"dfb9275edaa0886abb505911f112165b5aea21e1","modified":1706236991533},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/DataArrivalTimeHold.png","hash":"92ddfd9af047e7e1c88422f1814e5cf49dfd5b37","modified":1706236991533},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/DataPathRequirementCalculation.png","hash":"87142b4c14e57a2180cb4e57202adc71dc3afae2","modified":1706236991533},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/FourPathConstraints.png","hash":"cc2cdce9638ecd8178591ddb16797dfae6e7926c","modified":1706236991533},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/GeneratedClcokPath.png","hash":"3464c15c671d54a1aab04028c4c57554036fe806","modified":1706236991533},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/GeneratedClcokConstraints.png","hash":"b8085cccbfc14dc10b1ae3677b5992632d61b0b8","modified":1706236991533},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/GeneratedClockEdgeShiftConstraints.png","hash":"2af04b3e906bc7987cde6b8828d3972df6250239","modified":1706236991533},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/GeneratedClockEdgeShiftPath.png","hash":"fb504b1b563b7df2ec6a9ceddfe296d0addcbc86","modified":1706236991533},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/GeneratedClockSourceClock.png","hash":"5dc47958daf1ad06096eb3a1312a6f7b1f86096d","modified":1706236991534},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/HoldupExample.png","hash":"9b067ebf2a432ea950606ac8632c4792e02736a8","modified":1706236991534},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/HoldPathRequirement.png","hash":"36c2059852796d17f131ec06ccea145c0f1652d6","modified":1706236991534},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/LaunchEdgeCaptureEdge.png","hash":"39fa93dc64cc873871c644b420dd25cc51c3defa","modified":1706236991534},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/Min_Input_Delay.png","hash":"df8f91b9d3f5eb48b26bf45a72bcc1bb570a6be7","modified":1706236991534},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/PrimaryClockConstraints.png","hash":"d1f3b126a602a8a819d37461b1e9ad3955183f28","modified":1706236991534},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/PrimaryClockConstraintsFromSerdes.png","hash":"95360bc3da4fc3594320a5474149902e723d2bf3","modified":1706236991534},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/PrimaryClockConstraints2.png","hash":"b5599991d88c6cde89f58e21e418f1b78b5286c8","modified":1706236991534},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/PrimaryClockPath.png","hash":"2d963d5cb1ff4ea164f9406a6d09b886773c2932","modified":1706236991534},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/PrimaryClockPath2.png","hash":"3d89833353ad9b2ea902f70ac316ee759d17779e","modified":1706236991534},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/PrimaryClockPathFromSerdes.png","hash":"56505396bdd6b9f801b51d2783116450e88745f0","modified":1706236991534},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/RequireTimeRecovery.png","hash":"f56469d2bb4b359392a35b15d07c6a5b169dfcdd","modified":1706236991534},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/RequireTimeRemoval.png","hash":"babcd255f1b307500da8e3cb6ddfa190f3304b44","modified":1706236991534},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/SetupRequirement与实际不符.png","hash":"a5e4b8723095f4ba36ddeb4fd86f96f9092ea9dc","modified":1706236991534},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/SlackHold.png","hash":"6eee5f50cfbd770dac405183a75b39c74f6fff3d","modified":1706236991534},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/Th的由来.png","hash":"c461a55e3fe65859650a2739c7ed2ee331bcd299","modified":1706236991534},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/Tco的由来.png","hash":"c461a55e3fe65859650a2739c7ed2ee331bcd299","modified":1706236991534},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/TimeQuestHoldupSlack.png","hash":"731f02c2bc8881d95c1eaa49de62c8ab3513a72e","modified":1706236991534},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/TimeQuestRecovery.png","hash":"cae5feccd40bef629a3b1351bfc21a00169e09db","modified":1706236991534},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/TimeQuestRemoval.png","hash":"69908aaa45bf103d34e2e3d6b94666339036cd21","modified":1706236991534},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/TimeQuest时序分析Setup2.png","hash":"a3542ea9c4c4f43a7b768bed00975e655b2cca7b","modified":1706236991535},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/TsetupThold的由来.png","hash":"5c4a6a940bb0086c45f9f30730f792d5c1fe2470","modified":1706236991535},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/Tlogic很大.png","hash":"b5e509dfb743ce22bb53b63241c0f1048cea9843","modified":1706236991535},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/dataRequiredTimeHold.png","hash":"1a29529d3c87124ba6e270f2698b36a61fc499b1","modified":1706236991535},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/clk_skew很大.png","hash":"2956c2e9aba553ee4cbe68102e2f31563df6f550","modified":1706236991535},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/holdTimeRequirement.png","hash":"b7a27f095321574ef11348bcb569d525b3da2a3f","modified":1706236991535},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/input_delay.png","hash":"8c322a4fcb064498c6c8f8a30fa91604d8125909","modified":1706236991535},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/input_delay_constraints2.png","hash":"d79c8bbaafd45711ec1461321268fdd62c65b059","modified":1706236991535},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/input_delay_constraints1.png","hash":"116578dbaeac14d5c0915a0a2f24372b8b72284f","modified":1706236991535},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/input_delay_path2.png","hash":"59429805245eb19c5f8537b80e0ccaadec645e40","modified":1706236991535},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/input_delay_constraints3.png","hash":"d45e6bdd55f51d3713ccc652c9718a1d2e586704","modified":1706236991535},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/max_input_delay.png","hash":"814b526008237d9cdac5045c7c17a4c8cad7a48c","modified":1706236991535},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/max_output_delay.png","hash":"e8dc90d4ce0973559eac19373362e9c9e6e30550","modified":1706236991535},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/min_output_delay.png","hash":"2e06c9091259f2b87ebde365d944ade32516eb3a","modified":1706236991535},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/input_delay_path1.png","hash":"ad87e6446551f8f0870b806eb9ba0cc9532a0a82","modified":1706236991535},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/multicycle_path_rtl_diagram.png","hash":"616131424958e7c82a87c07ab785997282a9e75a","modified":1706236991535},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/multicycle_path_same_clock_timing.png","hash":"2ae328bcff8f9bfe1781c78d8074f5ea9217cdb9","modified":1706236991535},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/multicycle_path_same_clock.png","hash":"f2abda9b7d7b8599c938f1f55862c6c4e8de1c41","modified":1706236991535},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/output_delay.png","hash":"a356d0fa26afa3d3b27142a49816296abbdb6ae4","modified":1706236991535},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/output_delay_constraints1.png","hash":"bffc5fd0c20f0420444507d57ec4e5099606b7cf","modified":1706236991535},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/output_delay_constraints2.png","hash":"f3dbd6e6cdcfce1826fad0f5a4b58b5717ff9873","modified":1706236991535},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/output_delay_path1.png","hash":"355692a6cc0fa3741becc4f6dda9f65990f8baf0","modified":1706236991535},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/output_delay_path2.png","hash":"ad715d88b45abca3aadbfff2790d8920f5ce761e","modified":1706236991535},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/set_clock_group_command.png","hash":"e09940c2daec6745fe78f033c3349bd592ad7813","modified":1706236991535},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/set_clock_group_command2.png","hash":"b56a5e70c43ef426794b550c1957901ad0b3632c","modified":1706236991535},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/set_clock_group_path.png","hash":"332cf2834ccffc76b192ceb2f54afc7407d15889","modified":1706236991536},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/set_false_path_a2b_single.png","hash":"5286ac0655dc45aae95ca6ae32d7fe8769427e12","modified":1706236991536},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/set_false_path_a2b_dual.png","hash":"34d50212afccda164beeea93af06a742f174c792","modified":1706236991536},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/set_false_path_command.png","hash":"7b1c7a1f2f10cbeea1b14da239ef62ef047bc58c","modified":1706236991536},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/set_false_path_reset.png","hash":"cf11ac648c88890d7f26d419961cce02961cd913","modified":1706236991536},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/set_false_path_through_command.png","hash":"b5d52d9febe82b5f3d884cc40b844557b8689886","modified":1706236991536},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_hold_4.png","hash":"c02f54e93ee8fb97124e2beadede6ddf37c2ac12","modified":1706236991536},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/set_false_path_through_diagram.png","hash":"f042677ae27671d2855f216dd81f9cc448f22fb7","modified":1706236991536},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path.png","hash":"4d725db13da7c051533a381d93275f4e5f0acdc6","modified":1706236991536},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_4_timing.png","hash":"43b87d0f6dfe4fc96649093b2d7dd5370ccf32dc","modified":1706236991536},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_fast2slow.png","hash":"729df4bf5e079a72421f3e5fb6d4d5cf7ddedb95","modified":1706236991536},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_fast2slow_setup_hold_command.png","hash":"0df63e49cbe00077b185b00239274ab3952343ec","modified":1706236991536},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_fast2slow_setup_hold_timing.png","hash":"f98cdd07b367204e0044d18fa4975f9e2879f39a","modified":1706236991536},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_fast2slow_timing.png","hash":"04ed022e79d86a8aac4ec43ba5383afcf2560ed0","modified":1706236991536},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_holdup_timing.png","hash":"7a438c5656b97926c6bf661232d4505809cf55cf","modified":1706236991536},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_holdup_adjust.png","hash":"2cfc0786cae6a0ce3d8f8ef1417fe9dc0c46d884","modified":1706236991537},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_just_setup_timing.png","hash":"a00a0b6af011ca6a296e1d35e89d84056ae9bc35","modified":1706236991537},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_just_setup.png","hash":"ba7ed483f430b9064b6dbb0951181958806cc50b","modified":1706236991537},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_minus_shift.png","hash":"825c54187e934be24488d95753b5da8f2af220d3","modified":1706236991537},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_same_clk_timing.png","hash":"2e7f77dc543ae3a8886022b86fc56c7e6ee627bb","modified":1706236991537},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_minus_shift_timing.png","hash":"fe88ee2e225bd8b088c81304ff23366e71eb6337","modified":1706236991537},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_same_clk_timing2.png","hash":"4833f3bef23cbabd9dc94edb501d0034dc326223","modified":1706236991537},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_slow2fast.png","hash":"63157ca830c24471b016f5adfc9618b2cd3b6aea","modified":1706236991537},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_slow2fast_holdup_command.png","hash":"57d3a133bb994165038d0bd4ce42ab3b45e2c15d","modified":1706236991537},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_slow2fast_holdup_timing.png","hash":"9bdf041af4a3c387ff25149165caba4073f66d85","modified":1706236991537},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_slow2fast_just_setup_command.png","hash":"d0c3d823b428896349ff7947a59daf136abf1fbb","modified":1706236991537},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_slow2fast_just_setup_timing.png","hash":"f6dbf25497c9904571beb634908df7f921d73b8b","modified":1706236991537},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_slow2fast_timing.png","hash":"1406c1526fa73e232c4488a77808bbe09c8d21ae","modified":1706236991537},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_source_destination_clock.png","hash":"a45fc8307e821acc077c57f0950900f60c79445a","modified":1706236991537},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_timeshift0.3.png","hash":"825c54187e934be24488d95753b5da8f2af220d3","modified":1706236991537},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_start_end.png","hash":"6db762eab8c3c71d5d23a4c00b01d3a589ea9520","modified":1706236991537},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_timeshift0.3_timing.png","hash":"74f2e29291333fb095a4ff51873ab0306fa40fb1","modified":1706236991537},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_setup_timeshift_timing.png","hash":"b8393693c77215c18e8bee085e05207c76671fe8","modified":1706236991537},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/set_multicyclye_path_same_clk_command.png","hash":"55d64ad21b41621f3cfc2ebbc782a22ece8f6099","modified":1706236991537},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/set_multicyclye_path_same_clk_command2.png","hash":"350df7b518946cc82c98c678478e9f0fd5bb1581","modified":1706236991537},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/setup分析data_arrival_time.png","hash":"9879f593035b406506adb889f1e0e5757b498280","modified":1706236991537},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_setup_timeshift.png","hash":"1caaed8778f2dfbdd28736648dbe4fd64b5a50e4","modified":1706236991538},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/setup_time.png","hash":"22294eb4e8bbf3c8bbcd73792da0d315a387e832","modified":1706236991538},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/setup分析data_require_time.png","hash":"589e4edb8fd1e306ad6222803220309bdb223d68","modified":1706236991538},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/setup分析setup_slack.png","hash":"f70079bccdb96063bddd8272462b0f8ffa57c398","modified":1706236991538},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/single_bit_cdc_diagram.png","hash":"dc94a657bc4a8d9efae3c143052b0975f522025e","modified":1706236991538},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/三要素.png","hash":"94701a41a9378452c58f7ca5436266d90bb1579e","modified":1706236991538},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/建立时间计算数据的需求时间.png","hash":"172d10944be2c4a878bcc51ddda74c28c7d6adeb","modified":1706236991538},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/建立时间计算数据的到达时间.png","hash":"d3559ada0225362e4f488f8d1265caddda909c5f","modified":1706236991538},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/时序分析.png","hash":"7065f95d4c2aac13ca88aca919dd1aee6c0a2c25","modified":1706236991538},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/确定建立时间要求.png","hash":"7187f4711ed43b2eb52888174f62cced58d29d3a","modified":1706236991538},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/确定建立时间要求计算.png","hash":"10c50005fce5682c0677607c2c2a038bd4bb91f2","modified":1706236991538},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/建立时间计算Setup的裕量.png","hash":"90ac1cd5cc08bb51bf8a88c0d50ff3fd6e643b00","modified":1706236991538},{"_id":"public/css/prism-tomorrow.css","hash":"733208631ad1ebf0ba27f7e6f02eb11414d4e284","modified":1706236991538},{"_id":"public/medias/featureimages/14.jpg","hash":"164bda04d4ef6ae75f149c2e822d0d0f0b79e15c","modified":1706236991576},{"_id":"public/medias/featureimages/15.jpg","hash":"867c9882842f84290ba173292d551a626106a45d","modified":1706236991580},{"_id":"public/medias/featureimages/21.jpg","hash":"9ad4b78782e69f0ace50f76daa7a4bd687738332","modified":1706236991587},{"_id":"public/medias/featureimages/27.jpg","hash":"ea65367dab59059c343cd0a211f41ca4bd0dc2c9","modified":1706236991587},{"_id":"public/medias/featureimages/37.jpg","hash":"515fd43e0acddf316a5753ea1cdc259c9571eec6","modified":1706236991588},{"_id":"public/medias/featureimages/35.jpg","hash":"2f001a7d045a952ba059eb3575664347ebbf4d1f","modified":1706236991588},{"_id":"public/medias/featureimages/38.jpg","hash":"fc728ac4c69d06e911bbc4d6cba9c9ef1b158b9f","modified":1706236991588},{"_id":"public/medias/featureimages/36.jpg","hash":"a71a869c98c68123e94706fa970333235990f0ab","modified":1706236991588},{"_id":"public/medias/featureimages/47.jpg","hash":"ee4de6373759e67d96c0fe7237620ccdd190f188","modified":1706236991588},{"_id":"public/libs/awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1706236991588},{"_id":"public/libs/awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1706236991589},{"_id":"public/2023/06/linux-nei-he-tool-mu-lu/menuconfig.png","hash":"d9715c99899d7d2ec1557e648f00a36d55032858","modified":1706236991589},{"_id":"public/2023/08/process-dbus-daemon/1.png","hash":"7544cb54cbd15240ed0ee0d34379fdf0dd202859","modified":1706236991589},{"_id":"public/2022/01/zhong-hua-tong-shi-shang-gu-shi-xia/20210703105920999.png","hash":"e6a74917abe403a8adca2103d264f2b532765b96","modified":1706236991589},{"_id":"public/2022/01/zhong-hua-tong-shi-shang-gu-shi-xia/20210703105831609.png","hash":"6f74b0d301ff93d020a051b598c1843023c8a60f","modified":1706236991590},{"_id":"public/2023/08/yu-fa-zhi-dao-fan-yi-qi/语法制导翻译.png","hash":"902f47f8cc6dc63e4f74dde3187bef5569a77ee0","modified":1706236991590},{"_id":"public/2023/09/design-inputs-outputs-for-medical-device/2023-09-14_09-16-16.png","hash":"9f1a6bfbf9752a3630b4ebc8e44726783b44b189","modified":1706236991590},{"_id":"public/2023/09/design-inputs-outputs-for-medical-device/2023-09-14_9-14-12.png","hash":"09181a48656197cd2e5ae2c7a7fc0c3cd570e1a4","modified":1706236991590},{"_id":"public/2022/01/python-shi-yong-bai-du-fan-yi-de-api/20200302113654396.png","hash":"0eb46311fe5eee6803493cec10c082d2acef996b","modified":1706236991591},{"_id":"public/2024/01/fpga-ji-ben-dan-yuan/Cyclone_IV_dEVICES_LEs.png","hash":"16c96e701acfb91ef708059851df44958426e40f","modified":1706236991591},{"_id":"public/2024/01/fpga-ji-ben-dan-yuan/LAB_control_signal_generation_circuit.png","hash":"5487de5fefa5bcfa1d513d937563b63d819c96d5","modified":1706236991591},{"_id":"public/2024/01/fpga-ji-ben-dan-yuan/LAB_structure_for_Cyclone_IV_devices.png","hash":"f3ca3716e79ac7f94992fa4650e87948855c143e","modified":1706236991595},{"_id":"public/2024/01/fpga-ji-ben-dan-yuan/LEs_in_arithmetic_mode.png","hash":"a84a9a14a75b9345093e8947996b8e99d89b1260","modified":1706236991595},{"_id":"public/2024/01/fpga-ji-ben-dan-yuan/shows_LEs_in_normal_mode.png","hash":"18cd1cc357507e273de3b440d70991946eec12d2","modified":1706236991595},{"_id":"public/2023/04/heng-shan/20230403161331.jpg","hash":"a452aeceed392945bd8cf528b00b0f6475a6f7cd","modified":1706236991595},{"_id":"public/2023/04/heng-shan/20230403161404.jpg","hash":"1c641d5779759d0d48bd33a9e4c2020b7c51cde7","modified":1706236991595},{"_id":"public/2023/04/heng-shan/20230403161412.jpg","hash":"525c7afb118f1c0052078119b3ca24df7d5101f4","modified":1706236991595},{"_id":"public/2023/05/pin-gpio/Pinctrl.png","hash":"9bdf584dbb8e6fb33546aa917b3bd76790337d3b","modified":1706236991595},{"_id":"public/2023/05/pin-gpio/imx6ull pinctrl.png","hash":"28d5e0d8c17c46bff684820293b1028d8e8752b5","modified":1706236991596},{"_id":"public/2023/05/pin-gpio/pinctrl_system.png","hash":"8a57a4a6e04e1171f13fcedb6d0fac2fe58fbd5f","modified":1706236991596},{"_id":"public/2023/05/pin-gpio/iomuxc.png","hash":"d0d101818eb5c21c45e6ed4a033de957e1cb9795","modified":1706236991596},{"_id":"public/2023/05/pin-gpio/probe.png","hash":"9d21cfe994d9a48e7442f91f0fb6e59fea403795","modified":1706236991596},{"_id":"public/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928151916481-1456634923.png","hash":"1a6e87f307777f98d725943978c00efb4090c0ba","modified":1706236991596},{"_id":"public/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928152957065-501054685.png","hash":"02e70dd300ead042177d527aebf566eb8ebec4fc","modified":1706236991596},{"_id":"public/2023/04/ye-wu-gong-neng-ye-wu-liu-cheng-ye-wu-gui-ze-fen-xi/主干流程.png","hash":"f4a5350223b0e86788af65ad517ef1302feed1e7","modified":1706236991596},{"_id":"public/2023/04/emc-emi/2023-04-04_19-28-04.png","hash":"e95e091152fa0c866d73f5014c48cf5a62f54719","modified":1706236991596},{"_id":"public/2023/04/emc-emi/2023-04-04_19-33-05.png","hash":"7477c974bab91a2621066e5f826da10bf3f970c9","modified":1706236991596},{"_id":"public/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329201646615.png","hash":"33a6c6a068648814992c82eaeab0d798cd05258e","modified":1706236991596},{"_id":"public/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329203021908.png","hash":"0648ca9586b7a83463ad4f12efc003231171b681","modified":1706236991597},{"_id":"public/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329203626594.png","hash":"3e9af02ca14cc9e5098b1b148583dee50e0a28b8","modified":1706236991597},{"_id":"public/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/2dd308b3411c41658cce041f8c230853.png","hash":"4c66e0a781c7319210351bef8458dce004c1d3df","modified":1706236991597},{"_id":"public/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/32643a6fbe010dcc95af301416619164.png","hash":"cdbf520cd2419b7cdc97569c1d38e81ea6c2186e","modified":1706236991597},{"_id":"public/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/6aadad4da134377249d84bab5dbdfa8d.png","hash":"74983111bde7189cb23f4ee194c3d6e3e0ddde3f","modified":1706236991597},{"_id":"public/2023/09/ri-luo/微信图片_20230912150554.jpg","hash":"e3cc8da2ca9c9d5919681d9982dfb702fd9e7a0e","modified":1706236991597},{"_id":"public/2023/09/ri-luo/微信图片_20230912150558.jpg","hash":"94a6956302dffb50dc1d13e91a3940fe956dabe3","modified":1706236991597},{"_id":"public/2023/09/ri-luo/微信图片_20230912150602.jpg","hash":"3c142dfc86d8bcb90a2b7956911584be1139704c","modified":1706236991597},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/Tco_Th很大.png","hash":"19e03bcf6870d445a5f64a12d5b26a50a1334769","modified":1706236991597},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/TimeQuest时序分析Setup1.png","hash":"2d3f0eeab54169b9fc0a41bd2d5a0372683bd1d2","modified":1706236991597},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/四种路径.png","hash":"370c6ba22dd25bb19893f8618bb2e6229b56fdbf","modified":1706236991597},{"_id":"public/css/gitment.css","hash":"2bd15cc17dca35ac3ecc0acf167a23a1dd362acd","modified":1706236991657},{"_id":"public/css/my-gitalk.css","hash":"eeda46a83d0db1cc239a9cd27d544faf663f9883","modified":1706236991658},{"_id":"public/css/my.css","hash":"405d61aa393c79aeb2033ef227fc7beb7b20eff6","modified":1706236991667},{"_id":"public/js/click_show_text.js","hash":"613c5e7851df10317da8ac50ec91b26a3e2ef372","modified":1706236991667},{"_id":"public/js/matery.js","hash":"c5a9c4fae16126cae80719e7435705840718b628","modified":1706236991667},{"_id":"public/js/search.js","hash":"499e11786efbb04815b54a1de317cc8606a37555","modified":1706236991667},{"_id":"public/libs/aos/aos.js","hash":"02bfb40b0c4b6e9b0b4081218357145cbb327d74","modified":1706236991667},{"_id":"public/libs/codeBlock/codeCopy.js","hash":"b74a381adf6ef8404d6a0452c2b9f44b47219c80","modified":1706236991667},{"_id":"public/libs/aplayer/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1706236991667},{"_id":"public/libs/codeBlock/codeBlockFuction.js","hash":"c7ab06d27a525b15b1eb69027135269e9b9132fb","modified":1706236991667},{"_id":"public/libs/codeBlock/codeLang.js","hash":"ea8b51e4d75e7b2cd63e4d5bcb8db2cf7f23f5db","modified":1706236991667},{"_id":"public/libs/codeBlock/codeShrink.js","hash":"215910dc8f63fd50b97957e5fcdc8480aa2728cb","modified":1706236991667},{"_id":"public/libs/jqcloud/jqcloud.css","hash":"20d9f11a19d95c70e27cb922e0d6dccbec4eae89","modified":1706236991667},{"_id":"public/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"257eaae3020599e4939f50d5008a743827f25b8c","modified":1706236991667},{"_id":"public/libs/others/explosion.min.js","hash":"417b68e2cf2c6de2119c57626f4412105a8457f5","modified":1706236991668},{"_id":"public/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1706236991668},{"_id":"public/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1706236991668},{"_id":"public/libs/others/text.js","hash":"1791782cde0d1e4197f2ed58ecb7dd6aefddd169","modified":1706236991668},{"_id":"public/libs/others/fireworks.js","hash":"53981959bc6def4a85bbbb41b07e4b1474a2124d","modified":1706236991668},{"_id":"public/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1706236991668},{"_id":"public/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1706236991668},{"_id":"public/libs/tocbot/tocbot.css","hash":"15601837bf8557c2fd111e4450ed4c8495fd11a0","modified":1706236991668},{"_id":"public/libs/others/snow.js","hash":"7f3b1ad2f64d4473210a2c3218893649c73c980e","modified":1706236991668},{"_id":"public/libs/share/css/share.min.css","hash":"8a778a86f3ce9a042df6be63a9f1039631e351a5","modified":1706236991668},{"_id":"public/css/matery.css","hash":"9177986b225313e4a986a9ff35085104e5886b2a","modified":1706236991668},{"_id":"public/libs/aos/aos.css","hash":"191a3705a8f63e589a50a0ff2f2c5559f1a1b6b2","modified":1706236991668},{"_id":"public/libs/animate/animate.min.css","hash":"97afa151569f046b2e01f27c1871646e9cd87caf","modified":1706236991669},{"_id":"public/libs/aplayer/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1706236991669},{"_id":"public/libs/codeBlock/clipboard.min.js","hash":"9cd57c67fbd3e3067f80793ef8445f5ff7783563","modified":1706236991669},{"_id":"public/libs/cryptojs/crypto-js.min.js","hash":"5989527a378b55011a59522f41eeb3981518325c","modified":1706236991669},{"_id":"public/libs/gitalk/gitalk.css","hash":"3aac1db83b0135c521187254ff302d125cc30706","modified":1706236991669},{"_id":"public/libs/gitment/gitment-default.css","hash":"2903c59ee06b965bef32e937bd69f5b0b2190717","modified":1706236991669},{"_id":"public/libs/dplayer/DPlayer.min.css","hash":"f7d19655f873b813ffba5d1a17145c91f82631b8","modified":1706236991669},{"_id":"public/libs/masonry/masonry.pkgd.min.js","hash":"ff940b4ea68368ca0e4d5560cbb79fb147dfc3c5","modified":1706236991669},{"_id":"public/libs/valine/Valine.min.js","hash":"4e34802ccbb59f1daa58a62241ff57f923e50600","modified":1706236991669},{"_id":"public/libs/gitment/gitment.js","hash":"28c02c45ce568e084cd1041dc493f83f9c6c88c6","modified":1706236991670},{"_id":"public/libs/jquery/jquery-2.2.0.min.js","hash":"5d7e5bbfa540f0e53bd599e4305e1a4e815b5dd1","modified":1706236991670},{"_id":"public/libs/dplayer/DPlayer.min.js","hash":"c3bad7b265574fab0ae4d45867422ea1cb9d6599","modified":1706236991670},{"_id":"public/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1706236991670},{"_id":"public/libs/materialize/materialize.min.js","hash":"c8b4c65651921d888cf5f27430dfe2ad190d35bf","modified":1706236991670},{"_id":"public/libs/lightGallery/js/lightgallery-all.min.js","hash":"9f5ef4bc8a0a3c746ca4f3c3e6d64493b1a977d8","modified":1706236991670},{"_id":"public/libs/materialize/materialize.min.css","hash":"4d46df5f22cbc24eefa76228c7ee308dc3585594","modified":1706236991670},{"_id":"public/libs/share/js/jquery.share.min.js","hash":"16ce82901ca0e302cf47a35fb10f59009a5e7eb9","modified":1706236991670},{"_id":"public/libs/valine/av-min.js","hash":"2577e72b52b736d99649f9e95be8976d58563333","modified":1706236991670},{"_id":"public/libs/share/js/social-share.min.js","hash":"4df722bafde2c5d8faaace0d1f894798385a8793","modified":1706236991670},{"_id":"public/libs/awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1706236991671},{"_id":"public/medias/featureimages/1.jpg","hash":"aaf5863bed7563a86a6da15cef0b5d44740e449c","modified":1706236991671},{"_id":"public/medias/featureimages/0.jpg","hash":"4e9f83cbe1575a44fe9315f937e7505ed05b6920","modified":1706236991671},{"_id":"public/medias/featureimages/10.jpg","hash":"53f3eb05edab87ee07c889f26fc550e9b5e5cb91","modified":1706236991671},{"_id":"public/medias/featureimages/16.jpg","hash":"87100d52e5077c77f9e74856a1c5330d81708ae3","modified":1706236991671},{"_id":"public/medias/featureimages/11.jpg","hash":"4e4ed3d6f8466b3362cbaaa04dc31b8859d3e202","modified":1706236991672},{"_id":"public/medias/featureimages/2.jpg","hash":"8567da47271a81b74ca341d170e057bb42f42bf5","modified":1706236991672},{"_id":"public/medias/featureimages/24.jpg","hash":"33fc0af42186fa2c0e41712d5e45c716dd47bce6","modified":1706236991672},{"_id":"public/medias/featureimages/29.jpg","hash":"a8ff01c7f29be6d703040fad7889f5afba1eb844","modified":1706236991672},{"_id":"public/medias/featureimages/31.jpg","hash":"50eedc29287470f333612e6f71d88c3121357257","modified":1706236991673},{"_id":"public/medias/featureimages/28.jpg","hash":"565fb296d8e4e2e520d6f15985f1de33d7bd98c8","modified":1706236991673},{"_id":"public/medias/featureimages/33.jpg","hash":"851fadf999b21c4e42d7a5e4114a10abd21f81cd","modified":1706236991674},{"_id":"public/medias/featureimages/43.jpg","hash":"76bf6095d8e92aa5d6a4e2dff4c2d710c61da07e","modified":1706236991674},{"_id":"public/medias/featureimages/41.jpg","hash":"51ccac5c36201f1c04f66e5d54babbb21cf5dc5f","modified":1706236991675},{"_id":"public/medias/featureimages/6.jpg","hash":"e0eb036bf77aacc91dffea2d75f590f9f1b2b961","modified":1706236991675},{"_id":"public/medias/reward/wechat.jpg","hash":"010a7b4eaf2113af7660fab39f7b7d2dc2fb314e","modified":1706236991676},{"_id":"public/libs/awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1706236991676},{"_id":"public/libs/awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1706236991676},{"_id":"public/libs/awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1706236991676},{"_id":"public/2022/01/linux-input-zi-xi-tong/2909691-20220819093409715-1604400596.png","hash":"55b9667906c85b6e35a8306dec17b969ece62590","modified":1706236991677},{"_id":"public/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928153305849-1048335725.png","hash":"aeee98d5b5d62bc471f881b6482100864635f667","modified":1706236991677},{"_id":"public/2022/01/zhong-hua-tong-shi-shang-gu-shi-xia/20210703111602157.png","hash":"eed4aad178595cbb24f9d33be2b6b893d29ebe07","modified":1706236991677},{"_id":"public/2023/08/process-dbus-daemon/2.png","hash":"f682ea3446e17801aecb40fbeca58373ac1e9263","modified":1706236991677},{"_id":"public/2022/01/zhong-hua-tong-shi-shang-gu-shi-xia/20210703105815619.png","hash":"ed38e99ca771a664503c1fc241b65609b190a652","modified":1706236991677},{"_id":"public/2023/06/ttymxx-uart/cat-proc-devices.png","hash":"d7b01cb33a859dca9532928d23f626d7e9406c71","modified":1706236991678},{"_id":"public/2023/06/ttymxx-uart/ls-dev.png","hash":"b568d5d4f2dd4c06497e8bf3fd2c9c114cb807b7","modified":1706236991678},{"_id":"public/2024/01/i2c-ban-gao-dian-ping/picture2.jpg","hash":"f2eb183fad3124674ab1183a7792f895ac978724","modified":1706236991678},{"_id":"public/2023/05/pin-gpio/gpio.png","hash":"bad8a6af0e809665e3d511cf24ab38f173abf2d0","modified":1706236991678},{"_id":"public/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928152209724-1097250473.png","hash":"05d498f7f30591101a53a8c5c95924ff1a84001d","modified":1706236991678},{"_id":"public/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928152945955-899676295.png","hash":"9714cee9d41e446e660bc06e1908adad5edd6258","modified":1706236991678},{"_id":"public/2023/04/ye-wu-gong-neng-ye-wu-liu-cheng-ye-wu-gui-ze-fen-xi/探索分支.png","hash":"3cf5793d9bf2b409bd939c0e485c6e23c7f3d28a","modified":1706236991679},{"_id":"public/2023/04/emc-emi/2023-04-04_19-34-25.png","hash":"7dcff810f530ee4d40ee76651268a3c473f7d5ed","modified":1706236991679},{"_id":"public/2023/04/bei-jing/IMG_6716.JPG","hash":"99ff60c734012614ac5407d15ead6311fc76c8fb","modified":1706236991679},{"_id":"public/2023/09/ri-luo/微信图片_20230912150619.jpg","hash":"49118eb3b5234d91bd41dbd7a8ea92fb866bd506","modified":1706236991679},{"_id":"public/2023/04/xin-jiang/1b706b934fc955412e3ed163fd0b7cbc2.JPG","hash":"197d9abf8cb2a83ba7f92192e339ebdef533f956","modified":1706236991679},{"_id":"public/2023/04/xin-jiang/89c05a76a9273811c585c395890c9f522.JPG","hash":"acd08647f23bdbabb1f68cc061086d71df0dccd8","modified":1706236991679},{"_id":"public/libs/gitalk/gitalk.min.js","hash":"564fc7c731d05fa70d71ef853a2c8cc7725739e2","modified":1706236991730},{"_id":"public/libs/echarts/echarts.min.js","hash":"9496f386a0da4601cad22c479cc5543913a4d67f","modified":1706236991730},{"_id":"public/medias/featureimages/20.jpg","hash":"e854df6ea24c22c999216db611dfd3785b76b834","modified":1706236991731},{"_id":"public/medias/featureimages/23.jpg","hash":"c2f1f9387db7dd99d3c0e4df42a160d482dde5bd","modified":1706236991731},{"_id":"public/medias/featureimages/30.jpg","hash":"6dfe6d277ec3ef36e8c958a71712702a5be3e4d8","modified":1706236991732},{"_id":"public/medias/featureimages/46.jpg","hash":"1e73f8ed0bd91c4443c4f7e57d2ea5cf94d419c6","modified":1706236991732},{"_id":"public/medias/featureimages/8.jpg","hash":"b04f9b49261b2486260e64e6543da45689e272de","modified":1706236991732},{"_id":"public/medias/featureimages/13.jpg","hash":"1eed284202ae51c4f3051d943b3d97a7602a9fc6","modified":1706236991732},{"_id":"public/medias/banner/5.jpg","hash":"38272cddbb09c70c7785aed877f6c9b45a61262a","modified":1706236991732},{"_id":"public/medias/featureimages/3.jpg","hash":"4cabac02df559a5eb1b9abc8a0359fe6573a738b","modified":1706236991733},{"_id":"public/medias/featureimages/32.jpg","hash":"e440f9bdcdff7c181904b26b2774c48632e4d24a","modified":1706236991733},{"_id":"public/medias/featureimages/34.jpg","hash":"6fca10e13cae2a089909ea266fa6be510e57a2bd","modified":1706236991733},{"_id":"public/medias/featureimages/4.jpg","hash":"d7139f883aad272d619ce181ebcd86672a2a7bdc","modified":1706236991733},{"_id":"public/medias/featureimages/45.jpg","hash":"5c22e8d627f763ebae1d080025aee103383a8460","modified":1706236991734},{"_id":"public/medias/featureimages/7.jpg","hash":"26833abcdd65e10c48e8d0553cb3543d3e0ca4d8","modified":1706236991735},{"_id":"public/medias/featureimages/5.jpg","hash":"38272cddbb09c70c7785aed877f6c9b45a61262a","modified":1706236991738},{"_id":"public/medias/featureimages/48.jpg","hash":"13754e6efc8f6db46088d736ed2c290b0d9bfb33","modified":1706236991739},{"_id":"public/medias/reward/alipay.jpg","hash":"bf966a223684650a6c5f1bc5df6d571493e922f3","modified":1706236991739},{"_id":"public/medias/featureimages/22.jpg","hash":"2beb56f529f0ce49f36a84d55890b7c0de3d7705","modified":1706236991741},{"_id":"public/medias/featureimages/18.jpg","hash":"b8108799fbf3eadf0462fba04034a277a462018b","modified":1706236991742},{"_id":"public/medias/featureimages/44.jpg","hash":"6bca5b340c7e16350e3040da2416f6184ccd64a4","modified":1706236991742},{"_id":"public/2023/04/ye-wu-gong-neng-ye-wu-liu-cheng-ye-wu-gui-ze-fen-xi/业务规则.png","hash":"9096eaf502a8c77966e2ddba42aeca3d42a30c59","modified":1706236991743},{"_id":"public/2022/01/python-shi-yong-bai-du-fan-yi-de-api/20200302112847600.png","hash":"7826ff6dbdf5ff34629750ce22b0e94cccadef69","modified":1706236991743},{"_id":"public/2023/06/ttymxx-uart/cat-ttymxc2.png","hash":"5847a4ae7a6b9dc2e40b772d68e265417b69cebc","modified":1706236991743},{"_id":"public/2023/04/heng-shan/20230403161419.jpg","hash":"d52eba8c569ccd38a42589d5feccbad599bdb78e","modified":1706236991744},{"_id":"public/2023/09/ri-luo/微信图片_20230912150606.jpg","hash":"8245afc282aa75441b905a0328565a1bf7f9f4fe","modified":1706236991744},{"_id":"public/2023/09/ri-luo/微信图片_20230912150614.jpg","hash":"6d91b0d98fb205d1b72d17c6592c9623df2bfb53","modified":1706236991744},{"_id":"public/favicon.png","hash":"6fee8f6cf28858211c47939cb172633b18d1eee1","modified":1706236991845},{"_id":"public/medias/featureimages/39.jpg","hash":"2b914a3b098aa874f68b4fcda7c85613140c6420","modified":1706236991845},{"_id":"public/medias/featureimages/26.jpg","hash":"9c2eaf5aff8abdc4e215af96002c8525be9ddd06","modified":1706236991845},{"_id":"public/medias/featureimages/25.jpg","hash":"97930cf52f9e68ccf24d26b383704ca4724dae34","modified":1706236991845},{"_id":"public/medias/featureimages/17.jpg","hash":"4cbd4926b13132903c465685a127c577b56b2b8b","modified":1706236991846},{"_id":"public/medias/featureimages/42.jpg","hash":"c05648a22e1f083d13f40e76fed535f027fae0b6","modified":1706236991846},{"_id":"public/medias/music/avatars/每天爱你多一些.jpg","hash":"2beb56f529f0ce49f36a84d55890b7c0de3d7705","modified":1706236991846},{"_id":"public/medias/featureimages/12.jpg","hash":"29f884076a7fbed6900a1a05c41ffd3ce122a123","modified":1706236991847},{"_id":"public/2023/04/emc-emi/2023-04-04_19-30-08.png","hash":"4affe9d70ae0f96d3e097dedefeb4d8c2255f202","modified":1706236991847},{"_id":"public/2023/04/emc-emi/2023-04-04_19-32-59.png","hash":"f87f697280797d30f0e2f288829d1ef1e01679c5","modified":1706236991847},{"_id":"public/2023/04/xin-jiang/5d0b74a8910a3abba7e860149b9d40e12.JPG","hash":"ec0e0cd928032ca04d666abf09e657b401f8c286","modified":1706236991847},{"_id":"public/2023/04/heng-shan/20230403161440.jpg","hash":"de330e0d5f878351e1c4e01fd03e6646f47b7cd7","modified":1706236991847},{"_id":"public/2022/01/python-shi-yong-bai-du-fan-yi-de-api/20200302113313981.png","hash":"a3bc848fc823b39cb9304360dabc4113a61ebb40","modified":1706236991848},{"_id":"public/2023/04/shen-zhen-wu-tong-shan-mao-mian-du-juan/2b135a37c965e856f04d4a5faf8d2f2b2.JPG","hash":"f4165d53241b101e85fad7128831f04d684ad00a","modified":1706236991848},{"_id":"public/2023/04/ye-wu-gong-neng-ye-wu-liu-cheng-ye-wu-gui-ze-fen-xi/业务规则上.png","hash":"106e7b83de735bd1506057f05bded3f5b3f5fd1f","modified":1706236991848},{"_id":"public/2023/04/bei-jing/IMG_6717.JPG","hash":"9bfb74c92dc7ea4217d2dd03624ef50acf2e5d38","modified":1706236991848},{"_id":"public/medias/featureimages/40.jpg","hash":"7a69b037ce05312d9322fe3f11c4d645b88645aa","modified":1706236991878},{"_id":"public/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928152922659-1842915282.png","hash":"3e599491c205ce9c2473c7cb88ae34ffe5ed810c","modified":1706236991878},{"_id":"public/2022/01/chao-xiang-xi-jie-xi-python-pa-qu-wai-wang-tu-pian/20200302110709393.png","hash":"2ad2b400e4ac4b25e38c950980367bb6b7276066","modified":1706236991878},{"_id":"public/2023/06/ttymxx-uart/ttymxc.png","hash":"37188802f04a32b89f1bebec4b86cdf8df87472b","modified":1706236991878},{"_id":"public/2022/01/python-shi-yong-bai-du-fan-yi-de-api/20200302112753932.png","hash":"6f7c69b14491228187f0b0d593687015b1751112","modified":1706236991879},{"_id":"public/2023/04/emc-emi/2023-04-04_19-31-27.png","hash":"a548cc6c623a27b9b1ef07bf747c2f5846a1b8ad","modified":1706236991879},{"_id":"public/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/c7546c50623e8a8aa6ab33ead8fac6cb.png","hash":"a7316beb6a20159dfeb953c21713feeac78ac6ac","modified":1706236991879},{"_id":"public/2023/09/ri-luo/微信图片_20230912150622.jpg","hash":"b696a7b6c0a220fb02fbe911aee4def1f892612c","modified":1706236991879},{"_id":"public/2023/04/xin-jiang/76d386e1b8eeeb85abab758cefc855e0.JPG","hash":"b5263a0698617a32ddcab1602d590abea3061540","modified":1706236991880},{"_id":"public/2023/09/ri-luo/微信图片_20230912150536.jpg","hash":"9ea183b71aedb6d5bdb481e4b704d246952a564e","modified":1706236991913},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/set_max_delay_diagram.png","hash":"ab134fb201c7619ec1eb28596c87d89491feae0b","modified":1706236991913},{"_id":"public/2024/01/i2c-ban-gao-dian-ping/picture1.jpg","hash":"40165e2cdbe010e9a7cf691b8a9c4a8e168e6f3c","modified":1706236991914},{"_id":"public/2023/05/pin-gpio/pinctrl struct.png","hash":"8fb5c14e3e7b5a3819fd16cc07cead5aef72dae1","modified":1706236991914},{"_id":"public/medias/logo.png","hash":"6fee8f6cf28858211c47939cb172633b18d1eee1","modified":1706236991951},{"_id":"public/medias/banner/6.jpg","hash":"5be9274e63d6ac02607e3d659fd32532291385fa","modified":1706236991951},{"_id":"public/medias/banner/2.jpg","hash":"c2980f75f2c047d0957e3c8227b3f8d84e67f752","modified":1706236991952},{"_id":"public/medias/banner/0.jpg","hash":"73bae0e6812c46509b91e3155bd12ce8640b245a","modified":1706236991952},{"_id":"public/medias/banner/4.jpg","hash":"4d6f31f86966584360bcdbfecb6f6a2ec94f944d","modified":1706236991952},{"_id":"public/medias/banner/1.jpg","hash":"cd3fc47d2042a3277e4b375ad084365abdc28f5d","modified":1706236991953},{"_id":"public/2023/04/ye-wu-gong-neng-ye-wu-liu-cheng-ye-wu-gui-ze-fen-xi/穷尽分支.png","hash":"7af9f4b00d74e30e5821ba95a050baa41c7e37f9","modified":1706236991953},{"_id":"public/2023/09/design-inputs-outputs-for-medical-device/2023-09-14_09-19-28.png","hash":"94508ac046819fc5a1216027197c42570e7f6b59","modified":1706236991954},{"_id":"public/2023/04/emc-emi/2023-04-04_19-35-03.png","hash":"75a164a1aefb14493fd964ec6f1af67dad08dfad","modified":1706236991955},{"_id":"public/2023/04/bei-jing/DSC01699.JPG","hash":"88fd74c50d76197f25fcea4f145b0b7315afa381","modified":1706236991955},{"_id":"public/2023/04/xin-jiang/95d557eb4ef2235d74a45743be1b05842.JPG","hash":"4b854a6ecb431a313e93f8d48df7fd0044aa372c","modified":1706236991956},{"_id":"public/2024/01/shi-xu-yue-shu-zheng-li/复位结构.png","hash":"e4eef5c5a6c4454fd6714d1e0b1627bda96ff52a","modified":1706236991956},{"_id":"public/2023/08/yu-fa-zhi-dao-fan-yi-qi/简单语法制导定义.png","hash":"d8804dd13106bc160a54eb9d4608ae152771c85b","modified":1706236991975},{"_id":"public/2023/04/shen-zhen-wu-tong-shan-mao-mian-du-juan/7d011510a39a8f6e23429fa828448a7c2.JPG","hash":"e39b53d9c09ac1a17144d8bc8190636d516184fb","modified":1706236991975},{"_id":"public/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329201443609.png","hash":"58a7a16ec9b08da3d87fb952be7b90fa42d40b8a","modified":1706236991976},{"_id":"public/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/e852708ffd1c78efd87949efa7b31592.png","hash":"278cedda4410f27e589063fce68238de6ca46b43","modified":1706236991976},{"_id":"public/2023/04/xin-jiang/a2a9265c2707c16b5a1ca704a4d0856d.JPG","hash":"32140a32efde0712248d80606354ef18c8bdca95","modified":1706236991976},{"_id":"public/medias/avatars/myzhihu.png","hash":"4a9aec7e236615e3b698adfd3b36bc34ec05e5c7","modified":1706236991995},{"_id":"public/libs/awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1706236991995},{"_id":"public/2023/08/yu-fa-zhi-dao-fan-yi-qi/语法定义.png","hash":"a533dc2a50c57ec6e94517ba335cfcb3efd640ad","modified":1706236991996},{"_id":"public/2023/04/bei-jing/DSC01821.JPG","hash":"427acd97f61076e72289f67d92116b5264d532b6","modified":1706236991997},{"_id":"public/2023/04/xin-jiang/88a98ae85a4705294439aca39ae07d672.JPG","hash":"efaf4595479444c71cb33287f510e15a97023d5e","modified":1706236991997},{"_id":"public/2023/04/xin-jiang/a51d80549e7edc0d1ba69a885aa946ff2.JPG","hash":"d035b1f8fc6fa4742360fa30519dc3c349c5eb9d","modified":1706236991998},{"_id":"public/2023/04/shen-zhen-wu-tong-shan-mao-mian-du-juan/0a32e20ee914cca207bd5e0446eca332.JPG","hash":"d8487b0b07b39733ff17269e2ab21b35290fc7d5","modified":1706236992011},{"_id":"public/2023/04/heng-shan/20230403161434.jpg","hash":"eb3aa00bd533848c1fcdc5b8978baa825c332a99","modified":1706236992011},{"_id":"public/2023/04/bei-jing/DSC01645.JPG","hash":"37aae358c05c3ebe858be7fde41a6d991c53ffac","modified":1706236992012},{"_id":"public/2023/04/heng-shan/20230403161427.jpg","hash":"edede76d7524dbff86198f9ed27af324e846a990","modified":1706236992028},{"_id":"public/2023/04/ye-wu-gong-neng-ye-wu-liu-cheng-ye-wu-gui-ze-fen-xi/业务规则下.png","hash":"b2d1bd226e043c5a49cf997d195eab5828624e2e","modified":1706236992028},{"_id":"public/2023/09/ri-luo/微信图片_20230912090924.png","hash":"0d9e6f9116dc04a762668fc98b0176078bc17bd5","modified":1706236992029},{"_id":"public/2023/04/shen-zhen-wu-tong-shan-mao-mian-du-juan/f4e3370968454b29062472df853b648e.JPG","hash":"9527a20734ba33ad970d1c09e9c5af69148a9e36","modified":1706236992042},{"_id":"public/2023/04/shen-zhen-wu-tong-shan-mao-mian-du-juan/6f19a8a8bff80c030eeba535032db0f6.JPG","hash":"247ba6417dab25febabd897888b92c780012a972","modified":1706236992051},{"_id":"public/2023/04/bei-jing/DSC01755.JPG","hash":"45e044a7a2e818bc76bc695a2349c0220d2a6f43","modified":1706236992051},{"_id":"public/2023/04/bei-jing/DSC01827.JPG","hash":"93f303dcf1cb66fc7c46f1912cb33edc4fcc7c0c","modified":1706236992052},{"_id":"public/medias/featureimages/49.jpg","hash":"90ad50712c339a89402a363288dcd355e98d0fbb","modified":1706236992061},{"_id":"public/2023/04/shen-zhen-wu-tong-shan-mao-mian-du-juan/d2a7004a2e039c3f37d5fef10c7cc28a2.JPG","hash":"21997245573176ef723eae80b8337f1710d4a552","modified":1706236992061},{"_id":"public/2023/04/bei-jing/DSC01687.JPG","hash":"0ca6df7cba2538cc3df7566e7652696abcbff8cf","modified":1706236992067},{"_id":"public/2023/04/bei-jing/DSC01697.JPG","hash":"e2bdc7040260ef7a9fafaf623a3f980e69faec27","modified":1706236992068},{"_id":"public/2022/01/chao-xiang-xi-jie-xi-python-pa-qu-wai-wang-tu-pian/20200302111109517.png","hash":"3c1684024bc31494b116961152500c0109172a72","modified":1706236992081},{"_id":"public/2023/04/bei-jing/DSC01722.JPG","hash":"a50dcaff1db6ca1e6c7c746a580a96edf3695b61","modified":1706236992082},{"_id":"public/2023/08/yu-fa-zhi-dao-fan-yi-qi/文法定义.png","hash":"7a64dc003c476333af7f06cbe5e6669c2fcb5bf4","modified":1706236992093},{"_id":"public/2023/08/yu-fa-zhi-dao-fan-yi-qi/语法分析树.png","hash":"14fa0001d480a283ac54305d5ed033bd991005d8","modified":1706236992093},{"_id":"public/2023/04/xin-jiang/BBND3773.PNG","hash":"9d51e64746eaf562e333c0c58b1665c87b7e3c94","modified":1706236992093},{"_id":"public/2023/04/xin-jiang/6d0c92b575f36108df2062fda3b1e4ba2.PNG","hash":"b1520fdd30b641aad9016617c32119cd8ed82a27","modified":1706236992098},{"_id":"public/2023/04/xin-jiang/KNLN1045.PNG","hash":"9b81832789db7ed79eceb15cfd62958fe3c81f1e","modified":1706236992111},{"_id":"public/2023/04/ten-ge-li/6.jpg","hash":"7b0cbe85e3ac8f3bb07b151342332b577bf62c3b","modified":1706236992119},{"_id":"public/2023/04/xin-jiang/50f3a54d039eb642be22bc25607e11ca2.PNG","hash":"81d8346d84e26f93cfdc42b386fcbe5346f645ea","modified":1706236992120},{"_id":"public/2023/04/xin-jiang/254bc46a6128338402204fa78f54b3e12.PNG","hash":"e41e37de90a7768a13e2c5094c4b930aa03a47eb","modified":1706236992132},{"_id":"public/medias/banner/3.jpg","hash":"42a57b512acce7f09f122b6b8c4f85c3803cd438","modified":1706236992138},{"_id":"public/2023/04/ten-ge-li/5.jpg","hash":"8f369783db3afe07144f07bc27ab714853c3cfbb","modified":1706236992147},{"_id":"public/medias/music/不见就散-周深.mp3","hash":"c96c5ad02f4138acc75321d0651d776939a8410b","modified":1706236992166},{"_id":"public/2023/04/ten-ge-li/4.jpg","hash":"65423da6e9df83013372da9c0144723480560524","modified":1706236992179},{"_id":"public/medias/music/每天爱你多一些-张学友.mp3","hash":"c4c9d37ac5b8012f0650fc6e1d414160bb6cbd5e","modified":1706236992189},{"_id":"public/2023/04/ten-ge-li/1.jpg","hash":"aa5cc837537f2d220f140380d8aa4deb88ebc328","modified":1706236992213},{"_id":"public/2023/04/xin-jiang/MOVG5083.JPG","hash":"d735c13bacae84426c35f79b31f0d76e56b5dbcb","modified":1706236992231},{"_id":"public/2023/07/linux-platform/platform.png","hash":"8bbaa84862913279d587bda57cb8cbe1f203a548","modified":1706236992250},{"_id":"public/2023/04/ten-ge-li/3.jpg","hash":"ebdd58409be4f13114b49aca45a14587d6d33f7f","modified":1706236992250},{"_id":"public/2023/04/xin-jiang/YJUM1401.JPG","hash":"2298f67966321b94c232d69b82a5d0c3725c250b","modified":1706236992262},{"_id":"public/2023/04/xin-jiang/XRBQ0574.JPG","hash":"0a22babef32c3458bf6d3b132fc86fdb92df4ac1","modified":1706236992267},{"_id":"public/2023/04/ten-ge-li/2.jpg","hash":"a67afd08d4cfc6ad6f1df81d6b9f6799ddaf2b5d","modified":1706236992267},{"_id":"public/2023/09/medical-device-registration-standards/2023-09-14_10-00-13.png","hash":"6adb3401596eb5483381e51c9353e26a40251591","modified":1706236992276},{"_id":"public/2023/04/shang-hai/20230403160809.jpg","hash":"c00d70be19d150a3e7852ba2bf0eb43d79b5af8e","modified":1706236992276},{"_id":"public/2023/04/xin-jiang/ANKG1449.JPG","hash":"5baaa1ab9105091d0118f76229cef42117d346d3","modified":1706236992279},{"_id":"public/2023/04/xin-jiang/IGAX1811.JPG","hash":"b28a4910831f07c5d9a24e7a89f1a13a89c4e499","modified":1706236992284},{"_id":"public/2023/04/ten-ge-li/IMG_6912.JPG","hash":"cf10a567bf3ebbe495dbefef9766d64f40838583","modified":1706236992302},{"_id":"public/2023/04/xin-jiang/AZQE3071.JPG","hash":"ec500582aece897e57480cf258033db9afa09b4d","modified":1706236992302},{"_id":"public/2023/04/xin-jiang/AQSR2937.JPG","hash":"803cbcd9795224d0fe0f955a183097d5841e7e4a","modified":1706236992309},{"_id":"public/2023/04/xin-jiang/BBOD4958.JPG","hash":"d91a8e27fa87b395cf945e442e26b5afa5958529","modified":1706236992327},{"_id":"public/2023/04/ten-ge-li/IMG_6899.JPG","hash":"a83cb2a77b6e0783769e8db226b18ee12b684015","modified":1706236992332},{"_id":"public/2023/04/shang-hai/20230403160820.jpg","hash":"67c97c223cf033355d5f224595e474000472c8ee","modified":1706236992351},{"_id":"public/medias/music/平凡之路-朴树.mp3","hash":"fab92512ec9c0cdc2ea41889f440084c86786e05","modified":1706236992361},{"_id":"public/2023/04/shang-hai/20230403160752.jpg","hash":"1dd95e72274267e787dd795d8f25325365be8976","modified":1706236992365},{"_id":"public/2023/04/ten-ge-li/IMG_7069.JPG","hash":"54e10986b7f644c3f58d7231c4083ba7bf6b5934","modified":1706236992378},{"_id":"public/2023/04/shang-hai/20230403160815.jpg","hash":"4791996fab30c9e1b0a57b5362fa19252382924a","modified":1706236992383}],"Category":[{"name":"linux","_id":"clru1g2020009s4fusskta275"},{"name":"python","_id":"clru1g20e000is4fu8m7w6byr"},{"name":"history","_id":"clru1g20o000qs4fubbcbssh7"},{"name":"Embedded system","_id":"clru1g20w000ws4fun9y4rod1"},{"name":"gallery","_id":"clru1g2130014s4fuc3w84hjm"},{"name":"硬件","_id":"clru1g21d001bs4fuhd91vark"},{"name":"study","_id":"clru1g21u002cs4fu8qnm3d0x"},{"name":"process","_id":"clru1g21x002ls4furih9pp87"},{"name":"linux","parent":"clru1g21x002ls4furih9pp87","_id":"clru1g22b003es4fuo8v9rtyu"},{"name":"编译原理","_id":"clru1g22p004is4fumdau8ai0"},{"name":"FPGA","_id":"clru1g22v0055s4fur29a95rc"}],"Data":[{"_id":"musics","data":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}],"Page":[{"title":"404","date":"2019-07-19T08:41:10.000Z","type":"404","layout":"404","description":"你来到了没有知识的荒原 :(","_content":"","source":"404.md","raw":"---\ntitle: 404\ndate: 2019-07-19 16:41:10\ntype: \"404\"\nlayout: \"404\"\ndescription: \"你来到了没有知识的荒原 :(\"\n---\n","updated":"2024-01-05T08:12:19.068Z","path":"404.html","comments":1,"_id":"clru1g1ps0000s4fu4pl4tov2","content":"","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":""},{"title":"about","date":"2020-01-01T08:41:10.000Z","type":"about","layout":"about","_content":"\n\n# 教育经历\n\n* <b>本科 自动化</b>\n\n2020/09 - 现在\n<b>努力小白</b>\n\n\n\n# 联系方式\n\n* <b>电子邮箱</b>\n845343253@qq.com\n* <b>地址</b>\n太阳系地球中国境内\n* <b>微信</b>\n17675443156\n* <b>QQ</b>\n845343253","source":"about/index.md","raw":"---\ntitle: about\ndate: 2020-01-01 16:41:10\ntype: \"about\"\nlayout: \"about\"\n---\n\n\n# 教育经历\n\n* <b>本科 自动化</b>\n\n2020/09 - 现在\n<b>努力小白</b>\n\n\n\n# 联系方式\n\n* <b>电子邮箱</b>\n845343253@qq.com\n* <b>地址</b>\n太阳系地球中国境内\n* <b>微信</b>\n17675443156\n* <b>QQ</b>\n845343253","updated":"2024-01-05T08:12:19.886Z","path":"about/index.html","comments":1,"_id":"clru1g1sp0001s4fuokybur6h","content":"<h1 id=\"教育经历\"><a href=\"#教育经历\" class=\"headerlink\" title=\"教育经历\"></a>教育经历</h1><ul>\n<li><b>本科 自动化</b></li>\n</ul>\n<p>2020/09 - 现在<br><b>努力小白</b></p>\n<h1 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h1><ul>\n<li><b>电子邮箱</b><br><a href=\"mailto:845343253@qq.com\" target=\"_blank\" rel=\"noopener\">845343253@qq.com</a></li>\n<li><b>地址</b><br>太阳系地球中国境内</li>\n<li><b>微信</b><br>17675443156</li>\n<li><b>QQ</b><br>845343253</li>\n</ul>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<h1 id=\"教育经历\"><a href=\"#教育经历\" class=\"headerlink\" title=\"教育经历\"></a>教育经历</h1><ul>\n<li><b>本科 自动化</b></li>\n</ul>\n<p>2020/09 - 现在<br><b>努力小白</b></p>\n<h1 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h1><ul>\n<li><b>电子邮箱</b><br><a href=\"mailto:845343253@qq.com\" target=\"_blank\" rel=\"noopener\">845343253@qq.com</a></li>\n<li><b>地址</b><br>太阳系地球中国境内</li>\n<li><b>微信</b><br>17675443156</li>\n<li><b>QQ</b><br>845343253</li>\n</ul>\n"},{"title":"archives","date":"2020-01-01T08:39:20.000Z","type":"archives","layout":"archives","_content":"","source":"archives/index.md","raw":"---\ntitle: archives\ndate: 2020-01-01 16:39:20\ntype: \"archives\"\nlayout: \"archives\"\n---","updated":"2024-01-05T08:12:19.886Z","path":"archives/index.html","comments":1,"_id":"clru1g1sp0002s4fur9lqi147","content":"","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":""},{"title":"categories","date":"2020-01-01T08:39:20.000Z","type":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2020-01-01 16:39:20\ntype: \"categories\"\nlayout: \"categories\"\n---","updated":"2024-01-05T08:12:19.887Z","path":"categories/index.html","comments":1,"_id":"clru1g1u80003s4fupoy3g87c","content":"","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":""},{"title":"contact","date":"2020-01-01T09:17:02.000Z","type":"contact","layout":"contact","_content":"\n# 欢迎留言\n大家有任何问题，都可以在评论区给我留言，或者加我联系方式：\n* QQ：**845343253**\n* 微信：**17675443156**\n\n# 友链交换\n想要交换友链的小伙伴，欢迎在评论区留言，留言格式：\n* **名称：**你的博客名称\n* **地址：**你的博客地址\n* **简介：**一句话简介\n* **头像：**你的头像地址","source":"contact/index.md","raw":"---\ntitle: contact\ndate: 2020-01-01 17:17:02\ntype: \"contact\"\nlayout: \"contact\"\n---\n\n# 欢迎留言\n大家有任何问题，都可以在评论区给我留言，或者加我联系方式：\n* QQ：**845343253**\n* 微信：**17675443156**\n\n# 友链交换\n想要交换友链的小伙伴，欢迎在评论区留言，留言格式：\n* **名称：**你的博客名称\n* **地址：**你的博客地址\n* **简介：**一句话简介\n* **头像：**你的头像地址","updated":"2024-01-05T08:12:19.887Z","path":"contact/index.html","comments":1,"_id":"clru1g1vt0004s4fufnha9zhd","content":"<h1 id=\"欢迎留言\"><a href=\"#欢迎留言\" class=\"headerlink\" title=\"欢迎留言\"></a>欢迎留言</h1><p>大家有任何问题，都可以在评论区给我留言，或者加我联系方式：</p>\n<ul>\n<li>QQ：<strong>845343253</strong></li>\n<li>微信：<strong>17675443156</strong></li>\n</ul>\n<h1 id=\"友链交换\"><a href=\"#友链交换\" class=\"headerlink\" title=\"友链交换\"></a>友链交换</h1><p>想要交换友链的小伙伴，欢迎在评论区留言，留言格式：</p>\n<ul>\n<li><strong>名称：</strong>你的博客名称</li>\n<li><strong>地址：</strong>你的博客地址</li>\n<li><strong>简介：</strong>一句话简介</li>\n<li><strong>头像：</strong>你的头像地址</li>\n</ul>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<h1 id=\"欢迎留言\"><a href=\"#欢迎留言\" class=\"headerlink\" title=\"欢迎留言\"></a>欢迎留言</h1><p>大家有任何问题，都可以在评论区给我留言，或者加我联系方式：</p>\n<ul>\n<li>QQ：<strong>845343253</strong></li>\n<li>微信：<strong>17675443156</strong></li>\n</ul>\n<h1 id=\"友链交换\"><a href=\"#友链交换\" class=\"headerlink\" title=\"友链交换\"></a>友链交换</h1><p>想要交换友链的小伙伴，欢迎在评论区留言，留言格式：</p>\n<ul>\n<li><strong>名称：</strong>你的博客名称</li>\n<li><strong>地址：</strong>你的博客地址</li>\n<li><strong>简介：</strong>一句话简介</li>\n<li><strong>头像：</strong>你的头像地址</li>\n</ul>\n"},{"title":"gallery","date":"2019-11-30T08:00:17.000Z","type":"gallery","layout":"gallery","_content":"","source":"gallery/index.md","raw":"---\ntitle: gallery\ndate: 2019-11-30 16:00:17\ntype: \"gallery\"\nlayout: \"gallery\"\n---\n","updated":"2024-01-05T08:12:19.887Z","path":"gallery/index.html","comments":1,"_id":"clru1g1vv0005s4fu15g97e1a","content":"","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":""},{"title":"tags","date":"2020-01-01T08:40:27.000Z","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2020-01-01 16:40:27\ntype: \"tags\"\nlayout: \"tags\"\n---","updated":"2024-01-05T08:12:19.888Z","path":"tags/index.html","comments":1,"_id":"clru1g1vx0006s4fu3y2vk24u","content":"","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":""}],"Post":[{"title":"linux线程","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2022-01-01T13:08:57.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"<blockquote>\n<p>linux内核版本0.11</p>\n</blockquote>\n<h1>1：main</h1>\n<p>首先选出一号选手main函数，代码上和线程相关的主要是以下代码</p>\n<pre>\n\t<code class=\"yaml\">\n    void main(void) {    \n    move_to_user_mode();\n    if (!fork()) {\n        init();\n    }\n    for(;;) pause();\n}</code>\n</pre>\n<h1>&nbsp;2：<span style=\"letter-spacing: 0.5px;\"><strong>move_to_user_mode</strong></span></h1>\n<p><span style=\"letter-spacing: 0.5px; font-size: 15px;\"><span style=\"letter-spacing: 0.5px;\">这行代码的意思直接说非常简单，就是<strong>从内核态转变为了用户态</strong></span></span></p>\n<p>&nbsp;</p>\n<pre>\n\t<code class=\"yaml\">\n\t#define move_to_user_mode() \\\n\t__asm__ (\"movl %%esp,%%eax\\n\\t\" \\\n\t\"pushl $0x17\\n\\t\" \\\n\t\"pushl %%eax\\n\\t\" \\\n\t\"pushfl\\n\\t\" \\\n\t\"pushl $0x0f\\n\\t\" \\\n\t\"pushl $1f\\n\\t\" \\\n\t\"iret\\n\" \\\n\t\"1:\\tmovl $0x17,%%eax\\n\\t\" \\\n\t\"movw %%ax,%%ds\\n\\t\" \\\n\t\"movw %%ax,%%es\\n\\t\" \\\n\t\"movw %%ax,%%fs\\n\\t\" \\\n\t\"movw %%ax,%%gs\" \\\n\t:::\"ax\")\n</code>\n</pre>\n<h1>&nbsp;3：fork</h1>\n<p>fork函数是被系统调用使用的 具体路径如下：</p>\n<p>main.c:static inline _syscall0（int,fork）将fork绑定到_sys_fork</p>\n<p>　　system_call.s:_sys_fork:（调用函数_find_empty_process和_copy_process）</p>\n<p><img src=\"linux线程/2909691-20221018201940242-320806714.png\" alt=\"\" /></p>\n<p>总结作用：</p>\n<p>1：在task链表中找到一个进程空位并存放当前的进程（_find_empty_process）</p>\n<p>2：创建一个tsak_struct</p>\n<p>3：设置task_struct（_copy_process）</p>\n<p>这里就出现一个概念：<span style=\"font-size: 14px; letter-spacing: 0.5px;\">由于我们现在只有 0 号进程，且 task[] 除了 0 号索引位置，其他地方都是空的，所以这个方法运行完，last_pid 就是 1，也就是新进程被分配的 pid 就是 1</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\"><img src=\"linux线程/2909691-20221018202536805-171723429.png\" alt=\"\" /></span></p>\n<h1>4:init()</h1>\n<pre>\n\t<code class=\"yaml\">\n\tvoid init(void)\n\t{\n\t\tint pid,i;\n\t\tsetup((void *) &amp;drive_info);\n\t\t(void) open(\"/dev/tty0\",O_RDWR,0); //打开tty0 标准输入控制台\n\t\t(void) dup(0);//打开tty0 标准输出控制台\n\t\t(void) dup(0);//打开标准错误控制台\n\t\tprintf(\"%d buffers = %d bytes buffer space\\n\\r\",NR_BUFFERS,\n\t\t\tNR_BUFFERS*BLOCK_SIZE);\n\t\tprintf(\"Free mem: %d bytes\\n\\r\",memory_end-main_memory_start);\n\t\t//又创建一个进程（2号进程）<br />　　　　 if (!(pid=fork())) {\n\t\t\tclose(0);\n\t\t\tif (open(\"/etc/rc\",O_RDONLY,0)) ///etc/rc文件\n\t\t\t\t_exit(1);\n\t\t\texecve(\"/bin/sh\",argv_rc,envp_rc);//执行sh\n\t\t\t_exit(2);\n\t\t}\n\t\tif (pid&gt;0)\n\t\t\twhile (pid != wait(&amp;i))//等待父进程退出\n\t\t\t\t/* nothing */;\n\t\twhile (1) {<br />　　　　　　　　 //又创建一个进程 主要是害怕上面的进程创建失败 再创建一次\n\t\t\tif ((pid=fork())&lt;0) {\n\t\t\t\tprintf(\"Fork failed in init\\r\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!pid) {\n\t\t\t\tclose(0);close(1);close(2);\n\t\t\t\tsetsid();\n\t\t\t\t(void) open(\"/dev/tty0\",O_RDWR,0);\n\t\t\t\t(void) dup(0);\n\t\t\t\t(void) dup(0);\n\t\t\t\t_exit(execve(\"/bin/sh\",argv,envp));\n\t\t\t}\n\t\t\twhile (1)\n\t\t\t\tif (pid == wait(&amp;i))  //等待父进程退出 但是零号进程不可能退出\n\t\t\t\t\tbreak;\n\t\t\tprintf(\"\\n\\rchild %d died with code %04x\\n\\r\",pid,i);\n\t\t\tsync();\n\t\t}\n\t\t_exit(0);\t/* NOTE! _exit, not exit() */\n\t}\n</code>\n</pre>\n<p>&nbsp;总结</p>\n<p>1：打开标准输出 输入 错误控制台的句柄</p>\n<p>2：创建2号进程 并在中执行etc/rc文件 执行sh程序</p>\n<p>3：零号进程不可能退出 如果退出就执行for(;;) pause();</p>\n<p>&nbsp;</p>\n<p>目前为止main函数的执行完成 具体逻辑如下：</p>\n<p><img src=\"linux线程/2909691-20221018204634847-2097816257.png\" alt=\"\" /></p>\n<p>&nbsp;</p>\n<p><strong>Q:进程如何调度的</strong></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">不知道你是否还记得，定时器和时钟中断，再mian函数的前面执行了讲的 sched_init 函数。</span></p>\n<pre>\n\t<code class=\"yaml\">\n\tschedule.c\n\t#define HZ 100\n</pre>\n</div>\n<p><span style=\"font-size: 14px;\"><span style=\"letter-spacing: 0.5px;\">这个间隔时间被设置为 10 ms，也就是 100 Hz。</span> <span style=\"letter-spacing: 0.5px;\">发起的中断叫时钟中断，其中断向量号被设置为了timer_interrupt 。</span><span style=\"letter-spacing: 0.5px;\"><span style=\"letter-spacing: 0.5px;\">这样，中断来临时，CPU 会查找到中断处理函数，并跳转过去执行。</span></span></span></p>\n<pre>\n\t<code class=\"yaml\">\n\tsystem_call.s\n\t_timer_interrupt:\n    ...\n    // 增加系统滴答数\n    incl _jiffies\n    ...\n    // 调用函数 do_timer\n    call _do_timer\n    ...\n</code>\n</pre>\n<p>&nbsp;<span style=\"letter-spacing: 0.5px;\">这个函数做了两件事，一个是将<strong>系统滴答数</strong>这个变量 <strong>jiffies</strong> 加一，一个是调用了另一个函数 <strong>do_timer</strong>。</span></p>\n<pre>\n\t<code class=\"yaml\">\n\tsched.c\n\tvoid do_timer(long cpl) {\n    ...\n    // 当前线程还有剩余时间片，直接返回\n    if ((--current-&gt;counter)&gt;0) return;\n    // 若没有剩余时间片，调度\n    schedule();\n}\n</code>\n</pre>\n<p><span style=\"font-size: 14px;\">&nbsp;<span style=\"letter-spacing: 0.5px;\">do_timer 最重要的部分就是上面这段代码，非常简单。</span></span></p>\n<p><span style=\"font-size: 14px;\"><span style=\"letter-spacing: 0.5px;\">首先将当先进程的时间片 -1，然后判断：</span></span></p>\n<p><span style=\"font-size: 14px;\"><span style=\"letter-spacing: 0.5px;\">如果时间片仍然大于零，则什么都不做直接返回。</span></span></p>\n<p><span style=\"font-size: 14px;\"><span style=\"letter-spacing: 0.5px;\">如果时间片已经为零，则调用 schedule()，很明显，这就是进行进程调度的主干。</span></span></p>\n<pre>\n\t<code class=\"yaml\">\n\tvoid schedule(void) {\n\t\tint i, next, c;\n\t\tstruct task_struct ** p;\n\t\t...\n\t\twhile (1) {\n\t\t\tc = -1;\n\t\t\tnext = 0;\n\t\t\ti = NR_TASKS;\n\t\t\tp = &amp;task[NR_TASKS];\n\t\t\twhile (--i) {\n\t\t\t\tif (!*--p)\n\t\t\t\t\tcontinue;\n\t\t\t\tif ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c)\n\t\t\t\t\tc = (*p)-&gt;counter, next = i;\n\t\t\t}\n\t\t\tif (c) break;\n\t\t\tfor(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)\n\t\t\t\tif (*p)\n\t\t\t\t\t(*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; 1) +\n\t\t\t\t\t\t\t(*p)-&gt;priority;\n\t\t}\n\t\tswitch_to(next);\n}\n</code>\n</pre>\n<p>&nbsp;很简答，这个函数就做了三件事：</p>\n<p><span style=\"font-size: 14px;\"><strong><span style=\"letter-spacing: 0.5px;\">1.</span></strong><span style=\"letter-spacing: 0.5px;\"> 拿到剩余时间片（counter的值）最大且在 runnable 状态（state = 0）的进程号 next。</span></span></p>\n<p><span style=\"letter-spacing: 0.5px; font-size: 14px;\"><strong>2.</strong><span style=\"letter-spacing: 0.5px;\"> 如果所有 runnable 进程时间片都为 0，则将所有进程（注意不仅仅是 runnable 的进程）的 counter 重新赋值（counter = counter/2 + priority），然后再次执行步骤 1。</span></span></p>\n<p><span style=\"letter-spacing: 0.5px; font-size: 14px;\"><strong>3.</strong><span style=\"letter-spacing: 0.5px;\"> 最后拿到了一个进程号 next，调用了 switch_to(next) 这个方法，就切换到了这个进程去执行了。</span></span></p>\n<p>&nbsp;总结一下：</p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">罪魁祸首的，就是那个每 10ms 触发一次的定时器滴答。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">而这个滴答将会给 CPU 产生一个时钟中断信号。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">而这个中断信号会使 CPU 查找中断向量表，找到操作系统写好的一个时钟中断处理函数 do_timer。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">do_timer 会首先将当前进程的 counter 变量 -1，如果 counter 此时仍然大于 0，则就此结束。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">但如果 counter = 0 了，就开始进行进程的调度。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">进程调度就是找到所有处于 RUNNABLE 状态的进程，并找到一个 counter 值最大的进程，把它丢进 switch_to 函数的入参里。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">switch_to 这个终极函数，会保存当前进程上下文，恢复要跳转到的这个进程的上下文，同时使得 CPU 跳转到这个进程的偏移地址处。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">接着，这个进程就舒舒服服地运行了起来，等待着下一次时钟中断的来临。</span></p>\n<div class=\"notranslate\" style=\"all: initial;\">&nbsp;</div>\n<div class=\"notranslate\" style=\"all: initial;\">&nbsp;</div>\n<div class=\"notranslate\" style=\"all: initial;\">&nbsp;</div>\n<div class=\"notranslate\" style=\"all: initial;\">&nbsp;</div>\n","source":"_posts/2022/01/linux线程.md","raw":"---\ntitle: linux线程\npermalink: linux线程\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2022-01-01 21:08:57\npassword:\nsummary:\ntags:\n- linux\n- process\ncategories:\n- linux\nkeywords:\ndescription:\n---\n<blockquote>\n<p>linux内核版本0.11</p>\n</blockquote>\n<h1>1：main</h1>\n<p>首先选出一号选手main函数，代码上和线程相关的主要是以下代码</p>\n<pre>\n\t<code class=\"yaml\">\n    void main(void) {    \n    move_to_user_mode();\n    if (!fork()) {\n        init();\n    }\n    for(;;) pause();\n}</code>\n</pre>\n<h1>&nbsp;2：<span style=\"letter-spacing: 0.5px;\"><strong>move_to_user_mode</strong></span></h1>\n<p><span style=\"letter-spacing: 0.5px; font-size: 15px;\"><span style=\"letter-spacing: 0.5px;\">这行代码的意思直接说非常简单，就是<strong>从内核态转变为了用户态</strong></span></span></p>\n<p>&nbsp;</p>\n<pre>\n\t<code class=\"yaml\">\n\t#define move_to_user_mode() \\\n\t__asm__ (\"movl %%esp,%%eax\\n\\t\" \\\n\t\"pushl $0x17\\n\\t\" \\\n\t\"pushl %%eax\\n\\t\" \\\n\t\"pushfl\\n\\t\" \\\n\t\"pushl $0x0f\\n\\t\" \\\n\t\"pushl $1f\\n\\t\" \\\n\t\"iret\\n\" \\\n\t\"1:\\tmovl $0x17,%%eax\\n\\t\" \\\n\t\"movw %%ax,%%ds\\n\\t\" \\\n\t\"movw %%ax,%%es\\n\\t\" \\\n\t\"movw %%ax,%%fs\\n\\t\" \\\n\t\"movw %%ax,%%gs\" \\\n\t:::\"ax\")\n</code>\n</pre>\n<h1>&nbsp;3：fork</h1>\n<p>fork函数是被系统调用使用的 具体路径如下：</p>\n<p>main.c:static inline _syscall0（int,fork）将fork绑定到_sys_fork</p>\n<p>　　system_call.s:_sys_fork:（调用函数_find_empty_process和_copy_process）</p>\n<p><img src=\"linux线程/2909691-20221018201940242-320806714.png\" alt=\"\" /></p>\n<p>总结作用：</p>\n<p>1：在task链表中找到一个进程空位并存放当前的进程（_find_empty_process）</p>\n<p>2：创建一个tsak_struct</p>\n<p>3：设置task_struct（_copy_process）</p>\n<p>这里就出现一个概念：<span style=\"font-size: 14px; letter-spacing: 0.5px;\">由于我们现在只有 0 号进程，且 task[] 除了 0 号索引位置，其他地方都是空的，所以这个方法运行完，last_pid 就是 1，也就是新进程被分配的 pid 就是 1</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\"><img src=\"linux线程/2909691-20221018202536805-171723429.png\" alt=\"\" /></span></p>\n<h1>4:init()</h1>\n<pre>\n\t<code class=\"yaml\">\n\tvoid init(void)\n\t{\n\t\tint pid,i;\n\t\tsetup((void *) &amp;drive_info);\n\t\t(void) open(\"/dev/tty0\",O_RDWR,0); //打开tty0 标准输入控制台\n\t\t(void) dup(0);//打开tty0 标准输出控制台\n\t\t(void) dup(0);//打开标准错误控制台\n\t\tprintf(\"%d buffers = %d bytes buffer space\\n\\r\",NR_BUFFERS,\n\t\t\tNR_BUFFERS*BLOCK_SIZE);\n\t\tprintf(\"Free mem: %d bytes\\n\\r\",memory_end-main_memory_start);\n\t\t//又创建一个进程（2号进程）<br />　　　　 if (!(pid=fork())) {\n\t\t\tclose(0);\n\t\t\tif (open(\"/etc/rc\",O_RDONLY,0)) ///etc/rc文件\n\t\t\t\t_exit(1);\n\t\t\texecve(\"/bin/sh\",argv_rc,envp_rc);//执行sh\n\t\t\t_exit(2);\n\t\t}\n\t\tif (pid&gt;0)\n\t\t\twhile (pid != wait(&amp;i))//等待父进程退出\n\t\t\t\t/* nothing */;\n\t\twhile (1) {<br />　　　　　　　　 //又创建一个进程 主要是害怕上面的进程创建失败 再创建一次\n\t\t\tif ((pid=fork())&lt;0) {\n\t\t\t\tprintf(\"Fork failed in init\\r\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!pid) {\n\t\t\t\tclose(0);close(1);close(2);\n\t\t\t\tsetsid();\n\t\t\t\t(void) open(\"/dev/tty0\",O_RDWR,0);\n\t\t\t\t(void) dup(0);\n\t\t\t\t(void) dup(0);\n\t\t\t\t_exit(execve(\"/bin/sh\",argv,envp));\n\t\t\t}\n\t\t\twhile (1)\n\t\t\t\tif (pid == wait(&amp;i))  //等待父进程退出 但是零号进程不可能退出\n\t\t\t\t\tbreak;\n\t\t\tprintf(\"\\n\\rchild %d died with code %04x\\n\\r\",pid,i);\n\t\t\tsync();\n\t\t}\n\t\t_exit(0);\t/* NOTE! _exit, not exit() */\n\t}\n</code>\n</pre>\n<p>&nbsp;总结</p>\n<p>1：打开标准输出 输入 错误控制台的句柄</p>\n<p>2：创建2号进程 并在中执行etc/rc文件 执行sh程序</p>\n<p>3：零号进程不可能退出 如果退出就执行for(;;) pause();</p>\n<p>&nbsp;</p>\n<p>目前为止main函数的执行完成 具体逻辑如下：</p>\n<p><img src=\"linux线程/2909691-20221018204634847-2097816257.png\" alt=\"\" /></p>\n<p>&nbsp;</p>\n<p><strong>Q:进程如何调度的</strong></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">不知道你是否还记得，定时器和时钟中断，再mian函数的前面执行了讲的 sched_init 函数。</span></p>\n<pre>\n\t<code class=\"yaml\">\n\tschedule.c\n\t#define HZ 100\n</pre>\n</div>\n<p><span style=\"font-size: 14px;\"><span style=\"letter-spacing: 0.5px;\">这个间隔时间被设置为 10 ms，也就是 100 Hz。</span> <span style=\"letter-spacing: 0.5px;\">发起的中断叫时钟中断，其中断向量号被设置为了timer_interrupt 。</span><span style=\"letter-spacing: 0.5px;\"><span style=\"letter-spacing: 0.5px;\">这样，中断来临时，CPU 会查找到中断处理函数，并跳转过去执行。</span></span></span></p>\n<pre>\n\t<code class=\"yaml\">\n\tsystem_call.s\n\t_timer_interrupt:\n    ...\n    // 增加系统滴答数\n    incl _jiffies\n    ...\n    // 调用函数 do_timer\n    call _do_timer\n    ...\n</code>\n</pre>\n<p>&nbsp;<span style=\"letter-spacing: 0.5px;\">这个函数做了两件事，一个是将<strong>系统滴答数</strong>这个变量 <strong>jiffies</strong> 加一，一个是调用了另一个函数 <strong>do_timer</strong>。</span></p>\n<pre>\n\t<code class=\"yaml\">\n\tsched.c\n\tvoid do_timer(long cpl) {\n    ...\n    // 当前线程还有剩余时间片，直接返回\n    if ((--current-&gt;counter)&gt;0) return;\n    // 若没有剩余时间片，调度\n    schedule();\n}\n</code>\n</pre>\n<p><span style=\"font-size: 14px;\">&nbsp;<span style=\"letter-spacing: 0.5px;\">do_timer 最重要的部分就是上面这段代码，非常简单。</span></span></p>\n<p><span style=\"font-size: 14px;\"><span style=\"letter-spacing: 0.5px;\">首先将当先进程的时间片 -1，然后判断：</span></span></p>\n<p><span style=\"font-size: 14px;\"><span style=\"letter-spacing: 0.5px;\">如果时间片仍然大于零，则什么都不做直接返回。</span></span></p>\n<p><span style=\"font-size: 14px;\"><span style=\"letter-spacing: 0.5px;\">如果时间片已经为零，则调用 schedule()，很明显，这就是进行进程调度的主干。</span></span></p>\n<pre>\n\t<code class=\"yaml\">\n\tvoid schedule(void) {\n\t\tint i, next, c;\n\t\tstruct task_struct ** p;\n\t\t...\n\t\twhile (1) {\n\t\t\tc = -1;\n\t\t\tnext = 0;\n\t\t\ti = NR_TASKS;\n\t\t\tp = &amp;task[NR_TASKS];\n\t\t\twhile (--i) {\n\t\t\t\tif (!*--p)\n\t\t\t\t\tcontinue;\n\t\t\t\tif ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c)\n\t\t\t\t\tc = (*p)-&gt;counter, next = i;\n\t\t\t}\n\t\t\tif (c) break;\n\t\t\tfor(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)\n\t\t\t\tif (*p)\n\t\t\t\t\t(*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; 1) +\n\t\t\t\t\t\t\t(*p)-&gt;priority;\n\t\t}\n\t\tswitch_to(next);\n}\n</code>\n</pre>\n<p>&nbsp;很简答，这个函数就做了三件事：</p>\n<p><span style=\"font-size: 14px;\"><strong><span style=\"letter-spacing: 0.5px;\">1.</span></strong><span style=\"letter-spacing: 0.5px;\"> 拿到剩余时间片（counter的值）最大且在 runnable 状态（state = 0）的进程号 next。</span></span></p>\n<p><span style=\"letter-spacing: 0.5px; font-size: 14px;\"><strong>2.</strong><span style=\"letter-spacing: 0.5px;\"> 如果所有 runnable 进程时间片都为 0，则将所有进程（注意不仅仅是 runnable 的进程）的 counter 重新赋值（counter = counter/2 + priority），然后再次执行步骤 1。</span></span></p>\n<p><span style=\"letter-spacing: 0.5px; font-size: 14px;\"><strong>3.</strong><span style=\"letter-spacing: 0.5px;\"> 最后拿到了一个进程号 next，调用了 switch_to(next) 这个方法，就切换到了这个进程去执行了。</span></span></p>\n<p>&nbsp;总结一下：</p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">罪魁祸首的，就是那个每 10ms 触发一次的定时器滴答。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">而这个滴答将会给 CPU 产生一个时钟中断信号。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">而这个中断信号会使 CPU 查找中断向量表，找到操作系统写好的一个时钟中断处理函数 do_timer。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">do_timer 会首先将当前进程的 counter 变量 -1，如果 counter 此时仍然大于 0，则就此结束。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">但如果 counter = 0 了，就开始进行进程的调度。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">进程调度就是找到所有处于 RUNNABLE 状态的进程，并找到一个 counter 值最大的进程，把它丢进 switch_to 函数的入参里。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">switch_to 这个终极函数，会保存当前进程上下文，恢复要跳转到的这个进程的上下文，同时使得 CPU 跳转到这个进程的偏移地址处。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">接着，这个进程就舒舒服服地运行了起来，等待着下一次时钟中断的来临。</span></p>\n<div class=\"notranslate\" style=\"all: initial;\">&nbsp;</div>\n<div class=\"notranslate\" style=\"all: initial;\">&nbsp;</div>\n<div class=\"notranslate\" style=\"all: initial;\">&nbsp;</div>\n<div class=\"notranslate\" style=\"all: initial;\">&nbsp;</div>\n","slug":"linux线程","published":1,"updated":"2024-01-05T08:12:19.084Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clru1g1zt0007s4fuilzb4ji1","content":"<blockquote>\n<p>linux内核版本0.11</p>\n</blockquote>\n<h1>1：main</h1>\n<p>首先选出一号选手main函数，代码上和线程相关的主要是以下代码</p>\n<pre>\n    <code class=\"yaml\">\n    void main(void) {    \n    move_to_user_mode();\n    if (!fork()) {\n        init();\n    }\n    for(;;) pause();\n}</code>\n</pre>\n<h1>&nbsp;2：<span style=\"letter-spacing: 0.5px;\"><strong>move_to_user_mode</strong></span></h1>\n<p><span style=\"letter-spacing: 0.5px; font-size: 15px;\"><span style=\"letter-spacing: 0.5px;\">这行代码的意思直接说非常简单，就是<strong>从内核态转变为了用户态</strong></span></span></p>\n<p>&nbsp;</p>\n<pre>\n    <code class=\"yaml\">\n    #define move_to_user_mode() \\\n    __asm__ (\"movl %%esp,%%eax\\n\\t\" \\\n    \"pushl $0x17\\n\\t\" \\\n    \"pushl %%eax\\n\\t\" \\\n    \"pushfl\\n\\t\" \\\n    \"pushl $0x0f\\n\\t\" \\\n    \"pushl $1f\\n\\t\" \\\n    \"iret\\n\" \\\n    \"1:\\tmovl $0x17,%%eax\\n\\t\" \\\n    \"movw %%ax,%%ds\\n\\t\" \\\n    \"movw %%ax,%%es\\n\\t\" \\\n    \"movw %%ax,%%fs\\n\\t\" \\\n    \"movw %%ax,%%gs\" \\\n    :::\"ax\")\n</code>\n</pre>\n<h1>&nbsp;3：fork</h1>\n<p>fork函数是被系统调用使用的 具体路径如下：</p>\n<p>main.c:static inline _syscall0（int,fork）将fork绑定到_sys_fork</p>\n<p>　　system_call.s:_sys_fork:（调用函数_find_empty_process和_copy_process）</p>\n<p><img src=\"/2022/01/linux-xian-cheng/2909691-20221018201940242-320806714.png\" alt></p>\n<p>总结作用：</p>\n<p>1：在task链表中找到一个进程空位并存放当前的进程（_find_empty_process）</p>\n<p>2：创建一个tsak_struct</p>\n<p>3：设置task_struct（_copy_process）</p>\n<p>这里就出现一个概念：<span style=\"font-size: 14px; letter-spacing: 0.5px;\">由于我们现在只有 0 号进程，且 task[] 除了 0 号索引位置，其他地方都是空的，所以这个方法运行完，last_pid 就是 1，也就是新进程被分配的 pid 就是 1</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\"><img src=\"/2022/01/linux-xian-cheng/2909691-20221018202536805-171723429.png\" alt></span></p>\n<h1>4:init()</h1>\n<pre>\n    <code class=\"yaml\">\n    void init(void)\n    {\n        int pid,i;\n        setup((void *) &amp;drive_info);\n        (void) open(\"/dev/tty0\",O_RDWR,0); //打开tty0 标准输入控制台\n        (void) dup(0);//打开tty0 标准输出控制台\n        (void) dup(0);//打开标准错误控制台\n        printf(\"%d buffers = %d bytes buffer space\\n\\r\",NR_BUFFERS,\n            NR_BUFFERS*BLOCK_SIZE);\n        printf(\"Free mem: %d bytes\\n\\r\",memory_end-main_memory_start);\n        //又创建一个进程（2号进程）<br>　　　　 if (!(pid=fork())) {\n            close(0);\n            if (open(\"/etc/rc\",O_RDONLY,0)) ///etc/rc文件\n                _exit(1);\n            execve(\"/bin/sh\",argv_rc,envp_rc);//执行sh\n            _exit(2);\n        }\n        if (pid&gt;0)\n            while (pid != wait(&amp;i))//等待父进程退出\n                /* nothing */;\n        while (1) {<br>　　　　　　　　 //又创建一个进程 主要是害怕上面的进程创建失败 再创建一次\n            if ((pid=fork())&lt;0) {\n                printf(\"Fork failed in init\\r\\n\");\n                continue;\n            }\n            if (!pid) {\n                close(0);close(1);close(2);\n                setsid();\n                (void) open(\"/dev/tty0\",O_RDWR,0);\n                (void) dup(0);\n                (void) dup(0);\n                _exit(execve(\"/bin/sh\",argv,envp));\n            }\n            while (1)\n                if (pid == wait(&amp;i))  //等待父进程退出 但是零号进程不可能退出\n                    break;\n            printf(\"\\n\\rchild %d died with code %04x\\n\\r\",pid,i);\n            sync();\n        }\n        _exit(0);    /* NOTE! _exit, not exit() */\n    }\n</code>\n</pre>\n<p>&nbsp;总结</p>\n<p>1：打开标准输出 输入 错误控制台的句柄</p>\n<p>2：创建2号进程 并在中执行etc/rc文件 执行sh程序</p>\n<p>3：零号进程不可能退出 如果退出就执行for(;;) pause();</p>\n<p>&nbsp;</p>\n<p>目前为止main函数的执行完成 具体逻辑如下：</p>\n<p><img src=\"/2022/01/linux-xian-cheng/2909691-20221018204634847-2097816257.png\" alt></p>\n<p>&nbsp;</p>\n<p><strong>Q:进程如何调度的</strong></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">不知道你是否还记得，定时器和时钟中断，再mian函数的前面执行了讲的 sched_init 函数。</span></p>\n<pre>\n    <code class=\"yaml\">\n    schedule.c\n    #define HZ 100\n</code></pre>\n\n<p><span style=\"font-size: 14px;\"><span style=\"letter-spacing: 0.5px;\">这个间隔时间被设置为 10 ms，也就是 100 Hz。</span> <span style=\"letter-spacing: 0.5px;\">发起的中断叫时钟中断，其中断向量号被设置为了timer_interrupt 。</span><span style=\"letter-spacing: 0.5px;\"><span style=\"letter-spacing: 0.5px;\">这样，中断来临时，CPU 会查找到中断处理函数，并跳转过去执行。</span></span></span></p>\n<pre>\n    <code class=\"yaml\">\n    system_call.s\n    _timer_interrupt:\n    ...\n    // 增加系统滴答数\n    incl _jiffies\n    ...\n    // 调用函数 do_timer\n    call _do_timer\n    ...\n</code>\n</pre>\n<p>&nbsp;<span style=\"letter-spacing: 0.5px;\">这个函数做了两件事，一个是将<strong>系统滴答数</strong>这个变量 <strong>jiffies</strong> 加一，一个是调用了另一个函数 <strong>do_timer</strong>。</span></p>\n<pre>\n    <code class=\"yaml\">\n    sched.c\n    void do_timer(long cpl) {\n    ...\n    // 当前线程还有剩余时间片，直接返回\n    if ((--current-&gt;counter)&gt;0) return;\n    // 若没有剩余时间片，调度\n    schedule();\n}\n</code>\n</pre>\n<p><span style=\"font-size: 14px;\">&nbsp;<span style=\"letter-spacing: 0.5px;\">do_timer 最重要的部分就是上面这段代码，非常简单。</span></span></p>\n<p><span style=\"font-size: 14px;\"><span style=\"letter-spacing: 0.5px;\">首先将当先进程的时间片 -1，然后判断：</span></span></p>\n<p><span style=\"font-size: 14px;\"><span style=\"letter-spacing: 0.5px;\">如果时间片仍然大于零，则什么都不做直接返回。</span></span></p>\n<p><span style=\"font-size: 14px;\"><span style=\"letter-spacing: 0.5px;\">如果时间片已经为零，则调用 schedule()，很明显，这就是进行进程调度的主干。</span></span></p>\n<pre>\n    <code class=\"yaml\">\n    void schedule(void) {\n        int i, next, c;\n        struct task_struct ** p;\n        ...\n        while (1) {\n            c = -1;\n            next = 0;\n            i = NR_TASKS;\n            p = &amp;task[NR_TASKS];\n            while (--i) {\n                if (!*--p)\n                    continue;\n                if ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c)\n                    c = (*p)-&gt;counter, next = i;\n            }\n            if (c) break;\n            for(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)\n                if (*p)\n                    (*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; 1) +\n                            (*p)-&gt;priority;\n        }\n        switch_to(next);\n}\n</code>\n</pre>\n<p>&nbsp;很简答，这个函数就做了三件事：</p>\n<p><span style=\"font-size: 14px;\"><strong><span style=\"letter-spacing: 0.5px;\">1.</span></strong><span style=\"letter-spacing: 0.5px;\"> 拿到剩余时间片（counter的值）最大且在 runnable 状态（state = 0）的进程号 next。</span></span></p>\n<p><span style=\"letter-spacing: 0.5px; font-size: 14px;\"><strong>2.</strong><span style=\"letter-spacing: 0.5px;\"> 如果所有 runnable 进程时间片都为 0，则将所有进程（注意不仅仅是 runnable 的进程）的 counter 重新赋值（counter = counter/2 + priority），然后再次执行步骤 1。</span></span></p>\n<p><span style=\"letter-spacing: 0.5px; font-size: 14px;\"><strong>3.</strong><span style=\"letter-spacing: 0.5px;\"> 最后拿到了一个进程号 next，调用了 switch_to(next) 这个方法，就切换到了这个进程去执行了。</span></span></p>\n<p>&nbsp;总结一下：</p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">罪魁祸首的，就是那个每 10ms 触发一次的定时器滴答。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">而这个滴答将会给 CPU 产生一个时钟中断信号。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">而这个中断信号会使 CPU 查找中断向量表，找到操作系统写好的一个时钟中断处理函数 do_timer。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">do_timer 会首先将当前进程的 counter 变量 -1，如果 counter 此时仍然大于 0，则就此结束。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">但如果 counter = 0 了，就开始进行进程的调度。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">进程调度就是找到所有处于 RUNNABLE 状态的进程，并找到一个 counter 值最大的进程，把它丢进 switch_to 函数的入参里。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">switch_to 这个终极函数，会保存当前进程上下文，恢复要跳转到的这个进程的上下文，同时使得 CPU 跳转到这个进程的偏移地址处。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">接着，这个进程就舒舒服服地运行了起来，等待着下一次时钟中断的来临。</span></p>\n<div class=\"notranslate\" style=\"all: initial;\">&nbsp;</div>\n<div class=\"notranslate\" style=\"all: initial;\">&nbsp;</div>\n<div class=\"notranslate\" style=\"all: initial;\">&nbsp;</div>\n<div class=\"notranslate\" style=\"all: initial;\">&nbsp;</div>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<blockquote>\n<p>linux内核版本0.11</p>\n</blockquote>\n<h1>1：main</h1>\n<p>首先选出一号选手main函数，代码上和线程相关的主要是以下代码</p>\n<pre>\n    <code class=\"yaml\">\n    void main(void) {    \n    move_to_user_mode();\n    if (!fork()) {\n        init();\n    }\n    for(;;) pause();\n}</code>\n</pre>\n<h1>&nbsp;2：<span style=\"letter-spacing: 0.5px;\"><strong>move_to_user_mode</strong></span></h1>\n<p><span style=\"letter-spacing: 0.5px; font-size: 15px;\"><span style=\"letter-spacing: 0.5px;\">这行代码的意思直接说非常简单，就是<strong>从内核态转变为了用户态</strong></span></span></p>\n<p>&nbsp;</p>\n<pre>\n    <code class=\"yaml\">\n    #define move_to_user_mode() \\\n    __asm__ (\"movl %%esp,%%eax\\n\\t\" \\\n    \"pushl $0x17\\n\\t\" \\\n    \"pushl %%eax\\n\\t\" \\\n    \"pushfl\\n\\t\" \\\n    \"pushl $0x0f\\n\\t\" \\\n    \"pushl $1f\\n\\t\" \\\n    \"iret\\n\" \\\n    \"1:\\tmovl $0x17,%%eax\\n\\t\" \\\n    \"movw %%ax,%%ds\\n\\t\" \\\n    \"movw %%ax,%%es\\n\\t\" \\\n    \"movw %%ax,%%fs\\n\\t\" \\\n    \"movw %%ax,%%gs\" \\\n    :::\"ax\")\n</code>\n</pre>\n<h1>&nbsp;3：fork</h1>\n<p>fork函数是被系统调用使用的 具体路径如下：</p>\n<p>main.c:static inline _syscall0（int,fork）将fork绑定到_sys_fork</p>\n<p>　　system_call.s:_sys_fork:（调用函数_find_empty_process和_copy_process）</p>\n<p><img src=\"/2022/01/linux-xian-cheng/2909691-20221018201940242-320806714.png\" alt></p>\n<p>总结作用：</p>\n<p>1：在task链表中找到一个进程空位并存放当前的进程（_find_empty_process）</p>\n<p>2：创建一个tsak_struct</p>\n<p>3：设置task_struct（_copy_process）</p>\n<p>这里就出现一个概念：<span style=\"font-size: 14px; letter-spacing: 0.5px;\">由于我们现在只有 0 号进程，且 task[] 除了 0 号索引位置，其他地方都是空的，所以这个方法运行完，last_pid 就是 1，也就是新进程被分配的 pid 就是 1</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\"><img src=\"/2022/01/linux-xian-cheng/2909691-20221018202536805-171723429.png\" alt></span></p>\n<h1>4:init()</h1>\n<pre>\n    <code class=\"yaml\">\n    void init(void)\n    {\n        int pid,i;\n        setup((void *) &amp;drive_info);\n        (void) open(\"/dev/tty0\",O_RDWR,0); //打开tty0 标准输入控制台\n        (void) dup(0);//打开tty0 标准输出控制台\n        (void) dup(0);//打开标准错误控制台\n        printf(\"%d buffers = %d bytes buffer space\\n\\r\",NR_BUFFERS,\n            NR_BUFFERS*BLOCK_SIZE);\n        printf(\"Free mem: %d bytes\\n\\r\",memory_end-main_memory_start);\n        //又创建一个进程（2号进程）<br>　　　　 if (!(pid=fork())) {\n            close(0);\n            if (open(\"/etc/rc\",O_RDONLY,0)) ///etc/rc文件\n                _exit(1);\n            execve(\"/bin/sh\",argv_rc,envp_rc);//执行sh\n            _exit(2);\n        }\n        if (pid&gt;0)\n            while (pid != wait(&amp;i))//等待父进程退出\n                /* nothing */;\n        while (1) {<br>　　　　　　　　 //又创建一个进程 主要是害怕上面的进程创建失败 再创建一次\n            if ((pid=fork())&lt;0) {\n                printf(\"Fork failed in init\\r\\n\");\n                continue;\n            }\n            if (!pid) {\n                close(0);close(1);close(2);\n                setsid();\n                (void) open(\"/dev/tty0\",O_RDWR,0);\n                (void) dup(0);\n                (void) dup(0);\n                _exit(execve(\"/bin/sh\",argv,envp));\n            }\n            while (1)\n                if (pid == wait(&amp;i))  //等待父进程退出 但是零号进程不可能退出\n                    break;\n            printf(\"\\n\\rchild %d died with code %04x\\n\\r\",pid,i);\n            sync();\n        }\n        _exit(0);    /* NOTE! _exit, not exit() */\n    }\n</code>\n</pre>\n<p>&nbsp;总结</p>\n<p>1：打开标准输出 输入 错误控制台的句柄</p>\n<p>2：创建2号进程 并在中执行etc/rc文件 执行sh程序</p>\n<p>3：零号进程不可能退出 如果退出就执行for(;;) pause();</p>\n<p>&nbsp;</p>\n<p>目前为止main函数的执行完成 具体逻辑如下：</p>\n<p><img src=\"/2022/01/linux-xian-cheng/2909691-20221018204634847-2097816257.png\" alt></p>\n<p>&nbsp;</p>\n<p><strong>Q:进程如何调度的</strong></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">不知道你是否还记得，定时器和时钟中断，再mian函数的前面执行了讲的 sched_init 函数。</span></p>\n<pre>\n    <code class=\"yaml\">\n    schedule.c\n    #define HZ 100\n</code></pre>\n\n<p><span style=\"font-size: 14px;\"><span style=\"letter-spacing: 0.5px;\">这个间隔时间被设置为 10 ms，也就是 100 Hz。</span> <span style=\"letter-spacing: 0.5px;\">发起的中断叫时钟中断，其中断向量号被设置为了timer_interrupt 。</span><span style=\"letter-spacing: 0.5px;\"><span style=\"letter-spacing: 0.5px;\">这样，中断来临时，CPU 会查找到中断处理函数，并跳转过去执行。</span></span></span></p>\n<pre>\n    <code class=\"yaml\">\n    system_call.s\n    _timer_interrupt:\n    ...\n    // 增加系统滴答数\n    incl _jiffies\n    ...\n    // 调用函数 do_timer\n    call _do_timer\n    ...\n</code>\n</pre>\n<p>&nbsp;<span style=\"letter-spacing: 0.5px;\">这个函数做了两件事，一个是将<strong>系统滴答数</strong>这个变量 <strong>jiffies</strong> 加一，一个是调用了另一个函数 <strong>do_timer</strong>。</span></p>\n<pre>\n    <code class=\"yaml\">\n    sched.c\n    void do_timer(long cpl) {\n    ...\n    // 当前线程还有剩余时间片，直接返回\n    if ((--current-&gt;counter)&gt;0) return;\n    // 若没有剩余时间片，调度\n    schedule();\n}\n</code>\n</pre>\n<p><span style=\"font-size: 14px;\">&nbsp;<span style=\"letter-spacing: 0.5px;\">do_timer 最重要的部分就是上面这段代码，非常简单。</span></span></p>\n<p><span style=\"font-size: 14px;\"><span style=\"letter-spacing: 0.5px;\">首先将当先进程的时间片 -1，然后判断：</span></span></p>\n<p><span style=\"font-size: 14px;\"><span style=\"letter-spacing: 0.5px;\">如果时间片仍然大于零，则什么都不做直接返回。</span></span></p>\n<p><span style=\"font-size: 14px;\"><span style=\"letter-spacing: 0.5px;\">如果时间片已经为零，则调用 schedule()，很明显，这就是进行进程调度的主干。</span></span></p>\n<pre>\n    <code class=\"yaml\">\n    void schedule(void) {\n        int i, next, c;\n        struct task_struct ** p;\n        ...\n        while (1) {\n            c = -1;\n            next = 0;\n            i = NR_TASKS;\n            p = &amp;task[NR_TASKS];\n            while (--i) {\n                if (!*--p)\n                    continue;\n                if ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c)\n                    c = (*p)-&gt;counter, next = i;\n            }\n            if (c) break;\n            for(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)\n                if (*p)\n                    (*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; 1) +\n                            (*p)-&gt;priority;\n        }\n        switch_to(next);\n}\n</code>\n</pre>\n<p>&nbsp;很简答，这个函数就做了三件事：</p>\n<p><span style=\"font-size: 14px;\"><strong><span style=\"letter-spacing: 0.5px;\">1.</span></strong><span style=\"letter-spacing: 0.5px;\"> 拿到剩余时间片（counter的值）最大且在 runnable 状态（state = 0）的进程号 next。</span></span></p>\n<p><span style=\"letter-spacing: 0.5px; font-size: 14px;\"><strong>2.</strong><span style=\"letter-spacing: 0.5px;\"> 如果所有 runnable 进程时间片都为 0，则将所有进程（注意不仅仅是 runnable 的进程）的 counter 重新赋值（counter = counter/2 + priority），然后再次执行步骤 1。</span></span></p>\n<p><span style=\"letter-spacing: 0.5px; font-size: 14px;\"><strong>3.</strong><span style=\"letter-spacing: 0.5px;\"> 最后拿到了一个进程号 next，调用了 switch_to(next) 这个方法，就切换到了这个进程去执行了。</span></span></p>\n<p>&nbsp;总结一下：</p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">罪魁祸首的，就是那个每 10ms 触发一次的定时器滴答。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">而这个滴答将会给 CPU 产生一个时钟中断信号。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">而这个中断信号会使 CPU 查找中断向量表，找到操作系统写好的一个时钟中断处理函数 do_timer。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">do_timer 会首先将当前进程的 counter 变量 -1，如果 counter 此时仍然大于 0，则就此结束。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">但如果 counter = 0 了，就开始进行进程的调度。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">进程调度就是找到所有处于 RUNNABLE 状态的进程，并找到一个 counter 值最大的进程，把它丢进 switch_to 函数的入参里。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">switch_to 这个终极函数，会保存当前进程上下文，恢复要跳转到的这个进程的上下文，同时使得 CPU 跳转到这个进程的偏移地址处。</span></p>\n<p><span style=\"font-size: 14px; letter-spacing: 0.5px;\">接着，这个进程就舒舒服服地运行了起来，等待着下一次时钟中断的来临。</span></p>\n<div class=\"notranslate\" style=\"all: initial;\">&nbsp;</div>\n<div class=\"notranslate\" style=\"all: initial;\">&nbsp;</div>\n<div class=\"notranslate\" style=\"all: initial;\">&nbsp;</div>\n<div class=\"notranslate\" style=\"all: initial;\">&nbsp;</div>\n"},{"title":"Linux input子系统","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2022-01-01T13:12:46.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"<div>\n<div>\n<ul>\n<li>\n<h5>Input driver ：主要实现对硬件设备的读写访问，中断设置，并把硬件产生的事件转换为核心层定义的规范提交给事件处理层。</h5>\n</li>\n<li>\n<h5>Input core ：承上启下。为设备驱动层提供了规范和接口；通知事件处理层对事件进行处理；</h5>\n</li>\n<li>\n<h5>Event handler ：提供用户编程的接口（设备节点），并处理驱动层提交的数据处理。</h5>\n</li>\n</ul>\n<p><img src=\"Linux-input子系统/2909691-20220819093409715-1604400596.png\" alt=\"\" /></p>\n<h1>1输入子系统框架分析</h1>\n<div>\n<div>\n<h2>1.1设备驱动层（Input driver）</h2>\n<ul>\n<li>device是纯硬件操作层，包含不同的硬件接口处理，如gpio等</li>\n<li>对于每种不同的具体硬件操作，都对应着不同的input_dev结构体</li>\n<li>该结构体内部也包含着一个h_list，指向handle</li>\n</ul>\n</div>\n</div>\n<div>\n<div>\n<div>\n<div>\n<h2>1.2.系统核心层（Input core）</h2>\n<ul>\n<li>申请主设备号;</li>\n<li>提供input_register_device跟input_register_handler函数分别用于注册device跟handler;</li>\n<li>提供input_register_handle函数用于注册一个事件处理，代表一个成功配对的input_dev和input_handler;</li>\n</ul>\n</div>\n</div>\n<h2>1.3.事件处理层（Event handler）</h2>\n<ul>\n<li>不涉及硬件方面的具体操作，handler层是纯软件层，包含不同的解决方案，如键盘，鼠标，游戏手柄等；</li>\n<li>对于不同的解决方案，都包含一个名为input_handler的结构体，该结构体内含的主要成员如下：</li>\n</ul>\n<table>\n<thead>\n<tr><th>成员</th><th>功能</th></tr>\n</thead>\n<tbody>\n<tr>\n<td>.id_table</td>\n<td>一个存放该handler所支持的设备id的表（其实内部存放的是EV_xxx事件,用于判断device是否支持该事件）</td>\n</tr>\n<tr>\n<td>.fops</td>\n<td>该handler的file_operation</td>\n</tr>\n<tr>\n<td>.connect</td>\n<td>连接该handler跟所支持device的函数</td>\n</tr>\n<tr>\n<td>.disconnect</td>\n<td>断开该连接</td>\n</tr>\n<tr>\n<td>.event</td>\n<td>事件处理函数，让device调用</td>\n</tr>\n<tr>\n<td>h_list</td>\n<td>是一个链表，该链表保存着该handler到所支持的所有device的中间站：handle结构体的指针</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1>2.两条链表连接dev和handler</h1>\n<pre>\n\t<code class=\"yaml\">\n#file pwd: drivers/input/input.c\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@suse.cz>\");\nMODULE_DESCRIPTION(\"Input core\");\nMODULE_LICENSE(\"GPL\");\n#define INPUT_MAX_CHAR_DEVICES        1024\n#define INPUT_FIRST_DYNAMIC_DEV        256\nstatic DEFINE_IDA(input_ida);\nstatic LIST_HEAD(input_dev_list);\nstatic LIST_HEAD(input_handler_list);\n  </code>\n</pre> \n在input.c文件中两个全局链表input_handler_list和<span style=\"color: #000000;\">input_dev_list</span>，通过handle相互关联：</div>\n<div><img src=\"Linux-input子系统/2909691-20220819094250974-180404869.webp\" alt=\"\" />\n<p>&nbsp;</p>\n<h1>3.输入子系统代码分析</h1>\n<p>文件路径：driver/input/input.c （核心层）</p>\n<pre>\n\t<code class=\"yaml\">\nstatic int __init input_init(void)\n{\n    int err;\n    err = class_register(&input_class);  //在/sys/class下创建逻辑（input）类，在类下面挂载input设备\n    if (err) {\n        pr_err(\"unable to register input_dev class\\n\");\n        return err;\n    }\n    err = input_proc_init();　　//在/proc下面建立相关的虚拟文件，proc下创建的文件可以看作是虚拟文件对内核读写的一种操作\n    if (err)\n        goto fail1;\n    err = register_chrdev_region(MKDEV(INPUT_MAJOR, 0),//在/dev下创建input设备号\n                     INPUT_MAX_CHAR_DEVICES, \"input\");\n    if (err) {\n        pr_err(\"unable to register char major %d\", INPUT_MAJOR);\n        goto fail2;\n    }\n    return 0;\n fail2:    input_proc_exit();\n fail1:    class_unregister(&input_class);\n    return err;\n}\nstatic void __exit input_exit(void)\n{\n    input_proc_exit();\n    unregister_chrdev_region(MKDEV(INPUT_MAJOR, 0),\n                 INPUT_MAX_CHAR_DEVICES);\n    class_unregister(&input_class);\n}\nsubsys_initcall(input_init);\nmodule_exit(input_exit);\n  </code>\n</pre> \n<p>现在基本框架已经建成，如何往input系统里面注册dev和hanlder呢？</p>\n<h2>3.1注册dev</h2>\n<pre>\n\t<code class=\"yaml\">\n/**\n * struct input_dev - represents an input device\n * @name: name of the device\n * @phys: physical path to the device in the system hierarchy\n * @uniq: unique identification code for the device (if device has it)\n * @id: id of the device (struct input_id)\n * @propbit: bitmap of device properties and quirks\n * @evbit: bitmap of types of events supported by the device (EV_KEY,\n *    EV_REL, etc.)\n * @keybit: bitmap of keys/buttons this device has\n * @relbit: bitmap of relative axes for the device\n * @absbit: bitmap of absolute axes for the device\n * @mscbit: bitmap of miscellaneous events supported by the device\n * @ledbit: bitmap of leds present on the device\n * @sndbit: bitmap of sound effects supported by the device\n * @ffbit: bitmap of force feedback effects supported by the device\n * @swbit: bitmap of switches present on the device\n * @hint_events_per_packet: average number of events generated by the\n *    device in a packet (between EV_SYN/SYN_REPORT events). Used by\n *    event handlers to estimate size of the buffer needed to hold\n *    events.\n * @keycodemax: size of keycode table\n * @keycodesize: size of elements in keycode table\n * @keycode: map of scancodes to keycodes for this device\n * @getkeycode: optional legacy method to retrieve current keymap.\n * @setkeycode: optional method to alter current keymap, used to implement\n *    sparse keymaps. If not supplied default mechanism will be used.\n *    The method is being called while holding event_lock and thus must\n *    not sleep\n * @ff: force feedback structure associated with the device if device\n *    supports force feedback effects\n * @repeat_key: stores key code of the last key pressed; used to implement\n *    software autorepeat\n * @timer: timer for software autorepeat\n * @rep: current values for autorepeat parameters (delay, rate)\n * @mt: pointer to multitouch state\n * @absinfo: array of &struct input_absinfo elements holding information\n *    about absolute axes (current value, min, max, flat, fuzz,\n *    resolution)\n * @key: reflects current state of device's keys/buttons\n * @led: reflects current state of device's LEDs\n * @snd: reflects current state of sound effects\n * @sw: reflects current state of device's switches\n * @open: this method is called when the very first user calls\n *    input_open_device(). The driver must prepare the device\n *    to start generating events (start polling thread,\n *    request an IRQ, submit URB, etc.)\n * @close: this method is called when the very last user calls\n *    input_close_device().\n * @flush: purges the device. Most commonly used to get rid of force\n *    feedback effects loaded into the device when disconnecting\n *    from it\n * @event: event handler for events sent _to_ the device, like EV_LED\n *    or EV_SND. The device is expected to carry out the requested\n *    action (turn on a LED, play sound, etc.) The call is protected\n *    by @event_lock and must not sleep\n * @grab: input handle that currently has the device grabbed (via\n *    EVIOCGRAB ioctl). When a handle grabs a device it becomes sole\n *    recipient for all input events coming from the device\n * @event_lock: this spinlock is is taken when input core receives\n *    and processes a new event for the device (in input_event()).\n *    Code that accesses and/or modifies parameters of a device\n *    (such as keymap or absmin, absmax, absfuzz, etc.) after device\n *    has been registered with input core must take this lock.\n * @mutex: serializes calls to open(), close() and flush() methods\n * @users: stores number of users (input handlers) that opened this\n *    device. It is used by input_open_device() and input_close_device()\n *    to make sure that dev->open() is only called when the first\n *    user opens device and dev->close() is called when the very\n *    last user closes the device\n * @going_away: marks devices that are in a middle of unregistering and\n *    causes input_open_device*() fail with -ENODEV.\n * @dev: driver model's view of this device\n * @h_list: list of input handles associated with the device. When\n *    accessing the list dev->mutex must be held\n * @node: used to place the device onto input_dev_list\n * @num_vals: number of values queued in the current frame\n * @max_vals: maximum number of values queued in a frame\n * @vals: array of values queued in the current frame\n * @devres_managed: indicates that devices is managed with devres framework\n *    and needs not be explicitly unregistered or freed.\n */\nstruct input_dev {\n    const char *name;\n    const char *phys;\n    const char *uniq;\n    struct input_id id;\n    unsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];\n    unsigned long evbit[BITS_TO_LONGS(EV_CNT)];\n    unsigned long keybit[BITS_TO_LONGS(KEY_CNT)];\n    unsigned long relbit[BITS_TO_LONGS(REL_CNT)];\n    unsigned long absbit[BITS_TO_LONGS(ABS_CNT)];\n    unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)];\n    unsigned long ledbit[BITS_TO_LONGS(LED_CNT)];\n    unsigned long sndbit[BITS_TO_LONGS(SND_CNT)];\n    unsigned long ffbit[BITS_TO_LONGS(FF_CNT)];\n    unsigned long swbit[BITS_TO_LONGS(SW_CNT)];\n    unsigned int hint_events_per_packet;\n    unsigned int keycodemax;\n    unsigned int keycodesize;\n    void *keycode;\n    int (*setkeycode)(struct input_dev *dev,\n              const struct input_keymap_entry *ke,\n              unsigned int *old_keycode);\n    int (*getkeycode)(struct input_dev *dev,\n              struct input_keymap_entry *ke);\n    struct ff_device *ff;\n    unsigned int repeat_key;\n    struct timer_list timer;\n    int rep[REP_CNT];\n    struct input_mt *mt;\n    struct input_absinfo *absinfo;\n    unsigned long key[BITS_TO_LONGS(KEY_CNT)];\n    unsigned long led[BITS_TO_LONGS(LED_CNT)];\n    unsigned long snd[BITS_TO_LONGS(SND_CNT)];\n    unsigned long sw[BITS_TO_LONGS(SW_CNT)];\n    int (*open)(struct input_dev *dev);\n    void (*close)(struct input_dev *dev);\n    int (*flush)(struct input_dev *dev, struct file *file);\n    int (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value);\n    struct input_handle __rcu *grab;\n    spinlock_t event_lock;\n    struct mutex mutex;\n    unsigned int users;\n    bool going_away;\n    struct device dev;\n    struct list_head    h_list;\n    struct list_head    node;\n    unsigned int num_vals;\n    unsigned int max_vals;\n    struct input_value *vals;\n    bool devres_managed;\n};\n#define to_input_dev(d) container_of(d, struct input_dev, dev)\n  </code>\n</pre> \n<p>&nbsp;</p>\n<div>\n<div>&nbsp;</div><pre>\n\t<code class=\"yaml\">\n/**\n * input_register_device - register device with input core\n * @dev: device to be registered\n *\n * This function registers device with input core. The device must be\n * allocated with input_allocate_device() and all it's capabilities\n * set up before registering.\n * If function fails the device must be freed with input_free_device().\n * Once device has been successfully registered it can be unregistered\n * with input_unregister_device(); input_free_device() should not be\n * called in this case.\n *\n * Note that this function is also used to register managed input devices\n * (ones allocated with devm_input_allocate_device()). Such managed input\n * devices need not be explicitly unregistered or freed, their tear down\n * is controlled by the devres infrastructure. It is also worth noting\n * that tear down of managed input devices is internally a 2-step process:\n * registered managed input device is first unregistered, but stays in\n * memory and can still handle input_event() calls (although events will\n * not be delivered anywhere). The freeing of managed input device will\n * happen later, when devres stack is unwound to the point where device\n * allocation was made.\n */\nint input_register_device(struct input_dev *dev)\n{\n    struct input_devres *devres = NULL;\n     /* 输入事件的处理接口指针，用于和设备的事件类型进行匹配 */\n    struct input_handler *handler;\n    unsigned int packet_size;\n    const char *path;\n    int error;\n    if (dev->devres_managed) {\n        devres = devres_alloc(devm_input_device_unregister,\n                      sizeof(struct input_devres), GFP_KERNEL);\n        if (!devres)\n            return -ENOMEM;\n        devres->input = dev;\n    }\n    /* Every input device generates EV_SYN/SYN_REPORT events. */\n    __set_bit(EV_SYN, dev->evbit);\n    /* KEY_RESERVED is not supposed to be transmitted to userspace. */\n    __clear_bit(KEY_RESERVED, dev->keybit);\n    /* Make sure that bitmasks not mentioned in dev->evbit are clean. */\n    input_cleanse_bitmasks(dev);\n    packet_size = input_estimate_events_per_packet(dev);\n    if (dev->hint_events_per_packet < packet_size)\n        dev->hint_events_per_packet = packet_size;\n    dev->max_vals = dev->hint_events_per_packet + 2;\n    dev->vals = kcalloc(dev->max_vals, sizeof(*dev->vals), GFP_KERNEL);\n    if (!dev->vals) {\n        error = -ENOMEM;\n        goto err_devres_free;\n    }\n    /*\n     * If delay and period are pre-set by the driver, then autorepeating\n     * is handled by the driver itself and we don't do it in input.c.\n     */\n    if (!dev->rep[REP_DELAY] && !dev->rep[REP_PERIOD]) {\n        dev->timer.data = (long) dev;\n        dev->timer.function = input_repeat_key;\n        dev->rep[REP_DELAY] = 250;\n        dev->rep[REP_PERIOD] = 33;\n    }\n    if (!dev->getkeycode)\n        dev->getkeycode = input_default_getkeycode;\n    if (!dev->setkeycode)\n        dev->setkeycode = input_default_setkeycode;\n    error = device_add(&dev->dev);\n    if (error)\n        goto err_free_vals;\n    path = kobject_get_path(&dev->dev.kobj, GFP_KERNEL);\n    pr_info(\"%s as %s\\n\",\n        dev->name ? dev->name : \"Unspecified device\",\n        path ? path : \"N/A\");\n    kfree(path);\n    error = mutex_lock_interruptible(&input_mutex);\n    if (error)\n        goto err_device_del;\n    /* 重要:把设备挂到全局的input子系统设备链表input_dev_list上 */\n    list_add_tail(&dev->node, &input_dev_list);\n    /* 核心重点，input设备在增加到input_dev_list链表上之后，会查找\n     * input_handler_list事件处理链表上的handler进行匹配，这里的匹配\n     * 方式与设备模型的device和driver匹配过程很相似*/\n    list_for_each_entry(handler, &input_handler_list, node)\n        input_attach_handler(dev, handler);/*遍历input_handler_list，通过input_match_device试图与每一个handler进行匹配 匹配上了就使用connect连接*/\n    /*\n    static int input_attach_handler(struct input_dev *dev, struct input_handler *handler)\n    {\n        const struct input_device_id *id;\n        int error;\n\n        id = input_match_device(handler, dev);\n        if (!id)\n            return -ENODEV;\n        error = handler->connect(handler, dev, id);\n        if (error && error != -ENODEV)\n            pr_err(\"failed to attach handler %s to device %s, error: %d\\n\",\n                   handler->name, kobject_name(&dev->dev.kobj), error);\n        return error;\n    }\n    */\n    input_wakeup_procfs_readers();\n    mutex_unlock(&input_mutex);\n    if (dev->devres_managed) {\n        dev_dbg(dev->dev.parent, \"%s: registering %s with devres.\\n\",\n            __func__, dev_name(&dev->dev));\n        devres_add(dev->dev.parent, devres);\n    }\n    return 0;\nerr_device_del:\n    device_del(&dev->dev);\nerr_free_vals:\n    kfree(dev->vals);\n    dev->vals = NULL;\nerr_devres_free:\n    devres_free(devres);\n    return error;\n}\nEXPORT_SYMBOL(input_register_device);\n  </code>\n</pre> \n<h2>3.2注册handler</h2>\n<p>一般handler不需要我们自己写 内核里面已经有了很多的hanlder基本够用</p>\n下面以Evdev为例，来分析事件处理层。<br />\nvim drivers/input/evdev.c</div>\n<div>\n<pre>\n\t<code class=\"yaml\">\nstatic const struct input_device_id evdev_ids[] = {\n    { .driver_info = 1 },    /* Matches all devices */\n    { },            /* Terminating zero entry */\n};\nMODULE_DEVICE_TABLE(input, evdev_ids);\nstatic struct input_handler evdev_handler = {\n    .event        = evdev_event,\n    .events        = evdev_events,\n    .connect    = evdev_connect,\n    .disconnect    = evdev_disconnect,\n    .legacy_minors    = true,\n    .minor        = EVDEV_MINOR_BASE,\n    .name        = \"evdev\",\n    .id_table    = evdev_ids,\n};\nstatic int __init evdev_init(void)\n{\n    return input_register_handler(&evdev_handler);\n}\nstatic void __exit evdev_exit(void)\n{\n    input_unregister_handler(&evdev_handler);\n}\nmodule_init(evdev_init);\nmodule_exit(evdev_exit);\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>\");\nMODULE_DESCRIPTION(\"Input driver event char devices\");\nMODULE_LICENSE(\"GPL\");  \n  </code>\n</pre>  \n<p>注册的handler可以在proc/bus/input/danlder中查看到</p>\n</div>\n<p><img src=\"Linux-input子系统/2909691-20220819102740731-2036281828.png\" alt=\"\" /></p><pre>\n\t<code class=\"yaml\">\n/**\n* input_register_handler - register a new input handler\n* @handler: handler to be registered\n*\n* This function registers a new input handler (interface) for input\n* devices in the system and attaches it to all input devices that\n* are compatible with the handler.\n*/\nint input_register_handler(struct input_handler *handler)\n{\n     struct input_dev *dev;\n     int error;\n     error = mutex_lock_interruptible(&input_mutex);\n     if (error)\n         return error;\n \n     INIT_LIST_HEAD(&handler->h_list);\n 　　/* `重要`:把设备处理器挂到全局的input子系统设备链表input_handler_list上 */ \n     list_add_tail(&handler->node, &input_handler_list);\n 　　/*遍历input_dev_list，试图与每一个input_dev进行匹配*/\n     list_for_each_entry(dev, &input_dev_list, node)\n         input_attach_handler(dev, handler);　　　　/*static int input_attach_handler(struct input_dev *dev, struct input_handler *handler)\n{\n    const struct input_device_id *id;\n    int error;\n    ........\n    ........\n    input_wakeup_procfs_readers();\n    mutex_unlock(&input_mutex);\n    return 0;\n}\nEXPORT_SYMBOL(input_register_handler);\n  </code>\n</pre>  \n<p>这个过程和注册dev及其相似</p>\n<h2>3.3 handler的connect函数</h2><pre>\n\t<code class=\"yaml\">\nstatic int evdev_connect(struct input_handler *handler, struct input_dev *dev,\n             const struct input_device_id *id)\n{\n    struct evdev *evdev;\n    int minor;\n    int dev_no;\n    int error;\n    /*申请一个新的次设备号*/\n    minor = input_get_new_minor(EVDEV_MINOR_BASE, EVDEV_MINORS, true);\n    /* 这说明内核已经没办法再分配这种类型的设备了 */\n    if (minor < 0) {\n        error = minor;\n        pr_err(\"failed to reserve new minor: %d\\n\", error);\n        return error;\n    }\n    /* 开始给evdev事件层驱动分配空间了 */\n    evdev = kzalloc(sizeof(struct evdev), GFP_KERNEL);\n    if (!evdev) {\n        error = -ENOMEM;\n        goto err_free_minor;\n    }\n        /* 初始化client_list列表和evdev_wait队列 */\n    INIT_LIST_HEAD(&evdev->client_list);\n    spin_lock_init(&evdev->client_lock);\n    mutex_init(&evdev->mutex);\n    init_waitqueue_head(&evdev->wait);\n    evdev->exist = true;\n    dev_no = minor;\n    /* Normalize device number if it falls into legacy range */\n    if (dev_no < EVDEV_MINOR_BASE + EVDEV_MINORS)\n        dev_no -= EVDEV_MINOR_BASE;\n    /*设置设备节点名称，/dev/eventX 就是在此时设置*/\n    dev_set_name(&evdev->dev, \"event%d\", dev_no);\n    /* 初始化evdev结构体，其中handle为输入设备和事件处理的关联接口 */\n    evdev->handle.dev = input_get_device(dev);\n    evdev->handle.name = dev_name(&evdev->dev);\n    evdev->handle.handler = handler;\n    evdev->handle.private = evdev;\n      /*设置设备号，应用层就是通过设备号，找到该设备的*/\n    evdev->dev.devt = MKDEV(INPUT_MAJOR, minor);\n    evdev->dev.class = &input_class;\n    evdev->dev.parent = &dev->dev;\n    evdev->dev.release = evdev_free;\n    device_initialize(&evdev->dev);\n     /* input_dev设备驱动和handler事件处理层的关联，就在这时由handle完成 */\n    error = input_register_handle(&evdev->handle);\n    if (error)\n        goto err_free_evdev;\n    cdev_init(&evdev->cdev, &evdev_fops);\n    evdev->cdev.kobj.parent = &evdev->dev.kobj;\n    error = cdev_add(&evdev->cdev, evdev->dev.devt, 1);\n    if (error)\n        goto err_unregister_handle;\n    /*将设备加入到Linux设备模型，它的内部将找到它的bus，然后让它的bus\n    给它找到它的driver，在驱动或者总线的probe函数中，一般会在/dev/目录\n    先创建相应的设备节点，这样应用程序就可以通过该设备节点来使用设备了\n    ，/dev/eventX 设备节点就是在此时生成\n    */\n    error = device_add(&evdev->dev);\n    if (error)\n        goto err_cleanup_evdev;\n    return 0;\n err_cleanup_evdev:\n    evdev_cleanup(evdev);\n err_unregister_handle:\n    input_unregister_handle(&evdev->handle);\n err_free_evdev:\n    put_device(&evdev->dev);\n err_free_minor:\n    input_free_minor(minor);\n    return error;\n}\n  </code>\n</pre>   \n<p>over</p>\n<h1>4.应用层的角度分析到底层</h1>\n<p><img src=\"Linux-input子系统/input_logical.png\" alt=\"\" /></p>\n<p>显然，就是input_dev通过输入核心为驱动层提供统一的接口，<code>input_event</code>，来向事件处理层上报数据并唤醒。</p>\n</div>\n</div>\n","source":"_posts/2022/01/Linux-input子系统.md","raw":"---\ntitle: Linux input子系统\npermalink: Linux input子系统\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2022-01-01 21:12:46\npassword:\nsummary:\ntags:\n- linux\n- input\ncategories:\n- linux\nkeywords:\ndescription:\n---\n<div>\n<div>\n<ul>\n<li>\n<h5>Input driver ：主要实现对硬件设备的读写访问，中断设置，并把硬件产生的事件转换为核心层定义的规范提交给事件处理层。</h5>\n</li>\n<li>\n<h5>Input core ：承上启下。为设备驱动层提供了规范和接口；通知事件处理层对事件进行处理；</h5>\n</li>\n<li>\n<h5>Event handler ：提供用户编程的接口（设备节点），并处理驱动层提交的数据处理。</h5>\n</li>\n</ul>\n<p><img src=\"Linux-input子系统/2909691-20220819093409715-1604400596.png\" alt=\"\" /></p>\n<h1>1输入子系统框架分析</h1>\n<div>\n<div>\n<h2>1.1设备驱动层（Input driver）</h2>\n<ul>\n<li>device是纯硬件操作层，包含不同的硬件接口处理，如gpio等</li>\n<li>对于每种不同的具体硬件操作，都对应着不同的input_dev结构体</li>\n<li>该结构体内部也包含着一个h_list，指向handle</li>\n</ul>\n</div>\n</div>\n<div>\n<div>\n<div>\n<div>\n<h2>1.2.系统核心层（Input core）</h2>\n<ul>\n<li>申请主设备号;</li>\n<li>提供input_register_device跟input_register_handler函数分别用于注册device跟handler;</li>\n<li>提供input_register_handle函数用于注册一个事件处理，代表一个成功配对的input_dev和input_handler;</li>\n</ul>\n</div>\n</div>\n<h2>1.3.事件处理层（Event handler）</h2>\n<ul>\n<li>不涉及硬件方面的具体操作，handler层是纯软件层，包含不同的解决方案，如键盘，鼠标，游戏手柄等；</li>\n<li>对于不同的解决方案，都包含一个名为input_handler的结构体，该结构体内含的主要成员如下：</li>\n</ul>\n<table>\n<thead>\n<tr><th>成员</th><th>功能</th></tr>\n</thead>\n<tbody>\n<tr>\n<td>.id_table</td>\n<td>一个存放该handler所支持的设备id的表（其实内部存放的是EV_xxx事件,用于判断device是否支持该事件）</td>\n</tr>\n<tr>\n<td>.fops</td>\n<td>该handler的file_operation</td>\n</tr>\n<tr>\n<td>.connect</td>\n<td>连接该handler跟所支持device的函数</td>\n</tr>\n<tr>\n<td>.disconnect</td>\n<td>断开该连接</td>\n</tr>\n<tr>\n<td>.event</td>\n<td>事件处理函数，让device调用</td>\n</tr>\n<tr>\n<td>h_list</td>\n<td>是一个链表，该链表保存着该handler到所支持的所有device的中间站：handle结构体的指针</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1>2.两条链表连接dev和handler</h1>\n<pre>\n\t<code class=\"yaml\">\n#file pwd: drivers/input/input.c\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@suse.cz>\");\nMODULE_DESCRIPTION(\"Input core\");\nMODULE_LICENSE(\"GPL\");\n#define INPUT_MAX_CHAR_DEVICES        1024\n#define INPUT_FIRST_DYNAMIC_DEV        256\nstatic DEFINE_IDA(input_ida);\nstatic LIST_HEAD(input_dev_list);\nstatic LIST_HEAD(input_handler_list);\n  </code>\n</pre> \n在input.c文件中两个全局链表input_handler_list和<span style=\"color: #000000;\">input_dev_list</span>，通过handle相互关联：</div>\n<div><img src=\"Linux-input子系统/2909691-20220819094250974-180404869.webp\" alt=\"\" />\n<p>&nbsp;</p>\n<h1>3.输入子系统代码分析</h1>\n<p>文件路径：driver/input/input.c （核心层）</p>\n<pre>\n\t<code class=\"yaml\">\nstatic int __init input_init(void)\n{\n    int err;\n    err = class_register(&input_class);  //在/sys/class下创建逻辑（input）类，在类下面挂载input设备\n    if (err) {\n        pr_err(\"unable to register input_dev class\\n\");\n        return err;\n    }\n    err = input_proc_init();　　//在/proc下面建立相关的虚拟文件，proc下创建的文件可以看作是虚拟文件对内核读写的一种操作\n    if (err)\n        goto fail1;\n    err = register_chrdev_region(MKDEV(INPUT_MAJOR, 0),//在/dev下创建input设备号\n                     INPUT_MAX_CHAR_DEVICES, \"input\");\n    if (err) {\n        pr_err(\"unable to register char major %d\", INPUT_MAJOR);\n        goto fail2;\n    }\n    return 0;\n fail2:    input_proc_exit();\n fail1:    class_unregister(&input_class);\n    return err;\n}\nstatic void __exit input_exit(void)\n{\n    input_proc_exit();\n    unregister_chrdev_region(MKDEV(INPUT_MAJOR, 0),\n                 INPUT_MAX_CHAR_DEVICES);\n    class_unregister(&input_class);\n}\nsubsys_initcall(input_init);\nmodule_exit(input_exit);\n  </code>\n</pre> \n<p>现在基本框架已经建成，如何往input系统里面注册dev和hanlder呢？</p>\n<h2>3.1注册dev</h2>\n<pre>\n\t<code class=\"yaml\">\n/**\n * struct input_dev - represents an input device\n * @name: name of the device\n * @phys: physical path to the device in the system hierarchy\n * @uniq: unique identification code for the device (if device has it)\n * @id: id of the device (struct input_id)\n * @propbit: bitmap of device properties and quirks\n * @evbit: bitmap of types of events supported by the device (EV_KEY,\n *    EV_REL, etc.)\n * @keybit: bitmap of keys/buttons this device has\n * @relbit: bitmap of relative axes for the device\n * @absbit: bitmap of absolute axes for the device\n * @mscbit: bitmap of miscellaneous events supported by the device\n * @ledbit: bitmap of leds present on the device\n * @sndbit: bitmap of sound effects supported by the device\n * @ffbit: bitmap of force feedback effects supported by the device\n * @swbit: bitmap of switches present on the device\n * @hint_events_per_packet: average number of events generated by the\n *    device in a packet (between EV_SYN/SYN_REPORT events). Used by\n *    event handlers to estimate size of the buffer needed to hold\n *    events.\n * @keycodemax: size of keycode table\n * @keycodesize: size of elements in keycode table\n * @keycode: map of scancodes to keycodes for this device\n * @getkeycode: optional legacy method to retrieve current keymap.\n * @setkeycode: optional method to alter current keymap, used to implement\n *    sparse keymaps. If not supplied default mechanism will be used.\n *    The method is being called while holding event_lock and thus must\n *    not sleep\n * @ff: force feedback structure associated with the device if device\n *    supports force feedback effects\n * @repeat_key: stores key code of the last key pressed; used to implement\n *    software autorepeat\n * @timer: timer for software autorepeat\n * @rep: current values for autorepeat parameters (delay, rate)\n * @mt: pointer to multitouch state\n * @absinfo: array of &struct input_absinfo elements holding information\n *    about absolute axes (current value, min, max, flat, fuzz,\n *    resolution)\n * @key: reflects current state of device's keys/buttons\n * @led: reflects current state of device's LEDs\n * @snd: reflects current state of sound effects\n * @sw: reflects current state of device's switches\n * @open: this method is called when the very first user calls\n *    input_open_device(). The driver must prepare the device\n *    to start generating events (start polling thread,\n *    request an IRQ, submit URB, etc.)\n * @close: this method is called when the very last user calls\n *    input_close_device().\n * @flush: purges the device. Most commonly used to get rid of force\n *    feedback effects loaded into the device when disconnecting\n *    from it\n * @event: event handler for events sent _to_ the device, like EV_LED\n *    or EV_SND. The device is expected to carry out the requested\n *    action (turn on a LED, play sound, etc.) The call is protected\n *    by @event_lock and must not sleep\n * @grab: input handle that currently has the device grabbed (via\n *    EVIOCGRAB ioctl). When a handle grabs a device it becomes sole\n *    recipient for all input events coming from the device\n * @event_lock: this spinlock is is taken when input core receives\n *    and processes a new event for the device (in input_event()).\n *    Code that accesses and/or modifies parameters of a device\n *    (such as keymap or absmin, absmax, absfuzz, etc.) after device\n *    has been registered with input core must take this lock.\n * @mutex: serializes calls to open(), close() and flush() methods\n * @users: stores number of users (input handlers) that opened this\n *    device. It is used by input_open_device() and input_close_device()\n *    to make sure that dev->open() is only called when the first\n *    user opens device and dev->close() is called when the very\n *    last user closes the device\n * @going_away: marks devices that are in a middle of unregistering and\n *    causes input_open_device*() fail with -ENODEV.\n * @dev: driver model's view of this device\n * @h_list: list of input handles associated with the device. When\n *    accessing the list dev->mutex must be held\n * @node: used to place the device onto input_dev_list\n * @num_vals: number of values queued in the current frame\n * @max_vals: maximum number of values queued in a frame\n * @vals: array of values queued in the current frame\n * @devres_managed: indicates that devices is managed with devres framework\n *    and needs not be explicitly unregistered or freed.\n */\nstruct input_dev {\n    const char *name;\n    const char *phys;\n    const char *uniq;\n    struct input_id id;\n    unsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];\n    unsigned long evbit[BITS_TO_LONGS(EV_CNT)];\n    unsigned long keybit[BITS_TO_LONGS(KEY_CNT)];\n    unsigned long relbit[BITS_TO_LONGS(REL_CNT)];\n    unsigned long absbit[BITS_TO_LONGS(ABS_CNT)];\n    unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)];\n    unsigned long ledbit[BITS_TO_LONGS(LED_CNT)];\n    unsigned long sndbit[BITS_TO_LONGS(SND_CNT)];\n    unsigned long ffbit[BITS_TO_LONGS(FF_CNT)];\n    unsigned long swbit[BITS_TO_LONGS(SW_CNT)];\n    unsigned int hint_events_per_packet;\n    unsigned int keycodemax;\n    unsigned int keycodesize;\n    void *keycode;\n    int (*setkeycode)(struct input_dev *dev,\n              const struct input_keymap_entry *ke,\n              unsigned int *old_keycode);\n    int (*getkeycode)(struct input_dev *dev,\n              struct input_keymap_entry *ke);\n    struct ff_device *ff;\n    unsigned int repeat_key;\n    struct timer_list timer;\n    int rep[REP_CNT];\n    struct input_mt *mt;\n    struct input_absinfo *absinfo;\n    unsigned long key[BITS_TO_LONGS(KEY_CNT)];\n    unsigned long led[BITS_TO_LONGS(LED_CNT)];\n    unsigned long snd[BITS_TO_LONGS(SND_CNT)];\n    unsigned long sw[BITS_TO_LONGS(SW_CNT)];\n    int (*open)(struct input_dev *dev);\n    void (*close)(struct input_dev *dev);\n    int (*flush)(struct input_dev *dev, struct file *file);\n    int (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value);\n    struct input_handle __rcu *grab;\n    spinlock_t event_lock;\n    struct mutex mutex;\n    unsigned int users;\n    bool going_away;\n    struct device dev;\n    struct list_head    h_list;\n    struct list_head    node;\n    unsigned int num_vals;\n    unsigned int max_vals;\n    struct input_value *vals;\n    bool devres_managed;\n};\n#define to_input_dev(d) container_of(d, struct input_dev, dev)\n  </code>\n</pre> \n<p>&nbsp;</p>\n<div>\n<div>&nbsp;</div><pre>\n\t<code class=\"yaml\">\n/**\n * input_register_device - register device with input core\n * @dev: device to be registered\n *\n * This function registers device with input core. The device must be\n * allocated with input_allocate_device() and all it's capabilities\n * set up before registering.\n * If function fails the device must be freed with input_free_device().\n * Once device has been successfully registered it can be unregistered\n * with input_unregister_device(); input_free_device() should not be\n * called in this case.\n *\n * Note that this function is also used to register managed input devices\n * (ones allocated with devm_input_allocate_device()). Such managed input\n * devices need not be explicitly unregistered or freed, their tear down\n * is controlled by the devres infrastructure. It is also worth noting\n * that tear down of managed input devices is internally a 2-step process:\n * registered managed input device is first unregistered, but stays in\n * memory and can still handle input_event() calls (although events will\n * not be delivered anywhere). The freeing of managed input device will\n * happen later, when devres stack is unwound to the point where device\n * allocation was made.\n */\nint input_register_device(struct input_dev *dev)\n{\n    struct input_devres *devres = NULL;\n     /* 输入事件的处理接口指针，用于和设备的事件类型进行匹配 */\n    struct input_handler *handler;\n    unsigned int packet_size;\n    const char *path;\n    int error;\n    if (dev->devres_managed) {\n        devres = devres_alloc(devm_input_device_unregister,\n                      sizeof(struct input_devres), GFP_KERNEL);\n        if (!devres)\n            return -ENOMEM;\n        devres->input = dev;\n    }\n    /* Every input device generates EV_SYN/SYN_REPORT events. */\n    __set_bit(EV_SYN, dev->evbit);\n    /* KEY_RESERVED is not supposed to be transmitted to userspace. */\n    __clear_bit(KEY_RESERVED, dev->keybit);\n    /* Make sure that bitmasks not mentioned in dev->evbit are clean. */\n    input_cleanse_bitmasks(dev);\n    packet_size = input_estimate_events_per_packet(dev);\n    if (dev->hint_events_per_packet < packet_size)\n        dev->hint_events_per_packet = packet_size;\n    dev->max_vals = dev->hint_events_per_packet + 2;\n    dev->vals = kcalloc(dev->max_vals, sizeof(*dev->vals), GFP_KERNEL);\n    if (!dev->vals) {\n        error = -ENOMEM;\n        goto err_devres_free;\n    }\n    /*\n     * If delay and period are pre-set by the driver, then autorepeating\n     * is handled by the driver itself and we don't do it in input.c.\n     */\n    if (!dev->rep[REP_DELAY] && !dev->rep[REP_PERIOD]) {\n        dev->timer.data = (long) dev;\n        dev->timer.function = input_repeat_key;\n        dev->rep[REP_DELAY] = 250;\n        dev->rep[REP_PERIOD] = 33;\n    }\n    if (!dev->getkeycode)\n        dev->getkeycode = input_default_getkeycode;\n    if (!dev->setkeycode)\n        dev->setkeycode = input_default_setkeycode;\n    error = device_add(&dev->dev);\n    if (error)\n        goto err_free_vals;\n    path = kobject_get_path(&dev->dev.kobj, GFP_KERNEL);\n    pr_info(\"%s as %s\\n\",\n        dev->name ? dev->name : \"Unspecified device\",\n        path ? path : \"N/A\");\n    kfree(path);\n    error = mutex_lock_interruptible(&input_mutex);\n    if (error)\n        goto err_device_del;\n    /* 重要:把设备挂到全局的input子系统设备链表input_dev_list上 */\n    list_add_tail(&dev->node, &input_dev_list);\n    /* 核心重点，input设备在增加到input_dev_list链表上之后，会查找\n     * input_handler_list事件处理链表上的handler进行匹配，这里的匹配\n     * 方式与设备模型的device和driver匹配过程很相似*/\n    list_for_each_entry(handler, &input_handler_list, node)\n        input_attach_handler(dev, handler);/*遍历input_handler_list，通过input_match_device试图与每一个handler进行匹配 匹配上了就使用connect连接*/\n    /*\n    static int input_attach_handler(struct input_dev *dev, struct input_handler *handler)\n    {\n        const struct input_device_id *id;\n        int error;\n\n        id = input_match_device(handler, dev);\n        if (!id)\n            return -ENODEV;\n        error = handler->connect(handler, dev, id);\n        if (error && error != -ENODEV)\n            pr_err(\"failed to attach handler %s to device %s, error: %d\\n\",\n                   handler->name, kobject_name(&dev->dev.kobj), error);\n        return error;\n    }\n    */\n    input_wakeup_procfs_readers();\n    mutex_unlock(&input_mutex);\n    if (dev->devres_managed) {\n        dev_dbg(dev->dev.parent, \"%s: registering %s with devres.\\n\",\n            __func__, dev_name(&dev->dev));\n        devres_add(dev->dev.parent, devres);\n    }\n    return 0;\nerr_device_del:\n    device_del(&dev->dev);\nerr_free_vals:\n    kfree(dev->vals);\n    dev->vals = NULL;\nerr_devres_free:\n    devres_free(devres);\n    return error;\n}\nEXPORT_SYMBOL(input_register_device);\n  </code>\n</pre> \n<h2>3.2注册handler</h2>\n<p>一般handler不需要我们自己写 内核里面已经有了很多的hanlder基本够用</p>\n下面以Evdev为例，来分析事件处理层。<br />\nvim drivers/input/evdev.c</div>\n<div>\n<pre>\n\t<code class=\"yaml\">\nstatic const struct input_device_id evdev_ids[] = {\n    { .driver_info = 1 },    /* Matches all devices */\n    { },            /* Terminating zero entry */\n};\nMODULE_DEVICE_TABLE(input, evdev_ids);\nstatic struct input_handler evdev_handler = {\n    .event        = evdev_event,\n    .events        = evdev_events,\n    .connect    = evdev_connect,\n    .disconnect    = evdev_disconnect,\n    .legacy_minors    = true,\n    .minor        = EVDEV_MINOR_BASE,\n    .name        = \"evdev\",\n    .id_table    = evdev_ids,\n};\nstatic int __init evdev_init(void)\n{\n    return input_register_handler(&evdev_handler);\n}\nstatic void __exit evdev_exit(void)\n{\n    input_unregister_handler(&evdev_handler);\n}\nmodule_init(evdev_init);\nmodule_exit(evdev_exit);\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>\");\nMODULE_DESCRIPTION(\"Input driver event char devices\");\nMODULE_LICENSE(\"GPL\");  \n  </code>\n</pre>  \n<p>注册的handler可以在proc/bus/input/danlder中查看到</p>\n</div>\n<p><img src=\"Linux-input子系统/2909691-20220819102740731-2036281828.png\" alt=\"\" /></p><pre>\n\t<code class=\"yaml\">\n/**\n* input_register_handler - register a new input handler\n* @handler: handler to be registered\n*\n* This function registers a new input handler (interface) for input\n* devices in the system and attaches it to all input devices that\n* are compatible with the handler.\n*/\nint input_register_handler(struct input_handler *handler)\n{\n     struct input_dev *dev;\n     int error;\n     error = mutex_lock_interruptible(&input_mutex);\n     if (error)\n         return error;\n \n     INIT_LIST_HEAD(&handler->h_list);\n 　　/* `重要`:把设备处理器挂到全局的input子系统设备链表input_handler_list上 */ \n     list_add_tail(&handler->node, &input_handler_list);\n 　　/*遍历input_dev_list，试图与每一个input_dev进行匹配*/\n     list_for_each_entry(dev, &input_dev_list, node)\n         input_attach_handler(dev, handler);　　　　/*static int input_attach_handler(struct input_dev *dev, struct input_handler *handler)\n{\n    const struct input_device_id *id;\n    int error;\n    ........\n    ........\n    input_wakeup_procfs_readers();\n    mutex_unlock(&input_mutex);\n    return 0;\n}\nEXPORT_SYMBOL(input_register_handler);\n  </code>\n</pre>  \n<p>这个过程和注册dev及其相似</p>\n<h2>3.3 handler的connect函数</h2><pre>\n\t<code class=\"yaml\">\nstatic int evdev_connect(struct input_handler *handler, struct input_dev *dev,\n             const struct input_device_id *id)\n{\n    struct evdev *evdev;\n    int minor;\n    int dev_no;\n    int error;\n    /*申请一个新的次设备号*/\n    minor = input_get_new_minor(EVDEV_MINOR_BASE, EVDEV_MINORS, true);\n    /* 这说明内核已经没办法再分配这种类型的设备了 */\n    if (minor < 0) {\n        error = minor;\n        pr_err(\"failed to reserve new minor: %d\\n\", error);\n        return error;\n    }\n    /* 开始给evdev事件层驱动分配空间了 */\n    evdev = kzalloc(sizeof(struct evdev), GFP_KERNEL);\n    if (!evdev) {\n        error = -ENOMEM;\n        goto err_free_minor;\n    }\n        /* 初始化client_list列表和evdev_wait队列 */\n    INIT_LIST_HEAD(&evdev->client_list);\n    spin_lock_init(&evdev->client_lock);\n    mutex_init(&evdev->mutex);\n    init_waitqueue_head(&evdev->wait);\n    evdev->exist = true;\n    dev_no = minor;\n    /* Normalize device number if it falls into legacy range */\n    if (dev_no < EVDEV_MINOR_BASE + EVDEV_MINORS)\n        dev_no -= EVDEV_MINOR_BASE;\n    /*设置设备节点名称，/dev/eventX 就是在此时设置*/\n    dev_set_name(&evdev->dev, \"event%d\", dev_no);\n    /* 初始化evdev结构体，其中handle为输入设备和事件处理的关联接口 */\n    evdev->handle.dev = input_get_device(dev);\n    evdev->handle.name = dev_name(&evdev->dev);\n    evdev->handle.handler = handler;\n    evdev->handle.private = evdev;\n      /*设置设备号，应用层就是通过设备号，找到该设备的*/\n    evdev->dev.devt = MKDEV(INPUT_MAJOR, minor);\n    evdev->dev.class = &input_class;\n    evdev->dev.parent = &dev->dev;\n    evdev->dev.release = evdev_free;\n    device_initialize(&evdev->dev);\n     /* input_dev设备驱动和handler事件处理层的关联，就在这时由handle完成 */\n    error = input_register_handle(&evdev->handle);\n    if (error)\n        goto err_free_evdev;\n    cdev_init(&evdev->cdev, &evdev_fops);\n    evdev->cdev.kobj.parent = &evdev->dev.kobj;\n    error = cdev_add(&evdev->cdev, evdev->dev.devt, 1);\n    if (error)\n        goto err_unregister_handle;\n    /*将设备加入到Linux设备模型，它的内部将找到它的bus，然后让它的bus\n    给它找到它的driver，在驱动或者总线的probe函数中，一般会在/dev/目录\n    先创建相应的设备节点，这样应用程序就可以通过该设备节点来使用设备了\n    ，/dev/eventX 设备节点就是在此时生成\n    */\n    error = device_add(&evdev->dev);\n    if (error)\n        goto err_cleanup_evdev;\n    return 0;\n err_cleanup_evdev:\n    evdev_cleanup(evdev);\n err_unregister_handle:\n    input_unregister_handle(&evdev->handle);\n err_free_evdev:\n    put_device(&evdev->dev);\n err_free_minor:\n    input_free_minor(minor);\n    return error;\n}\n  </code>\n</pre>   \n<p>over</p>\n<h1>4.应用层的角度分析到底层</h1>\n<p><img src=\"Linux-input子系统/input_logical.png\" alt=\"\" /></p>\n<p>显然，就是input_dev通过输入核心为驱动层提供统一的接口，<code>input_event</code>，来向事件处理层上报数据并唤醒。</p>\n</div>\n</div>\n","slug":"Linux input子系统","published":1,"updated":"2024-01-05T08:12:19.080Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clru1g1zz0008s4futq2z4rl1","content":"<div>\n<div>\n<ul>\n<li>\n<h5>Input driver ：主要实现对硬件设备的读写访问，中断设置，并把硬件产生的事件转换为核心层定义的规范提交给事件处理层。</h5>\n</li>\n<li>\n<h5>Input core ：承上启下。为设备驱动层提供了规范和接口；通知事件处理层对事件进行处理；</h5>\n</li>\n<li>\n<h5>Event handler ：提供用户编程的接口（设备节点），并处理驱动层提交的数据处理。</h5>\n</li>\n</ul>\n<p><img src=\"/2022/01/linux-input-zi-xi-tong/2909691-20220819093409715-1604400596.png\" alt></p>\n<h1>1输入子系统框架分析</h1>\n<div>\n<div>\n<h2>1.1设备驱动层（Input driver）</h2>\n<ul>\n<li>device是纯硬件操作层，包含不同的硬件接口处理，如gpio等</li>\n<li>对于每种不同的具体硬件操作，都对应着不同的input_dev结构体</li>\n<li>该结构体内部也包含着一个h_list，指向handle</li>\n</ul>\n</div>\n</div>\n<div>\n<div>\n<div>\n<div>\n<h2>1.2.系统核心层（Input core）</h2>\n<ul>\n<li>申请主设备号;</li>\n<li>提供input_register_device跟input_register_handler函数分别用于注册device跟handler;</li>\n<li>提供input_register_handle函数用于注册一个事件处理，代表一个成功配对的input_dev和input_handler;</li>\n</ul>\n</div>\n</div>\n<h2>1.3.事件处理层（Event handler）</h2>\n<ul>\n<li>不涉及硬件方面的具体操作，handler层是纯软件层，包含不同的解决方案，如键盘，鼠标，游戏手柄等；</li>\n<li>对于不同的解决方案，都包含一个名为input_handler的结构体，该结构体内含的主要成员如下：</li>\n</ul>\n<table>\n<thead>\n<tr><th>成员</th><th>功能</th></tr>\n</thead>\n<tbody>\n<tr>\n<td>.id_table</td>\n<td>一个存放该handler所支持的设备id的表（其实内部存放的是EV_xxx事件,用于判断device是否支持该事件）</td>\n</tr>\n<tr>\n<td>.fops</td>\n<td>该handler的file_operation</td>\n</tr>\n<tr>\n<td>.connect</td>\n<td>连接该handler跟所支持device的函数</td>\n</tr>\n<tr>\n<td>.disconnect</td>\n<td>断开该连接</td>\n</tr>\n<tr>\n<td>.event</td>\n<td>事件处理函数，让device调用</td>\n</tr>\n<tr>\n<td>h_list</td>\n<td>是一个链表，该链表保存着该handler到所支持的所有device的中间站：handle结构体的指针</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1>2.两条链表连接dev和handler</h1>\n<pre>\n    <code class=\"yaml\">\n#file pwd: drivers/input/input.c\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@suse.cz>\");\nMODULE_DESCRIPTION(\"Input core\");\nMODULE_LICENSE(\"GPL\");\n#define INPUT_MAX_CHAR_DEVICES        1024\n#define INPUT_FIRST_DYNAMIC_DEV        256\nstatic DEFINE_IDA(input_ida);\nstatic LIST_HEAD(input_dev_list);\nstatic LIST_HEAD(input_handler_list);\n  </vojtech@suse.cz></code>\n</pre> \n在input.c文件中两个全局链表input_handler_list和<span style=\"color: #000000;\">input_dev_list</span>，通过handle相互关联：</div>\n<div><img src=\"/2022/01/linux-input-zi-xi-tong/2909691-20220819094250974-180404869.webp\" alt>\n<p>&nbsp;</p>\n<h1>3.输入子系统代码分析</h1>\n<p>文件路径：driver/input/input.c （核心层）</p>\n<pre>\n    <code class=\"yaml\">\nstatic int __init input_init(void)\n{\n    int err;\n    err = class_register(&input_class);  //在/sys/class下创建逻辑（input）类，在类下面挂载input设备\n    if (err) {\n        pr_err(\"unable to register input_dev class\\n\");\n        return err;\n    }\n    err = input_proc_init();　　//在/proc下面建立相关的虚拟文件，proc下创建的文件可以看作是虚拟文件对内核读写的一种操作\n    if (err)\n        goto fail1;\n    err = register_chrdev_region(MKDEV(INPUT_MAJOR, 0),//在/dev下创建input设备号\n                     INPUT_MAX_CHAR_DEVICES, \"input\");\n    if (err) {\n        pr_err(\"unable to register char major %d\", INPUT_MAJOR);\n        goto fail2;\n    }\n    return 0;\n fail2:    input_proc_exit();\n fail1:    class_unregister(&input_class);\n    return err;\n}\nstatic void __exit input_exit(void)\n{\n    input_proc_exit();\n    unregister_chrdev_region(MKDEV(INPUT_MAJOR, 0),\n                 INPUT_MAX_CHAR_DEVICES);\n    class_unregister(&input_class);\n}\nsubsys_initcall(input_init);\nmodule_exit(input_exit);\n  </code>\n</pre> \n<p>现在基本框架已经建成，如何往input系统里面注册dev和hanlder呢？</p>\n<h2>3.1注册dev</h2>\n<pre>\n    <code class=\"yaml\">\n/**\n * struct input_dev - represents an input device\n * @name: name of the device\n * @phys: physical path to the device in the system hierarchy\n * @uniq: unique identification code for the device (if device has it)\n * @id: id of the device (struct input_id)\n * @propbit: bitmap of device properties and quirks\n * @evbit: bitmap of types of events supported by the device (EV_KEY,\n *    EV_REL, etc.)\n * @keybit: bitmap of keys/buttons this device has\n * @relbit: bitmap of relative axes for the device\n * @absbit: bitmap of absolute axes for the device\n * @mscbit: bitmap of miscellaneous events supported by the device\n * @ledbit: bitmap of leds present on the device\n * @sndbit: bitmap of sound effects supported by the device\n * @ffbit: bitmap of force feedback effects supported by the device\n * @swbit: bitmap of switches present on the device\n * @hint_events_per_packet: average number of events generated by the\n *    device in a packet (between EV_SYN/SYN_REPORT events). Used by\n *    event handlers to estimate size of the buffer needed to hold\n *    events.\n * @keycodemax: size of keycode table\n * @keycodesize: size of elements in keycode table\n * @keycode: map of scancodes to keycodes for this device\n * @getkeycode: optional legacy method to retrieve current keymap.\n * @setkeycode: optional method to alter current keymap, used to implement\n *    sparse keymaps. If not supplied default mechanism will be used.\n *    The method is being called while holding event_lock and thus must\n *    not sleep\n * @ff: force feedback structure associated with the device if device\n *    supports force feedback effects\n * @repeat_key: stores key code of the last key pressed; used to implement\n *    software autorepeat\n * @timer: timer for software autorepeat\n * @rep: current values for autorepeat parameters (delay, rate)\n * @mt: pointer to multitouch state\n * @absinfo: array of &struct input_absinfo elements holding information\n *    about absolute axes (current value, min, max, flat, fuzz,\n *    resolution)\n * @key: reflects current state of device's keys/buttons\n * @led: reflects current state of device's LEDs\n * @snd: reflects current state of sound effects\n * @sw: reflects current state of device's switches\n * @open: this method is called when the very first user calls\n *    input_open_device(). The driver must prepare the device\n *    to start generating events (start polling thread,\n *    request an IRQ, submit URB, etc.)\n * @close: this method is called when the very last user calls\n *    input_close_device().\n * @flush: purges the device. Most commonly used to get rid of force\n *    feedback effects loaded into the device when disconnecting\n *    from it\n * @event: event handler for events sent _to_ the device, like EV_LED\n *    or EV_SND. The device is expected to carry out the requested\n *    action (turn on a LED, play sound, etc.) The call is protected\n *    by @event_lock and must not sleep\n * @grab: input handle that currently has the device grabbed (via\n *    EVIOCGRAB ioctl). When a handle grabs a device it becomes sole\n *    recipient for all input events coming from the device\n * @event_lock: this spinlock is is taken when input core receives\n *    and processes a new event for the device (in input_event()).\n *    Code that accesses and/or modifies parameters of a device\n *    (such as keymap or absmin, absmax, absfuzz, etc.) after device\n *    has been registered with input core must take this lock.\n * @mutex: serializes calls to open(), close() and flush() methods\n * @users: stores number of users (input handlers) that opened this\n *    device. It is used by input_open_device() and input_close_device()\n *    to make sure that dev->open() is only called when the first\n *    user opens device and dev->close() is called when the very\n *    last user closes the device\n * @going_away: marks devices that are in a middle of unregistering and\n *    causes input_open_device*() fail with -ENODEV.\n * @dev: driver model's view of this device\n * @h_list: list of input handles associated with the device. When\n *    accessing the list dev->mutex must be held\n * @node: used to place the device onto input_dev_list\n * @num_vals: number of values queued in the current frame\n * @max_vals: maximum number of values queued in a frame\n * @vals: array of values queued in the current frame\n * @devres_managed: indicates that devices is managed with devres framework\n *    and needs not be explicitly unregistered or freed.\n */\nstruct input_dev {\n    const char *name;\n    const char *phys;\n    const char *uniq;\n    struct input_id id;\n    unsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];\n    unsigned long evbit[BITS_TO_LONGS(EV_CNT)];\n    unsigned long keybit[BITS_TO_LONGS(KEY_CNT)];\n    unsigned long relbit[BITS_TO_LONGS(REL_CNT)];\n    unsigned long absbit[BITS_TO_LONGS(ABS_CNT)];\n    unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)];\n    unsigned long ledbit[BITS_TO_LONGS(LED_CNT)];\n    unsigned long sndbit[BITS_TO_LONGS(SND_CNT)];\n    unsigned long ffbit[BITS_TO_LONGS(FF_CNT)];\n    unsigned long swbit[BITS_TO_LONGS(SW_CNT)];\n    unsigned int hint_events_per_packet;\n    unsigned int keycodemax;\n    unsigned int keycodesize;\n    void *keycode;\n    int (*setkeycode)(struct input_dev *dev,\n              const struct input_keymap_entry *ke,\n              unsigned int *old_keycode);\n    int (*getkeycode)(struct input_dev *dev,\n              struct input_keymap_entry *ke);\n    struct ff_device *ff;\n    unsigned int repeat_key;\n    struct timer_list timer;\n    int rep[REP_CNT];\n    struct input_mt *mt;\n    struct input_absinfo *absinfo;\n    unsigned long key[BITS_TO_LONGS(KEY_CNT)];\n    unsigned long led[BITS_TO_LONGS(LED_CNT)];\n    unsigned long snd[BITS_TO_LONGS(SND_CNT)];\n    unsigned long sw[BITS_TO_LONGS(SW_CNT)];\n    int (*open)(struct input_dev *dev);\n    void (*close)(struct input_dev *dev);\n    int (*flush)(struct input_dev *dev, struct file *file);\n    int (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value);\n    struct input_handle __rcu *grab;\n    spinlock_t event_lock;\n    struct mutex mutex;\n    unsigned int users;\n    bool going_away;\n    struct device dev;\n    struct list_head    h_list;\n    struct list_head    node;\n    unsigned int num_vals;\n    unsigned int max_vals;\n    struct input_value *vals;\n    bool devres_managed;\n};\n#define to_input_dev(d) container_of(d, struct input_dev, dev)\n  </code>\n</pre> \n<p>&nbsp;</p>\n<div>\n<div>&nbsp;</div><pre>\n    <code class=\"yaml\">\n/**\n * input_register_device - register device with input core\n * @dev: device to be registered\n *\n * This function registers device with input core. The device must be\n * allocated with input_allocate_device() and all it's capabilities\n * set up before registering.\n * If function fails the device must be freed with input_free_device().\n * Once device has been successfully registered it can be unregistered\n * with input_unregister_device(); input_free_device() should not be\n * called in this case.\n *\n * Note that this function is also used to register managed input devices\n * (ones allocated with devm_input_allocate_device()). Such managed input\n * devices need not be explicitly unregistered or freed, their tear down\n * is controlled by the devres infrastructure. It is also worth noting\n * that tear down of managed input devices is internally a 2-step process:\n * registered managed input device is first unregistered, but stays in\n * memory and can still handle input_event() calls (although events will\n * not be delivered anywhere). The freeing of managed input device will\n * happen later, when devres stack is unwound to the point where device\n * allocation was made.\n */\nint input_register_device(struct input_dev *dev)\n{\n    struct input_devres *devres = NULL;\n     /* 输入事件的处理接口指针，用于和设备的事件类型进行匹配 */\n    struct input_handler *handler;\n    unsigned int packet_size;\n    const char *path;\n    int error;\n    if (dev->devres_managed) {\n        devres = devres_alloc(devm_input_device_unregister,\n                      sizeof(struct input_devres), GFP_KERNEL);\n        if (!devres)\n            return -ENOMEM;\n        devres->input = dev;\n    }\n    /* Every input device generates EV_SYN/SYN_REPORT events. */\n    __set_bit(EV_SYN, dev->evbit);\n    /* KEY_RESERVED is not supposed to be transmitted to userspace. */\n    __clear_bit(KEY_RESERVED, dev->keybit);\n    /* Make sure that bitmasks not mentioned in dev->evbit are clean. */\n    input_cleanse_bitmasks(dev);\n    packet_size = input_estimate_events_per_packet(dev);\n    if (dev->hint_events_per_packet < packet_size)\n        dev->hint_events_per_packet = packet_size;\n    dev->max_vals = dev->hint_events_per_packet + 2;\n    dev->vals = kcalloc(dev->max_vals, sizeof(*dev->vals), GFP_KERNEL);\n    if (!dev->vals) {\n        error = -ENOMEM;\n        goto err_devres_free;\n    }\n    /*\n     * If delay and period are pre-set by the driver, then autorepeating\n     * is handled by the driver itself and we don't do it in input.c.\n     */\n    if (!dev->rep[REP_DELAY] && !dev->rep[REP_PERIOD]) {\n        dev->timer.data = (long) dev;\n        dev->timer.function = input_repeat_key;\n        dev->rep[REP_DELAY] = 250;\n        dev->rep[REP_PERIOD] = 33;\n    }\n    if (!dev->getkeycode)\n        dev->getkeycode = input_default_getkeycode;\n    if (!dev->setkeycode)\n        dev->setkeycode = input_default_setkeycode;\n    error = device_add(&dev->dev);\n    if (error)\n        goto err_free_vals;\n    path = kobject_get_path(&dev->dev.kobj, GFP_KERNEL);\n    pr_info(\"%s as %s\\n\",\n        dev->name ? dev->name : \"Unspecified device\",\n        path ? path : \"N/A\");\n    kfree(path);\n    error = mutex_lock_interruptible(&input_mutex);\n    if (error)\n        goto err_device_del;\n    /* 重要:把设备挂到全局的input子系统设备链表input_dev_list上 */\n    list_add_tail(&dev->node, &input_dev_list);\n    /* 核心重点，input设备在增加到input_dev_list链表上之后，会查找\n     * input_handler_list事件处理链表上的handler进行匹配，这里的匹配\n     * 方式与设备模型的device和driver匹配过程很相似*/\n    list_for_each_entry(handler, &input_handler_list, node)\n        input_attach_handler(dev, handler);/*遍历input_handler_list，通过input_match_device试图与每一个handler进行匹配 匹配上了就使用connect连接*/\n    /*\n    static int input_attach_handler(struct input_dev *dev, struct input_handler *handler)\n    {\n        const struct input_device_id *id;\n        int error;\n\n<pre><code>    id = input_match_device(handler, dev);\n    if (!id)\n        return -ENODEV;\n    error = handler-&gt;connect(handler, dev, id);\n    if (error &amp;&amp; error != -ENODEV)\n        pr_err(&quot;failed to attach handler %s to device %s, error: %d\\n&quot;,\n               handler-&gt;name, kobject_name(&amp;dev-&gt;dev.kobj), error);\n    return error;\n}\n*/\ninput_wakeup_procfs_readers();\nmutex_unlock(&amp;input_mutex);\nif (dev-&gt;devres_managed) {\n    dev_dbg(dev-&gt;dev.parent, &quot;%s: registering %s with devres.\\n&quot;,\n        __func__, dev_name(&amp;dev-&gt;dev));\n    devres_add(dev-&gt;dev.parent, devres);\n}\nreturn 0;</code></pre><p>err_device_del:<br>    device_del(&amp;dev-&gt;dev);<br>err_free_vals:<br>    kfree(dev-&gt;vals);<br>    dev-&gt;vals = NULL;<br>err_devres_free:<br>    devres_free(devres);<br>    return error;<br>}<br>EXPORT_SYMBOL(input_register_device);<br>  </p></code><br></pre> <p></p>\n<h2>3.2注册handler</h2>\n<p>一般handler不需要我们自己写 内核里面已经有了很多的hanlder基本够用</p>\n下面以Evdev为例，来分析事件处理层。<br>\nvim drivers/input/evdev.c</div>\n<div>\n<pre>\n    <code class=\"yaml\">\nstatic const struct input_device_id evdev_ids[] = {\n    { .driver_info = 1 },    /* Matches all devices */\n    { },            /* Terminating zero entry */\n};\nMODULE_DEVICE_TABLE(input, evdev_ids);\nstatic struct input_handler evdev_handler = {\n    .event        = evdev_event,\n    .events        = evdev_events,\n    .connect    = evdev_connect,\n    .disconnect    = evdev_disconnect,\n    .legacy_minors    = true,\n    .minor        = EVDEV_MINOR_BASE,\n    .name        = \"evdev\",\n    .id_table    = evdev_ids,\n};\nstatic int __init evdev_init(void)\n{\n    return input_register_handler(&evdev_handler);\n}\nstatic void __exit evdev_exit(void)\n{\n    input_unregister_handler(&evdev_handler);\n}\nmodule_init(evdev_init);\nmodule_exit(evdev_exit);\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>\");\nMODULE_DESCRIPTION(\"Input driver event char devices\");\nMODULE_LICENSE(\"GPL\");  \n  </vojtech@ucw.cz></code>\n</pre>  \n<p>注册的handler可以在proc/bus/input/danlder中查看到</p>\n</div>\n<p><img src=\"/2022/01/linux-input-zi-xi-tong/2909691-20220819102740731-2036281828.png\" alt></p><pre>\n    <code class=\"yaml\">\n/**\n* input_register_handler - register a new input handler\n* @handler: handler to be registered\n*\n* This function registers a new input handler (interface) for input\n* devices in the system and attaches it to all input devices that\n* are compatible with the handler.\n*/\nint input_register_handler(struct input_handler *handler)\n{\n     struct input_dev *dev;\n     int error;\n     error = mutex_lock_interruptible(&input_mutex);\n     if (error)\n         return error;\n\n<pre><code> INIT_LIST_HEAD(&amp;handler-&gt;h_list);</code></pre><p> 　　/* <code>重要</code>:把设备处理器挂到全局的input子系统设备链表input_handler_list上 <em>/<br>     list_add_tail(&amp;handler-&gt;node, &amp;input_handler_list);<br> 　　/*遍历input_dev_list，试图与每一个input_dev进行匹配</em>/<br>     list_for_each_entry(dev, &amp;input_dev_list, node)<br>         input_attach_handler(dev, handler);　　　　/*static int input_attach_handler(struct input_dev *dev, struct input_handler *handler)<br>{<br>    const struct input_device_id *id;<br>    int error;<br>    ……..<br>    ……..<br>    input_wakeup_procfs_readers();<br>    mutex_unlock(&amp;input_mutex);<br>    return 0;<br>}<br>EXPORT_SYMBOL(input_register_handler);<br>  </p></code><br></pre>  <p></p>\n<p>这个过程和注册dev及其相似</p>\n<h2>3.3 handler的connect函数</h2><pre>\n    <code class=\"yaml\">\nstatic int evdev_connect(struct input_handler *handler, struct input_dev *dev,\n             const struct input_device_id *id)\n{\n    struct evdev *evdev;\n    int minor;\n    int dev_no;\n    int error;\n    /*申请一个新的次设备号*/\n    minor = input_get_new_minor(EVDEV_MINOR_BASE, EVDEV_MINORS, true);\n    /* 这说明内核已经没办法再分配这种类型的设备了 */\n    if (minor < 0) {\n        error = minor;\n        pr_err(\"failed to reserve new minor: %d\\n\", error);\n        return error;\n    }\n    /* 开始给evdev事件层驱动分配空间了 */\n    evdev = kzalloc(sizeof(struct evdev), GFP_KERNEL);\n    if (!evdev) {\n        error = -ENOMEM;\n        goto err_free_minor;\n    }\n        /* 初始化client_list列表和evdev_wait队列 */\n    INIT_LIST_HEAD(&evdev->client_list);\n    spin_lock_init(&evdev->client_lock);\n    mutex_init(&evdev->mutex);\n    init_waitqueue_head(&evdev->wait);\n    evdev->exist = true;\n    dev_no = minor;\n    /* Normalize device number if it falls into legacy range */\n    if (dev_no < EVDEV_MINOR_BASE + EVDEV_MINORS)\n        dev_no -= EVDEV_MINOR_BASE;\n    /*设置设备节点名称，/dev/eventX 就是在此时设置*/\n    dev_set_name(&evdev->dev, \"event%d\", dev_no);\n    /* 初始化evdev结构体，其中handle为输入设备和事件处理的关联接口 */\n    evdev->handle.dev = input_get_device(dev);\n    evdev->handle.name = dev_name(&evdev->dev);\n    evdev->handle.handler = handler;\n    evdev->handle.private = evdev;\n      /*设置设备号，应用层就是通过设备号，找到该设备的*/\n    evdev->dev.devt = MKDEV(INPUT_MAJOR, minor);\n    evdev->dev.class = &input_class;\n    evdev->dev.parent = &dev->dev;\n    evdev->dev.release = evdev_free;\n    device_initialize(&evdev->dev);\n     /* input_dev设备驱动和handler事件处理层的关联，就在这时由handle完成 */\n    error = input_register_handle(&evdev->handle);\n    if (error)\n        goto err_free_evdev;\n    cdev_init(&evdev->cdev, &evdev_fops);\n    evdev->cdev.kobj.parent = &evdev->dev.kobj;\n    error = cdev_add(&evdev->cdev, evdev->dev.devt, 1);\n    if (error)\n        goto err_unregister_handle;\n    /*将设备加入到Linux设备模型，它的内部将找到它的bus，然后让它的bus\n    给它找到它的driver，在驱动或者总线的probe函数中，一般会在/dev/目录\n    先创建相应的设备节点，这样应用程序就可以通过该设备节点来使用设备了\n    ，/dev/eventX 设备节点就是在此时生成\n    */\n    error = device_add(&evdev->dev);\n    if (error)\n        goto err_cleanup_evdev;\n    return 0;\n err_cleanup_evdev:\n    evdev_cleanup(evdev);\n err_unregister_handle:\n    input_unregister_handle(&evdev->handle);\n err_free_evdev:\n    put_device(&evdev->dev);\n err_free_minor:\n    input_free_minor(minor);\n    return error;\n}\n  </code>\n</pre>   \n<p>over</p>\n<h1>4.应用层的角度分析到底层</h1>\n<p><img src=\"/2022/01/linux-input-zi-xi-tong/input_logical.png\" alt></p>\n<p>显然，就是input_dev通过输入核心为驱动层提供统一的接口，<code>input_event</code>，来向事件处理层上报数据并唤醒。</p>\n</div>\n</div>\n</div>","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<div>\n<div>\n<ul>\n<li>\n<h5>Input driver ：主要实现对硬件设备的读写访问，中断设置，并把硬件产生的事件转换为核心层定义的规范提交给事件处理层。</h5>\n</li>\n<li>\n<h5>Input core ：承上启下。为设备驱动层提供了规范和接口；通知事件处理层对事件进行处理；</h5>\n</li>\n<li>\n<h5>Event handler ：提供用户编程的接口（设备节点），并处理驱动层提交的数据处理。</h5>\n</li>\n</ul>\n<p><img src=\"/2022/01/linux-input-zi-xi-tong/2909691-20220819093409715-1604400596.png\" alt></p>\n<h1>1输入子系统框架分析</h1>\n<div>\n<div>\n<h2>1.1设备驱动层（Input driver）</h2>\n<ul>\n<li>device是纯硬件操作层，包含不同的硬件接口处理，如gpio等</li>\n<li>对于每种不同的具体硬件操作，都对应着不同的input_dev结构体</li>\n<li>该结构体内部也包含着一个h_list，指向handle</li>\n</ul>\n</div>\n</div>\n<div>\n<div>\n<div>\n<div>\n<h2>1.2.系统核心层（Input core）</h2>\n<ul>\n<li>申请主设备号;</li>\n<li>提供input_register_device跟input_register_handler函数分别用于注册device跟handler;</li>\n<li>提供input_register_handle函数用于注册一个事件处理，代表一个成功配对的input_dev和input_handler;</li>\n</ul>\n</div>\n</div>\n<h2>1.3.事件处理层（Event handler）</h2>\n<ul>\n<li>不涉及硬件方面的具体操作，handler层是纯软件层，包含不同的解决方案，如键盘，鼠标，游戏手柄等；</li>\n<li>对于不同的解决方案，都包含一个名为input_handler的结构体，该结构体内含的主要成员如下：</li>\n</ul>\n<table>\n<thead>\n<tr><th>成员</th><th>功能</th></tr>\n</thead>\n<tbody>\n<tr>\n<td>.id_table</td>\n<td>一个存放该handler所支持的设备id的表（其实内部存放的是EV_xxx事件,用于判断device是否支持该事件）</td>\n</tr>\n<tr>\n<td>.fops</td>\n<td>该handler的file_operation</td>\n</tr>\n<tr>\n<td>.connect</td>\n<td>连接该handler跟所支持device的函数</td>\n</tr>\n<tr>\n<td>.disconnect</td>\n<td>断开该连接</td>\n</tr>\n<tr>\n<td>.event</td>\n<td>事件处理函数，让device调用</td>\n</tr>\n<tr>\n<td>h_list</td>\n<td>是一个链表，该链表保存着该handler到所支持的所有device的中间站：handle结构体的指针</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1>2.两条链表连接dev和handler</h1>\n<pre>\n    <code class=\"yaml\">\n#file pwd: drivers/input/input.c\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@suse.cz>\");\nMODULE_DESCRIPTION(\"Input core\");\nMODULE_LICENSE(\"GPL\");\n#define INPUT_MAX_CHAR_DEVICES        1024\n#define INPUT_FIRST_DYNAMIC_DEV        256\nstatic DEFINE_IDA(input_ida);\nstatic LIST_HEAD(input_dev_list);\nstatic LIST_HEAD(input_handler_list);\n  </vojtech@suse.cz></code>\n</pre> \n在input.c文件中两个全局链表input_handler_list和<span style=\"color: #000000;\">input_dev_list</span>，通过handle相互关联：</div>\n<div><img src=\"/2022/01/linux-input-zi-xi-tong/2909691-20220819094250974-180404869.webp\" alt>\n<p>&nbsp;</p>\n<h1>3.输入子系统代码分析</h1>\n<p>文件路径：driver/input/input.c （核心层）</p>\n<pre>\n    <code class=\"yaml\">\nstatic int __init input_init(void)\n{\n    int err;\n    err = class_register(&input_class);  //在/sys/class下创建逻辑（input）类，在类下面挂载input设备\n    if (err) {\n        pr_err(\"unable to register input_dev class\\n\");\n        return err;\n    }\n    err = input_proc_init();　　//在/proc下面建立相关的虚拟文件，proc下创建的文件可以看作是虚拟文件对内核读写的一种操作\n    if (err)\n        goto fail1;\n    err = register_chrdev_region(MKDEV(INPUT_MAJOR, 0),//在/dev下创建input设备号\n                     INPUT_MAX_CHAR_DEVICES, \"input\");\n    if (err) {\n        pr_err(\"unable to register char major %d\", INPUT_MAJOR);\n        goto fail2;\n    }\n    return 0;\n fail2:    input_proc_exit();\n fail1:    class_unregister(&input_class);\n    return err;\n}\nstatic void __exit input_exit(void)\n{\n    input_proc_exit();\n    unregister_chrdev_region(MKDEV(INPUT_MAJOR, 0),\n                 INPUT_MAX_CHAR_DEVICES);\n    class_unregister(&input_class);\n}\nsubsys_initcall(input_init);\nmodule_exit(input_exit);\n  </code>\n</pre> \n<p>现在基本框架已经建成，如何往input系统里面注册dev和hanlder呢？</p>\n<h2>3.1注册dev</h2>\n<pre>\n    <code class=\"yaml\">\n/**\n * struct input_dev - represents an input device\n * @name: name of the device\n * @phys: physical path to the device in the system hierarchy\n * @uniq: unique identification code for the device (if device has it)\n * @id: id of the device (struct input_id)\n * @propbit: bitmap of device properties and quirks\n * @evbit: bitmap of types of events supported by the device (EV_KEY,\n *    EV_REL, etc.)\n * @keybit: bitmap of keys/buttons this device has\n * @relbit: bitmap of relative axes for the device\n * @absbit: bitmap of absolute axes for the device\n * @mscbit: bitmap of miscellaneous events supported by the device\n * @ledbit: bitmap of leds present on the device\n * @sndbit: bitmap of sound effects supported by the device\n * @ffbit: bitmap of force feedback effects supported by the device\n * @swbit: bitmap of switches present on the device\n * @hint_events_per_packet: average number of events generated by the\n *    device in a packet (between EV_SYN/SYN_REPORT events). Used by\n *    event handlers to estimate size of the buffer needed to hold\n *    events.\n * @keycodemax: size of keycode table\n * @keycodesize: size of elements in keycode table\n * @keycode: map of scancodes to keycodes for this device\n * @getkeycode: optional legacy method to retrieve current keymap.\n * @setkeycode: optional method to alter current keymap, used to implement\n *    sparse keymaps. If not supplied default mechanism will be used.\n *    The method is being called while holding event_lock and thus must\n *    not sleep\n * @ff: force feedback structure associated with the device if device\n *    supports force feedback effects\n * @repeat_key: stores key code of the last key pressed; used to implement\n *    software autorepeat\n * @timer: timer for software autorepeat\n * @rep: current values for autorepeat parameters (delay, rate)\n * @mt: pointer to multitouch state\n * @absinfo: array of &struct input_absinfo elements holding information\n *    about absolute axes (current value, min, max, flat, fuzz,\n *    resolution)\n * @key: reflects current state of device's keys/buttons\n * @led: reflects current state of device's LEDs\n * @snd: reflects current state of sound effects\n * @sw: reflects current state of device's switches\n * @open: this method is called when the very first user calls\n *    input_open_device(). The driver must prepare the device\n *    to start generating events (start polling thread,\n *    request an IRQ, submit URB, etc.)\n * @close: this method is called when the very last user calls\n *    input_close_device().\n * @flush: purges the device. Most commonly used to get rid of force\n *    feedback effects loaded into the device when disconnecting\n *    from it\n * @event: event handler for events sent _to_ the device, like EV_LED\n *    or EV_SND. The device is expected to carry out the requested\n *    action (turn on a LED, play sound, etc.) The call is protected\n *    by @event_lock and must not sleep\n * @grab: input handle that currently has the device grabbed (via\n *    EVIOCGRAB ioctl). When a handle grabs a device it becomes sole\n *    recipient for all input events coming from the device\n * @event_lock: this spinlock is is taken when input core receives\n *    and processes a new event for the device (in input_event()).\n *    Code that accesses and/or modifies parameters of a device\n *    (such as keymap or absmin, absmax, absfuzz, etc.) after device\n *    has been registered with input core must take this lock.\n * @mutex: serializes calls to open(), close() and flush() methods\n * @users: stores number of users (input handlers) that opened this\n *    device. It is used by input_open_device() and input_close_device()\n *    to make sure that dev->open() is only called when the first\n *    user opens device and dev->close() is called when the very\n *    last user closes the device\n * @going_away: marks devices that are in a middle of unregistering and\n *    causes input_open_device*() fail with -ENODEV.\n * @dev: driver model's view of this device\n * @h_list: list of input handles associated with the device. When\n *    accessing the list dev->mutex must be held\n * @node: used to place the device onto input_dev_list\n * @num_vals: number of values queued in the current frame\n * @max_vals: maximum number of values queued in a frame\n * @vals: array of values queued in the current frame\n * @devres_managed: indicates that devices is managed with devres framework\n *    and needs not be explicitly unregistered or freed.\n */\nstruct input_dev {\n    const char *name;\n    const char *phys;\n    const char *uniq;\n    struct input_id id;\n    unsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];\n    unsigned long evbit[BITS_TO_LONGS(EV_CNT)];\n    unsigned long keybit[BITS_TO_LONGS(KEY_CNT)];\n    unsigned long relbit[BITS_TO_LONGS(REL_CNT)];\n    unsigned long absbit[BITS_TO_LONGS(ABS_CNT)];\n    unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)];\n    unsigned long ledbit[BITS_TO_LONGS(LED_CNT)];\n    unsigned long sndbit[BITS_TO_LONGS(SND_CNT)];\n    unsigned long ffbit[BITS_TO_LONGS(FF_CNT)];\n    unsigned long swbit[BITS_TO_LONGS(SW_CNT)];\n    unsigned int hint_events_per_packet;\n    unsigned int keycodemax;\n    unsigned int keycodesize;\n    void *keycode;\n    int (*setkeycode)(struct input_dev *dev,\n              const struct input_keymap_entry *ke,\n              unsigned int *old_keycode);\n    int (*getkeycode)(struct input_dev *dev,\n              struct input_keymap_entry *ke);\n    struct ff_device *ff;\n    unsigned int repeat_key;\n    struct timer_list timer;\n    int rep[REP_CNT];\n    struct input_mt *mt;\n    struct input_absinfo *absinfo;\n    unsigned long key[BITS_TO_LONGS(KEY_CNT)];\n    unsigned long led[BITS_TO_LONGS(LED_CNT)];\n    unsigned long snd[BITS_TO_LONGS(SND_CNT)];\n    unsigned long sw[BITS_TO_LONGS(SW_CNT)];\n    int (*open)(struct input_dev *dev);\n    void (*close)(struct input_dev *dev);\n    int (*flush)(struct input_dev *dev, struct file *file);\n    int (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value);\n    struct input_handle __rcu *grab;\n    spinlock_t event_lock;\n    struct mutex mutex;\n    unsigned int users;\n    bool going_away;\n    struct device dev;\n    struct list_head    h_list;\n    struct list_head    node;\n    unsigned int num_vals;\n    unsigned int max_vals;\n    struct input_value *vals;\n    bool devres_managed;\n};\n#define to_input_dev(d) container_of(d, struct input_dev, dev)\n  </code>\n</pre> \n<p>&nbsp;</p>\n<div>\n<div>&nbsp;</div><pre>\n    <code class=\"yaml\">\n/**\n * input_register_device - register device with input core\n * @dev: device to be registered\n *\n * This function registers device with input core. The device must be\n * allocated with input_allocate_device() and all it's capabilities\n * set up before registering.\n * If function fails the device must be freed with input_free_device().\n * Once device has been successfully registered it can be unregistered\n * with input_unregister_device(); input_free_device() should not be\n * called in this case.\n *\n * Note that this function is also used to register managed input devices\n * (ones allocated with devm_input_allocate_device()). Such managed input\n * devices need not be explicitly unregistered or freed, their tear down\n * is controlled by the devres infrastructure. It is also worth noting\n * that tear down of managed input devices is internally a 2-step process:\n * registered managed input device is first unregistered, but stays in\n * memory and can still handle input_event() calls (although events will\n * not be delivered anywhere). The freeing of managed input device will\n * happen later, when devres stack is unwound to the point where device\n * allocation was made.\n */\nint input_register_device(struct input_dev *dev)\n{\n    struct input_devres *devres = NULL;\n     /* 输入事件的处理接口指针，用于和设备的事件类型进行匹配 */\n    struct input_handler *handler;\n    unsigned int packet_size;\n    const char *path;\n    int error;\n    if (dev->devres_managed) {\n        devres = devres_alloc(devm_input_device_unregister,\n                      sizeof(struct input_devres), GFP_KERNEL);\n        if (!devres)\n            return -ENOMEM;\n        devres->input = dev;\n    }\n    /* Every input device generates EV_SYN/SYN_REPORT events. */\n    __set_bit(EV_SYN, dev->evbit);\n    /* KEY_RESERVED is not supposed to be transmitted to userspace. */\n    __clear_bit(KEY_RESERVED, dev->keybit);\n    /* Make sure that bitmasks not mentioned in dev->evbit are clean. */\n    input_cleanse_bitmasks(dev);\n    packet_size = input_estimate_events_per_packet(dev);\n    if (dev->hint_events_per_packet < packet_size)\n        dev->hint_events_per_packet = packet_size;\n    dev->max_vals = dev->hint_events_per_packet + 2;\n    dev->vals = kcalloc(dev->max_vals, sizeof(*dev->vals), GFP_KERNEL);\n    if (!dev->vals) {\n        error = -ENOMEM;\n        goto err_devres_free;\n    }\n    /*\n     * If delay and period are pre-set by the driver, then autorepeating\n     * is handled by the driver itself and we don't do it in input.c.\n     */\n    if (!dev->rep[REP_DELAY] && !dev->rep[REP_PERIOD]) {\n        dev->timer.data = (long) dev;\n        dev->timer.function = input_repeat_key;\n        dev->rep[REP_DELAY] = 250;\n        dev->rep[REP_PERIOD] = 33;\n    }\n    if (!dev->getkeycode)\n        dev->getkeycode = input_default_getkeycode;\n    if (!dev->setkeycode)\n        dev->setkeycode = input_default_setkeycode;\n    error = device_add(&dev->dev);\n    if (error)\n        goto err_free_vals;\n    path = kobject_get_path(&dev->dev.kobj, GFP_KERNEL);\n    pr_info(\"%s as %s\\n\",\n        dev->name ? dev->name : \"Unspecified device\",\n        path ? path : \"N/A\");\n    kfree(path);\n    error = mutex_lock_interruptible(&input_mutex);\n    if (error)\n        goto err_device_del;\n    /* 重要:把设备挂到全局的input子系统设备链表input_dev_list上 */\n    list_add_tail(&dev->node, &input_dev_list);\n    /* 核心重点，input设备在增加到input_dev_list链表上之后，会查找\n     * input_handler_list事件处理链表上的handler进行匹配，这里的匹配\n     * 方式与设备模型的device和driver匹配过程很相似*/\n    list_for_each_entry(handler, &input_handler_list, node)\n        input_attach_handler(dev, handler);/*遍历input_handler_list，通过input_match_device试图与每一个handler进行匹配 匹配上了就使用connect连接*/\n    /*\n    static int input_attach_handler(struct input_dev *dev, struct input_handler *handler)\n    {\n        const struct input_device_id *id;\n        int error;\n\n<pre><code>    id = input_match_device(handler, dev);\n    if (!id)\n        return -ENODEV;\n    error = handler-&gt;connect(handler, dev, id);\n    if (error &amp;&amp; error != -ENODEV)\n        pr_err(&quot;failed to attach handler %s to device %s, error: %d\\n&quot;,\n               handler-&gt;name, kobject_name(&amp;dev-&gt;dev.kobj), error);\n    return error;\n}\n*/\ninput_wakeup_procfs_readers();\nmutex_unlock(&amp;input_mutex);\nif (dev-&gt;devres_managed) {\n    dev_dbg(dev-&gt;dev.parent, &quot;%s: registering %s with devres.\\n&quot;,\n        __func__, dev_name(&amp;dev-&gt;dev));\n    devres_add(dev-&gt;dev.parent, devres);\n}\nreturn 0;</code></pre><p>err_device_del:<br>    device_del(&amp;dev-&gt;dev);<br>err_free_vals:<br>    kfree(dev-&gt;vals);<br>    dev-&gt;vals = NULL;<br>err_devres_free:<br>    devres_free(devres);<br>    return error;<br>}<br>EXPORT_SYMBOL(input_register_device);<br>  </p></code><br></pre> <p></p>\n<h2>3.2注册handler</h2>\n<p>一般handler不需要我们自己写 内核里面已经有了很多的hanlder基本够用</p>\n下面以Evdev为例，来分析事件处理层。<br>\nvim drivers/input/evdev.c</div>\n<div>\n<pre>\n    <code class=\"yaml\">\nstatic const struct input_device_id evdev_ids[] = {\n    { .driver_info = 1 },    /* Matches all devices */\n    { },            /* Terminating zero entry */\n};\nMODULE_DEVICE_TABLE(input, evdev_ids);\nstatic struct input_handler evdev_handler = {\n    .event        = evdev_event,\n    .events        = evdev_events,\n    .connect    = evdev_connect,\n    .disconnect    = evdev_disconnect,\n    .legacy_minors    = true,\n    .minor        = EVDEV_MINOR_BASE,\n    .name        = \"evdev\",\n    .id_table    = evdev_ids,\n};\nstatic int __init evdev_init(void)\n{\n    return input_register_handler(&evdev_handler);\n}\nstatic void __exit evdev_exit(void)\n{\n    input_unregister_handler(&evdev_handler);\n}\nmodule_init(evdev_init);\nmodule_exit(evdev_exit);\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>\");\nMODULE_DESCRIPTION(\"Input driver event char devices\");\nMODULE_LICENSE(\"GPL\");  \n  </vojtech@ucw.cz></code>\n</pre>  \n<p>注册的handler可以在proc/bus/input/danlder中查看到</p>\n</div>\n<p><img src=\"/2022/01/linux-input-zi-xi-tong/2909691-20220819102740731-2036281828.png\" alt></p><pre>\n    <code class=\"yaml\">\n/**\n* input_register_handler - register a new input handler\n* @handler: handler to be registered\n*\n* This function registers a new input handler (interface) for input\n* devices in the system and attaches it to all input devices that\n* are compatible with the handler.\n*/\nint input_register_handler(struct input_handler *handler)\n{\n     struct input_dev *dev;\n     int error;\n     error = mutex_lock_interruptible(&input_mutex);\n     if (error)\n         return error;\n\n<pre><code> INIT_LIST_HEAD(&amp;handler-&gt;h_list);</code></pre><p> 　　/* <code>重要</code>:把设备处理器挂到全局的input子系统设备链表input_handler_list上 <em>/<br>     list_add_tail(&amp;handler-&gt;node, &amp;input_handler_list);<br> 　　/*遍历input_dev_list，试图与每一个input_dev进行匹配</em>/<br>     list_for_each_entry(dev, &amp;input_dev_list, node)<br>         input_attach_handler(dev, handler);　　　　/*static int input_attach_handler(struct input_dev *dev, struct input_handler *handler)<br>{<br>    const struct input_device_id *id;<br>    int error;<br>    ……..<br>    ……..<br>    input_wakeup_procfs_readers();<br>    mutex_unlock(&amp;input_mutex);<br>    return 0;<br>}<br>EXPORT_SYMBOL(input_register_handler);<br>  </p></code><br></pre>  <p></p>\n<p>这个过程和注册dev及其相似</p>\n<h2>3.3 handler的connect函数</h2><pre>\n    <code class=\"yaml\">\nstatic int evdev_connect(struct input_handler *handler, struct input_dev *dev,\n             const struct input_device_id *id)\n{\n    struct evdev *evdev;\n    int minor;\n    int dev_no;\n    int error;\n    /*申请一个新的次设备号*/\n    minor = input_get_new_minor(EVDEV_MINOR_BASE, EVDEV_MINORS, true);\n    /* 这说明内核已经没办法再分配这种类型的设备了 */\n    if (minor < 0) {\n        error = minor;\n        pr_err(\"failed to reserve new minor: %d\\n\", error);\n        return error;\n    }\n    /* 开始给evdev事件层驱动分配空间了 */\n    evdev = kzalloc(sizeof(struct evdev), GFP_KERNEL);\n    if (!evdev) {\n        error = -ENOMEM;\n        goto err_free_minor;\n    }\n        /* 初始化client_list列表和evdev_wait队列 */\n    INIT_LIST_HEAD(&evdev->client_list);\n    spin_lock_init(&evdev->client_lock);\n    mutex_init(&evdev->mutex);\n    init_waitqueue_head(&evdev->wait);\n    evdev->exist = true;\n    dev_no = minor;\n    /* Normalize device number if it falls into legacy range */\n    if (dev_no < EVDEV_MINOR_BASE + EVDEV_MINORS)\n        dev_no -= EVDEV_MINOR_BASE;\n    /*设置设备节点名称，/dev/eventX 就是在此时设置*/\n    dev_set_name(&evdev->dev, \"event%d\", dev_no);\n    /* 初始化evdev结构体，其中handle为输入设备和事件处理的关联接口 */\n    evdev->handle.dev = input_get_device(dev);\n    evdev->handle.name = dev_name(&evdev->dev);\n    evdev->handle.handler = handler;\n    evdev->handle.private = evdev;\n      /*设置设备号，应用层就是通过设备号，找到该设备的*/\n    evdev->dev.devt = MKDEV(INPUT_MAJOR, minor);\n    evdev->dev.class = &input_class;\n    evdev->dev.parent = &dev->dev;\n    evdev->dev.release = evdev_free;\n    device_initialize(&evdev->dev);\n     /* input_dev设备驱动和handler事件处理层的关联，就在这时由handle完成 */\n    error = input_register_handle(&evdev->handle);\n    if (error)\n        goto err_free_evdev;\n    cdev_init(&evdev->cdev, &evdev_fops);\n    evdev->cdev.kobj.parent = &evdev->dev.kobj;\n    error = cdev_add(&evdev->cdev, evdev->dev.devt, 1);\n    if (error)\n        goto err_unregister_handle;\n    /*将设备加入到Linux设备模型，它的内部将找到它的bus，然后让它的bus\n    给它找到它的driver，在驱动或者总线的probe函数中，一般会在/dev/目录\n    先创建相应的设备节点，这样应用程序就可以通过该设备节点来使用设备了\n    ，/dev/eventX 设备节点就是在此时生成\n    */\n    error = device_add(&evdev->dev);\n    if (error)\n        goto err_cleanup_evdev;\n    return 0;\n err_cleanup_evdev:\n    evdev_cleanup(evdev);\n err_unregister_handle:\n    input_unregister_handle(&evdev->handle);\n err_free_evdev:\n    put_device(&evdev->dev);\n err_free_minor:\n    input_free_minor(minor);\n    return error;\n}\n  </code>\n</pre>   \n<p>over</p>\n<h1>4.应用层的角度分析到底层</h1>\n<p><img src=\"/2022/01/linux-input-zi-xi-tong/input_logical.png\" alt></p>\n<p>显然，就是input_dev通过输入核心为驱动层提供统一的接口，<code>input_event</code>，来向事件处理层上报数据并唤醒。</p>\n</div>\n</div>\n</div>"},{"title":"python使用百度翻译的API","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2022-01-01T12:12:26.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"  API 在python中就相当于一串代码，我们直接调用结果就够了，今天我们使用百度API打造自己的翻译小可爱。\n  百度搜索：百度apistore\n  ![](python使用百度翻译的API/20200302112753932.png)\n  进入后点击翻译\n  ![](python使用百度翻译的API/20200302112847600.png)\n  接下来各位就可以探索了，注册的艰巨任务就交给你们了。\n  注册后出现以下数据就ok了![](python使用百度翻译的API/20200302113313981.png)\n  我们参考百度api的文档与支持里面的开发者文档的通用翻译API里面有使用的方法，如图![](python使用百度翻译的API/20200302113654396.png)\n  大概的看下说明文档一下代码就可以很好的理解了 ，接下来直接代码分析\n  \n\n<pre>\n\t<code class=\"yaml\">\nimport random\nimport hashlib\nimport urllib\nimport requests\nimport json                                               #安装相应的库\n\n\nsrc = 'zh'                                                #翻译的源语言\nobj = 'en'                                                #翻译的目标语言\nappid = 'xxxxxxxxxxx'                                     #这里输入你注册后得到的appid\nsecretKey = 'xxxxxxxxxx'                                  #这里输入你注册后得到的密匙       \n\nmyurl = 'http://api.fanyi.baidu.com/api/trans/vip/translate'                  #必须加上的头\nword= input('请输入你要翻译的中文：')                                         #输入你要翻译的中文\nsalt = random.randint(31256, 66253)                                           #产生随计数\n\nsign = appid + word + str(salt) + secretKey                                   #文档的step1拼接字符串\nm1 = hashlib.md5()\nm1.update(sign.encode('utf-8'))\nsign = m1.hexdigest()                                                         #文档的step2计算签名\nmyur1 = myurl  + '?q=' + urllib.parse.quote(\n    word) + '&from=' + src + '&to=' + obj + '&appid='+ appid + '&salt=' + str(salt) + '&sign=' + sign\nprint (myur1)                                                                 #生成的url并打印出来\nenglish_data = requests.get(myur1)                                            #请求url\njs_data = json.loads(english_data.text)                                       #下载json数据\ncontent = js_data['trans_result'][0]['dst']                                   #提取json数据里面的dst\nprint (content)                                                               #打印出翻译的英文\n</code>\n</pre>\n![](python使用百度翻译的API/20200302115943813.png)\n这是运行的结构；其中翻译的url点击进去就会跳到浏览器里面 如图：\n![](python使用百度翻译的API/20200302120105912.png)\n里面的数据其实是字典结构的我们使用json的库提取其中的dst就是我们需要的翻译结果\n\n","source":"_posts/2022/01/python使用百度翻译的API.md","raw":"---\ntitle: python使用百度翻译的API\npermalink: python使用百度翻译的API\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2022-01-01 20:12:26\npassword:\nsummary:\ntags:\n- python\ncategories:\n- python\nkeywords:\ndescription:\n---\n  API 在python中就相当于一串代码，我们直接调用结果就够了，今天我们使用百度API打造自己的翻译小可爱。\n  百度搜索：百度apistore\n  ![](python使用百度翻译的API/20200302112753932.png)\n  进入后点击翻译\n  ![](python使用百度翻译的API/20200302112847600.png)\n  接下来各位就可以探索了，注册的艰巨任务就交给你们了。\n  注册后出现以下数据就ok了![](python使用百度翻译的API/20200302113313981.png)\n  我们参考百度api的文档与支持里面的开发者文档的通用翻译API里面有使用的方法，如图![](python使用百度翻译的API/20200302113654396.png)\n  大概的看下说明文档一下代码就可以很好的理解了 ，接下来直接代码分析\n  \n\n<pre>\n\t<code class=\"yaml\">\nimport random\nimport hashlib\nimport urllib\nimport requests\nimport json                                               #安装相应的库\n\n\nsrc = 'zh'                                                #翻译的源语言\nobj = 'en'                                                #翻译的目标语言\nappid = 'xxxxxxxxxxx'                                     #这里输入你注册后得到的appid\nsecretKey = 'xxxxxxxxxx'                                  #这里输入你注册后得到的密匙       \n\nmyurl = 'http://api.fanyi.baidu.com/api/trans/vip/translate'                  #必须加上的头\nword= input('请输入你要翻译的中文：')                                         #输入你要翻译的中文\nsalt = random.randint(31256, 66253)                                           #产生随计数\n\nsign = appid + word + str(salt) + secretKey                                   #文档的step1拼接字符串\nm1 = hashlib.md5()\nm1.update(sign.encode('utf-8'))\nsign = m1.hexdigest()                                                         #文档的step2计算签名\nmyur1 = myurl  + '?q=' + urllib.parse.quote(\n    word) + '&from=' + src + '&to=' + obj + '&appid='+ appid + '&salt=' + str(salt) + '&sign=' + sign\nprint (myur1)                                                                 #生成的url并打印出来\nenglish_data = requests.get(myur1)                                            #请求url\njs_data = json.loads(english_data.text)                                       #下载json数据\ncontent = js_data['trans_result'][0]['dst']                                   #提取json数据里面的dst\nprint (content)                                                               #打印出翻译的英文\n</code>\n</pre>\n![](python使用百度翻译的API/20200302115943813.png)\n这是运行的结构；其中翻译的url点击进去就会跳到浏览器里面 如图：\n![](python使用百度翻译的API/20200302120105912.png)\n里面的数据其实是字典结构的我们使用json的库提取其中的dst就是我们需要的翻译结果\n\n","slug":"python使用百度翻译的API","published":1,"updated":"2024-01-05T08:12:19.086Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clru1g204000bs4futt6zjx5x","content":"<p>  API 在python中就相当于一串代码，我们直接调用结果就够了，今天我们使用百度API打造自己的翻译小可爱。<br>  百度搜索：百度apistore<br>  <img src=\"/2022/01/python-shi-yong-bai-du-fan-yi-de-api/20200302112753932.png\" alt><br>  进入后点击翻译<br>  <img src=\"/2022/01/python-shi-yong-bai-du-fan-yi-de-api/20200302112847600.png\" alt><br>  接下来各位就可以探索了，注册的艰巨任务就交给你们了。<br>  注册后出现以下数据就ok了<img src=\"/2022/01/python-shi-yong-bai-du-fan-yi-de-api/20200302113313981.png\" alt><br>  我们参考百度api的文档与支持里面的开发者文档的通用翻译API里面有使用的方法，如图<img src=\"/2022/01/python-shi-yong-bai-du-fan-yi-de-api/20200302113654396.png\" alt><br>  大概的看下说明文档一下代码就可以很好的理解了 ，接下来直接代码分析</p>\n<pre>\n    <code class=\"yaml\">\nimport random\nimport hashlib\nimport urllib\nimport requests\nimport json                                               #安装相应的库\n\n\nsrc = 'zh'                                                #翻译的源语言\nobj = 'en'                                                #翻译的目标语言\nappid = 'xxxxxxxxxxx'                                     #这里输入你注册后得到的appid\nsecretKey = 'xxxxxxxxxx'                                  #这里输入你注册后得到的密匙       \n\nmyurl = 'http://api.fanyi.baidu.com/api/trans/vip/translate'                  #必须加上的头\nword= input('请输入你要翻译的中文：')                                         #输入你要翻译的中文\nsalt = random.randint(31256, 66253)                                           #产生随计数\n\nsign = appid + word + str(salt) + secretKey                                   #文档的step1拼接字符串\nm1 = hashlib.md5()\nm1.update(sign.encode('utf-8'))\nsign = m1.hexdigest()                                                         #文档的step2计算签名\nmyur1 = myurl  + '?q=' + urllib.parse.quote(\n    word) + '&from=' + src + '&to=' + obj + '&appid='+ appid + '&salt=' + str(salt) + '&sign=' + sign\nprint (myur1)                                                                 #生成的url并打印出来\nenglish_data = requests.get(myur1)                                            #请求url\njs_data = json.loads(english_data.text)                                       #下载json数据\ncontent = js_data['trans_result'][0]['dst']                                   #提取json数据里面的dst\nprint (content)                                                               #打印出翻译的英文\n</code>\n</pre>\n<p><img src=\"/2022/01/python-shi-yong-bai-du-fan-yi-de-api/20200302115943813.png\" alt><br>这是运行的结构；其中翻译的url点击进去就会跳到浏览器里面 如图：<br><img src=\"/2022/01/python-shi-yong-bai-du-fan-yi-de-api/20200302120105912.png\" alt><br>里面的数据其实是字典结构的我们使用json的库提取其中的dst就是我们需要的翻译结果</p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<p>  API 在python中就相当于一串代码，我们直接调用结果就够了，今天我们使用百度API打造自己的翻译小可爱。<br>  百度搜索：百度apistore<br>  <img src=\"/2022/01/python-shi-yong-bai-du-fan-yi-de-api/20200302112753932.png\" alt><br>  进入后点击翻译<br>  <img src=\"/2022/01/python-shi-yong-bai-du-fan-yi-de-api/20200302112847600.png\" alt><br>  接下来各位就可以探索了，注册的艰巨任务就交给你们了。<br>  注册后出现以下数据就ok了<img src=\"/2022/01/python-shi-yong-bai-du-fan-yi-de-api/20200302113313981.png\" alt><br>  我们参考百度api的文档与支持里面的开发者文档的通用翻译API里面有使用的方法，如图<img src=\"/2022/01/python-shi-yong-bai-du-fan-yi-de-api/20200302113654396.png\" alt><br>  大概的看下说明文档一下代码就可以很好的理解了 ，接下来直接代码分析</p>\n<pre>\n    <code class=\"yaml\">\nimport random\nimport hashlib\nimport urllib\nimport requests\nimport json                                               #安装相应的库\n\n\nsrc = 'zh'                                                #翻译的源语言\nobj = 'en'                                                #翻译的目标语言\nappid = 'xxxxxxxxxxx'                                     #这里输入你注册后得到的appid\nsecretKey = 'xxxxxxxxxx'                                  #这里输入你注册后得到的密匙       \n\nmyurl = 'http://api.fanyi.baidu.com/api/trans/vip/translate'                  #必须加上的头\nword= input('请输入你要翻译的中文：')                                         #输入你要翻译的中文\nsalt = random.randint(31256, 66253)                                           #产生随计数\n\nsign = appid + word + str(salt) + secretKey                                   #文档的step1拼接字符串\nm1 = hashlib.md5()\nm1.update(sign.encode('utf-8'))\nsign = m1.hexdigest()                                                         #文档的step2计算签名\nmyur1 = myurl  + '?q=' + urllib.parse.quote(\n    word) + '&from=' + src + '&to=' + obj + '&appid='+ appid + '&salt=' + str(salt) + '&sign=' + sign\nprint (myur1)                                                                 #生成的url并打印出来\nenglish_data = requests.get(myur1)                                            #请求url\njs_data = json.loads(english_data.text)                                       #下载json数据\ncontent = js_data['trans_result'][0]['dst']                                   #提取json数据里面的dst\nprint (content)                                                               #打印出翻译的英文\n</code>\n</pre>\n<p><img src=\"/2022/01/python-shi-yong-bai-du-fan-yi-de-api/20200302115943813.png\" alt><br>这是运行的结构；其中翻译的url点击进去就会跳到浏览器里面 如图：<br><img src=\"/2022/01/python-shi-yong-bai-du-fan-yi-de-api/20200302120105912.png\" alt><br>里面的数据其实是字典结构的我们使用json的库提取其中的dst就是我们需要的翻译结果</p>\n"},{"title":"中华通史.上古史-夏","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2022-01-01T12:35:31.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"@[TOC](夏代)\n\n# 夏国简介\n帝舜去世,禹得到诸侯一致的拥护,继立为天子。他曾受舜封为夏伯,赐姓姒,故国号夏,建都安邑,他先后请皋陶与益佐理政事。禹的政治,一方面督励人民从事农耕;方面整伤社会秩序,法律很严。他从北而南巡视天下,曾大会诸侯于涂山。防风氏后到为禹所杀。史称执玉帛而来与会的有万国,执玉的是大国,执帛的是小国。这些诸侯也就是那个时候的氏族部落,足以说明禹声威之盛远过唐虞。他继续向东方巡视,行至中途,死在会稽山[今浙江绍兴东南],据说他的葬礼极其简单,所谓“桐棺三寸”、“衣衾三领”真是一生刻苦。禹死之后,有一段很短的时间,由益代行政事。后来诸侯,怀念禹功,都拥护禹子启而不拥护益。于是启继位为天子,从此建立了父子相传的君主制度。\n\n\n# 夏代大事\n![](20210703105815619.png)![](20210703105831609.png)![](20210703105920999.png)\n史称:“帝尧之时洪水滔天,浩浩怀山襄陵。”成为当时最严重的一个问题叠经派人治理,都没有成功,尧乃接受四岳的推荐,用鲧治水,鲧就是禹的父亲。鲧用堵塞的方法,多筑堤坝。但是洪水滔滔,随筑随溃,经过九年的功夫,没有成功,引起人民的怨愤。到了舜执政的时候,便将鲧殛死。而用鲧子禹继续治水。这洪水之灾,从尧初算起已经几十年了。舜又命益与弃协助禹。禹伤父功不成,乃焦思苦虑。不惜一切的劳苦,希望能完成先业,以雪父耻。他完全改变他父亲的方法,从疏导着手。他带着许多“准绳”、“规矩”等测量的工具,登山涉水,观察地形高下,而后施工。他又用了许多交通工具,史称“陆行乘车,水行乘船,泥行乘橇,山行乘撵。”他先从黄河的中段冀州地方开始。这也是黄河泛滥的枢纽地带[今山西、河南之间]。一步步的向东方的兖州、青州、徐州、南方的荆州、豫州疏导,最后又折向西北去整理黄河的上游。他将黄河下游的河道分辟为九股,散其水势。然后再分为漯济流入渤海。又疏通了许多其他的河道,完成了许多惊人的工程。他率领人民,和黄河作了十三年的奋斗,把这上百年的洪水之灾,完全治平。使老百姓免于饥溺流离之苦,能在黄河流域安居乐业下来。他这十三年中,为了国家和人民,奋不顾身,曾经几次经过家门而不入。顾不得饮食起居,他治水时总是亲自拿着募锸以身作则带头去作。冒着狂风暴雨,弄得身体憔悴而永不休息。和他同样辛苦的,还有协助他的益和弃。益掌火,在治水之前,纵火焚山林,以驱禽兽,弃为后稷,掌播谷。在水平之后,教人民耕种,从事善后工作。他们这样辛劳,一方面获得百姓的爱戴;一方面获得后世的崇拜,禹成为后来苦行家墨子的宗师。而禹与后稷,被孟子尊为是“历史上最富于同情心的人”。\n夏启继立后,曾大会诸侯于钧台[今河南禹县许昌之间]。有扈氏不服,启率兵与有扈战于甘[今作《甘誓》]灭有扈。夏启的政权,乃归稳定。正式称为“夏后启”,启在位九年卒,子太康立。太康逸豫失政,太康五弟,追思禹德,乃作《五子之歌》。这时有东夷地方的一个有穷氏诸侯后羿作乱,太康被逼迁于斟部[河南巩县附近]。太康传弟仲康,仲康传子相,相又一度迁都于商邱[河南商邱],夏朝实际成为后羿的政权,后来后羿又被其权臣寒浞所杀,寒浞又弑相而篡夏,夏自禹至相不到九十年,而国统几绝。相妻有缗氏怀孕在身,逃至有仍[今山东济宁],生了一个遗腹子,是为少康。少康既长,从有仍氏地方逃到虞地[河南虞城],投奔有虞氏,有虞氏君收纳了少康,给以田一成[方十里为成]、众旅[五百人为旅]。后来少康就凭藉着这一成一旅的资本,强大起来。收抚旧日夏朝的士众,灭掉寒浞,复兴夏朝,还都于安邑,史称少康中兴。这后羿、寒浞之乱前后历时百年。\n少康时曾再度发生河患,以冥为司空再度治河。由少康传子杼,杼传槐[是为夏之第八主]。槐即位,九夷来朝,九夷畎夷、于夷、方夷、黄夷、白夷、赤夷、玄夷、风夷、阳夷都是居住在东方滨海一带的落后民族。这说明在夏朝中叶的时候,夏朝的政教势力,已远达东海之滨。以前五帝到夏禹时,主要的异族战斗是苗、黎。苗、黎在西方。到夏时征服苗黎之后,继之以服九夷,说明夏人之向东发展。这个夏朝的中兴,为时约二百年,传到第十四个君主孔甲,淫乱无度,夏政再衰。诸侯纷纷叛离,中枢的权力,日益纷散,夏政乃一蹶不振。《周语》说:“孔甲乱夏,四世而陨”。夏代从孔甲乱政,以后三传到了履癸,履癸先都斟郛,后都河南禹县。这履癸就是夏桀,种种无道,荒淫奢侈。传说夏桀宠爱有施氏之女妹喜,又宠爱岷山氏二女琬、琰。又营建倾宫瑶台,作酒池肉林,杀忠臣关龙逢。太史令终古哭谏夏桀,夏桀不听,终古就亡奔于商。商人是东方的一个诸侯,世居于今安徽亳县到河南商邱一带的地方。从孔甲失德以后,商人逐渐壮大,逐渐获得诸侯的拥护。到了商汤的时候,诸侯多叛桀而归汤。有些诸侯不服从汤,汤出兵去讨伐。兵行所到之处,百姓无不欢迎。其威德远在夏桀之上。就在夏桀在位的第五十三年[公元前一七五一年],商汤俯顺舆情,率领诸侯之兵,讨伐夏桀。与夏桀大战于鸣条[旧说在山西安邑附近,近人考应在淮河之南],夏桀大败。向东南方逃走,被商汤一路追击。夏桀屡战屡败,终被商汤所俘。商汤就把夏桀流放在南巢[安徽巢县],三年而死,史称“商汤革命”。这是我国历史上第一次的贵族革命。这个夏朝,也是中国历史上第一个正式的朝代。凡历十四世,十七主,四百余年而亡。\n![](20210703111602157.png)\n# 夏代影响\n\n 1.  治水\n禹治水的范围极大,据旧《史记》载,所谓疏“三江五湖”,几乎遍于全国,除了黄河之外,又导黄河的支流济水,又导淮水,又导长江。江、淮、河、济谓之四渎,所谓“四渎修,而民宅安。”我们近人推断,在那个时候,治水范围不会如此之广。我们可相信的是大禹的治水,是以黄河中段的冀州豫州为主。而渐及东方的兖州、徐州、可能的上溯到黄河上游的雍州、梁州和荆州的一部分。其他淮水与长江北面的若干支流。也可能附带的疏导过。然而仅这一个估计的范围已经很大,已经是禹率领着千万人民,经过十几年才能完成的功业。大禹治水的目的,是谋求人民生活的安定,使人民生活安定最好的方法,是使人民在这片新整理的土地上从事农耕。所以大禹治水后,就由弃的协助展开全面的农村建设,从夏朝起中国正式成为一个农业的国家。又由于治河的结果,自然而然的了解到各地的地势物产、风俗人情,自然171中华通史·第一卷·绪论上古史而然的加强了中央与地方及人民的联系。于是他制定了一个政治的区划,这个区划是分全国为九州。这九州是雍州[约当今陕西之地]、冀州[约当今山西南部]、豫州[约当今河南]、兖州[约当今河北南部]、青州[约当今山东]、徐州约当今苏北、皖北、扬州[约当今皖南、苏南]、荆州[约当今豫南与湖北]梁州[约当今陕南]成为中国版图的基础。\n又分为全国为五服[以王畿为中心,王畿四周五百里内为甸服,五百里外为侯服,侯服外五百里为绥服,绥服外五百里为要服,要服外五百里为荒服],构成一个以王京为中心的空间观念。又根据各地的物产,制为九等贡赋。此孟子所谓“夏后氏五十而贡”。这就是禹贡九州。所以由于大禹的治水的结果,他奠定了中国的农业社会;他建立了中国的疆域概念。他是最早建立中华民族成为一个国家的大英雄。禹称夏后氏,“夏”便成为我民族对外之代名辞。按《说文》“夏”字“”作人形,注云:“中国人也”[因之,当时中国境内诸民族,称为诸夏]。故后人称禹为大禹,诚非偶然。\n\n 2. 大禹始称王,始定传子之局。\n以前五帝的共主称氏,以前虞舜的禅让,均未脱氏族的形态。到了夏禹以后传子称王,证明中央的权威提高。诸侯对于中央的关系更加服从,更加密切。中央王室的政权更加稳定,更进一步走向封建帝国。按人类上古史的演变,由最早的部落到封建的君主世袭,这是一个大的进步,这是一个国家组织的完成。我们看禹时诸侯大会涂山,诛防风氏。启时大会诸侯钓台,诛有扈氏。都是说明这个国家组织与中央政府权力的扩大。\n\n 3. 治水成功,推进农业。\n夏人建国后配合农时而制订以建寅为岁首[正月]的历法。最合乎农业的时序,周人称夏人为“得天”。这个“夏正”历法,在商、周、秦时一度改变,到汉以后又恢复采用直用到今天,就是那四序分明的阴历,我们又叫做农历。由于夏禹的治水兴农,而建立了“农历”。我们又由这“农历”,可以推想到夏朝的农业社会。因为这“夏正”,是最符合农业的一个时序。\n夏代的文化已入于铜器时代。我们现在出土的铜器,虽尚未有确切的文字足以证明是夏代的铜器。但在山西、河南带若干出土的铜器中,相信其中或有夏器,并且根据殷商铜器之精美,其铜器制造,一定为时已久,则上推两三百年在夏朝时定有铜器可无疑。禹铸九鼎之说见于《史记》、《说文》、《左传》、《墨子》诸书,自然不是虚构。并且自春秋到秦汉历代有求鼎之事,绝对不是毫无根据的狂妄举动。据说禹铸九鼎是集九牧之铜铸成,上面刻划着各地的方物所谓铸鼎象物”。看了这九鼎,就可以知道九州的产物情形,这和《禹贡》的制度正相配合。这九鼎一直成为传国重器,也就是国家的象征。\n\n> 本文内容均抄录于[中华通史.上古史]，致谢陈致平先生","source":"_posts/2022/01/中华通史-上古史-夏.md","raw":"---\ntitle: 中华通史.上古史-夏\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2022-01-01 20:35:31\npassword:\nsummary:\ntags:\n- history\ncategories:\n- history\nkeywords:\ndescription:\n---\n@[TOC](夏代)\n\n# 夏国简介\n帝舜去世,禹得到诸侯一致的拥护,继立为天子。他曾受舜封为夏伯,赐姓姒,故国号夏,建都安邑,他先后请皋陶与益佐理政事。禹的政治,一方面督励人民从事农耕;方面整伤社会秩序,法律很严。他从北而南巡视天下,曾大会诸侯于涂山。防风氏后到为禹所杀。史称执玉帛而来与会的有万国,执玉的是大国,执帛的是小国。这些诸侯也就是那个时候的氏族部落,足以说明禹声威之盛远过唐虞。他继续向东方巡视,行至中途,死在会稽山[今浙江绍兴东南],据说他的葬礼极其简单,所谓“桐棺三寸”、“衣衾三领”真是一生刻苦。禹死之后,有一段很短的时间,由益代行政事。后来诸侯,怀念禹功,都拥护禹子启而不拥护益。于是启继位为天子,从此建立了父子相传的君主制度。\n\n\n# 夏代大事\n![](20210703105815619.png)![](20210703105831609.png)![](20210703105920999.png)\n史称:“帝尧之时洪水滔天,浩浩怀山襄陵。”成为当时最严重的一个问题叠经派人治理,都没有成功,尧乃接受四岳的推荐,用鲧治水,鲧就是禹的父亲。鲧用堵塞的方法,多筑堤坝。但是洪水滔滔,随筑随溃,经过九年的功夫,没有成功,引起人民的怨愤。到了舜执政的时候,便将鲧殛死。而用鲧子禹继续治水。这洪水之灾,从尧初算起已经几十年了。舜又命益与弃协助禹。禹伤父功不成,乃焦思苦虑。不惜一切的劳苦,希望能完成先业,以雪父耻。他完全改变他父亲的方法,从疏导着手。他带着许多“准绳”、“规矩”等测量的工具,登山涉水,观察地形高下,而后施工。他又用了许多交通工具,史称“陆行乘车,水行乘船,泥行乘橇,山行乘撵。”他先从黄河的中段冀州地方开始。这也是黄河泛滥的枢纽地带[今山西、河南之间]。一步步的向东方的兖州、青州、徐州、南方的荆州、豫州疏导,最后又折向西北去整理黄河的上游。他将黄河下游的河道分辟为九股,散其水势。然后再分为漯济流入渤海。又疏通了许多其他的河道,完成了许多惊人的工程。他率领人民,和黄河作了十三年的奋斗,把这上百年的洪水之灾,完全治平。使老百姓免于饥溺流离之苦,能在黄河流域安居乐业下来。他这十三年中,为了国家和人民,奋不顾身,曾经几次经过家门而不入。顾不得饮食起居,他治水时总是亲自拿着募锸以身作则带头去作。冒着狂风暴雨,弄得身体憔悴而永不休息。和他同样辛苦的,还有协助他的益和弃。益掌火,在治水之前,纵火焚山林,以驱禽兽,弃为后稷,掌播谷。在水平之后,教人民耕种,从事善后工作。他们这样辛劳,一方面获得百姓的爱戴;一方面获得后世的崇拜,禹成为后来苦行家墨子的宗师。而禹与后稷,被孟子尊为是“历史上最富于同情心的人”。\n夏启继立后,曾大会诸侯于钧台[今河南禹县许昌之间]。有扈氏不服,启率兵与有扈战于甘[今作《甘誓》]灭有扈。夏启的政权,乃归稳定。正式称为“夏后启”,启在位九年卒,子太康立。太康逸豫失政,太康五弟,追思禹德,乃作《五子之歌》。这时有东夷地方的一个有穷氏诸侯后羿作乱,太康被逼迁于斟部[河南巩县附近]。太康传弟仲康,仲康传子相,相又一度迁都于商邱[河南商邱],夏朝实际成为后羿的政权,后来后羿又被其权臣寒浞所杀,寒浞又弑相而篡夏,夏自禹至相不到九十年,而国统几绝。相妻有缗氏怀孕在身,逃至有仍[今山东济宁],生了一个遗腹子,是为少康。少康既长,从有仍氏地方逃到虞地[河南虞城],投奔有虞氏,有虞氏君收纳了少康,给以田一成[方十里为成]、众旅[五百人为旅]。后来少康就凭藉着这一成一旅的资本,强大起来。收抚旧日夏朝的士众,灭掉寒浞,复兴夏朝,还都于安邑,史称少康中兴。这后羿、寒浞之乱前后历时百年。\n少康时曾再度发生河患,以冥为司空再度治河。由少康传子杼,杼传槐[是为夏之第八主]。槐即位,九夷来朝,九夷畎夷、于夷、方夷、黄夷、白夷、赤夷、玄夷、风夷、阳夷都是居住在东方滨海一带的落后民族。这说明在夏朝中叶的时候,夏朝的政教势力,已远达东海之滨。以前五帝到夏禹时,主要的异族战斗是苗、黎。苗、黎在西方。到夏时征服苗黎之后,继之以服九夷,说明夏人之向东发展。这个夏朝的中兴,为时约二百年,传到第十四个君主孔甲,淫乱无度,夏政再衰。诸侯纷纷叛离,中枢的权力,日益纷散,夏政乃一蹶不振。《周语》说:“孔甲乱夏,四世而陨”。夏代从孔甲乱政,以后三传到了履癸,履癸先都斟郛,后都河南禹县。这履癸就是夏桀,种种无道,荒淫奢侈。传说夏桀宠爱有施氏之女妹喜,又宠爱岷山氏二女琬、琰。又营建倾宫瑶台,作酒池肉林,杀忠臣关龙逢。太史令终古哭谏夏桀,夏桀不听,终古就亡奔于商。商人是东方的一个诸侯,世居于今安徽亳县到河南商邱一带的地方。从孔甲失德以后,商人逐渐壮大,逐渐获得诸侯的拥护。到了商汤的时候,诸侯多叛桀而归汤。有些诸侯不服从汤,汤出兵去讨伐。兵行所到之处,百姓无不欢迎。其威德远在夏桀之上。就在夏桀在位的第五十三年[公元前一七五一年],商汤俯顺舆情,率领诸侯之兵,讨伐夏桀。与夏桀大战于鸣条[旧说在山西安邑附近,近人考应在淮河之南],夏桀大败。向东南方逃走,被商汤一路追击。夏桀屡战屡败,终被商汤所俘。商汤就把夏桀流放在南巢[安徽巢县],三年而死,史称“商汤革命”。这是我国历史上第一次的贵族革命。这个夏朝,也是中国历史上第一个正式的朝代。凡历十四世,十七主,四百余年而亡。\n![](20210703111602157.png)\n# 夏代影响\n\n 1.  治水\n禹治水的范围极大,据旧《史记》载,所谓疏“三江五湖”,几乎遍于全国,除了黄河之外,又导黄河的支流济水,又导淮水,又导长江。江、淮、河、济谓之四渎,所谓“四渎修,而民宅安。”我们近人推断,在那个时候,治水范围不会如此之广。我们可相信的是大禹的治水,是以黄河中段的冀州豫州为主。而渐及东方的兖州、徐州、可能的上溯到黄河上游的雍州、梁州和荆州的一部分。其他淮水与长江北面的若干支流。也可能附带的疏导过。然而仅这一个估计的范围已经很大,已经是禹率领着千万人民,经过十几年才能完成的功业。大禹治水的目的,是谋求人民生活的安定,使人民生活安定最好的方法,是使人民在这片新整理的土地上从事农耕。所以大禹治水后,就由弃的协助展开全面的农村建设,从夏朝起中国正式成为一个农业的国家。又由于治河的结果,自然而然的了解到各地的地势物产、风俗人情,自然171中华通史·第一卷·绪论上古史而然的加强了中央与地方及人民的联系。于是他制定了一个政治的区划,这个区划是分全国为九州。这九州是雍州[约当今陕西之地]、冀州[约当今山西南部]、豫州[约当今河南]、兖州[约当今河北南部]、青州[约当今山东]、徐州约当今苏北、皖北、扬州[约当今皖南、苏南]、荆州[约当今豫南与湖北]梁州[约当今陕南]成为中国版图的基础。\n又分为全国为五服[以王畿为中心,王畿四周五百里内为甸服,五百里外为侯服,侯服外五百里为绥服,绥服外五百里为要服,要服外五百里为荒服],构成一个以王京为中心的空间观念。又根据各地的物产,制为九等贡赋。此孟子所谓“夏后氏五十而贡”。这就是禹贡九州。所以由于大禹的治水的结果,他奠定了中国的农业社会;他建立了中国的疆域概念。他是最早建立中华民族成为一个国家的大英雄。禹称夏后氏,“夏”便成为我民族对外之代名辞。按《说文》“夏”字“”作人形,注云:“中国人也”[因之,当时中国境内诸民族,称为诸夏]。故后人称禹为大禹,诚非偶然。\n\n 2. 大禹始称王,始定传子之局。\n以前五帝的共主称氏,以前虞舜的禅让,均未脱氏族的形态。到了夏禹以后传子称王,证明中央的权威提高。诸侯对于中央的关系更加服从,更加密切。中央王室的政权更加稳定,更进一步走向封建帝国。按人类上古史的演变,由最早的部落到封建的君主世袭,这是一个大的进步,这是一个国家组织的完成。我们看禹时诸侯大会涂山,诛防风氏。启时大会诸侯钓台,诛有扈氏。都是说明这个国家组织与中央政府权力的扩大。\n\n 3. 治水成功,推进农业。\n夏人建国后配合农时而制订以建寅为岁首[正月]的历法。最合乎农业的时序,周人称夏人为“得天”。这个“夏正”历法,在商、周、秦时一度改变,到汉以后又恢复采用直用到今天,就是那四序分明的阴历,我们又叫做农历。由于夏禹的治水兴农,而建立了“农历”。我们又由这“农历”,可以推想到夏朝的农业社会。因为这“夏正”,是最符合农业的一个时序。\n夏代的文化已入于铜器时代。我们现在出土的铜器,虽尚未有确切的文字足以证明是夏代的铜器。但在山西、河南带若干出土的铜器中,相信其中或有夏器,并且根据殷商铜器之精美,其铜器制造,一定为时已久,则上推两三百年在夏朝时定有铜器可无疑。禹铸九鼎之说见于《史记》、《说文》、《左传》、《墨子》诸书,自然不是虚构。并且自春秋到秦汉历代有求鼎之事,绝对不是毫无根据的狂妄举动。据说禹铸九鼎是集九牧之铜铸成,上面刻划着各地的方物所谓铸鼎象物”。看了这九鼎,就可以知道九州的产物情形,这和《禹贡》的制度正相配合。这九鼎一直成为传国重器,也就是国家的象征。\n\n> 本文内容均抄录于[中华通史.上古史]，致谢陈致平先生","slug":"中华通史-上古史-夏","published":1,"updated":"2024-01-05T08:12:19.094Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clru1g205000cs4fuq737vg42","content":"<p>@<a href=\"夏代\">TOC</a></p>\n<h1 id=\"夏国简介\"><a href=\"#夏国简介\" class=\"headerlink\" title=\"夏国简介\"></a>夏国简介</h1><p>帝舜去世,禹得到诸侯一致的拥护,继立为天子。他曾受舜封为夏伯,赐姓姒,故国号夏,建都安邑,他先后请皋陶与益佐理政事。禹的政治,一方面督励人民从事农耕;方面整伤社会秩序,法律很严。他从北而南巡视天下,曾大会诸侯于涂山。防风氏后到为禹所杀。史称执玉帛而来与会的有万国,执玉的是大国,执帛的是小国。这些诸侯也就是那个时候的氏族部落,足以说明禹声威之盛远过唐虞。他继续向东方巡视,行至中途,死在会稽山[今浙江绍兴东南],据说他的葬礼极其简单,所谓“桐棺三寸”、“衣衾三领”真是一生刻苦。禹死之后,有一段很短的时间,由益代行政事。后来诸侯,怀念禹功,都拥护禹子启而不拥护益。于是启继位为天子,从此建立了父子相传的君主制度。</p>\n<h1 id=\"夏代大事\"><a href=\"#夏代大事\" class=\"headerlink\" title=\"夏代大事\"></a>夏代大事</h1><p><img src=\"/2022/01/zhong-hua-tong-shi-shang-gu-shi-xia/20210703105815619.png\" alt><img src=\"/2022/01/zhong-hua-tong-shi-shang-gu-shi-xia/20210703105831609.png\" alt><img src=\"/2022/01/zhong-hua-tong-shi-shang-gu-shi-xia/20210703105920999.png\" alt><br>史称:“帝尧之时洪水滔天,浩浩怀山襄陵。”成为当时最严重的一个问题叠经派人治理,都没有成功,尧乃接受四岳的推荐,用鲧治水,鲧就是禹的父亲。鲧用堵塞的方法,多筑堤坝。但是洪水滔滔,随筑随溃,经过九年的功夫,没有成功,引起人民的怨愤。到了舜执政的时候,便将鲧殛死。而用鲧子禹继续治水。这洪水之灾,从尧初算起已经几十年了。舜又命益与弃协助禹。禹伤父功不成,乃焦思苦虑。不惜一切的劳苦,希望能完成先业,以雪父耻。他完全改变他父亲的方法,从疏导着手。他带着许多“准绳”、“规矩”等测量的工具,登山涉水,观察地形高下,而后施工。他又用了许多交通工具,史称“陆行乘车,水行乘船,泥行乘橇,山行乘撵。”他先从黄河的中段冀州地方开始。这也是黄河泛滥的枢纽地带[今山西、河南之间]。一步步的向东方的兖州、青州、徐州、南方的荆州、豫州疏导,最后又折向西北去整理黄河的上游。他将黄河下游的河道分辟为九股,散其水势。然后再分为漯济流入渤海。又疏通了许多其他的河道,完成了许多惊人的工程。他率领人民,和黄河作了十三年的奋斗,把这上百年的洪水之灾,完全治平。使老百姓免于饥溺流离之苦,能在黄河流域安居乐业下来。他这十三年中,为了国家和人民,奋不顾身,曾经几次经过家门而不入。顾不得饮食起居,他治水时总是亲自拿着募锸以身作则带头去作。冒着狂风暴雨,弄得身体憔悴而永不休息。和他同样辛苦的,还有协助他的益和弃。益掌火,在治水之前,纵火焚山林,以驱禽兽,弃为后稷,掌播谷。在水平之后,教人民耕种,从事善后工作。他们这样辛劳,一方面获得百姓的爱戴;一方面获得后世的崇拜,禹成为后来苦行家墨子的宗师。而禹与后稷,被孟子尊为是“历史上最富于同情心的人”。<br>夏启继立后,曾大会诸侯于钧台[今河南禹县许昌之间]。有扈氏不服,启率兵与有扈战于甘[今作《甘誓》]灭有扈。夏启的政权,乃归稳定。正式称为“夏后启”,启在位九年卒,子太康立。太康逸豫失政,太康五弟,追思禹德,乃作《五子之歌》。这时有东夷地方的一个有穷氏诸侯后羿作乱,太康被逼迁于斟部[河南巩县附近]。太康传弟仲康,仲康传子相,相又一度迁都于商邱[河南商邱],夏朝实际成为后羿的政权,后来后羿又被其权臣寒浞所杀,寒浞又弑相而篡夏,夏自禹至相不到九十年,而国统几绝。相妻有缗氏怀孕在身,逃至有仍[今山东济宁],生了一个遗腹子,是为少康。少康既长,从有仍氏地方逃到虞地[河南虞城],投奔有虞氏,有虞氏君收纳了少康,给以田一成[方十里为成]、众旅[五百人为旅]。后来少康就凭藉着这一成一旅的资本,强大起来。收抚旧日夏朝的士众,灭掉寒浞,复兴夏朝,还都于安邑,史称少康中兴。这后羿、寒浞之乱前后历时百年。<br>少康时曾再度发生河患,以冥为司空再度治河。由少康传子杼,杼传槐[是为夏之第八主]。槐即位,九夷来朝,九夷畎夷、于夷、方夷、黄夷、白夷、赤夷、玄夷、风夷、阳夷都是居住在东方滨海一带的落后民族。这说明在夏朝中叶的时候,夏朝的政教势力,已远达东海之滨。以前五帝到夏禹时,主要的异族战斗是苗、黎。苗、黎在西方。到夏时征服苗黎之后,继之以服九夷,说明夏人之向东发展。这个夏朝的中兴,为时约二百年,传到第十四个君主孔甲,淫乱无度,夏政再衰。诸侯纷纷叛离,中枢的权力,日益纷散,夏政乃一蹶不振。《周语》说:“孔甲乱夏,四世而陨”。夏代从孔甲乱政,以后三传到了履癸,履癸先都斟郛,后都河南禹县。这履癸就是夏桀,种种无道,荒淫奢侈。传说夏桀宠爱有施氏之女妹喜,又宠爱岷山氏二女琬、琰。又营建倾宫瑶台,作酒池肉林,杀忠臣关龙逢。太史令终古哭谏夏桀,夏桀不听,终古就亡奔于商。商人是东方的一个诸侯,世居于今安徽亳县到河南商邱一带的地方。从孔甲失德以后,商人逐渐壮大,逐渐获得诸侯的拥护。到了商汤的时候,诸侯多叛桀而归汤。有些诸侯不服从汤,汤出兵去讨伐。兵行所到之处,百姓无不欢迎。其威德远在夏桀之上。就在夏桀在位的第五十三年[公元前一七五一年],商汤俯顺舆情,率领诸侯之兵,讨伐夏桀。与夏桀大战于鸣条[旧说在山西安邑附近,近人考应在淮河之南],夏桀大败。向东南方逃走,被商汤一路追击。夏桀屡战屡败,终被商汤所俘。商汤就把夏桀流放在南巢[安徽巢县],三年而死,史称“商汤革命”。这是我国历史上第一次的贵族革命。这个夏朝,也是中国历史上第一个正式的朝代。凡历十四世,十七主,四百余年而亡。<br><img src=\"/2022/01/zhong-hua-tong-shi-shang-gu-shi-xia/20210703111602157.png\" alt></p>\n<h1 id=\"夏代影响\"><a href=\"#夏代影响\" class=\"headerlink\" title=\"夏代影响\"></a>夏代影响</h1><ol>\n<li><p>治水<br>禹治水的范围极大,据旧《史记》载,所谓疏“三江五湖”,几乎遍于全国,除了黄河之外,又导黄河的支流济水,又导淮水,又导长江。江、淮、河、济谓之四渎,所谓“四渎修,而民宅安。”我们近人推断,在那个时候,治水范围不会如此之广。我们可相信的是大禹的治水,是以黄河中段的冀州豫州为主。而渐及东方的兖州、徐州、可能的上溯到黄河上游的雍州、梁州和荆州的一部分。其他淮水与长江北面的若干支流。也可能附带的疏导过。然而仅这一个估计的范围已经很大,已经是禹率领着千万人民,经过十几年才能完成的功业。大禹治水的目的,是谋求人民生活的安定,使人民生活安定最好的方法,是使人民在这片新整理的土地上从事农耕。所以大禹治水后,就由弃的协助展开全面的农村建设,从夏朝起中国正式成为一个农业的国家。又由于治河的结果,自然而然的了解到各地的地势物产、风俗人情,自然171中华通史·第一卷·绪论上古史而然的加强了中央与地方及人民的联系。于是他制定了一个政治的区划,这个区划是分全国为九州。这九州是雍州[约当今陕西之地]、冀州[约当今山西南部]、豫州[约当今河南]、兖州[约当今河北南部]、青州[约当今山东]、徐州约当今苏北、皖北、扬州[约当今皖南、苏南]、荆州[约当今豫南与湖北]梁州[约当今陕南]成为中国版图的基础。<br>又分为全国为五服[以王畿为中心,王畿四周五百里内为甸服,五百里外为侯服,侯服外五百里为绥服,绥服外五百里为要服,要服外五百里为荒服],构成一个以王京为中心的空间观念。又根据各地的物产,制为九等贡赋。此孟子所谓“夏后氏五十而贡”。这就是禹贡九州。所以由于大禹的治水的结果,他奠定了中国的农业社会;他建立了中国的疆域概念。他是最早建立中华民族成为一个国家的大英雄。禹称夏后氏,“夏”便成为我民族对外之代名辞。按《说文》“夏”字“”作人形,注云:“中国人也”[因之,当时中国境内诸民族,称为诸夏]。故后人称禹为大禹,诚非偶然。</p>\n</li>\n<li><p>大禹始称王,始定传子之局。<br>以前五帝的共主称氏,以前虞舜的禅让,均未脱氏族的形态。到了夏禹以后传子称王,证明中央的权威提高。诸侯对于中央的关系更加服从,更加密切。中央王室的政权更加稳定,更进一步走向封建帝国。按人类上古史的演变,由最早的部落到封建的君主世袭,这是一个大的进步,这是一个国家组织的完成。我们看禹时诸侯大会涂山,诛防风氏。启时大会诸侯钓台,诛有扈氏。都是说明这个国家组织与中央政府权力的扩大。</p>\n</li>\n<li><p>治水成功,推进农业。<br>夏人建国后配合农时而制订以建寅为岁首[正月]的历法。最合乎农业的时序,周人称夏人为“得天”。这个“夏正”历法,在商、周、秦时一度改变,到汉以后又恢复采用直用到今天,就是那四序分明的阴历,我们又叫做农历。由于夏禹的治水兴农,而建立了“农历”。我们又由这“农历”,可以推想到夏朝的农业社会。因为这“夏正”,是最符合农业的一个时序。<br>夏代的文化已入于铜器时代。我们现在出土的铜器,虽尚未有确切的文字足以证明是夏代的铜器。但在山西、河南带若干出土的铜器中,相信其中或有夏器,并且根据殷商铜器之精美,其铜器制造,一定为时已久,则上推两三百年在夏朝时定有铜器可无疑。禹铸九鼎之说见于《史记》、《说文》、《左传》、《墨子》诸书,自然不是虚构。并且自春秋到秦汉历代有求鼎之事,绝对不是毫无根据的狂妄举动。据说禹铸九鼎是集九牧之铜铸成,上面刻划着各地的方物所谓铸鼎象物”。看了这九鼎,就可以知道九州的产物情形,这和《禹贡》的制度正相配合。这九鼎一直成为传国重器,也就是国家的象征。</p>\n</li>\n</ol>\n<blockquote>\n<p>本文内容均抄录于[中华通史.上古史]，致谢陈致平先生</p>\n</blockquote>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<p>@<a href=\"夏代\">TOC</a></p>\n<h1 id=\"夏国简介\"><a href=\"#夏国简介\" class=\"headerlink\" title=\"夏国简介\"></a>夏国简介</h1><p>帝舜去世,禹得到诸侯一致的拥护,继立为天子。他曾受舜封为夏伯,赐姓姒,故国号夏,建都安邑,他先后请皋陶与益佐理政事。禹的政治,一方面督励人民从事农耕;方面整伤社会秩序,法律很严。他从北而南巡视天下,曾大会诸侯于涂山。防风氏后到为禹所杀。史称执玉帛而来与会的有万国,执玉的是大国,执帛的是小国。这些诸侯也就是那个时候的氏族部落,足以说明禹声威之盛远过唐虞。他继续向东方巡视,行至中途,死在会稽山[今浙江绍兴东南],据说他的葬礼极其简单,所谓“桐棺三寸”、“衣衾三领”真是一生刻苦。禹死之后,有一段很短的时间,由益代行政事。后来诸侯,怀念禹功,都拥护禹子启而不拥护益。于是启继位为天子,从此建立了父子相传的君主制度。</p>\n<h1 id=\"夏代大事\"><a href=\"#夏代大事\" class=\"headerlink\" title=\"夏代大事\"></a>夏代大事</h1><p><img src=\"/2022/01/zhong-hua-tong-shi-shang-gu-shi-xia/20210703105815619.png\" alt><img src=\"/2022/01/zhong-hua-tong-shi-shang-gu-shi-xia/20210703105831609.png\" alt><img src=\"/2022/01/zhong-hua-tong-shi-shang-gu-shi-xia/20210703105920999.png\" alt><br>史称:“帝尧之时洪水滔天,浩浩怀山襄陵。”成为当时最严重的一个问题叠经派人治理,都没有成功,尧乃接受四岳的推荐,用鲧治水,鲧就是禹的父亲。鲧用堵塞的方法,多筑堤坝。但是洪水滔滔,随筑随溃,经过九年的功夫,没有成功,引起人民的怨愤。到了舜执政的时候,便将鲧殛死。而用鲧子禹继续治水。这洪水之灾,从尧初算起已经几十年了。舜又命益与弃协助禹。禹伤父功不成,乃焦思苦虑。不惜一切的劳苦,希望能完成先业,以雪父耻。他完全改变他父亲的方法,从疏导着手。他带着许多“准绳”、“规矩”等测量的工具,登山涉水,观察地形高下,而后施工。他又用了许多交通工具,史称“陆行乘车,水行乘船,泥行乘橇,山行乘撵。”他先从黄河的中段冀州地方开始。这也是黄河泛滥的枢纽地带[今山西、河南之间]。一步步的向东方的兖州、青州、徐州、南方的荆州、豫州疏导,最后又折向西北去整理黄河的上游。他将黄河下游的河道分辟为九股,散其水势。然后再分为漯济流入渤海。又疏通了许多其他的河道,完成了许多惊人的工程。他率领人民,和黄河作了十三年的奋斗,把这上百年的洪水之灾,完全治平。使老百姓免于饥溺流离之苦,能在黄河流域安居乐业下来。他这十三年中,为了国家和人民,奋不顾身,曾经几次经过家门而不入。顾不得饮食起居,他治水时总是亲自拿着募锸以身作则带头去作。冒着狂风暴雨,弄得身体憔悴而永不休息。和他同样辛苦的,还有协助他的益和弃。益掌火,在治水之前,纵火焚山林,以驱禽兽,弃为后稷,掌播谷。在水平之后,教人民耕种,从事善后工作。他们这样辛劳,一方面获得百姓的爱戴;一方面获得后世的崇拜,禹成为后来苦行家墨子的宗师。而禹与后稷,被孟子尊为是“历史上最富于同情心的人”。<br>夏启继立后,曾大会诸侯于钧台[今河南禹县许昌之间]。有扈氏不服,启率兵与有扈战于甘[今作《甘誓》]灭有扈。夏启的政权,乃归稳定。正式称为“夏后启”,启在位九年卒,子太康立。太康逸豫失政,太康五弟,追思禹德,乃作《五子之歌》。这时有东夷地方的一个有穷氏诸侯后羿作乱,太康被逼迁于斟部[河南巩县附近]。太康传弟仲康,仲康传子相,相又一度迁都于商邱[河南商邱],夏朝实际成为后羿的政权,后来后羿又被其权臣寒浞所杀,寒浞又弑相而篡夏,夏自禹至相不到九十年,而国统几绝。相妻有缗氏怀孕在身,逃至有仍[今山东济宁],生了一个遗腹子,是为少康。少康既长,从有仍氏地方逃到虞地[河南虞城],投奔有虞氏,有虞氏君收纳了少康,给以田一成[方十里为成]、众旅[五百人为旅]。后来少康就凭藉着这一成一旅的资本,强大起来。收抚旧日夏朝的士众,灭掉寒浞,复兴夏朝,还都于安邑,史称少康中兴。这后羿、寒浞之乱前后历时百年。<br>少康时曾再度发生河患,以冥为司空再度治河。由少康传子杼,杼传槐[是为夏之第八主]。槐即位,九夷来朝,九夷畎夷、于夷、方夷、黄夷、白夷、赤夷、玄夷、风夷、阳夷都是居住在东方滨海一带的落后民族。这说明在夏朝中叶的时候,夏朝的政教势力,已远达东海之滨。以前五帝到夏禹时,主要的异族战斗是苗、黎。苗、黎在西方。到夏时征服苗黎之后,继之以服九夷,说明夏人之向东发展。这个夏朝的中兴,为时约二百年,传到第十四个君主孔甲,淫乱无度,夏政再衰。诸侯纷纷叛离,中枢的权力,日益纷散,夏政乃一蹶不振。《周语》说:“孔甲乱夏,四世而陨”。夏代从孔甲乱政,以后三传到了履癸,履癸先都斟郛,后都河南禹县。这履癸就是夏桀,种种无道,荒淫奢侈。传说夏桀宠爱有施氏之女妹喜,又宠爱岷山氏二女琬、琰。又营建倾宫瑶台,作酒池肉林,杀忠臣关龙逢。太史令终古哭谏夏桀,夏桀不听,终古就亡奔于商。商人是东方的一个诸侯,世居于今安徽亳县到河南商邱一带的地方。从孔甲失德以后,商人逐渐壮大,逐渐获得诸侯的拥护。到了商汤的时候,诸侯多叛桀而归汤。有些诸侯不服从汤,汤出兵去讨伐。兵行所到之处,百姓无不欢迎。其威德远在夏桀之上。就在夏桀在位的第五十三年[公元前一七五一年],商汤俯顺舆情,率领诸侯之兵,讨伐夏桀。与夏桀大战于鸣条[旧说在山西安邑附近,近人考应在淮河之南],夏桀大败。向东南方逃走,被商汤一路追击。夏桀屡战屡败,终被商汤所俘。商汤就把夏桀流放在南巢[安徽巢县],三年而死,史称“商汤革命”。这是我国历史上第一次的贵族革命。这个夏朝,也是中国历史上第一个正式的朝代。凡历十四世,十七主,四百余年而亡。<br><img src=\"/2022/01/zhong-hua-tong-shi-shang-gu-shi-xia/20210703111602157.png\" alt></p>\n<h1 id=\"夏代影响\"><a href=\"#夏代影响\" class=\"headerlink\" title=\"夏代影响\"></a>夏代影响</h1><ol>\n<li><p>治水<br>禹治水的范围极大,据旧《史记》载,所谓疏“三江五湖”,几乎遍于全国,除了黄河之外,又导黄河的支流济水,又导淮水,又导长江。江、淮、河、济谓之四渎,所谓“四渎修,而民宅安。”我们近人推断,在那个时候,治水范围不会如此之广。我们可相信的是大禹的治水,是以黄河中段的冀州豫州为主。而渐及东方的兖州、徐州、可能的上溯到黄河上游的雍州、梁州和荆州的一部分。其他淮水与长江北面的若干支流。也可能附带的疏导过。然而仅这一个估计的范围已经很大,已经是禹率领着千万人民,经过十几年才能完成的功业。大禹治水的目的,是谋求人民生活的安定,使人民生活安定最好的方法,是使人民在这片新整理的土地上从事农耕。所以大禹治水后,就由弃的协助展开全面的农村建设,从夏朝起中国正式成为一个农业的国家。又由于治河的结果,自然而然的了解到各地的地势物产、风俗人情,自然171中华通史·第一卷·绪论上古史而然的加强了中央与地方及人民的联系。于是他制定了一个政治的区划,这个区划是分全国为九州。这九州是雍州[约当今陕西之地]、冀州[约当今山西南部]、豫州[约当今河南]、兖州[约当今河北南部]、青州[约当今山东]、徐州约当今苏北、皖北、扬州[约当今皖南、苏南]、荆州[约当今豫南与湖北]梁州[约当今陕南]成为中国版图的基础。<br>又分为全国为五服[以王畿为中心,王畿四周五百里内为甸服,五百里外为侯服,侯服外五百里为绥服,绥服外五百里为要服,要服外五百里为荒服],构成一个以王京为中心的空间观念。又根据各地的物产,制为九等贡赋。此孟子所谓“夏后氏五十而贡”。这就是禹贡九州。所以由于大禹的治水的结果,他奠定了中国的农业社会;他建立了中国的疆域概念。他是最早建立中华民族成为一个国家的大英雄。禹称夏后氏,“夏”便成为我民族对外之代名辞。按《说文》“夏”字“”作人形,注云:“中国人也”[因之,当时中国境内诸民族,称为诸夏]。故后人称禹为大禹,诚非偶然。</p>\n</li>\n<li><p>大禹始称王,始定传子之局。<br>以前五帝的共主称氏,以前虞舜的禅让,均未脱氏族的形态。到了夏禹以后传子称王,证明中央的权威提高。诸侯对于中央的关系更加服从,更加密切。中央王室的政权更加稳定,更进一步走向封建帝国。按人类上古史的演变,由最早的部落到封建的君主世袭,这是一个大的进步,这是一个国家组织的完成。我们看禹时诸侯大会涂山,诛防风氏。启时大会诸侯钓台,诛有扈氏。都是说明这个国家组织与中央政府权力的扩大。</p>\n</li>\n<li><p>治水成功,推进农业。<br>夏人建国后配合农时而制订以建寅为岁首[正月]的历法。最合乎农业的时序,周人称夏人为“得天”。这个“夏正”历法,在商、周、秦时一度改变,到汉以后又恢复采用直用到今天,就是那四序分明的阴历,我们又叫做农历。由于夏禹的治水兴农,而建立了“农历”。我们又由这“农历”,可以推想到夏朝的农业社会。因为这“夏正”,是最符合农业的一个时序。<br>夏代的文化已入于铜器时代。我们现在出土的铜器,虽尚未有确切的文字足以证明是夏代的铜器。但在山西、河南带若干出土的铜器中,相信其中或有夏器,并且根据殷商铜器之精美,其铜器制造,一定为时已久,则上推两三百年在夏朝时定有铜器可无疑。禹铸九鼎之说见于《史记》、《说文》、《左传》、《墨子》诸书,自然不是虚构。并且自春秋到秦汉历代有求鼎之事,绝对不是毫无根据的狂妄举动。据说禹铸九鼎是集九牧之铜铸成,上面刻划着各地的方物所谓铸鼎象物”。看了这九鼎,就可以知道九州的产物情形,这和《禹贡》的制度正相配合。这九鼎一直成为传国重器,也就是国家的象征。</p>\n</li>\n</ol>\n<blockquote>\n<p>本文内容均抄录于[中华通史.上古史]，致谢陈致平先生</p>\n</blockquote>\n"},{"title":"菜鸟应该如何开始设计一个项目的嵌入式软件架构","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2022-01-01T12:21:23.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"@[toc]\n## 前言\n*<font size=2 >CSDN，GIT等各大论坛上很多文章都有讲，如何设计项目的嵌入式软件架构，But门槛实在太高了，需要做需求调研，需求分析，概要设计，详细设计，架构验证，开发-单元测试，集成测试等等，实不相瞒这些没有半年八载的项目经验根本做不出来的，刚好经过这周的嵌入式架构培训，提炼下最近在做项目的嵌入式软件架构的设计经验吧，不喜勿碰，谢谢。*\n## 六步走战略\n### 第0步——嵌软需求：功能/接口/质量/硬件约束/方案约束/数据流\n ## 技能一：用例图和用例描述\n<font color=blue>Q:需求如何转换成软件框架\n<font color=blue>A:画用例图，写用列描述 \n\n**<font size=4 >用例图**（Use Case Diagrame）：描述了人们希望如何使用一个系统，将相关用户、用户需要系统提供的服务以及系统需要用户提供的服务更清晰的显示出来，以便使系统用户更容易理解这些元素的用途，也便于开发人员最终实现这些元素。\n用例图包括了三方面的内容：1用例，2参与者，3参与者和用例之间的关系。\n**<font size=3 >用例**：是对系统的用户需求（主要是功能需求）的描述，用例表达了系统的功能和所提供的服务，描述了活动者与系统交互中的对话。\n**<font size=3 >参与者**：参与者是系统外部的一个实体，它以某种方式参与了用例的执行过程，在UML中，通常用名字写在下面的人形图标表示。值得注意的是：参与者不一定是人，也可以是任何的事。\n**<font size=3 >参与者和用例之间的关系**：1关联关系，2泛化关系，3包含关系，4扩展关系下面使用亿图软件演示下用例，参与者以及二者之间的关系。\n下面这张图网上扣的，是图书馆的用例图(这里画的用例还不完全)：\n![图书馆系统](菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329193127889.jpg)<font size=2 >为什么要画用例图，而不是UML，状态机这些专业的语言用图，其实最重要的一点就是产品想做好就必须站在客户的角度思考问题，在产品需求分析阶段就要开始为上帝考虑，等到设计阶段再来思考用户体验就为时已晚，产品基本也就失败了。\n\n**<font size=4 >用例描述**：用例图仅仅是描述了系统具有的功能，但是并没有描述每一个用例的行为，也就是执行过程。\n我们不需要对每一个用例进行分析，而是需要在这些用例中，找出那些关键用例，然后对这些关键用例写出用例描述，因为关键用例才是系统架构的决定因素。\n\nQ：关键用例如何分析？。\nA: 抓住功能/接口/质量/硬件约束/方案约束/数据流这几个方面来思考。·\n\t功能：产品最关键的因素，以实现的功能来展开用例\n\t接口：硬件接口是实现功能的方式，软件接口决定层间接口的好坏\n\t质量：提高产品竞争里的核心\n\t硬件约束：决定底层驱动的复杂程度\n\t方案约束：高内聚，低耦合的前提\n\t数据流：拿捏代码逻辑的最好方法\n下面也是从网络上找的用例描述示例，可以看到并没有统一的格式，需要根据项目的性质进行增减。\n![用例描述](菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329195920218.jpg)\n\nQ:假设我们在不断的搜集和分析中，尽可能地列出了所有的需求(功能需求、质量属性、条件约束)，下一步需要做什么呢？需求这么多，该从哪一个需求入手呢？\n\nA:关键需求 = 关键功能 + 关键质量。它确定了架构的大方向。\n\n\n### 第1步——粗粒度分层\n### 第2步——中粒度分模块\n### 第3步——细粒度分ISR/周期仸务/事件驱动任务\n ## 技能二：分层，分模块，分子系统\n<font color=blue>Q:如何将需求阶段的用例图和用例描述，转换成代码\n<font color=blue>A:分层，分模块，分子系统\n\n这里举一个电梯的例子：\n![](菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329201443609.png)\n\n\n\n**<font size=4 >分层**：这里的分层是指软件代码的层次结构，并不是电梯的楼层哟，请看下图\n![分层](菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329200632579.png)底层库，驱动，HAL，服务层，功能层，用户层等，我们需要的是在第0步种对用例描述的功能，接口，硬件，约束等进行总结，提炼出我们需要做的驱动，服务和用户接口。\n这里安利一种思维是“洋葱皮”分层模式：上层调用下层，下层不能调上层。入口组装func模块，func组装下层模块。如下图所示：\n![](菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329202548677.png)\n在分层上的体现就是如下图所示：\n![](菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329202358795.png)\n**<font size=4 >分模块**：一句话按功能划分模块，电梯这个项目有几个功能就划分几个模块，以下对移动功能列出一个模块：\n![分模块](菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329201646615.png)项目的设计过程种，由着诸多的需求。而很多需求都可以进行归类，根据功能需求的方法进行模块的划分。可以让需求在归类上得到明确的划分，而且通过功能需求进行软件的模块划分使得功能分解，任务分配等方面都有较好的分解。不知道大家发现没其实分模块阶段就进行了ISR/周期仸务/事件驱动任务的设计。\n如果一个项目大家分析到这里是不是大概觉得自己知道写哪些代码了，接下来就是将模块连接起来，形成软件的骨架。\n\n**<font size=4 >分子系统**：\nQ:子系统如何分\nA:纵深封装\n什么叫纵深封装，意思就是形成跨层子系统，func层模块，封装drv模块，子系统接口公开，接口粒度大，所以松耦合\n![子系统](菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329203021908.png)在分层上的体现就是：\n![在这里插入图片描述](菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329203335481.png)子系统在分层上的体现就是：\n![子系统](菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329203626594.png)到这里设计完每个子系统之后，层层递进，层组成模块，模块细化层，子系统连接模块，模块递进成子系统。\n\n到这里基本软件的框架就能设计出来，具体的模块封装，任务并发，模块接口这些就看个人道行了。\n### 第4步——分析一个功能的协作链：定义task间通信方式/数据流关系\n### 第5步——分析并发情况下协作链：优化task的并发执行/数据流关系\n### 第6步——分析参与多功能的同一模块：优化模块的通用性/灵活性/可扩展\n以上3步是大佬总结的bug的3个方向，想要有一个稳定的系统，这3步是必须做的，其实我把他们统称为Bug，简而言之我们就要要有发现Bug的能力。\n ## 技能三：Bug工程师，要会找bu g\n这里提供几种找Bug的方法：\n1：SystemView分析工具：[rtthread的systemview分析工具](https://www.rt-thread.org/document/site/application-note/debug/systemview/an0009-systemview/)\n2：CmBacktrace：[ARM Cortex-M 系列 MCU 错误追踪库](http://packages.rt-thread.org/detail.html?package=CmBacktrace)\n3：Pc-lint:[静态代码检查工具](https://freertos.blog.csdn.net/article/details/5930634?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control&dist_request_id=1328740.41223.16170229474446557&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control)\n生命不止，BUG不止。发现好的bug工具再来补充。\n\n**后续步——5、 6循环，不断优化。但若发现架构大缺陷，回溯到1-2-3-4**\n\n经过这次的架构培训，我基本上把自己在平常工作中，对应用程序架构设计的这个思考过程描述了一遍。\n\n佛经里说了：凡是回归原点，不懂就不懂，努力学习。懂了也要相信人外有人，放下架子，谦虚，能力提升方可最大化。\n\n这篇文章介绍的设计流程，也是一个套路而已。这个套路在面对一个新领域、新项目时，就像一个脚手架一样，告诉我们这一步该做什么，下一步该做什么，应该使用什么样的工具。\n\n在僵化的运用这个套路之后，你可以继续改造、优化，然后丢掉这个套路，从而形成适合你自己的套路，从此走向思考致富的道路！\n\nGOOD LUCK\n\n\n\n\n\n \n\n","source":"_posts/2022/01/菜鸟应该如何开始设计一个项目的嵌入式软件架构.md","raw":"---\ntitle: 菜鸟应该如何开始设计一个项目的嵌入式软件架构\npermalink: 菜鸟应该如何开始设计一个项目的嵌入式软件架构\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2022-01-01 20:21:23\npassword:\nsummary:\ntags:\n- Embedded system\ncategories:\n- Embedded system\nkeywords:\ndescription:\n---\n@[toc]\n## 前言\n*<font size=2 >CSDN，GIT等各大论坛上很多文章都有讲，如何设计项目的嵌入式软件架构，But门槛实在太高了，需要做需求调研，需求分析，概要设计，详细设计，架构验证，开发-单元测试，集成测试等等，实不相瞒这些没有半年八载的项目经验根本做不出来的，刚好经过这周的嵌入式架构培训，提炼下最近在做项目的嵌入式软件架构的设计经验吧，不喜勿碰，谢谢。*\n## 六步走战略\n### 第0步——嵌软需求：功能/接口/质量/硬件约束/方案约束/数据流\n ## 技能一：用例图和用例描述\n<font color=blue>Q:需求如何转换成软件框架\n<font color=blue>A:画用例图，写用列描述 \n\n**<font size=4 >用例图**（Use Case Diagrame）：描述了人们希望如何使用一个系统，将相关用户、用户需要系统提供的服务以及系统需要用户提供的服务更清晰的显示出来，以便使系统用户更容易理解这些元素的用途，也便于开发人员最终实现这些元素。\n用例图包括了三方面的内容：1用例，2参与者，3参与者和用例之间的关系。\n**<font size=3 >用例**：是对系统的用户需求（主要是功能需求）的描述，用例表达了系统的功能和所提供的服务，描述了活动者与系统交互中的对话。\n**<font size=3 >参与者**：参与者是系统外部的一个实体，它以某种方式参与了用例的执行过程，在UML中，通常用名字写在下面的人形图标表示。值得注意的是：参与者不一定是人，也可以是任何的事。\n**<font size=3 >参与者和用例之间的关系**：1关联关系，2泛化关系，3包含关系，4扩展关系下面使用亿图软件演示下用例，参与者以及二者之间的关系。\n下面这张图网上扣的，是图书馆的用例图(这里画的用例还不完全)：\n![图书馆系统](菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329193127889.jpg)<font size=2 >为什么要画用例图，而不是UML，状态机这些专业的语言用图，其实最重要的一点就是产品想做好就必须站在客户的角度思考问题，在产品需求分析阶段就要开始为上帝考虑，等到设计阶段再来思考用户体验就为时已晚，产品基本也就失败了。\n\n**<font size=4 >用例描述**：用例图仅仅是描述了系统具有的功能，但是并没有描述每一个用例的行为，也就是执行过程。\n我们不需要对每一个用例进行分析，而是需要在这些用例中，找出那些关键用例，然后对这些关键用例写出用例描述，因为关键用例才是系统架构的决定因素。\n\nQ：关键用例如何分析？。\nA: 抓住功能/接口/质量/硬件约束/方案约束/数据流这几个方面来思考。·\n\t功能：产品最关键的因素，以实现的功能来展开用例\n\t接口：硬件接口是实现功能的方式，软件接口决定层间接口的好坏\n\t质量：提高产品竞争里的核心\n\t硬件约束：决定底层驱动的复杂程度\n\t方案约束：高内聚，低耦合的前提\n\t数据流：拿捏代码逻辑的最好方法\n下面也是从网络上找的用例描述示例，可以看到并没有统一的格式，需要根据项目的性质进行增减。\n![用例描述](菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329195920218.jpg)\n\nQ:假设我们在不断的搜集和分析中，尽可能地列出了所有的需求(功能需求、质量属性、条件约束)，下一步需要做什么呢？需求这么多，该从哪一个需求入手呢？\n\nA:关键需求 = 关键功能 + 关键质量。它确定了架构的大方向。\n\n\n### 第1步——粗粒度分层\n### 第2步——中粒度分模块\n### 第3步——细粒度分ISR/周期仸务/事件驱动任务\n ## 技能二：分层，分模块，分子系统\n<font color=blue>Q:如何将需求阶段的用例图和用例描述，转换成代码\n<font color=blue>A:分层，分模块，分子系统\n\n这里举一个电梯的例子：\n![](菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329201443609.png)\n\n\n\n**<font size=4 >分层**：这里的分层是指软件代码的层次结构，并不是电梯的楼层哟，请看下图\n![分层](菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329200632579.png)底层库，驱动，HAL，服务层，功能层，用户层等，我们需要的是在第0步种对用例描述的功能，接口，硬件，约束等进行总结，提炼出我们需要做的驱动，服务和用户接口。\n这里安利一种思维是“洋葱皮”分层模式：上层调用下层，下层不能调上层。入口组装func模块，func组装下层模块。如下图所示：\n![](菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329202548677.png)\n在分层上的体现就是如下图所示：\n![](菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329202358795.png)\n**<font size=4 >分模块**：一句话按功能划分模块，电梯这个项目有几个功能就划分几个模块，以下对移动功能列出一个模块：\n![分模块](菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329201646615.png)项目的设计过程种，由着诸多的需求。而很多需求都可以进行归类，根据功能需求的方法进行模块的划分。可以让需求在归类上得到明确的划分，而且通过功能需求进行软件的模块划分使得功能分解，任务分配等方面都有较好的分解。不知道大家发现没其实分模块阶段就进行了ISR/周期仸务/事件驱动任务的设计。\n如果一个项目大家分析到这里是不是大概觉得自己知道写哪些代码了，接下来就是将模块连接起来，形成软件的骨架。\n\n**<font size=4 >分子系统**：\nQ:子系统如何分\nA:纵深封装\n什么叫纵深封装，意思就是形成跨层子系统，func层模块，封装drv模块，子系统接口公开，接口粒度大，所以松耦合\n![子系统](菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329203021908.png)在分层上的体现就是：\n![在这里插入图片描述](菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329203335481.png)子系统在分层上的体现就是：\n![子系统](菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329203626594.png)到这里设计完每个子系统之后，层层递进，层组成模块，模块细化层，子系统连接模块，模块递进成子系统。\n\n到这里基本软件的框架就能设计出来，具体的模块封装，任务并发，模块接口这些就看个人道行了。\n### 第4步——分析一个功能的协作链：定义task间通信方式/数据流关系\n### 第5步——分析并发情况下协作链：优化task的并发执行/数据流关系\n### 第6步——分析参与多功能的同一模块：优化模块的通用性/灵活性/可扩展\n以上3步是大佬总结的bug的3个方向，想要有一个稳定的系统，这3步是必须做的，其实我把他们统称为Bug，简而言之我们就要要有发现Bug的能力。\n ## 技能三：Bug工程师，要会找bu g\n这里提供几种找Bug的方法：\n1：SystemView分析工具：[rtthread的systemview分析工具](https://www.rt-thread.org/document/site/application-note/debug/systemview/an0009-systemview/)\n2：CmBacktrace：[ARM Cortex-M 系列 MCU 错误追踪库](http://packages.rt-thread.org/detail.html?package=CmBacktrace)\n3：Pc-lint:[静态代码检查工具](https://freertos.blog.csdn.net/article/details/5930634?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control&dist_request_id=1328740.41223.16170229474446557&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control)\n生命不止，BUG不止。发现好的bug工具再来补充。\n\n**后续步——5、 6循环，不断优化。但若发现架构大缺陷，回溯到1-2-3-4**\n\n经过这次的架构培训，我基本上把自己在平常工作中，对应用程序架构设计的这个思考过程描述了一遍。\n\n佛经里说了：凡是回归原点，不懂就不懂，努力学习。懂了也要相信人外有人，放下架子，谦虚，能力提升方可最大化。\n\n这篇文章介绍的设计流程，也是一个套路而已。这个套路在面对一个新领域、新项目时，就像一个脚手架一样，告诉我们这一步该做什么，下一步该做什么，应该使用什么样的工具。\n\n在僵化的运用这个套路之后，你可以继续改造、优化，然后丢掉这个套路，从而形成适合你自己的套路，从此走向思考致富的道路！\n\nGOOD LUCK\n\n\n\n\n\n \n\n","slug":"菜鸟应该如何开始设计一个项目的嵌入式软件架构","published":1,"updated":"2024-01-05T08:12:19.101Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clru1g206000ds4furzkxg6pl","content":"<p>@[toc]</p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>*<font size=\"2\">CSDN，GIT等各大论坛上很多文章都有讲，如何设计项目的嵌入式软件架构，But门槛实在太高了，需要做需求调研，需求分析，概要设计，详细设计，架构验证，开发-单元测试，集成测试等等，实不相瞒这些没有半年八载的项目经验根本做不出来的，刚好经过这周的嵌入式架构培训，提炼下最近在做项目的嵌入式软件架构的设计经验吧，不喜勿碰，谢谢。*</font></p>\n<h2 id=\"六步走战略\"><a href=\"#六步走战略\" class=\"headerlink\" title=\"六步走战略\"></a>六步走战略</h2><h3 id=\"第0步——嵌软需求：功能-接口-质量-硬件约束-方案约束-数据流\"><a href=\"#第0步——嵌软需求：功能-接口-质量-硬件约束-方案约束-数据流\" class=\"headerlink\" title=\"第0步——嵌软需求：功能/接口/质量/硬件约束/方案约束/数据流\"></a>第0步——嵌软需求：功能/接口/质量/硬件约束/方案约束/数据流</h3><h2 id=\"技能一：用例图和用例描述\"><a href=\"#技能一：用例图和用例描述\" class=\"headerlink\" title=\"技能一：用例图和用例描述\"></a>技能一：用例图和用例描述</h2><p><font color=\"blue\">Q:需求如何转换成软件框架<br><font color=\"blue\">A:画用例图，写用列描述 </font></font></p>\n<p><strong><font size=\"4\">用例图</font></strong>（Use Case Diagrame）：描述了人们希望如何使用一个系统，将相关用户、用户需要系统提供的服务以及系统需要用户提供的服务更清晰的显示出来，以便使系统用户更容易理解这些元素的用途，也便于开发人员最终实现这些元素。<br>用例图包括了三方面的内容：1用例，2参与者，3参与者和用例之间的关系。<br><strong><font size=\"3\">用例</font></strong>：是对系统的用户需求（主要是功能需求）的描述，用例表达了系统的功能和所提供的服务，描述了活动者与系统交互中的对话。<br><strong><font size=\"3\">参与者</font></strong>：参与者是系统外部的一个实体，它以某种方式参与了用例的执行过程，在UML中，通常用名字写在下面的人形图标表示。值得注意的是：参与者不一定是人，也可以是任何的事。<br><strong><font size=\"3\">参与者和用例之间的关系</font></strong>：1关联关系，2泛化关系，3包含关系，4扩展关系下面使用亿图软件演示下用例，参与者以及二者之间的关系。<br>下面这张图网上扣的，是图书馆的用例图(这里画的用例还不完全)：<br><img src=\"/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329193127889.jpg\" alt=\"图书馆系统\"><font size=\"2\">为什么要画用例图，而不是UML，状态机这些专业的语言用图，其实最重要的一点就是产品想做好就必须站在客户的角度思考问题，在产品需求分析阶段就要开始为上帝考虑，等到设计阶段再来思考用户体验就为时已晚，产品基本也就失败了。</font></p>\n<p><strong><font size=\"4\">用例描述</font></strong>：用例图仅仅是描述了系统具有的功能，但是并没有描述每一个用例的行为，也就是执行过程。<br>我们不需要对每一个用例进行分析，而是需要在这些用例中，找出那些关键用例，然后对这些关键用例写出用例描述，因为关键用例才是系统架构的决定因素。</p>\n<p>Q：关键用例如何分析？。<br>A: 抓住功能/接口/质量/硬件约束/方案约束/数据流这几个方面来思考。·<br>    功能：产品最关键的因素，以实现的功能来展开用例<br>    接口：硬件接口是实现功能的方式，软件接口决定层间接口的好坏<br>    质量：提高产品竞争里的核心<br>    硬件约束：决定底层驱动的复杂程度<br>    方案约束：高内聚，低耦合的前提<br>    数据流：拿捏代码逻辑的最好方法<br>下面也是从网络上找的用例描述示例，可以看到并没有统一的格式，需要根据项目的性质进行增减。<br><img src=\"/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329195920218.jpg\" alt=\"用例描述\"></p>\n<p>Q:假设我们在不断的搜集和分析中，尽可能地列出了所有的需求(功能需求、质量属性、条件约束)，下一步需要做什么呢？需求这么多，该从哪一个需求入手呢？</p>\n<p>A:关键需求 = 关键功能 + 关键质量。它确定了架构的大方向。</p>\n<h3 id=\"第1步——粗粒度分层\"><a href=\"#第1步——粗粒度分层\" class=\"headerlink\" title=\"第1步——粗粒度分层\"></a>第1步——粗粒度分层</h3><h3 id=\"第2步——中粒度分模块\"><a href=\"#第2步——中粒度分模块\" class=\"headerlink\" title=\"第2步——中粒度分模块\"></a>第2步——中粒度分模块</h3><h3 id=\"第3步——细粒度分ISR-周期仸务-事件驱动任务\"><a href=\"#第3步——细粒度分ISR-周期仸务-事件驱动任务\" class=\"headerlink\" title=\"第3步——细粒度分ISR/周期仸务/事件驱动任务\"></a>第3步——细粒度分ISR/周期仸务/事件驱动任务</h3><h2 id=\"技能二：分层，分模块，分子系统\"><a href=\"#技能二：分层，分模块，分子系统\" class=\"headerlink\" title=\"技能二：分层，分模块，分子系统\"></a>技能二：分层，分模块，分子系统</h2><p><font color=\"blue\">Q:如何将需求阶段的用例图和用例描述，转换成代码<br><font color=\"blue\">A:分层，分模块，分子系统</font></font></p>\n<p>这里举一个电梯的例子：<br><img src=\"/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329201443609.png\" alt></p>\n<p><strong><font size=\"4\">分层</font></strong>：这里的分层是指软件代码的层次结构，并不是电梯的楼层哟，请看下图<br><img src=\"/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329200632579.png\" alt=\"分层\">底层库，驱动，HAL，服务层，功能层，用户层等，我们需要的是在第0步种对用例描述的功能，接口，硬件，约束等进行总结，提炼出我们需要做的驱动，服务和用户接口。<br>这里安利一种思维是“洋葱皮”分层模式：上层调用下层，下层不能调上层。入口组装func模块，func组装下层模块。如下图所示：<br><img src=\"/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329202548677.png\" alt><br>在分层上的体现就是如下图所示：<br><img src=\"/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329202358795.png\" alt><br><strong><font size=\"4\">分模块</font></strong>：一句话按功能划分模块，电梯这个项目有几个功能就划分几个模块，以下对移动功能列出一个模块：<br><img src=\"/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329201646615.png\" alt=\"分模块\">项目的设计过程种，由着诸多的需求。而很多需求都可以进行归类，根据功能需求的方法进行模块的划分。可以让需求在归类上得到明确的划分，而且通过功能需求进行软件的模块划分使得功能分解，任务分配等方面都有较好的分解。不知道大家发现没其实分模块阶段就进行了ISR/周期仸务/事件驱动任务的设计。<br>如果一个项目大家分析到这里是不是大概觉得自己知道写哪些代码了，接下来就是将模块连接起来，形成软件的骨架。</p>\n<p><strong><font size=\"4\">分子系统</font></strong>：<br>Q:子系统如何分<br>A:纵深封装<br>什么叫纵深封装，意思就是形成跨层子系统，func层模块，封装drv模块，子系统接口公开，接口粒度大，所以松耦合<br><img src=\"/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329203021908.png\" alt=\"子系统\">在分层上的体现就是：<br><img src=\"/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329203335481.png\" alt=\"在这里插入图片描述\">子系统在分层上的体现就是：<br><img src=\"/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329203626594.png\" alt=\"子系统\">到这里设计完每个子系统之后，层层递进，层组成模块，模块细化层，子系统连接模块，模块递进成子系统。</p>\n<p>到这里基本软件的框架就能设计出来，具体的模块封装，任务并发，模块接口这些就看个人道行了。</p>\n<h3 id=\"第4步——分析一个功能的协作链：定义task间通信方式-数据流关系\"><a href=\"#第4步——分析一个功能的协作链：定义task间通信方式-数据流关系\" class=\"headerlink\" title=\"第4步——分析一个功能的协作链：定义task间通信方式/数据流关系\"></a>第4步——分析一个功能的协作链：定义task间通信方式/数据流关系</h3><h3 id=\"第5步——分析并发情况下协作链：优化task的并发执行-数据流关系\"><a href=\"#第5步——分析并发情况下协作链：优化task的并发执行-数据流关系\" class=\"headerlink\" title=\"第5步——分析并发情况下协作链：优化task的并发执行/数据流关系\"></a>第5步——分析并发情况下协作链：优化task的并发执行/数据流关系</h3><h3 id=\"第6步——分析参与多功能的同一模块：优化模块的通用性-灵活性-可扩展\"><a href=\"#第6步——分析参与多功能的同一模块：优化模块的通用性-灵活性-可扩展\" class=\"headerlink\" title=\"第6步——分析参与多功能的同一模块：优化模块的通用性/灵活性/可扩展\"></a>第6步——分析参与多功能的同一模块：优化模块的通用性/灵活性/可扩展</h3><p>以上3步是大佬总结的bug的3个方向，想要有一个稳定的系统，这3步是必须做的，其实我把他们统称为Bug，简而言之我们就要要有发现Bug的能力。</p>\n<h2 id=\"技能三：Bug工程师，要会找bu-g\"><a href=\"#技能三：Bug工程师，要会找bu-g\" class=\"headerlink\" title=\"技能三：Bug工程师，要会找bu g\"></a>技能三：Bug工程师，要会找bu g</h2><p>这里提供几种找Bug的方法：<br>1：SystemView分析工具：<a href=\"https://www.rt-thread.org/document/site/application-note/debug/systemview/an0009-systemview/\" target=\"_blank\" rel=\"noopener\">rtthread的systemview分析工具</a><br>2：CmBacktrace：<a href=\"http://packages.rt-thread.org/detail.html?package=CmBacktrace\" target=\"_blank\" rel=\"noopener\">ARM Cortex-M 系列 MCU 错误追踪库</a><br>3：Pc-lint:<a href=\"https://freertos.blog.csdn.net/article/details/5930634?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control&dist_request_id=1328740.41223.16170229474446557&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control\" target=\"_blank\" rel=\"noopener\">静态代码检查工具</a><br>生命不止，BUG不止。发现好的bug工具再来补充。</p>\n<p><strong>后续步——5、 6循环，不断优化。但若发现架构大缺陷，回溯到1-2-3-4</strong></p>\n<p>经过这次的架构培训，我基本上把自己在平常工作中，对应用程序架构设计的这个思考过程描述了一遍。</p>\n<p>佛经里说了：凡是回归原点，不懂就不懂，努力学习。懂了也要相信人外有人，放下架子，谦虚，能力提升方可最大化。</p>\n<p>这篇文章介绍的设计流程，也是一个套路而已。这个套路在面对一个新领域、新项目时，就像一个脚手架一样，告诉我们这一步该做什么，下一步该做什么，应该使用什么样的工具。</p>\n<p>在僵化的运用这个套路之后，你可以继续改造、优化，然后丢掉这个套路，从而形成适合你自己的套路，从此走向思考致富的道路！</p>\n<p>GOOD LUCK</p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<p>@[toc]</p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>*<font size=\"2\">CSDN，GIT等各大论坛上很多文章都有讲，如何设计项目的嵌入式软件架构，But门槛实在太高了，需要做需求调研，需求分析，概要设计，详细设计，架构验证，开发-单元测试，集成测试等等，实不相瞒这些没有半年八载的项目经验根本做不出来的，刚好经过这周的嵌入式架构培训，提炼下最近在做项目的嵌入式软件架构的设计经验吧，不喜勿碰，谢谢。*</font></p>\n<h2 id=\"六步走战略\"><a href=\"#六步走战略\" class=\"headerlink\" title=\"六步走战略\"></a>六步走战略</h2><h3 id=\"第0步——嵌软需求：功能-接口-质量-硬件约束-方案约束-数据流\"><a href=\"#第0步——嵌软需求：功能-接口-质量-硬件约束-方案约束-数据流\" class=\"headerlink\" title=\"第0步——嵌软需求：功能/接口/质量/硬件约束/方案约束/数据流\"></a>第0步——嵌软需求：功能/接口/质量/硬件约束/方案约束/数据流</h3><h2 id=\"技能一：用例图和用例描述\"><a href=\"#技能一：用例图和用例描述\" class=\"headerlink\" title=\"技能一：用例图和用例描述\"></a>技能一：用例图和用例描述</h2><p><font color=\"blue\">Q:需求如何转换成软件框架<br><font color=\"blue\">A:画用例图，写用列描述 </font></font></p>\n<p><strong><font size=\"4\">用例图</font></strong>（Use Case Diagrame）：描述了人们希望如何使用一个系统，将相关用户、用户需要系统提供的服务以及系统需要用户提供的服务更清晰的显示出来，以便使系统用户更容易理解这些元素的用途，也便于开发人员最终实现这些元素。<br>用例图包括了三方面的内容：1用例，2参与者，3参与者和用例之间的关系。<br><strong><font size=\"3\">用例</font></strong>：是对系统的用户需求（主要是功能需求）的描述，用例表达了系统的功能和所提供的服务，描述了活动者与系统交互中的对话。<br><strong><font size=\"3\">参与者</font></strong>：参与者是系统外部的一个实体，它以某种方式参与了用例的执行过程，在UML中，通常用名字写在下面的人形图标表示。值得注意的是：参与者不一定是人，也可以是任何的事。<br><strong><font size=\"3\">参与者和用例之间的关系</font></strong>：1关联关系，2泛化关系，3包含关系，4扩展关系下面使用亿图软件演示下用例，参与者以及二者之间的关系。<br>下面这张图网上扣的，是图书馆的用例图(这里画的用例还不完全)：<br><img src=\"/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329193127889.jpg\" alt=\"图书馆系统\"><font size=\"2\">为什么要画用例图，而不是UML，状态机这些专业的语言用图，其实最重要的一点就是产品想做好就必须站在客户的角度思考问题，在产品需求分析阶段就要开始为上帝考虑，等到设计阶段再来思考用户体验就为时已晚，产品基本也就失败了。</font></p>\n<p><strong><font size=\"4\">用例描述</font></strong>：用例图仅仅是描述了系统具有的功能，但是并没有描述每一个用例的行为，也就是执行过程。<br>我们不需要对每一个用例进行分析，而是需要在这些用例中，找出那些关键用例，然后对这些关键用例写出用例描述，因为关键用例才是系统架构的决定因素。</p>\n<p>Q：关键用例如何分析？。<br>A: 抓住功能/接口/质量/硬件约束/方案约束/数据流这几个方面来思考。·<br>    功能：产品最关键的因素，以实现的功能来展开用例<br>    接口：硬件接口是实现功能的方式，软件接口决定层间接口的好坏<br>    质量：提高产品竞争里的核心<br>    硬件约束：决定底层驱动的复杂程度<br>    方案约束：高内聚，低耦合的前提<br>    数据流：拿捏代码逻辑的最好方法<br>下面也是从网络上找的用例描述示例，可以看到并没有统一的格式，需要根据项目的性质进行增减。<br><img src=\"/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329195920218.jpg\" alt=\"用例描述\"></p>\n<p>Q:假设我们在不断的搜集和分析中，尽可能地列出了所有的需求(功能需求、质量属性、条件约束)，下一步需要做什么呢？需求这么多，该从哪一个需求入手呢？</p>\n<p>A:关键需求 = 关键功能 + 关键质量。它确定了架构的大方向。</p>\n<h3 id=\"第1步——粗粒度分层\"><a href=\"#第1步——粗粒度分层\" class=\"headerlink\" title=\"第1步——粗粒度分层\"></a>第1步——粗粒度分层</h3><h3 id=\"第2步——中粒度分模块\"><a href=\"#第2步——中粒度分模块\" class=\"headerlink\" title=\"第2步——中粒度分模块\"></a>第2步——中粒度分模块</h3><h3 id=\"第3步——细粒度分ISR-周期仸务-事件驱动任务\"><a href=\"#第3步——细粒度分ISR-周期仸务-事件驱动任务\" class=\"headerlink\" title=\"第3步——细粒度分ISR/周期仸务/事件驱动任务\"></a>第3步——细粒度分ISR/周期仸务/事件驱动任务</h3><h2 id=\"技能二：分层，分模块，分子系统\"><a href=\"#技能二：分层，分模块，分子系统\" class=\"headerlink\" title=\"技能二：分层，分模块，分子系统\"></a>技能二：分层，分模块，分子系统</h2><p><font color=\"blue\">Q:如何将需求阶段的用例图和用例描述，转换成代码<br><font color=\"blue\">A:分层，分模块，分子系统</font></font></p>\n<p>这里举一个电梯的例子：<br><img src=\"/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329201443609.png\" alt></p>\n<p><strong><font size=\"4\">分层</font></strong>：这里的分层是指软件代码的层次结构，并不是电梯的楼层哟，请看下图<br><img src=\"/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329200632579.png\" alt=\"分层\">底层库，驱动，HAL，服务层，功能层，用户层等，我们需要的是在第0步种对用例描述的功能，接口，硬件，约束等进行总结，提炼出我们需要做的驱动，服务和用户接口。<br>这里安利一种思维是“洋葱皮”分层模式：上层调用下层，下层不能调上层。入口组装func模块，func组装下层模块。如下图所示：<br><img src=\"/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329202548677.png\" alt><br>在分层上的体现就是如下图所示：<br><img src=\"/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329202358795.png\" alt><br><strong><font size=\"4\">分模块</font></strong>：一句话按功能划分模块，电梯这个项目有几个功能就划分几个模块，以下对移动功能列出一个模块：<br><img src=\"/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329201646615.png\" alt=\"分模块\">项目的设计过程种，由着诸多的需求。而很多需求都可以进行归类，根据功能需求的方法进行模块的划分。可以让需求在归类上得到明确的划分，而且通过功能需求进行软件的模块划分使得功能分解，任务分配等方面都有较好的分解。不知道大家发现没其实分模块阶段就进行了ISR/周期仸务/事件驱动任务的设计。<br>如果一个项目大家分析到这里是不是大概觉得自己知道写哪些代码了，接下来就是将模块连接起来，形成软件的骨架。</p>\n<p><strong><font size=\"4\">分子系统</font></strong>：<br>Q:子系统如何分<br>A:纵深封装<br>什么叫纵深封装，意思就是形成跨层子系统，func层模块，封装drv模块，子系统接口公开，接口粒度大，所以松耦合<br><img src=\"/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329203021908.png\" alt=\"子系统\">在分层上的体现就是：<br><img src=\"/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329203335481.png\" alt=\"在这里插入图片描述\">子系统在分层上的体现就是：<br><img src=\"/2022/01/cai-niao-ying-gai-ru-he-kai-shi-she-ji-yi-ge-xiang-mu-de-qian-ru-shi-ruan-jian-jia-gou/20210329203626594.png\" alt=\"子系统\">到这里设计完每个子系统之后，层层递进，层组成模块，模块细化层，子系统连接模块，模块递进成子系统。</p>\n<p>到这里基本软件的框架就能设计出来，具体的模块封装，任务并发，模块接口这些就看个人道行了。</p>\n<h3 id=\"第4步——分析一个功能的协作链：定义task间通信方式-数据流关系\"><a href=\"#第4步——分析一个功能的协作链：定义task间通信方式-数据流关系\" class=\"headerlink\" title=\"第4步——分析一个功能的协作链：定义task间通信方式/数据流关系\"></a>第4步——分析一个功能的协作链：定义task间通信方式/数据流关系</h3><h3 id=\"第5步——分析并发情况下协作链：优化task的并发执行-数据流关系\"><a href=\"#第5步——分析并发情况下协作链：优化task的并发执行-数据流关系\" class=\"headerlink\" title=\"第5步——分析并发情况下协作链：优化task的并发执行/数据流关系\"></a>第5步——分析并发情况下协作链：优化task的并发执行/数据流关系</h3><h3 id=\"第6步——分析参与多功能的同一模块：优化模块的通用性-灵活性-可扩展\"><a href=\"#第6步——分析参与多功能的同一模块：优化模块的通用性-灵活性-可扩展\" class=\"headerlink\" title=\"第6步——分析参与多功能的同一模块：优化模块的通用性/灵活性/可扩展\"></a>第6步——分析参与多功能的同一模块：优化模块的通用性/灵活性/可扩展</h3><p>以上3步是大佬总结的bug的3个方向，想要有一个稳定的系统，这3步是必须做的，其实我把他们统称为Bug，简而言之我们就要要有发现Bug的能力。</p>\n<h2 id=\"技能三：Bug工程师，要会找bu-g\"><a href=\"#技能三：Bug工程师，要会找bu-g\" class=\"headerlink\" title=\"技能三：Bug工程师，要会找bu g\"></a>技能三：Bug工程师，要会找bu g</h2><p>这里提供几种找Bug的方法：<br>1：SystemView分析工具：<a href=\"https://www.rt-thread.org/document/site/application-note/debug/systemview/an0009-systemview/\" target=\"_blank\" rel=\"noopener\">rtthread的systemview分析工具</a><br>2：CmBacktrace：<a href=\"http://packages.rt-thread.org/detail.html?package=CmBacktrace\" target=\"_blank\" rel=\"noopener\">ARM Cortex-M 系列 MCU 错误追踪库</a><br>3：Pc-lint:<a href=\"https://freertos.blog.csdn.net/article/details/5930634?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control&dist_request_id=1328740.41223.16170229474446557&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control\" target=\"_blank\" rel=\"noopener\">静态代码检查工具</a><br>生命不止，BUG不止。发现好的bug工具再来补充。</p>\n<p><strong>后续步——5、 6循环，不断优化。但若发现架构大缺陷，回溯到1-2-3-4</strong></p>\n<p>经过这次的架构培训，我基本上把自己在平常工作中，对应用程序架构设计的这个思考过程描述了一遍。</p>\n<p>佛经里说了：凡是回归原点，不懂就不懂，努力学习。懂了也要相信人外有人，放下架子，谦虚，能力提升方可最大化。</p>\n<p>这篇文章介绍的设计流程，也是一个套路而已。这个套路在面对一个新领域、新项目时，就像一个脚手架一样，告诉我们这一步该做什么，下一步该做什么，应该使用什么样的工具。</p>\n<p>在僵化的运用这个套路之后，你可以继续改造、优化，然后丢掉这个套路，从而形成适合你自己的套路，从此走向思考致富的道路！</p>\n<p>GOOD LUCK</p>\n"},{"title":"IMX6ull 移植 lVGL总结","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2022-01-01T12:59:25.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"<h1>1 ：准备工作</h1>\n<p>硬件：正点原子的Imx6ull开发板</p>\n<p>环境：ubuntu18.0</p>\n<p>lvgl软件地址：<a href=\"git@gitee.com:qian-qiang/imx6ull_lvgl_demo.git\" target=\"_blank\" rel=\"noopener\">git@gitee.com:qian-qiang/imx6ull_lvgl_demo.git</a></p>\n<h1>2：git 厂库修改文件</h1>\n<p>2.1：修改文件lv_drv_config.h</p>\n<p><img src=\"IMX6ull-移植-lVGL总结/2909691-20220928151916481-1456634923.png\" alt=\"\" height=\"513\" width=\"1084\" /></p>\n<p><img src=\"IMX6ull-移植-lVGL总结/2909691-20220928152209724-1097250473.png\" alt=\"\" height=\"368\" width=\"1087\" /></p>\n<p><img src=\"IMX6ull-移植-lVGL总结/2909691-20220928153140065-1807119912.png\" alt=\"\" height=\"177\" width=\"1081\" /></p>\n<p id=\"1664350186406\"></p>\n<p id=\"1664349615994\">2.2：修改文件lv_conf.h</p>\n<p><img src=\"IMX6ull-移植-lVGL总结/2909691-20220928152957065-501054685.png\" alt=\"\" height=\"387\" width=\"1664\" /></p>\n<p><img src=\"IMX6ull-移植-lVGL总结/2909691-20220928152945955-899676295.png\" alt=\"\" height=\"843\" width=\"1671\" /></p>\n<p><img src=\"IMX6ull-移植-lVGL总结/2909691-20220928152922659-1842915282.png\" alt=\"\" /></p>\n<p id=\"1664350048873\">2.3：修改文件main.c</p>\n<p><img src=\"IMX6ull-移植-lVGL总结/2909691-20220928153305849-1048335725.png\" alt=\"\" /></p>\n<h1>3：make</h1>\n<p>由于环境的问题 make过程中可能有问题 上百度应该改都能解决 最后生成demo文件&nbsp;</p>\n<p><img src=\"IMX6ull-移植-lVGL总结/2909691-20220928153451220-1274979267.png\" alt=\"\" /></p>\n<h1>4：scp到开发板运行即可</h1>\n<p>&nbsp;</p>\n<p id=\"1664350272125\"></p>\n<p id=\"1664349445067\"></p>\n<p>&nbsp;</p>\n","source":"_posts/2022/01/IMX6ull-移植-lVGL总结.md","raw":"---\ntitle: IMX6ull 移植 lVGL总结\npermalink: IMX6ull 移植 lVGL总结\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2022-01-01 20:59:25\npassword:\nsummary:\ntags:\n- linux\n- imx6ull\ncategories:\n- linux\nkeywords:\ndescription:\n---\n<h1>1 ：准备工作</h1>\n<p>硬件：正点原子的Imx6ull开发板</p>\n<p>环境：ubuntu18.0</p>\n<p>lvgl软件地址：<a href=\"git@gitee.com:qian-qiang/imx6ull_lvgl_demo.git\" target=\"_blank\" rel=\"noopener\">git@gitee.com:qian-qiang/imx6ull_lvgl_demo.git</a></p>\n<h1>2：git 厂库修改文件</h1>\n<p>2.1：修改文件lv_drv_config.h</p>\n<p><img src=\"IMX6ull-移植-lVGL总结/2909691-20220928151916481-1456634923.png\" alt=\"\" height=\"513\" width=\"1084\" /></p>\n<p><img src=\"IMX6ull-移植-lVGL总结/2909691-20220928152209724-1097250473.png\" alt=\"\" height=\"368\" width=\"1087\" /></p>\n<p><img src=\"IMX6ull-移植-lVGL总结/2909691-20220928153140065-1807119912.png\" alt=\"\" height=\"177\" width=\"1081\" /></p>\n<p id=\"1664350186406\"></p>\n<p id=\"1664349615994\">2.2：修改文件lv_conf.h</p>\n<p><img src=\"IMX6ull-移植-lVGL总结/2909691-20220928152957065-501054685.png\" alt=\"\" height=\"387\" width=\"1664\" /></p>\n<p><img src=\"IMX6ull-移植-lVGL总结/2909691-20220928152945955-899676295.png\" alt=\"\" height=\"843\" width=\"1671\" /></p>\n<p><img src=\"IMX6ull-移植-lVGL总结/2909691-20220928152922659-1842915282.png\" alt=\"\" /></p>\n<p id=\"1664350048873\">2.3：修改文件main.c</p>\n<p><img src=\"IMX6ull-移植-lVGL总结/2909691-20220928153305849-1048335725.png\" alt=\"\" /></p>\n<h1>3：make</h1>\n<p>由于环境的问题 make过程中可能有问题 上百度应该改都能解决 最后生成demo文件&nbsp;</p>\n<p><img src=\"IMX6ull-移植-lVGL总结/2909691-20220928153451220-1274979267.png\" alt=\"\" /></p>\n<h1>4：scp到开发板运行即可</h1>\n<p>&nbsp;</p>\n<p id=\"1664350272125\"></p>\n<p id=\"1664349445067\"></p>\n<p>&nbsp;</p>\n","slug":"IMX6ull 移植 lVGL总结","published":1,"updated":"2024-01-05T08:12:19.070Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clru1g20a000gs4fukjgw8gmn","content":"<h1>1 ：准备工作</h1>\n<p>硬件：正点原子的Imx6ull开发板</p>\n<p>环境：ubuntu18.0</p>\n<p>lvgl软件地址：<a href=\"git@gitee.com:qian-qiang/imx6ull_lvgl_demo.git\" target=\"_blank\" rel=\"noopener\">git@gitee.com:qian-qiang/imx6ull_lvgl_demo.git</a></p>\n<h1>2：git 厂库修改文件</h1>\n<p>2.1：修改文件lv_drv_config.h</p>\n<p><img src=\"/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928151916481-1456634923.png\" alt height=\"513\" width=\"1084\"></p>\n<p><img src=\"/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928152209724-1097250473.png\" alt height=\"368\" width=\"1087\"></p>\n<p><img src=\"/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928153140065-1807119912.png\" alt height=\"177\" width=\"1081\"></p>\n<p id=\"1664350186406\"></p>\n<p id=\"1664349615994\">2.2：修改文件lv_conf.h</p>\n<p><img src=\"/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928152957065-501054685.png\" alt height=\"387\" width=\"1664\"></p>\n<p><img src=\"/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928152945955-899676295.png\" alt height=\"843\" width=\"1671\"></p>\n<p><img src=\"/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928152922659-1842915282.png\" alt></p>\n<p id=\"1664350048873\">2.3：修改文件main.c</p>\n<p><img src=\"/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928153305849-1048335725.png\" alt></p>\n<h1>3：make</h1>\n<p>由于环境的问题 make过程中可能有问题 上百度应该改都能解决 最后生成demo文件&nbsp;</p>\n<p><img src=\"/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928153451220-1274979267.png\" alt></p>\n<h1>4：scp到开发板运行即可</h1>\n<p>&nbsp;</p>\n<p id=\"1664350272125\"></p>\n<p id=\"1664349445067\"></p>\n<p>&nbsp;</p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<h1>1 ：准备工作</h1>\n<p>硬件：正点原子的Imx6ull开发板</p>\n<p>环境：ubuntu18.0</p>\n<p>lvgl软件地址：<a href=\"git@gitee.com:qian-qiang/imx6ull_lvgl_demo.git\" target=\"_blank\" rel=\"noopener\">git@gitee.com:qian-qiang/imx6ull_lvgl_demo.git</a></p>\n<h1>2：git 厂库修改文件</h1>\n<p>2.1：修改文件lv_drv_config.h</p>\n<p><img src=\"/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928151916481-1456634923.png\" alt height=\"513\" width=\"1084\"></p>\n<p><img src=\"/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928152209724-1097250473.png\" alt height=\"368\" width=\"1087\"></p>\n<p><img src=\"/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928153140065-1807119912.png\" alt height=\"177\" width=\"1081\"></p>\n<p id=\"1664350186406\"></p>\n<p id=\"1664349615994\">2.2：修改文件lv_conf.h</p>\n<p><img src=\"/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928152957065-501054685.png\" alt height=\"387\" width=\"1664\"></p>\n<p><img src=\"/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928152945955-899676295.png\" alt height=\"843\" width=\"1671\"></p>\n<p><img src=\"/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928152922659-1842915282.png\" alt></p>\n<p id=\"1664350048873\">2.3：修改文件main.c</p>\n<p><img src=\"/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928153305849-1048335725.png\" alt></p>\n<h1>3：make</h1>\n<p>由于环境的问题 make过程中可能有问题 上百度应该改都能解决 最后生成demo文件&nbsp;</p>\n<p><img src=\"/2022/01/imx6ull-yi-zhi-lvgl-zong-jie/2909691-20220928153451220-1274979267.png\" alt></p>\n<h1>4：scp到开发板运行即可</h1>\n<p>&nbsp;</p>\n<p id=\"1664350272125\"></p>\n<p id=\"1664349445067\"></p>\n<p>&nbsp;</p>\n"},{"title":"腾格里","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-04-28T05:15:39.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"\n![6.jpg](6.jpg)\n![4.jpg](4.jpg)\n![5.jpg](5.jpg)\n![IMG_6912.JPG](IMG_6912.JPG)\n![1.jpg](1.jpg)\n![3.jpg](3.jpg)\n![2.jpg](2.jpg)\n![IMG_7069.JPG](IMG_7069.JPG)\n![IMG_6899.JPG](IMG_6899.JPG)\n","source":"_posts/2023/04/ten-ge-li.md","raw":"---\ntitle: 腾格里\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-04-28 13:15:39\npassword:\nsummary:\ntags:\n- gallery-腾格里\ncategories:\n- gallery\nkeywords:\ndescription:\n---\n\n![6.jpg](6.jpg)\n![4.jpg](4.jpg)\n![5.jpg](5.jpg)\n![IMG_6912.JPG](IMG_6912.JPG)\n![1.jpg](1.jpg)\n![3.jpg](3.jpg)\n![2.jpg](2.jpg)\n![IMG_7069.JPG](IMG_7069.JPG)\n![IMG_6899.JPG](IMG_6899.JPG)\n","slug":"ten-ge-li","published":1,"updated":"2024-01-05T08:12:19.138Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clru1g20d000hs4fu1jtgir76","content":"<p><img src=\"/2023/04/ten-ge-li/6.jpg\" alt=\"6.jpg\"><br><img src=\"/2023/04/ten-ge-li/4.jpg\" alt=\"4.jpg\"><br><img src=\"/2023/04/ten-ge-li/5.jpg\" alt=\"5.jpg\"><br><img src=\"/2023/04/ten-ge-li/IMG_6912.JPG\" alt=\"IMG_6912.JPG\"><br><img src=\"/2023/04/ten-ge-li/1.jpg\" alt=\"1.jpg\"><br><img src=\"/2023/04/ten-ge-li/3.jpg\" alt=\"3.jpg\"><br><img src=\"/2023/04/ten-ge-li/2.jpg\" alt=\"2.jpg\"><br><img src=\"/2023/04/ten-ge-li/IMG_7069.JPG\" alt=\"IMG_7069.JPG\"><br><img src=\"/2023/04/ten-ge-li/IMG_6899.JPG\" alt=\"IMG_6899.JPG\"></p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<p><img src=\"/2023/04/ten-ge-li/6.jpg\" alt=\"6.jpg\"><br><img src=\"/2023/04/ten-ge-li/4.jpg\" alt=\"4.jpg\"><br><img src=\"/2023/04/ten-ge-li/5.jpg\" alt=\"5.jpg\"><br><img src=\"/2023/04/ten-ge-li/IMG_6912.JPG\" alt=\"IMG_6912.JPG\"><br><img src=\"/2023/04/ten-ge-li/1.jpg\" alt=\"1.jpg\"><br><img src=\"/2023/04/ten-ge-li/3.jpg\" alt=\"3.jpg\"><br><img src=\"/2023/04/ten-ge-li/2.jpg\" alt=\"2.jpg\"><br><img src=\"/2023/04/ten-ge-li/IMG_7069.JPG\" alt=\"IMG_7069.JPG\"><br><img src=\"/2023/04/ten-ge-li/IMG_6899.JPG\" alt=\"IMG_6899.JPG\"></p>\n"},{"title":"EMC-EMI","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-04-04T11:24:09.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"<blockquote>EMC=EMI+EMS</blockquote>\n<h1>1：理论概念</h1>\n<h2>1.1时域和频域</h2>\n<p>建议通过示波器的FFT变换去了解时域和频域的概念</p>\n<h2>1.2分贝</h2>\n<p>电磁兼容测试中常用单位：</p>\n<p>&nbsp; 　　功率：P<sub>db</sub>=10lg(p1/p2) P2与P1应采用相同的单位。应该明确dB为两个量的比值，是无量纲的。<br />&nbsp;　　 电压:&nbsp; 同上 电压分贝常用&mu;V为单位<br />&nbsp; 　　电流：同上 以&mu;A为单位的电流。</p>\n<p>　　&nbsp; 电场强度与磁场强度：H=E/Z <br />&nbsp; 　　功率密度：S=E X H&nbsp;&nbsp;&nbsp; 功率密度的基本单位为W/m2(电场强度V／m;磁场强度A/m),<br />功率密度的物理作用比较难理解 提供一个关系来理解：后面的db数值和一个叫自由空间波阻抗的概念有关</p>\n<pre>\n\t<code class=\"yaml\">\n在自由空间，功率密度S与电场强度E的关系化为分贝：\nSdB（W/m2）=EdB（V/m） &ndash; 25.8dB    \nSdB（mW/cm2）=EdB（&mu;V/m） &ndash; 155.8dB  \nSdB（&mu;W/cm2）=EdB（&mu;V/m） &ndash; 125.8dB\n    </code>\n</pre>\n<h2>&nbsp;1.3电场和磁场</h2>\n<p>高中概念E/H场正交同时传播 建议了解下<strong>天线模型</strong></p>\n<h2>&nbsp;1.4共模和差模</h2>\n<p>电压和电流的变化通过通过导线传输时有两中形态，即&ldquo;差模&rdquo;和&ldquo;共模&rdquo; 。 这里我们把这两根线比喻成两个小人，一个MM，一个GG。来张图，形象点</p>\n<p><img src=\"EMC-EMI/2023-04-04_19-28-04.png\" alt=\"\" /></p>\n<p>这里是两个人MM和GG，他们俩都会飞，他们手牵手飞到离地面10米的位置，那他们对地的高度即为共模信号，当他们俩一个想飞高点一个想飞低点时，这时候他们牵着飞手就会感受到拉力，这就是差模信号。也就是说这两个人是对差模信号有响应的，对共模信号没有响应。理论上讲这两个人只对差模有响应而对共模没有响应。但你让这俩人往地底下飞试试，那就苦命鸳鸯，撞死了。地下不行就去遨游太空啊，行，还是苦命鸳鸯，没空气憋死了。所以共模信号也有一定的共模范围的。差模信号也有一定差模范围。</p>\n<p>借助上面的比喻来系统理解下几个基础的概念：</p>\n<pre>\n\t<code class=\"yaml\">\n借助上面的比喻来系统理解下几个基础的概念：\n共模电压：在每一导体和所规定的参照点之间（往往是大地或机架）出现的相量电压平均值。或者说同时加在电压表两测量端和规定公共端之间的那部分输出电压。\n\n差模电压：一组规定的带电导体中任意两根之间的电压。使差模电压又称对称电压。\n\n共模干扰：干扰电压在信号线及其回线（一般称为信号地线）上的幅度相同，这里的电压以附近任何一个物体（大地、金属机箱、参考地线板等）为参考电位，干扰电流回路则是在导线与参考物体构成的回路中流动。\n简明说就是信号线到地的回路干扰。\n\n差模干扰：干扰电压存在于信号线及其回线（一般称为信号地线）之间，干扰电流回路则是在导线与参考物体构成的回路中流动。\n简明说就是信号线到信号线的回路干扰。\n    </code>\n</pre>\n<h1>2：简介</h1>\n<h2>2.1：电磁干扰形成的三要素</h2>\n<p>形成电磁干扰必然具备三个基本要素:<br />①电磁骚扰源，<br />②耦合途径或传播通道，<br />③敏感设备。<br />电磁兼容设计即是从这三个基本要素出发。<br /><img src=\"EMC-EMI/2023-04-04_19-30-08.png\" alt=\"\" /></p>\n<p>所以我们可以从3个路径来解决emc问题：1干掉干扰源 2解决传播途径问题 3优化敏感设备</p>\n<h2>2.2：电磁骚扰的传播途径</h2>\n<p>电磁骚扰的传播途径包括传导耦合（传导耦合包括互传导耦合和导线间的感性与容性耦合）和辐射耦合<br />（辐射耦合包括近场耦合和远场耦合）<br /><img src=\"EMC-EMI/2023-04-04_19-31-27.png\" alt=\"\" /></p>\n<h1>3：EMC测试类型</h1>\n<blockquote>\n<p>由于前几天做的是辐射测试这里只对EMI的辐射发射测试做分析介绍</p>\n\n</blockquote>\n<p data-pid=\"hw0JtPdM\">EMI测试项目包括：</p>\n<p data-pid=\"ajAvvm_K\">1、辐射发射测试</p>\n<p data-pid=\"aMKdQ727\">2、传导发射测试</p>\n<p data-pid=\"V4hfmcc8\">3、骚扰功率测试</p>\n<p data-pid=\"HlkauZDq\">4、电流谐波测试</p>\n<p data-pid=\"iKa3kjf2\">5、电源谐波测量</p>\n<p data-pid=\"qa38dtwO\">6、闪烁测试</p>\n<p data-pid=\"ufgEgLKt\">EMS测试项目包括：</p>\n<p data-pid=\"yJxWLW6l\">1、静电放电抗扰度</p>\n<p data-pid=\"cY_CdNFF\">2、射频电磁场抗扰度</p>\n<p data-pid=\"w_TvMw5R\">3、电快速瞬变脉冲群抗扰度</p>\n<p data-pid=\"VAiXwT4K\">4、冲击（包括雷击和浪涌）抗扰度</p>\n<p data-pid=\"4njCrycj\">5、射频场感应传导抗扰度</p>\n<p data-pid=\"_pVOSVWw\">6、工频磁场抗扰度试验</p>\n<p data-pid=\"Ejw7z-1t\">7、电压跌落短时中断和电压渐降抗扰度</p>\n<p data-pid=\"Ejw7z-1t\">具体测试方法请看《EMC设计与测试案列分析》</p>\n<h1>4：辐射发射测试</h1>\n<h2>4.1辐射发射测试的目的</h2>\n<p>　　因为EMC设计及EMC问题的分析是建立在EMC测试的基础上的，所以有必要对EMC测试做简单的阐述。测试电子，电气和机电设备及其部件的辐射发射，包括来自所有组件、电缆及连接线上的辐射发射。它用来鉴定其辐射是否符合标准的要求，以致在正常使用过程中影响同一环境中的其他设备。</p>\n<h2>4.2 常用的辐射发射测试设备</h2>\n<p>根据常用传导骚扰测试标准CISPR16及EN55022的要求，辐射发射测试主要需要以下设备：</p>\n<p>（1） EMI自动测试控制系统（电脑及其界面单元）；(2) EMI测试接收机;</p>\n<p>（3）各式天线（主动、被动棒状天线、大小形状环路天线、功率双锥天线、对数螺旋天线、喇叭天线）及天线控制单元等；</p>\n<p>&nbsp; (4)半电波暗室或开阔场。</p>\n<p>EMI测试接收机是EMC测试中最常用的基本测试仪器，基于测试接收机的频率响应特性要求，按CISPR16标准规定，测试接收机应有四种基本检波方式，即准峰值检波、均方根值检波、峰值检波及平均值检波。然而，大多数电磁干扰都是脉冲干扰，它们对音频影响的客观效果随着重复频率的增高而增大，具有特定时间常数的准峰值检波器的输出特性，可以近似反映这种影响。</p>\n<h2>4.3 辐射发射的测试方法</h2>\n<p>下图是符合CISPR16及EN55022标准要求的辐射发射测试布置图。辐射发射测试时，被测设备（EUT）置于半电波暗室内部，并在转台上旋转，以找到最大的辐射点。辐射信号由接收天线接收后，通过电缆传到电波暗室外的接收机。</p>\n<p><img src=\"EMC-EMI/2023-04-04_19-32-29.png\" alt=\"\" /></p>\n<h1>5：整改</h1>\n<p><em><strong>常见的电磁兼容整改措施：</strong></em><br />&nbsp;　　对常见的电磁兼容问题，我们通过综合采用以下几个方面的整改措施，一般可以解决大部分的问题：<br />屏蔽问题：<br />&nbsp;　　可以在屏蔽体的装配面处涂导电胶，或者在装配面处加导电衬垫，甚至采用导电金属胶带进行补救。<br />&nbsp;　　导电衬垫可以是编织的金属丝线、硬度较低易于塑型的软金属(铜、铅等)、包装金属层的橡胶、导电橡胶或者是梳状簧片接触指状物等。<br />布局布线问题：<br />&nbsp;　　在不影响性能的前提下，适当调整设备电缆走向和排列，做到不同类型的电缆相互隔离。<br />电缆问题：<br />&nbsp;　　改变普通的小信号或高频信号电缆为带屏蔽的电缆，改变普通的大电流信号或数据传输信号电缆为对称绞线电缆。</p>\n<p>接地问题：<br />　　加强接地的机械性能，降低接地电阻。同时对于设备整体要有单独的低阻抗接地。<br />接口问题：<br />&nbsp;　　在设备电源输入线上加装或串联电源滤波器。<br />关键部位的处理：<br />&nbsp;　　在可能的情况下，对重要器件进行屏蔽、隔离处理，如加装接地良好的金属隔离板或小的屏蔽罩等。<br />电路和电源问题：<br />&nbsp;　　在各器件电源输入端并联小电容，以旁路电源带来的高频干扰。</p>\n<p>现在就对我们遇到的问题做分析：电磁骚扰发射：分为传导发射（连续发射和断续发射）和辐射发射（骚扰场强和骚扰功率）</p>\n<p><em><strong>针对电磁骚扰发射测试常见问题对策及整改措施</strong></em></p>\n<p>1：产品内主要电磁骚扰源分析（电源/电机/电路板/高频器件？）</p>\n<p>2：骚扰源定位（这里我们出现了一个错误后面介绍）</p>\n<p>3：产品连续传导发射超标问题及对策</p>\n<p>4：产品断续传导发射超标问题及对策</p>\n<p>5：产品辐射骚扰超标问题及对策</p>\n<p>6：骚扰功率干扰的产生和对策</p>\n<h2>5.1：主要电磁骚扰源</h2>\n<p>a:设备开关电源的开关回路：骚扰源主频几十kHz到百余kHz，高次谐波可延伸到数十MHz。<br />b:设备直流电源的整流回路：工频线性电源工频整流噪声频率上限可延伸到数百kHz；开关电源高频整流噪声频率上限可延伸到数十MHz。<br />&nbsp;c:电动设备直流电机的电刷噪声：噪声频率上限可延伸到数百MHz。<br />&nbsp;d:电动设备交流电机的运行噪声：高次谐波可延伸到数十MHz。<br />&nbsp;e:变频调速电路的骚扰发射：开关调速回路骚扰源频率从几十kHz到几十MHz。<br />&nbsp;f:设备运行状态切换的开关噪声：由机械或电子开关动作产生的噪声频率上限可延伸到数百MHz。<br />&nbsp;g:智能控制设备的晶振及数字电路电磁骚扰：骚扰源主频几十kHz到几十MHz，高次谐波可延伸到数百MHz。<br />&nbsp;等等.................</p>\n<h2>5.2：骚扰源定位</h2>\n<p><strong>根据测量曲线定位</strong>：依据：超标骚扰频率范围、超标骚扰频域分布、窄带还是宽带骚扰等来判断<br /><br /><img src=\"EMC-EMI/2023-04-04_19-32-59.png\" alt=\"\" /></p>\n<p><img src=\"EMC-EMI/2023-04-04_19-33-05.png\" alt=\"\" /></p>\n<p><strong>根据被测设备工作方式和内部结构定位</strong>：</p>\n<p>a:有没有使用标准不建议使用的半波整流和对称/非对称电源调整电路?<br />b:内部结构中电路板布局是否合理?<br />c:内部电缆走线是否合理?</p>\n<p>d:内部滤波器（滤波电路）安装是否合理?<br />e:内部电路接地和搭接方式是否合理?<br />f:机箱屏蔽是否满足对应产品的需求?</p>\n<p><br /><strong>根据功能模块工作情况进行故障定位</strong><br />a:若设备的各个模块可以暂停和恢复工作，可以通过逐个暂停这些模块的工作来判断骚扰来源。<br />b:若模块不可以独立暂停和恢复工作，可以通过与该设备其它功能模块一起组合进行暂停和恢复工作，从而判断骚扰的大概来源。<br />c:若模块不可以独立暂停和恢复工作，也可以通过用待判断模块与其它合格设备的相关功能模块组合并测量的方式，从而判断骚扰的大概来源。<br />d:对怀疑骚扰超标的模块，可以用与合格模块置换的方式来进行骚扰判定。<br />但是需要注意的是不能测试完一个模块发现没有起到作用又将这个模块恢复到初始状态 这个时候应该保持更改不变 继续下一个模块的排查，我们在最初的排查过程中就犯了这个错误，导致浪费了测试时间。<br />下面去个例子说明：</p>\n<p>　　假设一个系统在测试时出现了辐射发射超标，使系统不能满足EMC标准中对辐射发射的限值。经过初步分析，原因可能有4个，它们分别是：</p>\n<p>（1）主机与键盘之间的互连电缆（电缆1）上的共模电流产生的辐射；</p>\n<p>（2）主机与打印机之间的互连电缆（电缆2）上的共模电流产生的辐射；</p>\n<p>（3）机箱面板与机箱基体之间的缝隙（开口1）产生的泄漏；</p>\n<p>（4）某显示窗口（开口2）产生的泄漏。</p>\n<p>在诊断时，首先在电缆1上套一个铁氧体磁环，以减小共模辐射，结果发现频谱仪屏幕上显示的信号并没有明显减小。于是认为电缆1不是一个主要的泄漏源，将铁氧体磁环取下，套在电缆2上，结果发现频谱仪屏幕上显示的信号还没有明显减小。结果得出结论，电缆不是泄漏源。</p>\n<p>再对机箱上的泄漏进行检查。用屏蔽胶带将开口1堵上，发现频谱仪屏幕上显示的信号没有明显减小。认为开口1不是主要泄漏源，将屏蔽胶带取下，堵到开口2上。结果频谱仪上的显示信号还没有减小。之所以会发生这个问题，是因为测试人员忽视了频谱分析仪上显示的信号幅度是以dB为单位显示的。下面看一下为什么会有这种现象。</p>\n<p>假设这4个泄漏源所占的成分各占1／4，并且在每个辐射源上采取的措施能够将这个辐射源完全抑制掉，则采取以上4个措施中的一个时，频谱仪上显示信号降低的幅度&Delta;A为</p>\n<p>&Delta;A=20lg(4/3)=2.5 dB</p>\n<p>幅度减小这么少，显然是微不足道的。但这却已经将泄漏减少了25％。</p>\n<p>正确的方法是，在对一个可能的泄漏源采取了抑制措施后，即使没有明显的改善，也不要将这个措施去掉，继续对可能的泄漏源采取措施。当采取到某个措施时，如果干扰幅度降低很多，并不一定说明这个泄漏源是主要的，而仅说明这个干扰源是最后一个。按照这个步骤对4个泄漏源逐个处理的结果如图</p>\n\n<img src=\"EMC-EMI/2023-04-04_19-33-48.png\" alt=\"\" />\n<p>在前面的叙述中，假定对某个泄漏源采取措施后，这个泄漏源被100％消除掉，如果这样，当最后一个泄漏源去掉后，电磁干扰的减小应为无限大。实际这是不可能的。在采取任何一个措施时，都不可能将干扰源100％消除。泄漏源去掉的程度可以是99％，或99.9％，甚至99.99％以上，而绝不可能是100％，所以当最后一个泄漏源去掉后，尽管改善很大，但仍是有限值。</p>\n<h2>5.3：连续传导发射超标问题及对策</h2>\n<p><strong>连续传导骚扰的主要来源：</strong></p>\n<p>a:开关电源的开关频率及谐波骚扰<br />b:电源整流回路的整流噪声<br />c:交流电机的运行噪声</p>\n<p>d:直流电机的电刷噪声</p>\n<p>e:智能控制设备的晶振</p>\n<p>f:数字电路电磁骚扰<br /><strong>导致射频传导发射超标的原因如图所示:</strong><br /><img src=\"EMC-EMI/2023-04-04_19-34-25.png\" alt=\"\" /></p>\n<p>（1）开关电源或DC/DC变换器工作在脉冲状态，它们本身会产生很强的干扰，这种干扰既有共模分量，也有差模分量。对于一般开关电源和变换器，在1MHz以下以差模干扰为主，在1MHz以上以共模干扰为主。<br />（2）数字电路的工作电流是瞬变的，虽然在每个电路芯片的旁边和线路板上都安装了解耦电容，但还是会有一部分瞬变电流反映在电源中，沿着电源线传导发射。<br />（3）机箱内的线路板、电缆都是辐射源，这些辐射能量会感应进电源线和电源电路本身，形成传导发射。需要注意的是，当机箱内各种频率的信号耦合进电源电路时，由于电源内有许多二极管、三极管电路，会使这些不同频率的信号相互发生混频、调制，甚至对干扰进行放大，从而导致严重的干扰。<br /><strong>解决方法：</strong></p>\n<p>在电源线入口处安装电源线滤波器是保证通过射频传导发射试验的唯一方法（滤波器的安装位置也很重要）。<br />如果仅做150kHz~30MHz范围内的传导发射试验，一般的电源线滤波器就可以满足要求，大部分电源线滤波器在100kHz以上都已有较大的插入损耗。由于30MHz以上的高频性能不良会导致辐射发射的问题，所以应加以注意。如果需要做30~300MHz频率范围内的骚扰功率发射试验或30~1GHz频率范围内的辐射骚扰，选择滤波器时必须注意滤波器的高频特性。</p>\n<p>对电源线的处理：<br />（1）检查电源线附近有无信号电缆存在，有无可能是因为信号电缆与电源线之间的耦合使电源线的传导骚扰发射超标（这种情况多见于超标频率的频段较高的情况下）。如有，或拉大两者间的距离，或采取屏蔽措施。<br />（2）加装电源线滤波器（如果已经有滤波器。则换用高性能的滤波器），要特别注意安装位置（尽可能放在机箱中电源线入口端）和安装情况，要保证滤波器外壳与机箱搭接良好、接地良好。<br />（3）虽经采取措施，设备传导骚扰发射仍未达标。此时可考虑在设备内部线路连接接地端子的地方串入一个电感。由于这部分连接属单点接地，平时无电流流过，因此这个电感可以做得较大，而无需担心有铁芯的饱和问题。<br />采取这一措施的理由是设备传导骚扰发射测试实际上是对地电压测试（电源线对大地的骚扰电压测试），电源线上有工作电流流过，故滤波器的滤波电感值受制于工作电流，不能做得很大，滤波器的插入损耗也就有限，特别是低频端损耗更加有限。新方案里的附加电感正好可以弥补这一缺憾，从而取得更好的传导骚扰抑制能力。<br />对信号线的处理：<br />（1）注意信号线周围有无其他辐射能量（附近的布线及印刷板的布局）被引到信号线上。如有，或拉大两者的距离，或采取屏蔽措施，或考虑改变设备内部布局和印刷板的布局。<br />（2）在信号线上套铁氧体磁环（或铁氧体磁夹）。<br />（3）对信号线进行共模滤波，必要时采用滤波连接器（或滤波阵列板）。注意滤波器的参数，传导骚扰发射超标的频率比辐射骚扰发射超标的频率应低些，因此取用的元件参数应当偏大一些</p>\n<h2>5.4：断续传导发射超标问题及对策</h2>\n<p><strong>断续传导骚扰的主要来源：</strong></p>\n<p>a:恒温控制器具，程序自动的机器和其他电气控制或操作的器具的开关操作会产生断续骚扰。此类操作一般通过继电器和程控电子/机械开关等实现。此类骚扰一般由继电器、开关的触点抖动及非纯阻负载通断所产生的电涌冲击形成。<br /><strong>解决方法：</strong><br />从内部电路和结构上考虑，减少其断续骚扰，使其满足测量要求。<br />从电源电路和电源结构入手，在电源中采取适当的措施，对内部电路产生的断续骚扰加以抑制，使其满足测量标准的要求。<br />a:在开关触点或开关模块两端并联高频电容或RC、DRC吸波网络，吸收开关抖动脉冲及非阻性负载的浪涌脉冲。 同时应留意这些元器件的耐压和功率承受能力应满足设备正常工作的要求。<br />b:对被供电设备内通过程控开关控制的非阻性部件的供电回路上增加限流电路或软启动装置，抑制其启动浪涌冲击。<br />c:对被供电设备内通过开关量控制的感性部件应增加反向浪涌吸收元件，以吸收部件断电时产生的反向感应高压浪涌冲击。<br />d:在被供电设备的电源输入端增加高频吸收回路，抑制其高频骚扰向电源反向注入。</p>\n<h2>5.5：辐射骚扰超标问题及对策</h2>\n<p><strong>辐射骚扰的主要骚扰来源:</strong><br />a:开关电源的开关频率及谐波骚扰<br />b:交流电机的运行噪声、直流电机的电刷噪声<br />c:电磁感应设备的电磁骚扰<br />d:智能控制设备的晶振及数字电路电磁骚扰等</p>\n<p>导致辐射发射试验失败的原因有两种可能最大：</p>\n<p>　　一种是设备外壳的屏蔽性能不完善；<br />　　另一种是射频骚扰经由电源线和其他线缆的逸出。<br /><br /><strong>解决方法：</strong><br /><img src=\"EMC-EMI/2023-04-04_19-35-03.png\" alt=\"\" /></p>\n<p>当我们通过骚扰定位方式找到辐射骚扰超标点的骚扰源后，即可采用相对应的骚扰源抑制措施。<br />一般来说：<br />首先抑制骚扰源，这可以通过优化电路设计、电路结构和排版，加强滤波和正确的接地来达到。<br />其次是要切断耦合途径，这可以通过正确的机壳屏蔽和传输线滤波达到。<br /><strong>首先说下机箱问题：</strong></p>\n<p>一、金属机箱屏蔽性能不完善（非金属机箱还没碰到不做讨论）<br />对于金属机箱屏蔽性能不完善引起的辐射骚扰发射超标，应采取以下措施：<br />1）机箱的缝隙过大，或机箱配合上存在问题<br />　处理意见：<br />（1）清除结合面上的油漆、氧化层及表面玷污；<br />（2）增加结合面上的紧固件数目及接触表面的平整度；<br />（3）采取永久性的接缝（要连续焊接）；<br />（4）采用导电衬垫来改善接触表面的接触性能。<br />2）其他功能性开孔过大<br />处理意见：<br />（1）通风口采用防尘板，必要时采用波导通风板，但后者成本昂贵；<br />（2）显示窗口采用带有屏蔽作用的透明材料；或采用隔舱，并对信号线采取滤波措施；<br />（3）对键盘等采用隔舱，并对信号线采取滤波措施。<br />3）机箱内部布线不当，电磁骚扰透过缝隙逸出<br />处理意见：<br />&nbsp; 将印刷板及设备内部布线等可能产生辐射骚扰的布局，远离缝隙或功能性开孔的部位，<br />&nbsp; 或采取增加屏蔽的补救措施或重新布局。<br /><strong>其次说下线缆问题：</strong><br />1）对电源线的处理<br />（1）加装电源线滤波器（如果己经有滤波器，则换用高性能的滤波器），要特别注意安装位置（尽可能放在机箱中电源线入口端）和安装情况，要保证滤波器外壳与机箱搭接良好、接地良好；<br />（2）如果不合格的频率比较高，可考虑在电源线入口的部分套装铁氧体磁环。<br />2）对信号线的处理<br />（1）在信号线上套铁氧体磁环（或铁氧体磁夹）；<br />（2）对信号线滤波（共模滤波），必要时将连接器改用滤波阵列板或滤波连接器；<br />（3）换用屏蔽电缆，屏蔽电缆的屏蔽层与机箱尽量采用360&deg;搭接方式，必要时在屏蔽线上再套铁氧体磁环</p>\n<h2>5.6：骚扰功率干扰的产生和对策</h2>\n<p><strong>骚扰功率的主要来源：</strong></p>\n<p>a:电源线滤波装置的高频插入损耗不足</p>\n<p><strong>解决方法：</strong></p>\n<p>（1）滤波器电路没有屏蔽，这种情况经常发生在将滤波电路安装在线路板上的场合，高频干扰直接耦合进滤波电路，造成滤波器失效；<br />（2）滤波器本身高频性能不良，在100MHz以上插入损耗很小；<br />（3）使用非屏蔽机箱，导致滤波器的金属外壳无处端接；<strong><br /></strong>（4）使用非屏蔽机箱，干扰直接耦合到电源线和信号线上，滤波器实际上没有起作用；<br />（5）在屏蔽机箱中，滤波器离电源进口过远、造成干扰直接耦合到电源线和信号线上；<br />（6）在屏蔽机箱中，滤波器外壳与金属机箱之间连接阻抗过大（没有直接搭接，而是通过长导线连接）；<br />（7）滤波器的输入线与输出线靠得很近，发生耦合，导致滤波器的高频插人损耗不足。<strong><br /><br /></strong></p>\n<p><strong>参考书籍:&lt;EMC（电磁兼容）设计与测试案例分析 郑军奇编著 电子工业出版社&gt;</strong></p>\n<p><strong>看书的时候整理了一下导图无私分享下：</strong></p>\n<div class=\"cnblogs_Highlighter\">\n<pre class=\"brush:csharp;gutter:true;\">git@gitee.com:qian-qiang/book-map.git\n</pre>\n</div>\n<p>&nbsp;</p>\n","source":"_posts/2023/04/EMC-EMI.md","raw":"---\ntitle: EMC-EMI\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-04-04 19:24:09\npassword:\nsummary:\ntags:\n- EMC-EMI\ncategories:\n- 硬件\nkeywords:\ndescription:\n---\n<blockquote>EMC=EMI+EMS</blockquote>\n<h1>1：理论概念</h1>\n<h2>1.1时域和频域</h2>\n<p>建议通过示波器的FFT变换去了解时域和频域的概念</p>\n<h2>1.2分贝</h2>\n<p>电磁兼容测试中常用单位：</p>\n<p>&nbsp; 　　功率：P<sub>db</sub>=10lg(p1/p2) P2与P1应采用相同的单位。应该明确dB为两个量的比值，是无量纲的。<br />&nbsp;　　 电压:&nbsp; 同上 电压分贝常用&mu;V为单位<br />&nbsp; 　　电流：同上 以&mu;A为单位的电流。</p>\n<p>　　&nbsp; 电场强度与磁场强度：H=E/Z <br />&nbsp; 　　功率密度：S=E X H&nbsp;&nbsp;&nbsp; 功率密度的基本单位为W/m2(电场强度V／m;磁场强度A/m),<br />功率密度的物理作用比较难理解 提供一个关系来理解：后面的db数值和一个叫自由空间波阻抗的概念有关</p>\n<pre>\n\t<code class=\"yaml\">\n在自由空间，功率密度S与电场强度E的关系化为分贝：\nSdB（W/m2）=EdB（V/m） &ndash; 25.8dB    \nSdB（mW/cm2）=EdB（&mu;V/m） &ndash; 155.8dB  \nSdB（&mu;W/cm2）=EdB（&mu;V/m） &ndash; 125.8dB\n    </code>\n</pre>\n<h2>&nbsp;1.3电场和磁场</h2>\n<p>高中概念E/H场正交同时传播 建议了解下<strong>天线模型</strong></p>\n<h2>&nbsp;1.4共模和差模</h2>\n<p>电压和电流的变化通过通过导线传输时有两中形态，即&ldquo;差模&rdquo;和&ldquo;共模&rdquo; 。 这里我们把这两根线比喻成两个小人，一个MM，一个GG。来张图，形象点</p>\n<p><img src=\"EMC-EMI/2023-04-04_19-28-04.png\" alt=\"\" /></p>\n<p>这里是两个人MM和GG，他们俩都会飞，他们手牵手飞到离地面10米的位置，那他们对地的高度即为共模信号，当他们俩一个想飞高点一个想飞低点时，这时候他们牵着飞手就会感受到拉力，这就是差模信号。也就是说这两个人是对差模信号有响应的，对共模信号没有响应。理论上讲这两个人只对差模有响应而对共模没有响应。但你让这俩人往地底下飞试试，那就苦命鸳鸯，撞死了。地下不行就去遨游太空啊，行，还是苦命鸳鸯，没空气憋死了。所以共模信号也有一定的共模范围的。差模信号也有一定差模范围。</p>\n<p>借助上面的比喻来系统理解下几个基础的概念：</p>\n<pre>\n\t<code class=\"yaml\">\n借助上面的比喻来系统理解下几个基础的概念：\n共模电压：在每一导体和所规定的参照点之间（往往是大地或机架）出现的相量电压平均值。或者说同时加在电压表两测量端和规定公共端之间的那部分输出电压。\n\n差模电压：一组规定的带电导体中任意两根之间的电压。使差模电压又称对称电压。\n\n共模干扰：干扰电压在信号线及其回线（一般称为信号地线）上的幅度相同，这里的电压以附近任何一个物体（大地、金属机箱、参考地线板等）为参考电位，干扰电流回路则是在导线与参考物体构成的回路中流动。\n简明说就是信号线到地的回路干扰。\n\n差模干扰：干扰电压存在于信号线及其回线（一般称为信号地线）之间，干扰电流回路则是在导线与参考物体构成的回路中流动。\n简明说就是信号线到信号线的回路干扰。\n    </code>\n</pre>\n<h1>2：简介</h1>\n<h2>2.1：电磁干扰形成的三要素</h2>\n<p>形成电磁干扰必然具备三个基本要素:<br />①电磁骚扰源，<br />②耦合途径或传播通道，<br />③敏感设备。<br />电磁兼容设计即是从这三个基本要素出发。<br /><img src=\"EMC-EMI/2023-04-04_19-30-08.png\" alt=\"\" /></p>\n<p>所以我们可以从3个路径来解决emc问题：1干掉干扰源 2解决传播途径问题 3优化敏感设备</p>\n<h2>2.2：电磁骚扰的传播途径</h2>\n<p>电磁骚扰的传播途径包括传导耦合（传导耦合包括互传导耦合和导线间的感性与容性耦合）和辐射耦合<br />（辐射耦合包括近场耦合和远场耦合）<br /><img src=\"EMC-EMI/2023-04-04_19-31-27.png\" alt=\"\" /></p>\n<h1>3：EMC测试类型</h1>\n<blockquote>\n<p>由于前几天做的是辐射测试这里只对EMI的辐射发射测试做分析介绍</p>\n\n</blockquote>\n<p data-pid=\"hw0JtPdM\">EMI测试项目包括：</p>\n<p data-pid=\"ajAvvm_K\">1、辐射发射测试</p>\n<p data-pid=\"aMKdQ727\">2、传导发射测试</p>\n<p data-pid=\"V4hfmcc8\">3、骚扰功率测试</p>\n<p data-pid=\"HlkauZDq\">4、电流谐波测试</p>\n<p data-pid=\"iKa3kjf2\">5、电源谐波测量</p>\n<p data-pid=\"qa38dtwO\">6、闪烁测试</p>\n<p data-pid=\"ufgEgLKt\">EMS测试项目包括：</p>\n<p data-pid=\"yJxWLW6l\">1、静电放电抗扰度</p>\n<p data-pid=\"cY_CdNFF\">2、射频电磁场抗扰度</p>\n<p data-pid=\"w_TvMw5R\">3、电快速瞬变脉冲群抗扰度</p>\n<p data-pid=\"VAiXwT4K\">4、冲击（包括雷击和浪涌）抗扰度</p>\n<p data-pid=\"4njCrycj\">5、射频场感应传导抗扰度</p>\n<p data-pid=\"_pVOSVWw\">6、工频磁场抗扰度试验</p>\n<p data-pid=\"Ejw7z-1t\">7、电压跌落短时中断和电压渐降抗扰度</p>\n<p data-pid=\"Ejw7z-1t\">具体测试方法请看《EMC设计与测试案列分析》</p>\n<h1>4：辐射发射测试</h1>\n<h2>4.1辐射发射测试的目的</h2>\n<p>　　因为EMC设计及EMC问题的分析是建立在EMC测试的基础上的，所以有必要对EMC测试做简单的阐述。测试电子，电气和机电设备及其部件的辐射发射，包括来自所有组件、电缆及连接线上的辐射发射。它用来鉴定其辐射是否符合标准的要求，以致在正常使用过程中影响同一环境中的其他设备。</p>\n<h2>4.2 常用的辐射发射测试设备</h2>\n<p>根据常用传导骚扰测试标准CISPR16及EN55022的要求，辐射发射测试主要需要以下设备：</p>\n<p>（1） EMI自动测试控制系统（电脑及其界面单元）；(2) EMI测试接收机;</p>\n<p>（3）各式天线（主动、被动棒状天线、大小形状环路天线、功率双锥天线、对数螺旋天线、喇叭天线）及天线控制单元等；</p>\n<p>&nbsp; (4)半电波暗室或开阔场。</p>\n<p>EMI测试接收机是EMC测试中最常用的基本测试仪器，基于测试接收机的频率响应特性要求，按CISPR16标准规定，测试接收机应有四种基本检波方式，即准峰值检波、均方根值检波、峰值检波及平均值检波。然而，大多数电磁干扰都是脉冲干扰，它们对音频影响的客观效果随着重复频率的增高而增大，具有特定时间常数的准峰值检波器的输出特性，可以近似反映这种影响。</p>\n<h2>4.3 辐射发射的测试方法</h2>\n<p>下图是符合CISPR16及EN55022标准要求的辐射发射测试布置图。辐射发射测试时，被测设备（EUT）置于半电波暗室内部，并在转台上旋转，以找到最大的辐射点。辐射信号由接收天线接收后，通过电缆传到电波暗室外的接收机。</p>\n<p><img src=\"EMC-EMI/2023-04-04_19-32-29.png\" alt=\"\" /></p>\n<h1>5：整改</h1>\n<p><em><strong>常见的电磁兼容整改措施：</strong></em><br />&nbsp;　　对常见的电磁兼容问题，我们通过综合采用以下几个方面的整改措施，一般可以解决大部分的问题：<br />屏蔽问题：<br />&nbsp;　　可以在屏蔽体的装配面处涂导电胶，或者在装配面处加导电衬垫，甚至采用导电金属胶带进行补救。<br />&nbsp;　　导电衬垫可以是编织的金属丝线、硬度较低易于塑型的软金属(铜、铅等)、包装金属层的橡胶、导电橡胶或者是梳状簧片接触指状物等。<br />布局布线问题：<br />&nbsp;　　在不影响性能的前提下，适当调整设备电缆走向和排列，做到不同类型的电缆相互隔离。<br />电缆问题：<br />&nbsp;　　改变普通的小信号或高频信号电缆为带屏蔽的电缆，改变普通的大电流信号或数据传输信号电缆为对称绞线电缆。</p>\n<p>接地问题：<br />　　加强接地的机械性能，降低接地电阻。同时对于设备整体要有单独的低阻抗接地。<br />接口问题：<br />&nbsp;　　在设备电源输入线上加装或串联电源滤波器。<br />关键部位的处理：<br />&nbsp;　　在可能的情况下，对重要器件进行屏蔽、隔离处理，如加装接地良好的金属隔离板或小的屏蔽罩等。<br />电路和电源问题：<br />&nbsp;　　在各器件电源输入端并联小电容，以旁路电源带来的高频干扰。</p>\n<p>现在就对我们遇到的问题做分析：电磁骚扰发射：分为传导发射（连续发射和断续发射）和辐射发射（骚扰场强和骚扰功率）</p>\n<p><em><strong>针对电磁骚扰发射测试常见问题对策及整改措施</strong></em></p>\n<p>1：产品内主要电磁骚扰源分析（电源/电机/电路板/高频器件？）</p>\n<p>2：骚扰源定位（这里我们出现了一个错误后面介绍）</p>\n<p>3：产品连续传导发射超标问题及对策</p>\n<p>4：产品断续传导发射超标问题及对策</p>\n<p>5：产品辐射骚扰超标问题及对策</p>\n<p>6：骚扰功率干扰的产生和对策</p>\n<h2>5.1：主要电磁骚扰源</h2>\n<p>a:设备开关电源的开关回路：骚扰源主频几十kHz到百余kHz，高次谐波可延伸到数十MHz。<br />b:设备直流电源的整流回路：工频线性电源工频整流噪声频率上限可延伸到数百kHz；开关电源高频整流噪声频率上限可延伸到数十MHz。<br />&nbsp;c:电动设备直流电机的电刷噪声：噪声频率上限可延伸到数百MHz。<br />&nbsp;d:电动设备交流电机的运行噪声：高次谐波可延伸到数十MHz。<br />&nbsp;e:变频调速电路的骚扰发射：开关调速回路骚扰源频率从几十kHz到几十MHz。<br />&nbsp;f:设备运行状态切换的开关噪声：由机械或电子开关动作产生的噪声频率上限可延伸到数百MHz。<br />&nbsp;g:智能控制设备的晶振及数字电路电磁骚扰：骚扰源主频几十kHz到几十MHz，高次谐波可延伸到数百MHz。<br />&nbsp;等等.................</p>\n<h2>5.2：骚扰源定位</h2>\n<p><strong>根据测量曲线定位</strong>：依据：超标骚扰频率范围、超标骚扰频域分布、窄带还是宽带骚扰等来判断<br /><br /><img src=\"EMC-EMI/2023-04-04_19-32-59.png\" alt=\"\" /></p>\n<p><img src=\"EMC-EMI/2023-04-04_19-33-05.png\" alt=\"\" /></p>\n<p><strong>根据被测设备工作方式和内部结构定位</strong>：</p>\n<p>a:有没有使用标准不建议使用的半波整流和对称/非对称电源调整电路?<br />b:内部结构中电路板布局是否合理?<br />c:内部电缆走线是否合理?</p>\n<p>d:内部滤波器（滤波电路）安装是否合理?<br />e:内部电路接地和搭接方式是否合理?<br />f:机箱屏蔽是否满足对应产品的需求?</p>\n<p><br /><strong>根据功能模块工作情况进行故障定位</strong><br />a:若设备的各个模块可以暂停和恢复工作，可以通过逐个暂停这些模块的工作来判断骚扰来源。<br />b:若模块不可以独立暂停和恢复工作，可以通过与该设备其它功能模块一起组合进行暂停和恢复工作，从而判断骚扰的大概来源。<br />c:若模块不可以独立暂停和恢复工作，也可以通过用待判断模块与其它合格设备的相关功能模块组合并测量的方式，从而判断骚扰的大概来源。<br />d:对怀疑骚扰超标的模块，可以用与合格模块置换的方式来进行骚扰判定。<br />但是需要注意的是不能测试完一个模块发现没有起到作用又将这个模块恢复到初始状态 这个时候应该保持更改不变 继续下一个模块的排查，我们在最初的排查过程中就犯了这个错误，导致浪费了测试时间。<br />下面去个例子说明：</p>\n<p>　　假设一个系统在测试时出现了辐射发射超标，使系统不能满足EMC标准中对辐射发射的限值。经过初步分析，原因可能有4个，它们分别是：</p>\n<p>（1）主机与键盘之间的互连电缆（电缆1）上的共模电流产生的辐射；</p>\n<p>（2）主机与打印机之间的互连电缆（电缆2）上的共模电流产生的辐射；</p>\n<p>（3）机箱面板与机箱基体之间的缝隙（开口1）产生的泄漏；</p>\n<p>（4）某显示窗口（开口2）产生的泄漏。</p>\n<p>在诊断时，首先在电缆1上套一个铁氧体磁环，以减小共模辐射，结果发现频谱仪屏幕上显示的信号并没有明显减小。于是认为电缆1不是一个主要的泄漏源，将铁氧体磁环取下，套在电缆2上，结果发现频谱仪屏幕上显示的信号还没有明显减小。结果得出结论，电缆不是泄漏源。</p>\n<p>再对机箱上的泄漏进行检查。用屏蔽胶带将开口1堵上，发现频谱仪屏幕上显示的信号没有明显减小。认为开口1不是主要泄漏源，将屏蔽胶带取下，堵到开口2上。结果频谱仪上的显示信号还没有减小。之所以会发生这个问题，是因为测试人员忽视了频谱分析仪上显示的信号幅度是以dB为单位显示的。下面看一下为什么会有这种现象。</p>\n<p>假设这4个泄漏源所占的成分各占1／4，并且在每个辐射源上采取的措施能够将这个辐射源完全抑制掉，则采取以上4个措施中的一个时，频谱仪上显示信号降低的幅度&Delta;A为</p>\n<p>&Delta;A=20lg(4/3)=2.5 dB</p>\n<p>幅度减小这么少，显然是微不足道的。但这却已经将泄漏减少了25％。</p>\n<p>正确的方法是，在对一个可能的泄漏源采取了抑制措施后，即使没有明显的改善，也不要将这个措施去掉，继续对可能的泄漏源采取措施。当采取到某个措施时，如果干扰幅度降低很多，并不一定说明这个泄漏源是主要的，而仅说明这个干扰源是最后一个。按照这个步骤对4个泄漏源逐个处理的结果如图</p>\n\n<img src=\"EMC-EMI/2023-04-04_19-33-48.png\" alt=\"\" />\n<p>在前面的叙述中，假定对某个泄漏源采取措施后，这个泄漏源被100％消除掉，如果这样，当最后一个泄漏源去掉后，电磁干扰的减小应为无限大。实际这是不可能的。在采取任何一个措施时，都不可能将干扰源100％消除。泄漏源去掉的程度可以是99％，或99.9％，甚至99.99％以上，而绝不可能是100％，所以当最后一个泄漏源去掉后，尽管改善很大，但仍是有限值。</p>\n<h2>5.3：连续传导发射超标问题及对策</h2>\n<p><strong>连续传导骚扰的主要来源：</strong></p>\n<p>a:开关电源的开关频率及谐波骚扰<br />b:电源整流回路的整流噪声<br />c:交流电机的运行噪声</p>\n<p>d:直流电机的电刷噪声</p>\n<p>e:智能控制设备的晶振</p>\n<p>f:数字电路电磁骚扰<br /><strong>导致射频传导发射超标的原因如图所示:</strong><br /><img src=\"EMC-EMI/2023-04-04_19-34-25.png\" alt=\"\" /></p>\n<p>（1）开关电源或DC/DC变换器工作在脉冲状态，它们本身会产生很强的干扰，这种干扰既有共模分量，也有差模分量。对于一般开关电源和变换器，在1MHz以下以差模干扰为主，在1MHz以上以共模干扰为主。<br />（2）数字电路的工作电流是瞬变的，虽然在每个电路芯片的旁边和线路板上都安装了解耦电容，但还是会有一部分瞬变电流反映在电源中，沿着电源线传导发射。<br />（3）机箱内的线路板、电缆都是辐射源，这些辐射能量会感应进电源线和电源电路本身，形成传导发射。需要注意的是，当机箱内各种频率的信号耦合进电源电路时，由于电源内有许多二极管、三极管电路，会使这些不同频率的信号相互发生混频、调制，甚至对干扰进行放大，从而导致严重的干扰。<br /><strong>解决方法：</strong></p>\n<p>在电源线入口处安装电源线滤波器是保证通过射频传导发射试验的唯一方法（滤波器的安装位置也很重要）。<br />如果仅做150kHz~30MHz范围内的传导发射试验，一般的电源线滤波器就可以满足要求，大部分电源线滤波器在100kHz以上都已有较大的插入损耗。由于30MHz以上的高频性能不良会导致辐射发射的问题，所以应加以注意。如果需要做30~300MHz频率范围内的骚扰功率发射试验或30~1GHz频率范围内的辐射骚扰，选择滤波器时必须注意滤波器的高频特性。</p>\n<p>对电源线的处理：<br />（1）检查电源线附近有无信号电缆存在，有无可能是因为信号电缆与电源线之间的耦合使电源线的传导骚扰发射超标（这种情况多见于超标频率的频段较高的情况下）。如有，或拉大两者间的距离，或采取屏蔽措施。<br />（2）加装电源线滤波器（如果已经有滤波器。则换用高性能的滤波器），要特别注意安装位置（尽可能放在机箱中电源线入口端）和安装情况，要保证滤波器外壳与机箱搭接良好、接地良好。<br />（3）虽经采取措施，设备传导骚扰发射仍未达标。此时可考虑在设备内部线路连接接地端子的地方串入一个电感。由于这部分连接属单点接地，平时无电流流过，因此这个电感可以做得较大，而无需担心有铁芯的饱和问题。<br />采取这一措施的理由是设备传导骚扰发射测试实际上是对地电压测试（电源线对大地的骚扰电压测试），电源线上有工作电流流过，故滤波器的滤波电感值受制于工作电流，不能做得很大，滤波器的插入损耗也就有限，特别是低频端损耗更加有限。新方案里的附加电感正好可以弥补这一缺憾，从而取得更好的传导骚扰抑制能力。<br />对信号线的处理：<br />（1）注意信号线周围有无其他辐射能量（附近的布线及印刷板的布局）被引到信号线上。如有，或拉大两者的距离，或采取屏蔽措施，或考虑改变设备内部布局和印刷板的布局。<br />（2）在信号线上套铁氧体磁环（或铁氧体磁夹）。<br />（3）对信号线进行共模滤波，必要时采用滤波连接器（或滤波阵列板）。注意滤波器的参数，传导骚扰发射超标的频率比辐射骚扰发射超标的频率应低些，因此取用的元件参数应当偏大一些</p>\n<h2>5.4：断续传导发射超标问题及对策</h2>\n<p><strong>断续传导骚扰的主要来源：</strong></p>\n<p>a:恒温控制器具，程序自动的机器和其他电气控制或操作的器具的开关操作会产生断续骚扰。此类操作一般通过继电器和程控电子/机械开关等实现。此类骚扰一般由继电器、开关的触点抖动及非纯阻负载通断所产生的电涌冲击形成。<br /><strong>解决方法：</strong><br />从内部电路和结构上考虑，减少其断续骚扰，使其满足测量要求。<br />从电源电路和电源结构入手，在电源中采取适当的措施，对内部电路产生的断续骚扰加以抑制，使其满足测量标准的要求。<br />a:在开关触点或开关模块两端并联高频电容或RC、DRC吸波网络，吸收开关抖动脉冲及非阻性负载的浪涌脉冲。 同时应留意这些元器件的耐压和功率承受能力应满足设备正常工作的要求。<br />b:对被供电设备内通过程控开关控制的非阻性部件的供电回路上增加限流电路或软启动装置，抑制其启动浪涌冲击。<br />c:对被供电设备内通过开关量控制的感性部件应增加反向浪涌吸收元件，以吸收部件断电时产生的反向感应高压浪涌冲击。<br />d:在被供电设备的电源输入端增加高频吸收回路，抑制其高频骚扰向电源反向注入。</p>\n<h2>5.5：辐射骚扰超标问题及对策</h2>\n<p><strong>辐射骚扰的主要骚扰来源:</strong><br />a:开关电源的开关频率及谐波骚扰<br />b:交流电机的运行噪声、直流电机的电刷噪声<br />c:电磁感应设备的电磁骚扰<br />d:智能控制设备的晶振及数字电路电磁骚扰等</p>\n<p>导致辐射发射试验失败的原因有两种可能最大：</p>\n<p>　　一种是设备外壳的屏蔽性能不完善；<br />　　另一种是射频骚扰经由电源线和其他线缆的逸出。<br /><br /><strong>解决方法：</strong><br /><img src=\"EMC-EMI/2023-04-04_19-35-03.png\" alt=\"\" /></p>\n<p>当我们通过骚扰定位方式找到辐射骚扰超标点的骚扰源后，即可采用相对应的骚扰源抑制措施。<br />一般来说：<br />首先抑制骚扰源，这可以通过优化电路设计、电路结构和排版，加强滤波和正确的接地来达到。<br />其次是要切断耦合途径，这可以通过正确的机壳屏蔽和传输线滤波达到。<br /><strong>首先说下机箱问题：</strong></p>\n<p>一、金属机箱屏蔽性能不完善（非金属机箱还没碰到不做讨论）<br />对于金属机箱屏蔽性能不完善引起的辐射骚扰发射超标，应采取以下措施：<br />1）机箱的缝隙过大，或机箱配合上存在问题<br />　处理意见：<br />（1）清除结合面上的油漆、氧化层及表面玷污；<br />（2）增加结合面上的紧固件数目及接触表面的平整度；<br />（3）采取永久性的接缝（要连续焊接）；<br />（4）采用导电衬垫来改善接触表面的接触性能。<br />2）其他功能性开孔过大<br />处理意见：<br />（1）通风口采用防尘板，必要时采用波导通风板，但后者成本昂贵；<br />（2）显示窗口采用带有屏蔽作用的透明材料；或采用隔舱，并对信号线采取滤波措施；<br />（3）对键盘等采用隔舱，并对信号线采取滤波措施。<br />3）机箱内部布线不当，电磁骚扰透过缝隙逸出<br />处理意见：<br />&nbsp; 将印刷板及设备内部布线等可能产生辐射骚扰的布局，远离缝隙或功能性开孔的部位，<br />&nbsp; 或采取增加屏蔽的补救措施或重新布局。<br /><strong>其次说下线缆问题：</strong><br />1）对电源线的处理<br />（1）加装电源线滤波器（如果己经有滤波器，则换用高性能的滤波器），要特别注意安装位置（尽可能放在机箱中电源线入口端）和安装情况，要保证滤波器外壳与机箱搭接良好、接地良好；<br />（2）如果不合格的频率比较高，可考虑在电源线入口的部分套装铁氧体磁环。<br />2）对信号线的处理<br />（1）在信号线上套铁氧体磁环（或铁氧体磁夹）；<br />（2）对信号线滤波（共模滤波），必要时将连接器改用滤波阵列板或滤波连接器；<br />（3）换用屏蔽电缆，屏蔽电缆的屏蔽层与机箱尽量采用360&deg;搭接方式，必要时在屏蔽线上再套铁氧体磁环</p>\n<h2>5.6：骚扰功率干扰的产生和对策</h2>\n<p><strong>骚扰功率的主要来源：</strong></p>\n<p>a:电源线滤波装置的高频插入损耗不足</p>\n<p><strong>解决方法：</strong></p>\n<p>（1）滤波器电路没有屏蔽，这种情况经常发生在将滤波电路安装在线路板上的场合，高频干扰直接耦合进滤波电路，造成滤波器失效；<br />（2）滤波器本身高频性能不良，在100MHz以上插入损耗很小；<br />（3）使用非屏蔽机箱，导致滤波器的金属外壳无处端接；<strong><br /></strong>（4）使用非屏蔽机箱，干扰直接耦合到电源线和信号线上，滤波器实际上没有起作用；<br />（5）在屏蔽机箱中，滤波器离电源进口过远、造成干扰直接耦合到电源线和信号线上；<br />（6）在屏蔽机箱中，滤波器外壳与金属机箱之间连接阻抗过大（没有直接搭接，而是通过长导线连接）；<br />（7）滤波器的输入线与输出线靠得很近，发生耦合，导致滤波器的高频插人损耗不足。<strong><br /><br /></strong></p>\n<p><strong>参考书籍:&lt;EMC（电磁兼容）设计与测试案例分析 郑军奇编著 电子工业出版社&gt;</strong></p>\n<p><strong>看书的时候整理了一下导图无私分享下：</strong></p>\n<div class=\"cnblogs_Highlighter\">\n<pre class=\"brush:csharp;gutter:true;\">git@gitee.com:qian-qiang/book-map.git\n</pre>\n</div>\n<p>&nbsp;</p>\n","slug":"EMC-EMI","published":1,"updated":"2024-01-05T08:12:19.122Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clru1g20j000ls4fuaql2kexw","content":"<blockquote>EMC=EMI+EMS</blockquote>\n<h1>1：理论概念</h1>\n<h2>1.1时域和频域</h2>\n<p>建议通过示波器的FFT变换去了解时域和频域的概念</p>\n<h2>1.2分贝</h2>\n<p>电磁兼容测试中常用单位：</p>\n<p>&nbsp; 　　功率：P<sub>db</sub>=10lg(p1/p2) P2与P1应采用相同的单位。应该明确dB为两个量的比值，是无量纲的。<br>&nbsp;　　 电压:&nbsp; 同上 电压分贝常用&mu;V为单位<br>&nbsp; 　　电流：同上 以&mu;A为单位的电流。</p>\n<p>　　&nbsp; 电场强度与磁场强度：H=E/Z <br>&nbsp; 　　功率密度：S=E X H&nbsp;&nbsp;&nbsp; 功率密度的基本单位为W/m2(电场强度V／m;磁场强度A/m),<br>功率密度的物理作用比较难理解 提供一个关系来理解：后面的db数值和一个叫自由空间波阻抗的概念有关</p>\n<pre>\n    <code class=\"yaml\">\n在自由空间，功率密度S与电场强度E的关系化为分贝：\nSdB（W/m2）=EdB（V/m） &ndash; 25.8dB    \nSdB（mW/cm2）=EdB（&mu;V/m） &ndash; 155.8dB  \nSdB（&mu;W/cm2）=EdB（&mu;V/m） &ndash; 125.8dB\n    </code>\n</pre>\n<h2>&nbsp;1.3电场和磁场</h2>\n<p>高中概念E/H场正交同时传播 建议了解下<strong>天线模型</strong></p>\n<h2>&nbsp;1.4共模和差模</h2>\n<p>电压和电流的变化通过通过导线传输时有两中形态，即&ldquo;差模&rdquo;和&ldquo;共模&rdquo; 。 这里我们把这两根线比喻成两个小人，一个MM，一个GG。来张图，形象点</p>\n<p><img src=\"/2023/04/emc-emi/2023-04-04_19-28-04.png\" alt></p>\n<p>这里是两个人MM和GG，他们俩都会飞，他们手牵手飞到离地面10米的位置，那他们对地的高度即为共模信号，当他们俩一个想飞高点一个想飞低点时，这时候他们牵着飞手就会感受到拉力，这就是差模信号。也就是说这两个人是对差模信号有响应的，对共模信号没有响应。理论上讲这两个人只对差模有响应而对共模没有响应。但你让这俩人往地底下飞试试，那就苦命鸳鸯，撞死了。地下不行就去遨游太空啊，行，还是苦命鸳鸯，没空气憋死了。所以共模信号也有一定的共模范围的。差模信号也有一定差模范围。</p>\n<p>借助上面的比喻来系统理解下几个基础的概念：</p>\n<pre>\n    <code class=\"yaml\">\n借助上面的比喻来系统理解下几个基础的概念：\n共模电压：在每一导体和所规定的参照点之间（往往是大地或机架）出现的相量电压平均值。或者说同时加在电压表两测量端和规定公共端之间的那部分输出电压。\n\n<p>差模电压：一组规定的带电导体中任意两根之间的电压。使差模电压又称对称电压。</p>\n<p>共模干扰：干扰电压在信号线及其回线（一般称为信号地线）上的幅度相同，这里的电压以附近任何一个物体（大地、金属机箱、参考地线板等）为参考电位，干扰电流回路则是在导线与参考物体构成的回路中流动。<br>简明说就是信号线到地的回路干扰。</p>\n<p>差模干扰：干扰电压存在于信号线及其回线（一般称为信号地线）之间，干扰电流回路则是在导线与参考物体构成的回路中流动。<br>简明说就是信号线到信号线的回路干扰。<br>    </p></code><br></pre><p></p>\n<h1>2：简介</h1>\n<h2>2.1：电磁干扰形成的三要素</h2>\n<p>形成电磁干扰必然具备三个基本要素:<br>①电磁骚扰源，<br>②耦合途径或传播通道，<br>③敏感设备。<br>电磁兼容设计即是从这三个基本要素出发。<br><img src=\"/2023/04/emc-emi/2023-04-04_19-30-08.png\" alt></p>\n<p>所以我们可以从3个路径来解决emc问题：1干掉干扰源 2解决传播途径问题 3优化敏感设备</p>\n<h2>2.2：电磁骚扰的传播途径</h2>\n<p>电磁骚扰的传播途径包括传导耦合（传导耦合包括互传导耦合和导线间的感性与容性耦合）和辐射耦合<br>（辐射耦合包括近场耦合和远场耦合）<br><img src=\"/2023/04/emc-emi/2023-04-04_19-31-27.png\" alt></p>\n<h1>3：EMC测试类型</h1>\n<blockquote>\n<p>由于前几天做的是辐射测试这里只对EMI的辐射发射测试做分析介绍</p>\n\n</blockquote>\n<p data-pid=\"hw0JtPdM\">EMI测试项目包括：</p>\n<p data-pid=\"ajAvvm_K\">1、辐射发射测试</p>\n<p data-pid=\"aMKdQ727\">2、传导发射测试</p>\n<p data-pid=\"V4hfmcc8\">3、骚扰功率测试</p>\n<p data-pid=\"HlkauZDq\">4、电流谐波测试</p>\n<p data-pid=\"iKa3kjf2\">5、电源谐波测量</p>\n<p data-pid=\"qa38dtwO\">6、闪烁测试</p>\n<p data-pid=\"ufgEgLKt\">EMS测试项目包括：</p>\n<p data-pid=\"yJxWLW6l\">1、静电放电抗扰度</p>\n<p data-pid=\"cY_CdNFF\">2、射频电磁场抗扰度</p>\n<p data-pid=\"w_TvMw5R\">3、电快速瞬变脉冲群抗扰度</p>\n<p data-pid=\"VAiXwT4K\">4、冲击（包括雷击和浪涌）抗扰度</p>\n<p data-pid=\"4njCrycj\">5、射频场感应传导抗扰度</p>\n<p data-pid=\"_pVOSVWw\">6、工频磁场抗扰度试验</p>\n<p data-pid=\"Ejw7z-1t\">7、电压跌落短时中断和电压渐降抗扰度</p>\n<p data-pid=\"Ejw7z-1t\">具体测试方法请看《EMC设计与测试案列分析》</p>\n<h1>4：辐射发射测试</h1>\n<h2>4.1辐射发射测试的目的</h2>\n<p>　　因为EMC设计及EMC问题的分析是建立在EMC测试的基础上的，所以有必要对EMC测试做简单的阐述。测试电子，电气和机电设备及其部件的辐射发射，包括来自所有组件、电缆及连接线上的辐射发射。它用来鉴定其辐射是否符合标准的要求，以致在正常使用过程中影响同一环境中的其他设备。</p>\n<h2>4.2 常用的辐射发射测试设备</h2>\n<p>根据常用传导骚扰测试标准CISPR16及EN55022的要求，辐射发射测试主要需要以下设备：</p>\n<p>（1） EMI自动测试控制系统（电脑及其界面单元）；(2) EMI测试接收机;</p>\n<p>（3）各式天线（主动、被动棒状天线、大小形状环路天线、功率双锥天线、对数螺旋天线、喇叭天线）及天线控制单元等；</p>\n<p>&nbsp; (4)半电波暗室或开阔场。</p>\n<p>EMI测试接收机是EMC测试中最常用的基本测试仪器，基于测试接收机的频率响应特性要求，按CISPR16标准规定，测试接收机应有四种基本检波方式，即准峰值检波、均方根值检波、峰值检波及平均值检波。然而，大多数电磁干扰都是脉冲干扰，它们对音频影响的客观效果随着重复频率的增高而增大，具有特定时间常数的准峰值检波器的输出特性，可以近似反映这种影响。</p>\n<h2>4.3 辐射发射的测试方法</h2>\n<p>下图是符合CISPR16及EN55022标准要求的辐射发射测试布置图。辐射发射测试时，被测设备（EUT）置于半电波暗室内部，并在转台上旋转，以找到最大的辐射点。辐射信号由接收天线接收后，通过电缆传到电波暗室外的接收机。</p>\n<p><img src=\"/2023/04/emc-emi/2023-04-04_19-32-29.png\" alt></p>\n<h1>5：整改</h1>\n<p><em><strong>常见的电磁兼容整改措施：</strong></em><br>&nbsp;　　对常见的电磁兼容问题，我们通过综合采用以下几个方面的整改措施，一般可以解决大部分的问题：<br>屏蔽问题：<br>&nbsp;　　可以在屏蔽体的装配面处涂导电胶，或者在装配面处加导电衬垫，甚至采用导电金属胶带进行补救。<br>&nbsp;　　导电衬垫可以是编织的金属丝线、硬度较低易于塑型的软金属(铜、铅等)、包装金属层的橡胶、导电橡胶或者是梳状簧片接触指状物等。<br>布局布线问题：<br>&nbsp;　　在不影响性能的前提下，适当调整设备电缆走向和排列，做到不同类型的电缆相互隔离。<br>电缆问题：<br>&nbsp;　　改变普通的小信号或高频信号电缆为带屏蔽的电缆，改变普通的大电流信号或数据传输信号电缆为对称绞线电缆。</p>\n<p>接地问题：<br>　　加强接地的机械性能，降低接地电阻。同时对于设备整体要有单独的低阻抗接地。<br>接口问题：<br>&nbsp;　　在设备电源输入线上加装或串联电源滤波器。<br>关键部位的处理：<br>&nbsp;　　在可能的情况下，对重要器件进行屏蔽、隔离处理，如加装接地良好的金属隔离板或小的屏蔽罩等。<br>电路和电源问题：<br>&nbsp;　　在各器件电源输入端并联小电容，以旁路电源带来的高频干扰。</p>\n<p>现在就对我们遇到的问题做分析：电磁骚扰发射：分为传导发射（连续发射和断续发射）和辐射发射（骚扰场强和骚扰功率）</p>\n<p><em><strong>针对电磁骚扰发射测试常见问题对策及整改措施</strong></em></p>\n<p>1：产品内主要电磁骚扰源分析（电源/电机/电路板/高频器件？）</p>\n<p>2：骚扰源定位（这里我们出现了一个错误后面介绍）</p>\n<p>3：产品连续传导发射超标问题及对策</p>\n<p>4：产品断续传导发射超标问题及对策</p>\n<p>5：产品辐射骚扰超标问题及对策</p>\n<p>6：骚扰功率干扰的产生和对策</p>\n<h2>5.1：主要电磁骚扰源</h2>\n<p>a:设备开关电源的开关回路：骚扰源主频几十kHz到百余kHz，高次谐波可延伸到数十MHz。<br>b:设备直流电源的整流回路：工频线性电源工频整流噪声频率上限可延伸到数百kHz；开关电源高频整流噪声频率上限可延伸到数十MHz。<br>&nbsp;c:电动设备直流电机的电刷噪声：噪声频率上限可延伸到数百MHz。<br>&nbsp;d:电动设备交流电机的运行噪声：高次谐波可延伸到数十MHz。<br>&nbsp;e:变频调速电路的骚扰发射：开关调速回路骚扰源频率从几十kHz到几十MHz。<br>&nbsp;f:设备运行状态切换的开关噪声：由机械或电子开关动作产生的噪声频率上限可延伸到数百MHz。<br>&nbsp;g:智能控制设备的晶振及数字电路电磁骚扰：骚扰源主频几十kHz到几十MHz，高次谐波可延伸到数百MHz。<br>&nbsp;等等.................</p>\n<h2>5.2：骚扰源定位</h2>\n<p><strong>根据测量曲线定位</strong>：依据：超标骚扰频率范围、超标骚扰频域分布、窄带还是宽带骚扰等来判断<br><br><img src=\"/2023/04/emc-emi/2023-04-04_19-32-59.png\" alt></p>\n<p><img src=\"/2023/04/emc-emi/2023-04-04_19-33-05.png\" alt></p>\n<p><strong>根据被测设备工作方式和内部结构定位</strong>：</p>\n<p>a:有没有使用标准不建议使用的半波整流和对称/非对称电源调整电路?<br>b:内部结构中电路板布局是否合理?<br>c:内部电缆走线是否合理?</p>\n<p>d:内部滤波器（滤波电路）安装是否合理?<br>e:内部电路接地和搭接方式是否合理?<br>f:机箱屏蔽是否满足对应产品的需求?</p>\n<p><br><strong>根据功能模块工作情况进行故障定位</strong><br>a:若设备的各个模块可以暂停和恢复工作，可以通过逐个暂停这些模块的工作来判断骚扰来源。<br>b:若模块不可以独立暂停和恢复工作，可以通过与该设备其它功能模块一起组合进行暂停和恢复工作，从而判断骚扰的大概来源。<br>c:若模块不可以独立暂停和恢复工作，也可以通过用待判断模块与其它合格设备的相关功能模块组合并测量的方式，从而判断骚扰的大概来源。<br>d:对怀疑骚扰超标的模块，可以用与合格模块置换的方式来进行骚扰判定。<br>但是需要注意的是不能测试完一个模块发现没有起到作用又将这个模块恢复到初始状态 这个时候应该保持更改不变 继续下一个模块的排查，我们在最初的排查过程中就犯了这个错误，导致浪费了测试时间。<br>下面去个例子说明：</p>\n<p>　　假设一个系统在测试时出现了辐射发射超标，使系统不能满足EMC标准中对辐射发射的限值。经过初步分析，原因可能有4个，它们分别是：</p>\n<p>（1）主机与键盘之间的互连电缆（电缆1）上的共模电流产生的辐射；</p>\n<p>（2）主机与打印机之间的互连电缆（电缆2）上的共模电流产生的辐射；</p>\n<p>（3）机箱面板与机箱基体之间的缝隙（开口1）产生的泄漏；</p>\n<p>（4）某显示窗口（开口2）产生的泄漏。</p>\n<p>在诊断时，首先在电缆1上套一个铁氧体磁环，以减小共模辐射，结果发现频谱仪屏幕上显示的信号并没有明显减小。于是认为电缆1不是一个主要的泄漏源，将铁氧体磁环取下，套在电缆2上，结果发现频谱仪屏幕上显示的信号还没有明显减小。结果得出结论，电缆不是泄漏源。</p>\n<p>再对机箱上的泄漏进行检查。用屏蔽胶带将开口1堵上，发现频谱仪屏幕上显示的信号没有明显减小。认为开口1不是主要泄漏源，将屏蔽胶带取下，堵到开口2上。结果频谱仪上的显示信号还没有减小。之所以会发生这个问题，是因为测试人员忽视了频谱分析仪上显示的信号幅度是以dB为单位显示的。下面看一下为什么会有这种现象。</p>\n<p>假设这4个泄漏源所占的成分各占1／4，并且在每个辐射源上采取的措施能够将这个辐射源完全抑制掉，则采取以上4个措施中的一个时，频谱仪上显示信号降低的幅度&Delta;A为</p>\n<p>&Delta;A=20lg(4/3)=2.5 dB</p>\n<p>幅度减小这么少，显然是微不足道的。但这却已经将泄漏减少了25％。</p>\n<p>正确的方法是，在对一个可能的泄漏源采取了抑制措施后，即使没有明显的改善，也不要将这个措施去掉，继续对可能的泄漏源采取措施。当采取到某个措施时，如果干扰幅度降低很多，并不一定说明这个泄漏源是主要的，而仅说明这个干扰源是最后一个。按照这个步骤对4个泄漏源逐个处理的结果如图</p>\n\n<img src=\"/2023/04/emc-emi/2023-04-04_19-33-48.png\" alt>\n<p>在前面的叙述中，假定对某个泄漏源采取措施后，这个泄漏源被100％消除掉，如果这样，当最后一个泄漏源去掉后，电磁干扰的减小应为无限大。实际这是不可能的。在采取任何一个措施时，都不可能将干扰源100％消除。泄漏源去掉的程度可以是99％，或99.9％，甚至99.99％以上，而绝不可能是100％，所以当最后一个泄漏源去掉后，尽管改善很大，但仍是有限值。</p>\n<h2>5.3：连续传导发射超标问题及对策</h2>\n<p><strong>连续传导骚扰的主要来源：</strong></p>\n<p>a:开关电源的开关频率及谐波骚扰<br>b:电源整流回路的整流噪声<br>c:交流电机的运行噪声</p>\n<p>d:直流电机的电刷噪声</p>\n<p>e:智能控制设备的晶振</p>\n<p>f:数字电路电磁骚扰<br><strong>导致射频传导发射超标的原因如图所示:</strong><br><img src=\"/2023/04/emc-emi/2023-04-04_19-34-25.png\" alt></p>\n<p>（1）开关电源或DC/DC变换器工作在脉冲状态，它们本身会产生很强的干扰，这种干扰既有共模分量，也有差模分量。对于一般开关电源和变换器，在1MHz以下以差模干扰为主，在1MHz以上以共模干扰为主。<br>（2）数字电路的工作电流是瞬变的，虽然在每个电路芯片的旁边和线路板上都安装了解耦电容，但还是会有一部分瞬变电流反映在电源中，沿着电源线传导发射。<br>（3）机箱内的线路板、电缆都是辐射源，这些辐射能量会感应进电源线和电源电路本身，形成传导发射。需要注意的是，当机箱内各种频率的信号耦合进电源电路时，由于电源内有许多二极管、三极管电路，会使这些不同频率的信号相互发生混频、调制，甚至对干扰进行放大，从而导致严重的干扰。<br><strong>解决方法：</strong></p>\n<p>在电源线入口处安装电源线滤波器是保证通过射频传导发射试验的唯一方法（滤波器的安装位置也很重要）。<br>如果仅做150kHz~30MHz范围内的传导发射试验，一般的电源线滤波器就可以满足要求，大部分电源线滤波器在100kHz以上都已有较大的插入损耗。由于30MHz以上的高频性能不良会导致辐射发射的问题，所以应加以注意。如果需要做30~300MHz频率范围内的骚扰功率发射试验或30~1GHz频率范围内的辐射骚扰，选择滤波器时必须注意滤波器的高频特性。</p>\n<p>对电源线的处理：<br>（1）检查电源线附近有无信号电缆存在，有无可能是因为信号电缆与电源线之间的耦合使电源线的传导骚扰发射超标（这种情况多见于超标频率的频段较高的情况下）。如有，或拉大两者间的距离，或采取屏蔽措施。<br>（2）加装电源线滤波器（如果已经有滤波器。则换用高性能的滤波器），要特别注意安装位置（尽可能放在机箱中电源线入口端）和安装情况，要保证滤波器外壳与机箱搭接良好、接地良好。<br>（3）虽经采取措施，设备传导骚扰发射仍未达标。此时可考虑在设备内部线路连接接地端子的地方串入一个电感。由于这部分连接属单点接地，平时无电流流过，因此这个电感可以做得较大，而无需担心有铁芯的饱和问题。<br>采取这一措施的理由是设备传导骚扰发射测试实际上是对地电压测试（电源线对大地的骚扰电压测试），电源线上有工作电流流过，故滤波器的滤波电感值受制于工作电流，不能做得很大，滤波器的插入损耗也就有限，特别是低频端损耗更加有限。新方案里的附加电感正好可以弥补这一缺憾，从而取得更好的传导骚扰抑制能力。<br>对信号线的处理：<br>（1）注意信号线周围有无其他辐射能量（附近的布线及印刷板的布局）被引到信号线上。如有，或拉大两者的距离，或采取屏蔽措施，或考虑改变设备内部布局和印刷板的布局。<br>（2）在信号线上套铁氧体磁环（或铁氧体磁夹）。<br>（3）对信号线进行共模滤波，必要时采用滤波连接器（或滤波阵列板）。注意滤波器的参数，传导骚扰发射超标的频率比辐射骚扰发射超标的频率应低些，因此取用的元件参数应当偏大一些</p>\n<h2>5.4：断续传导发射超标问题及对策</h2>\n<p><strong>断续传导骚扰的主要来源：</strong></p>\n<p>a:恒温控制器具，程序自动的机器和其他电气控制或操作的器具的开关操作会产生断续骚扰。此类操作一般通过继电器和程控电子/机械开关等实现。此类骚扰一般由继电器、开关的触点抖动及非纯阻负载通断所产生的电涌冲击形成。<br><strong>解决方法：</strong><br>从内部电路和结构上考虑，减少其断续骚扰，使其满足测量要求。<br>从电源电路和电源结构入手，在电源中采取适当的措施，对内部电路产生的断续骚扰加以抑制，使其满足测量标准的要求。<br>a:在开关触点或开关模块两端并联高频电容或RC、DRC吸波网络，吸收开关抖动脉冲及非阻性负载的浪涌脉冲。 同时应留意这些元器件的耐压和功率承受能力应满足设备正常工作的要求。<br>b:对被供电设备内通过程控开关控制的非阻性部件的供电回路上增加限流电路或软启动装置，抑制其启动浪涌冲击。<br>c:对被供电设备内通过开关量控制的感性部件应增加反向浪涌吸收元件，以吸收部件断电时产生的反向感应高压浪涌冲击。<br>d:在被供电设备的电源输入端增加高频吸收回路，抑制其高频骚扰向电源反向注入。</p>\n<h2>5.5：辐射骚扰超标问题及对策</h2>\n<p><strong>辐射骚扰的主要骚扰来源:</strong><br>a:开关电源的开关频率及谐波骚扰<br>b:交流电机的运行噪声、直流电机的电刷噪声<br>c:电磁感应设备的电磁骚扰<br>d:智能控制设备的晶振及数字电路电磁骚扰等</p>\n<p>导致辐射发射试验失败的原因有两种可能最大：</p>\n<p>　　一种是设备外壳的屏蔽性能不完善；<br>　　另一种是射频骚扰经由电源线和其他线缆的逸出。<br><br><strong>解决方法：</strong><br><img src=\"/2023/04/emc-emi/2023-04-04_19-35-03.png\" alt></p>\n<p>当我们通过骚扰定位方式找到辐射骚扰超标点的骚扰源后，即可采用相对应的骚扰源抑制措施。<br>一般来说：<br>首先抑制骚扰源，这可以通过优化电路设计、电路结构和排版，加强滤波和正确的接地来达到。<br>其次是要切断耦合途径，这可以通过正确的机壳屏蔽和传输线滤波达到。<br><strong>首先说下机箱问题：</strong></p>\n<p>一、金属机箱屏蔽性能不完善（非金属机箱还没碰到不做讨论）<br>对于金属机箱屏蔽性能不完善引起的辐射骚扰发射超标，应采取以下措施：<br>1）机箱的缝隙过大，或机箱配合上存在问题<br>　处理意见：<br>（1）清除结合面上的油漆、氧化层及表面玷污；<br>（2）增加结合面上的紧固件数目及接触表面的平整度；<br>（3）采取永久性的接缝（要连续焊接）；<br>（4）采用导电衬垫来改善接触表面的接触性能。<br>2）其他功能性开孔过大<br>处理意见：<br>（1）通风口采用防尘板，必要时采用波导通风板，但后者成本昂贵；<br>（2）显示窗口采用带有屏蔽作用的透明材料；或采用隔舱，并对信号线采取滤波措施；<br>（3）对键盘等采用隔舱，并对信号线采取滤波措施。<br>3）机箱内部布线不当，电磁骚扰透过缝隙逸出<br>处理意见：<br>&nbsp; 将印刷板及设备内部布线等可能产生辐射骚扰的布局，远离缝隙或功能性开孔的部位，<br>&nbsp; 或采取增加屏蔽的补救措施或重新布局。<br><strong>其次说下线缆问题：</strong><br>1）对电源线的处理<br>（1）加装电源线滤波器（如果己经有滤波器，则换用高性能的滤波器），要特别注意安装位置（尽可能放在机箱中电源线入口端）和安装情况，要保证滤波器外壳与机箱搭接良好、接地良好；<br>（2）如果不合格的频率比较高，可考虑在电源线入口的部分套装铁氧体磁环。<br>2）对信号线的处理<br>（1）在信号线上套铁氧体磁环（或铁氧体磁夹）；<br>（2）对信号线滤波（共模滤波），必要时将连接器改用滤波阵列板或滤波连接器；<br>（3）换用屏蔽电缆，屏蔽电缆的屏蔽层与机箱尽量采用360&deg;搭接方式，必要时在屏蔽线上再套铁氧体磁环</p>\n<h2>5.6：骚扰功率干扰的产生和对策</h2>\n<p><strong>骚扰功率的主要来源：</strong></p>\n<p>a:电源线滤波装置的高频插入损耗不足</p>\n<p><strong>解决方法：</strong></p>\n<p>（1）滤波器电路没有屏蔽，这种情况经常发生在将滤波电路安装在线路板上的场合，高频干扰直接耦合进滤波电路，造成滤波器失效；<br>（2）滤波器本身高频性能不良，在100MHz以上插入损耗很小；<br>（3）使用非屏蔽机箱，导致滤波器的金属外壳无处端接；<strong><br></strong>（4）使用非屏蔽机箱，干扰直接耦合到电源线和信号线上，滤波器实际上没有起作用；<br>（5）在屏蔽机箱中，滤波器离电源进口过远、造成干扰直接耦合到电源线和信号线上；<br>（6）在屏蔽机箱中，滤波器外壳与金属机箱之间连接阻抗过大（没有直接搭接，而是通过长导线连接）；<br>（7）滤波器的输入线与输出线靠得很近，发生耦合，导致滤波器的高频插人损耗不足。<strong><br><br></strong></p>\n<p><strong>参考书籍:&lt;EMC（电磁兼容）设计与测试案例分析 郑军奇编著 电子工业出版社&gt;</strong></p>\n<p><strong>看书的时候整理了一下导图无私分享下：</strong></p>\n<div class=\"cnblogs_Highlighter\">\n<pre class=\"brush:csharp;gutter:true;\">git@gitee.com:qian-qiang/book-map.git\n</pre>\n</div>\n<p>&nbsp;</p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<blockquote>EMC=EMI+EMS</blockquote>\n<h1>1：理论概念</h1>\n<h2>1.1时域和频域</h2>\n<p>建议通过示波器的FFT变换去了解时域和频域的概念</p>\n<h2>1.2分贝</h2>\n<p>电磁兼容测试中常用单位：</p>\n<p>&nbsp; 　　功率：P<sub>db</sub>=10lg(p1/p2) P2与P1应采用相同的单位。应该明确dB为两个量的比值，是无量纲的。<br>&nbsp;　　 电压:&nbsp; 同上 电压分贝常用&mu;V为单位<br>&nbsp; 　　电流：同上 以&mu;A为单位的电流。</p>\n<p>　　&nbsp; 电场强度与磁场强度：H=E/Z <br>&nbsp; 　　功率密度：S=E X H&nbsp;&nbsp;&nbsp; 功率密度的基本单位为W/m2(电场强度V／m;磁场强度A/m),<br>功率密度的物理作用比较难理解 提供一个关系来理解：后面的db数值和一个叫自由空间波阻抗的概念有关</p>\n<pre>\n    <code class=\"yaml\">\n在自由空间，功率密度S与电场强度E的关系化为分贝：\nSdB（W/m2）=EdB（V/m） &ndash; 25.8dB    \nSdB（mW/cm2）=EdB（&mu;V/m） &ndash; 155.8dB  \nSdB（&mu;W/cm2）=EdB（&mu;V/m） &ndash; 125.8dB\n    </code>\n</pre>\n<h2>&nbsp;1.3电场和磁场</h2>\n<p>高中概念E/H场正交同时传播 建议了解下<strong>天线模型</strong></p>\n<h2>&nbsp;1.4共模和差模</h2>\n<p>电压和电流的变化通过通过导线传输时有两中形态，即&ldquo;差模&rdquo;和&ldquo;共模&rdquo; 。 这里我们把这两根线比喻成两个小人，一个MM，一个GG。来张图，形象点</p>\n<p><img src=\"/2023/04/emc-emi/2023-04-04_19-28-04.png\" alt></p>\n<p>这里是两个人MM和GG，他们俩都会飞，他们手牵手飞到离地面10米的位置，那他们对地的高度即为共模信号，当他们俩一个想飞高点一个想飞低点时，这时候他们牵着飞手就会感受到拉力，这就是差模信号。也就是说这两个人是对差模信号有响应的，对共模信号没有响应。理论上讲这两个人只对差模有响应而对共模没有响应。但你让这俩人往地底下飞试试，那就苦命鸳鸯，撞死了。地下不行就去遨游太空啊，行，还是苦命鸳鸯，没空气憋死了。所以共模信号也有一定的共模范围的。差模信号也有一定差模范围。</p>\n<p>借助上面的比喻来系统理解下几个基础的概念：</p>\n<pre>\n    <code class=\"yaml\">\n借助上面的比喻来系统理解下几个基础的概念：\n共模电压：在每一导体和所规定的参照点之间（往往是大地或机架）出现的相量电压平均值。或者说同时加在电压表两测量端和规定公共端之间的那部分输出电压。\n\n<p>差模电压：一组规定的带电导体中任意两根之间的电压。使差模电压又称对称电压。</p>\n<p>共模干扰：干扰电压在信号线及其回线（一般称为信号地线）上的幅度相同，这里的电压以附近任何一个物体（大地、金属机箱、参考地线板等）为参考电位，干扰电流回路则是在导线与参考物体构成的回路中流动。<br>简明说就是信号线到地的回路干扰。</p>\n<p>差模干扰：干扰电压存在于信号线及其回线（一般称为信号地线）之间，干扰电流回路则是在导线与参考物体构成的回路中流动。<br>简明说就是信号线到信号线的回路干扰。<br>    </p></code><br></pre><p></p>\n<h1>2：简介</h1>\n<h2>2.1：电磁干扰形成的三要素</h2>\n<p>形成电磁干扰必然具备三个基本要素:<br>①电磁骚扰源，<br>②耦合途径或传播通道，<br>③敏感设备。<br>电磁兼容设计即是从这三个基本要素出发。<br><img src=\"/2023/04/emc-emi/2023-04-04_19-30-08.png\" alt></p>\n<p>所以我们可以从3个路径来解决emc问题：1干掉干扰源 2解决传播途径问题 3优化敏感设备</p>\n<h2>2.2：电磁骚扰的传播途径</h2>\n<p>电磁骚扰的传播途径包括传导耦合（传导耦合包括互传导耦合和导线间的感性与容性耦合）和辐射耦合<br>（辐射耦合包括近场耦合和远场耦合）<br><img src=\"/2023/04/emc-emi/2023-04-04_19-31-27.png\" alt></p>\n<h1>3：EMC测试类型</h1>\n<blockquote>\n<p>由于前几天做的是辐射测试这里只对EMI的辐射发射测试做分析介绍</p>\n\n</blockquote>\n<p data-pid=\"hw0JtPdM\">EMI测试项目包括：</p>\n<p data-pid=\"ajAvvm_K\">1、辐射发射测试</p>\n<p data-pid=\"aMKdQ727\">2、传导发射测试</p>\n<p data-pid=\"V4hfmcc8\">3、骚扰功率测试</p>\n<p data-pid=\"HlkauZDq\">4、电流谐波测试</p>\n<p data-pid=\"iKa3kjf2\">5、电源谐波测量</p>\n<p data-pid=\"qa38dtwO\">6、闪烁测试</p>\n<p data-pid=\"ufgEgLKt\">EMS测试项目包括：</p>\n<p data-pid=\"yJxWLW6l\">1、静电放电抗扰度</p>\n<p data-pid=\"cY_CdNFF\">2、射频电磁场抗扰度</p>\n<p data-pid=\"w_TvMw5R\">3、电快速瞬变脉冲群抗扰度</p>\n<p data-pid=\"VAiXwT4K\">4、冲击（包括雷击和浪涌）抗扰度</p>\n<p data-pid=\"4njCrycj\">5、射频场感应传导抗扰度</p>\n<p data-pid=\"_pVOSVWw\">6、工频磁场抗扰度试验</p>\n<p data-pid=\"Ejw7z-1t\">7、电压跌落短时中断和电压渐降抗扰度</p>\n<p data-pid=\"Ejw7z-1t\">具体测试方法请看《EMC设计与测试案列分析》</p>\n<h1>4：辐射发射测试</h1>\n<h2>4.1辐射发射测试的目的</h2>\n<p>　　因为EMC设计及EMC问题的分析是建立在EMC测试的基础上的，所以有必要对EMC测试做简单的阐述。测试电子，电气和机电设备及其部件的辐射发射，包括来自所有组件、电缆及连接线上的辐射发射。它用来鉴定其辐射是否符合标准的要求，以致在正常使用过程中影响同一环境中的其他设备。</p>\n<h2>4.2 常用的辐射发射测试设备</h2>\n<p>根据常用传导骚扰测试标准CISPR16及EN55022的要求，辐射发射测试主要需要以下设备：</p>\n<p>（1） EMI自动测试控制系统（电脑及其界面单元）；(2) EMI测试接收机;</p>\n<p>（3）各式天线（主动、被动棒状天线、大小形状环路天线、功率双锥天线、对数螺旋天线、喇叭天线）及天线控制单元等；</p>\n<p>&nbsp; (4)半电波暗室或开阔场。</p>\n<p>EMI测试接收机是EMC测试中最常用的基本测试仪器，基于测试接收机的频率响应特性要求，按CISPR16标准规定，测试接收机应有四种基本检波方式，即准峰值检波、均方根值检波、峰值检波及平均值检波。然而，大多数电磁干扰都是脉冲干扰，它们对音频影响的客观效果随着重复频率的增高而增大，具有特定时间常数的准峰值检波器的输出特性，可以近似反映这种影响。</p>\n<h2>4.3 辐射发射的测试方法</h2>\n<p>下图是符合CISPR16及EN55022标准要求的辐射发射测试布置图。辐射发射测试时，被测设备（EUT）置于半电波暗室内部，并在转台上旋转，以找到最大的辐射点。辐射信号由接收天线接收后，通过电缆传到电波暗室外的接收机。</p>\n<p><img src=\"/2023/04/emc-emi/2023-04-04_19-32-29.png\" alt></p>\n<h1>5：整改</h1>\n<p><em><strong>常见的电磁兼容整改措施：</strong></em><br>&nbsp;　　对常见的电磁兼容问题，我们通过综合采用以下几个方面的整改措施，一般可以解决大部分的问题：<br>屏蔽问题：<br>&nbsp;　　可以在屏蔽体的装配面处涂导电胶，或者在装配面处加导电衬垫，甚至采用导电金属胶带进行补救。<br>&nbsp;　　导电衬垫可以是编织的金属丝线、硬度较低易于塑型的软金属(铜、铅等)、包装金属层的橡胶、导电橡胶或者是梳状簧片接触指状物等。<br>布局布线问题：<br>&nbsp;　　在不影响性能的前提下，适当调整设备电缆走向和排列，做到不同类型的电缆相互隔离。<br>电缆问题：<br>&nbsp;　　改变普通的小信号或高频信号电缆为带屏蔽的电缆，改变普通的大电流信号或数据传输信号电缆为对称绞线电缆。</p>\n<p>接地问题：<br>　　加强接地的机械性能，降低接地电阻。同时对于设备整体要有单独的低阻抗接地。<br>接口问题：<br>&nbsp;　　在设备电源输入线上加装或串联电源滤波器。<br>关键部位的处理：<br>&nbsp;　　在可能的情况下，对重要器件进行屏蔽、隔离处理，如加装接地良好的金属隔离板或小的屏蔽罩等。<br>电路和电源问题：<br>&nbsp;　　在各器件电源输入端并联小电容，以旁路电源带来的高频干扰。</p>\n<p>现在就对我们遇到的问题做分析：电磁骚扰发射：分为传导发射（连续发射和断续发射）和辐射发射（骚扰场强和骚扰功率）</p>\n<p><em><strong>针对电磁骚扰发射测试常见问题对策及整改措施</strong></em></p>\n<p>1：产品内主要电磁骚扰源分析（电源/电机/电路板/高频器件？）</p>\n<p>2：骚扰源定位（这里我们出现了一个错误后面介绍）</p>\n<p>3：产品连续传导发射超标问题及对策</p>\n<p>4：产品断续传导发射超标问题及对策</p>\n<p>5：产品辐射骚扰超标问题及对策</p>\n<p>6：骚扰功率干扰的产生和对策</p>\n<h2>5.1：主要电磁骚扰源</h2>\n<p>a:设备开关电源的开关回路：骚扰源主频几十kHz到百余kHz，高次谐波可延伸到数十MHz。<br>b:设备直流电源的整流回路：工频线性电源工频整流噪声频率上限可延伸到数百kHz；开关电源高频整流噪声频率上限可延伸到数十MHz。<br>&nbsp;c:电动设备直流电机的电刷噪声：噪声频率上限可延伸到数百MHz。<br>&nbsp;d:电动设备交流电机的运行噪声：高次谐波可延伸到数十MHz。<br>&nbsp;e:变频调速电路的骚扰发射：开关调速回路骚扰源频率从几十kHz到几十MHz。<br>&nbsp;f:设备运行状态切换的开关噪声：由机械或电子开关动作产生的噪声频率上限可延伸到数百MHz。<br>&nbsp;g:智能控制设备的晶振及数字电路电磁骚扰：骚扰源主频几十kHz到几十MHz，高次谐波可延伸到数百MHz。<br>&nbsp;等等.................</p>\n<h2>5.2：骚扰源定位</h2>\n<p><strong>根据测量曲线定位</strong>：依据：超标骚扰频率范围、超标骚扰频域分布、窄带还是宽带骚扰等来判断<br><br><img src=\"/2023/04/emc-emi/2023-04-04_19-32-59.png\" alt></p>\n<p><img src=\"/2023/04/emc-emi/2023-04-04_19-33-05.png\" alt></p>\n<p><strong>根据被测设备工作方式和内部结构定位</strong>：</p>\n<p>a:有没有使用标准不建议使用的半波整流和对称/非对称电源调整电路?<br>b:内部结构中电路板布局是否合理?<br>c:内部电缆走线是否合理?</p>\n<p>d:内部滤波器（滤波电路）安装是否合理?<br>e:内部电路接地和搭接方式是否合理?<br>f:机箱屏蔽是否满足对应产品的需求?</p>\n<p><br><strong>根据功能模块工作情况进行故障定位</strong><br>a:若设备的各个模块可以暂停和恢复工作，可以通过逐个暂停这些模块的工作来判断骚扰来源。<br>b:若模块不可以独立暂停和恢复工作，可以通过与该设备其它功能模块一起组合进行暂停和恢复工作，从而判断骚扰的大概来源。<br>c:若模块不可以独立暂停和恢复工作，也可以通过用待判断模块与其它合格设备的相关功能模块组合并测量的方式，从而判断骚扰的大概来源。<br>d:对怀疑骚扰超标的模块，可以用与合格模块置换的方式来进行骚扰判定。<br>但是需要注意的是不能测试完一个模块发现没有起到作用又将这个模块恢复到初始状态 这个时候应该保持更改不变 继续下一个模块的排查，我们在最初的排查过程中就犯了这个错误，导致浪费了测试时间。<br>下面去个例子说明：</p>\n<p>　　假设一个系统在测试时出现了辐射发射超标，使系统不能满足EMC标准中对辐射发射的限值。经过初步分析，原因可能有4个，它们分别是：</p>\n<p>（1）主机与键盘之间的互连电缆（电缆1）上的共模电流产生的辐射；</p>\n<p>（2）主机与打印机之间的互连电缆（电缆2）上的共模电流产生的辐射；</p>\n<p>（3）机箱面板与机箱基体之间的缝隙（开口1）产生的泄漏；</p>\n<p>（4）某显示窗口（开口2）产生的泄漏。</p>\n<p>在诊断时，首先在电缆1上套一个铁氧体磁环，以减小共模辐射，结果发现频谱仪屏幕上显示的信号并没有明显减小。于是认为电缆1不是一个主要的泄漏源，将铁氧体磁环取下，套在电缆2上，结果发现频谱仪屏幕上显示的信号还没有明显减小。结果得出结论，电缆不是泄漏源。</p>\n<p>再对机箱上的泄漏进行检查。用屏蔽胶带将开口1堵上，发现频谱仪屏幕上显示的信号没有明显减小。认为开口1不是主要泄漏源，将屏蔽胶带取下，堵到开口2上。结果频谱仪上的显示信号还没有减小。之所以会发生这个问题，是因为测试人员忽视了频谱分析仪上显示的信号幅度是以dB为单位显示的。下面看一下为什么会有这种现象。</p>\n<p>假设这4个泄漏源所占的成分各占1／4，并且在每个辐射源上采取的措施能够将这个辐射源完全抑制掉，则采取以上4个措施中的一个时，频谱仪上显示信号降低的幅度&Delta;A为</p>\n<p>&Delta;A=20lg(4/3)=2.5 dB</p>\n<p>幅度减小这么少，显然是微不足道的。但这却已经将泄漏减少了25％。</p>\n<p>正确的方法是，在对一个可能的泄漏源采取了抑制措施后，即使没有明显的改善，也不要将这个措施去掉，继续对可能的泄漏源采取措施。当采取到某个措施时，如果干扰幅度降低很多，并不一定说明这个泄漏源是主要的，而仅说明这个干扰源是最后一个。按照这个步骤对4个泄漏源逐个处理的结果如图</p>\n\n<img src=\"/2023/04/emc-emi/2023-04-04_19-33-48.png\" alt>\n<p>在前面的叙述中，假定对某个泄漏源采取措施后，这个泄漏源被100％消除掉，如果这样，当最后一个泄漏源去掉后，电磁干扰的减小应为无限大。实际这是不可能的。在采取任何一个措施时，都不可能将干扰源100％消除。泄漏源去掉的程度可以是99％，或99.9％，甚至99.99％以上，而绝不可能是100％，所以当最后一个泄漏源去掉后，尽管改善很大，但仍是有限值。</p>\n<h2>5.3：连续传导发射超标问题及对策</h2>\n<p><strong>连续传导骚扰的主要来源：</strong></p>\n<p>a:开关电源的开关频率及谐波骚扰<br>b:电源整流回路的整流噪声<br>c:交流电机的运行噪声</p>\n<p>d:直流电机的电刷噪声</p>\n<p>e:智能控制设备的晶振</p>\n<p>f:数字电路电磁骚扰<br><strong>导致射频传导发射超标的原因如图所示:</strong><br><img src=\"/2023/04/emc-emi/2023-04-04_19-34-25.png\" alt></p>\n<p>（1）开关电源或DC/DC变换器工作在脉冲状态，它们本身会产生很强的干扰，这种干扰既有共模分量，也有差模分量。对于一般开关电源和变换器，在1MHz以下以差模干扰为主，在1MHz以上以共模干扰为主。<br>（2）数字电路的工作电流是瞬变的，虽然在每个电路芯片的旁边和线路板上都安装了解耦电容，但还是会有一部分瞬变电流反映在电源中，沿着电源线传导发射。<br>（3）机箱内的线路板、电缆都是辐射源，这些辐射能量会感应进电源线和电源电路本身，形成传导发射。需要注意的是，当机箱内各种频率的信号耦合进电源电路时，由于电源内有许多二极管、三极管电路，会使这些不同频率的信号相互发生混频、调制，甚至对干扰进行放大，从而导致严重的干扰。<br><strong>解决方法：</strong></p>\n<p>在电源线入口处安装电源线滤波器是保证通过射频传导发射试验的唯一方法（滤波器的安装位置也很重要）。<br>如果仅做150kHz~30MHz范围内的传导发射试验，一般的电源线滤波器就可以满足要求，大部分电源线滤波器在100kHz以上都已有较大的插入损耗。由于30MHz以上的高频性能不良会导致辐射发射的问题，所以应加以注意。如果需要做30~300MHz频率范围内的骚扰功率发射试验或30~1GHz频率范围内的辐射骚扰，选择滤波器时必须注意滤波器的高频特性。</p>\n<p>对电源线的处理：<br>（1）检查电源线附近有无信号电缆存在，有无可能是因为信号电缆与电源线之间的耦合使电源线的传导骚扰发射超标（这种情况多见于超标频率的频段较高的情况下）。如有，或拉大两者间的距离，或采取屏蔽措施。<br>（2）加装电源线滤波器（如果已经有滤波器。则换用高性能的滤波器），要特别注意安装位置（尽可能放在机箱中电源线入口端）和安装情况，要保证滤波器外壳与机箱搭接良好、接地良好。<br>（3）虽经采取措施，设备传导骚扰发射仍未达标。此时可考虑在设备内部线路连接接地端子的地方串入一个电感。由于这部分连接属单点接地，平时无电流流过，因此这个电感可以做得较大，而无需担心有铁芯的饱和问题。<br>采取这一措施的理由是设备传导骚扰发射测试实际上是对地电压测试（电源线对大地的骚扰电压测试），电源线上有工作电流流过，故滤波器的滤波电感值受制于工作电流，不能做得很大，滤波器的插入损耗也就有限，特别是低频端损耗更加有限。新方案里的附加电感正好可以弥补这一缺憾，从而取得更好的传导骚扰抑制能力。<br>对信号线的处理：<br>（1）注意信号线周围有无其他辐射能量（附近的布线及印刷板的布局）被引到信号线上。如有，或拉大两者的距离，或采取屏蔽措施，或考虑改变设备内部布局和印刷板的布局。<br>（2）在信号线上套铁氧体磁环（或铁氧体磁夹）。<br>（3）对信号线进行共模滤波，必要时采用滤波连接器（或滤波阵列板）。注意滤波器的参数，传导骚扰发射超标的频率比辐射骚扰发射超标的频率应低些，因此取用的元件参数应当偏大一些</p>\n<h2>5.4：断续传导发射超标问题及对策</h2>\n<p><strong>断续传导骚扰的主要来源：</strong></p>\n<p>a:恒温控制器具，程序自动的机器和其他电气控制或操作的器具的开关操作会产生断续骚扰。此类操作一般通过继电器和程控电子/机械开关等实现。此类骚扰一般由继电器、开关的触点抖动及非纯阻负载通断所产生的电涌冲击形成。<br><strong>解决方法：</strong><br>从内部电路和结构上考虑，减少其断续骚扰，使其满足测量要求。<br>从电源电路和电源结构入手，在电源中采取适当的措施，对内部电路产生的断续骚扰加以抑制，使其满足测量标准的要求。<br>a:在开关触点或开关模块两端并联高频电容或RC、DRC吸波网络，吸收开关抖动脉冲及非阻性负载的浪涌脉冲。 同时应留意这些元器件的耐压和功率承受能力应满足设备正常工作的要求。<br>b:对被供电设备内通过程控开关控制的非阻性部件的供电回路上增加限流电路或软启动装置，抑制其启动浪涌冲击。<br>c:对被供电设备内通过开关量控制的感性部件应增加反向浪涌吸收元件，以吸收部件断电时产生的反向感应高压浪涌冲击。<br>d:在被供电设备的电源输入端增加高频吸收回路，抑制其高频骚扰向电源反向注入。</p>\n<h2>5.5：辐射骚扰超标问题及对策</h2>\n<p><strong>辐射骚扰的主要骚扰来源:</strong><br>a:开关电源的开关频率及谐波骚扰<br>b:交流电机的运行噪声、直流电机的电刷噪声<br>c:电磁感应设备的电磁骚扰<br>d:智能控制设备的晶振及数字电路电磁骚扰等</p>\n<p>导致辐射发射试验失败的原因有两种可能最大：</p>\n<p>　　一种是设备外壳的屏蔽性能不完善；<br>　　另一种是射频骚扰经由电源线和其他线缆的逸出。<br><br><strong>解决方法：</strong><br><img src=\"/2023/04/emc-emi/2023-04-04_19-35-03.png\" alt></p>\n<p>当我们通过骚扰定位方式找到辐射骚扰超标点的骚扰源后，即可采用相对应的骚扰源抑制措施。<br>一般来说：<br>首先抑制骚扰源，这可以通过优化电路设计、电路结构和排版，加强滤波和正确的接地来达到。<br>其次是要切断耦合途径，这可以通过正确的机壳屏蔽和传输线滤波达到。<br><strong>首先说下机箱问题：</strong></p>\n<p>一、金属机箱屏蔽性能不完善（非金属机箱还没碰到不做讨论）<br>对于金属机箱屏蔽性能不完善引起的辐射骚扰发射超标，应采取以下措施：<br>1）机箱的缝隙过大，或机箱配合上存在问题<br>　处理意见：<br>（1）清除结合面上的油漆、氧化层及表面玷污；<br>（2）增加结合面上的紧固件数目及接触表面的平整度；<br>（3）采取永久性的接缝（要连续焊接）；<br>（4）采用导电衬垫来改善接触表面的接触性能。<br>2）其他功能性开孔过大<br>处理意见：<br>（1）通风口采用防尘板，必要时采用波导通风板，但后者成本昂贵；<br>（2）显示窗口采用带有屏蔽作用的透明材料；或采用隔舱，并对信号线采取滤波措施；<br>（3）对键盘等采用隔舱，并对信号线采取滤波措施。<br>3）机箱内部布线不当，电磁骚扰透过缝隙逸出<br>处理意见：<br>&nbsp; 将印刷板及设备内部布线等可能产生辐射骚扰的布局，远离缝隙或功能性开孔的部位，<br>&nbsp; 或采取增加屏蔽的补救措施或重新布局。<br><strong>其次说下线缆问题：</strong><br>1）对电源线的处理<br>（1）加装电源线滤波器（如果己经有滤波器，则换用高性能的滤波器），要特别注意安装位置（尽可能放在机箱中电源线入口端）和安装情况，要保证滤波器外壳与机箱搭接良好、接地良好；<br>（2）如果不合格的频率比较高，可考虑在电源线入口的部分套装铁氧体磁环。<br>2）对信号线的处理<br>（1）在信号线上套铁氧体磁环（或铁氧体磁夹）；<br>（2）对信号线滤波（共模滤波），必要时将连接器改用滤波阵列板或滤波连接器；<br>（3）换用屏蔽电缆，屏蔽电缆的屏蔽层与机箱尽量采用360&deg;搭接方式，必要时在屏蔽线上再套铁氧体磁环</p>\n<h2>5.6：骚扰功率干扰的产生和对策</h2>\n<p><strong>骚扰功率的主要来源：</strong></p>\n<p>a:电源线滤波装置的高频插入损耗不足</p>\n<p><strong>解决方法：</strong></p>\n<p>（1）滤波器电路没有屏蔽，这种情况经常发生在将滤波电路安装在线路板上的场合，高频干扰直接耦合进滤波电路，造成滤波器失效；<br>（2）滤波器本身高频性能不良，在100MHz以上插入损耗很小；<br>（3）使用非屏蔽机箱，导致滤波器的金属外壳无处端接；<strong><br></strong>（4）使用非屏蔽机箱，干扰直接耦合到电源线和信号线上，滤波器实际上没有起作用；<br>（5）在屏蔽机箱中，滤波器离电源进口过远、造成干扰直接耦合到电源线和信号线上；<br>（6）在屏蔽机箱中，滤波器外壳与金属机箱之间连接阻抗过大（没有直接搭接，而是通过长导线连接）；<br>（7）滤波器的输入线与输出线靠得很近，发生耦合，导致滤波器的高频插人损耗不足。<strong><br><br></strong></p>\n<p><strong>参考书籍:&lt;EMC（电磁兼容）设计与测试案例分析 郑军奇编著 电子工业出版社&gt;</strong></p>\n<p><strong>看书的时候整理了一下导图无私分享下：</strong></p>\n<div class=\"cnblogs_Highlighter\">\n<pre class=\"brush:csharp;gutter:true;\">git@gitee.com:qian-qiang/book-map.git\n</pre>\n</div>\n<p>&nbsp;</p>\n"},{"title":"超详细解析python爬取外网图片","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2022-01-01T11:46:39.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"废话不多说直接上货\n\n```python\nfrom bs4 import BeautifulSoup          #网页解析库\nimport requests                        #网页请求库\nimport json                            #json数据解析库\nimport random                          #随机数产生库\nimport hashlib                         #MD5加密算法的模块\nimport urllib                          #python自带的http请求库\n\nlist = []                              #存放图片的网站\n\nheaders ={\n    'accept':'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',\n    'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:73.0) Gecko/20100101 Firefox/73.0'\n}                                      #我用的是Firefox浏览器伪造请求头\ndef baidu_translate(text, fromLang='zh', toLang='en'):                    #中文翻译函数（不懂请看下面链接）\n    appid = 'xxxxxxxxxxxxxx'                                              #每个账号的appid\n    secretKey = 'xxxxxxxxxxxxx'                                           #每个账号的钥匙\n\n    myurl = 'http://api.fanyi.baidu.com/api/trans/vip/translate'          #百度翻译必须带上的头部\n    q = text                                                              #需要翻译的中文\n    salt = random.randint(32768, 65536)                                   #salt是产生的随机数\n\n    sign = appid + q + str(salt) + secretKey                              #拼接字符串1\n    m1 = hashlib.md5()                                                 \n    m1.update(sign.encode('utf-8'))                             \n    sign = m1.hexdigest()                                                 #mdk5加密生成的计算签名\n    myur1 = myurl  + '?q=' + urllib.parse.quote(\n        q) + '&from=' + fromLang + '&to=' + toLang + '&appid='+ appid + '&salt=' + str(salt) + '&sign=' + sign                                     #拼接字符串1+mdk5加密生成的计算签名生产的翻译网页\n    return myur1                                                          #函数返回翻译网页\n\nurl_path = 'https://unsplash.com/s/photos/'         #我爬取的是国外的unsplash网站的图片\nword= input('请输入你要下载的图片：')                                      #输入中文要下载的图片\nenglish_data = requests.get(baidu_translate(word))                       #请求百度翻译api的翻译                                          \njs_data = json.loads(english_data.text)                                  #下载翻译网页返回的json数据                          \ncontent = js_data['trans_result'][0]['dst']                              #提取其中的英文翻译\nurl = url_path + content + '/'                      #将英文翻译添加到图片网站上形成你要访问的图片主页\n\nwb_data = requests.get(url,headers=headers)                              #请求图片网站数据\nsoup = BeautifulSoup(wb_data.text,'lxml')                                #解析数据\nimgs = soup.select('a > div > img')                                      #定位到图片的网页地址\n\nfor img in imgs:                                                         #将所有的图片url都下载到list中\n    photo = img.get('src')                                               #提取src节点的数据\n    list.append(photo)                                                   #得到图片的url\n\npath = 'C:/Users/qq/Pictures/Camera Roll/'                               #我的保存路径\nfor item in list:                                                        #读取每个图片的url\n        data = requests.get(item,headers=headers)                        #请求url\n        fp = open(path+item.split('?')[0][-27:]+'.jpg','wb')             #图片的名字\n        fp.write(data.content)                                           #下载图片\n        fp.close()                                                       #下载完成关闭图片\n       \n\n\n```\n下面说下重点\n1.百度翻译的实现过程，请看下面的文章：[百度API的使用方法](https://blog.csdn.net/weixin_43495433/article/details/104608087)\n2.图片网站和图片的url：\n   图片网站是指查找图片的网站!![](超详细解析python爬取外网图片/20200302110709393.png)\n   这个是图片的url![这个是图片的url](超详细解析python爬取外网图片/20200302111109517.png)","source":"_posts/2022/01/超详细解析python爬取外网图片.md","raw":"---\ntitle: 超详细解析python爬取外网图片\npermalink: 超详细解析python爬取外网图片\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2022-01-01 19:46:39\npassword:\nsummary:\ntags:\n- python\ncategories:\n- python\nkeywords:\ndescription:\n---\n废话不多说直接上货\n\n```python\nfrom bs4 import BeautifulSoup          #网页解析库\nimport requests                        #网页请求库\nimport json                            #json数据解析库\nimport random                          #随机数产生库\nimport hashlib                         #MD5加密算法的模块\nimport urllib                          #python自带的http请求库\n\nlist = []                              #存放图片的网站\n\nheaders ={\n    'accept':'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',\n    'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:73.0) Gecko/20100101 Firefox/73.0'\n}                                      #我用的是Firefox浏览器伪造请求头\ndef baidu_translate(text, fromLang='zh', toLang='en'):                    #中文翻译函数（不懂请看下面链接）\n    appid = 'xxxxxxxxxxxxxx'                                              #每个账号的appid\n    secretKey = 'xxxxxxxxxxxxx'                                           #每个账号的钥匙\n\n    myurl = 'http://api.fanyi.baidu.com/api/trans/vip/translate'          #百度翻译必须带上的头部\n    q = text                                                              #需要翻译的中文\n    salt = random.randint(32768, 65536)                                   #salt是产生的随机数\n\n    sign = appid + q + str(salt) + secretKey                              #拼接字符串1\n    m1 = hashlib.md5()                                                 \n    m1.update(sign.encode('utf-8'))                             \n    sign = m1.hexdigest()                                                 #mdk5加密生成的计算签名\n    myur1 = myurl  + '?q=' + urllib.parse.quote(\n        q) + '&from=' + fromLang + '&to=' + toLang + '&appid='+ appid + '&salt=' + str(salt) + '&sign=' + sign                                     #拼接字符串1+mdk5加密生成的计算签名生产的翻译网页\n    return myur1                                                          #函数返回翻译网页\n\nurl_path = 'https://unsplash.com/s/photos/'         #我爬取的是国外的unsplash网站的图片\nword= input('请输入你要下载的图片：')                                      #输入中文要下载的图片\nenglish_data = requests.get(baidu_translate(word))                       #请求百度翻译api的翻译                                          \njs_data = json.loads(english_data.text)                                  #下载翻译网页返回的json数据                          \ncontent = js_data['trans_result'][0]['dst']                              #提取其中的英文翻译\nurl = url_path + content + '/'                      #将英文翻译添加到图片网站上形成你要访问的图片主页\n\nwb_data = requests.get(url,headers=headers)                              #请求图片网站数据\nsoup = BeautifulSoup(wb_data.text,'lxml')                                #解析数据\nimgs = soup.select('a > div > img')                                      #定位到图片的网页地址\n\nfor img in imgs:                                                         #将所有的图片url都下载到list中\n    photo = img.get('src')                                               #提取src节点的数据\n    list.append(photo)                                                   #得到图片的url\n\npath = 'C:/Users/qq/Pictures/Camera Roll/'                               #我的保存路径\nfor item in list:                                                        #读取每个图片的url\n        data = requests.get(item,headers=headers)                        #请求url\n        fp = open(path+item.split('?')[0][-27:]+'.jpg','wb')             #图片的名字\n        fp.write(data.content)                                           #下载图片\n        fp.close()                                                       #下载完成关闭图片\n       \n\n\n```\n下面说下重点\n1.百度翻译的实现过程，请看下面的文章：[百度API的使用方法](https://blog.csdn.net/weixin_43495433/article/details/104608087)\n2.图片网站和图片的url：\n   图片网站是指查找图片的网站!![](超详细解析python爬取外网图片/20200302110709393.png)\n   这个是图片的url![这个是图片的url](超详细解析python爬取外网图片/20200302111109517.png)","slug":"超详细解析python爬取外网图片","published":1,"updated":"2024-01-05T08:12:19.110Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clru1g20m000ns4fu53hv0diq","content":"<p>废话不多说直接上货</p>\n<pre class=\" language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> bs4 <span class=\"token keyword\">import</span> BeautifulSoup          <span class=\"token comment\" spellcheck=\"true\">#网页解析库</span>\n<span class=\"token keyword\">import</span> requests                        <span class=\"token comment\" spellcheck=\"true\">#网页请求库</span>\n<span class=\"token keyword\">import</span> json                            <span class=\"token comment\" spellcheck=\"true\">#json数据解析库</span>\n<span class=\"token keyword\">import</span> random                          <span class=\"token comment\" spellcheck=\"true\">#随机数产生库</span>\n<span class=\"token keyword\">import</span> hashlib                         <span class=\"token comment\" spellcheck=\"true\">#MD5加密算法的模块</span>\n<span class=\"token keyword\">import</span> urllib                          <span class=\"token comment\" spellcheck=\"true\">#python自带的http请求库</span>\n\nlist <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>                              <span class=\"token comment\" spellcheck=\"true\">#存放图片的网站</span>\n\nheaders <span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>\n    <span class=\"token string\">'accept'</span><span class=\"token punctuation\">:</span><span class=\"token string\">'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'User-Agent'</span><span class=\"token punctuation\">:</span><span class=\"token string\">'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:73.0) Gecko/20100101 Firefox/73.0'</span>\n<span class=\"token punctuation\">}</span>                                      <span class=\"token comment\" spellcheck=\"true\">#我用的是Firefox浏览器伪造请求头</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">baidu_translate</span><span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">,</span> fromLang<span class=\"token operator\">=</span><span class=\"token string\">'zh'</span><span class=\"token punctuation\">,</span> toLang<span class=\"token operator\">=</span><span class=\"token string\">'en'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>                    <span class=\"token comment\" spellcheck=\"true\">#中文翻译函数（不懂请看下面链接）</span>\n    appid <span class=\"token operator\">=</span> <span class=\"token string\">'xxxxxxxxxxxxxx'</span>                                              <span class=\"token comment\" spellcheck=\"true\">#每个账号的appid</span>\n    secretKey <span class=\"token operator\">=</span> <span class=\"token string\">'xxxxxxxxxxxxx'</span>                                           <span class=\"token comment\" spellcheck=\"true\">#每个账号的钥匙</span>\n\n    myurl <span class=\"token operator\">=</span> <span class=\"token string\">'http://api.fanyi.baidu.com/api/trans/vip/translate'</span>          <span class=\"token comment\" spellcheck=\"true\">#百度翻译必须带上的头部</span>\n    q <span class=\"token operator\">=</span> text                                                              <span class=\"token comment\" spellcheck=\"true\">#需要翻译的中文</span>\n    salt <span class=\"token operator\">=</span> random<span class=\"token punctuation\">.</span>randint<span class=\"token punctuation\">(</span><span class=\"token number\">32768</span><span class=\"token punctuation\">,</span> <span class=\"token number\">65536</span><span class=\"token punctuation\">)</span>                                   <span class=\"token comment\" spellcheck=\"true\">#salt是产生的随机数</span>\n\n    sign <span class=\"token operator\">=</span> appid <span class=\"token operator\">+</span> q <span class=\"token operator\">+</span> str<span class=\"token punctuation\">(</span>salt<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> secretKey                              <span class=\"token comment\" spellcheck=\"true\">#拼接字符串1</span>\n    m1 <span class=\"token operator\">=</span> hashlib<span class=\"token punctuation\">.</span>md5<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>                                                 \n    m1<span class=\"token punctuation\">.</span>update<span class=\"token punctuation\">(</span>sign<span class=\"token punctuation\">.</span>encode<span class=\"token punctuation\">(</span><span class=\"token string\">'utf-8'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>                             \n    sign <span class=\"token operator\">=</span> m1<span class=\"token punctuation\">.</span>hexdigest<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>                                                 <span class=\"token comment\" spellcheck=\"true\">#mdk5加密生成的计算签名</span>\n    myur1 <span class=\"token operator\">=</span> myurl  <span class=\"token operator\">+</span> <span class=\"token string\">'?q='</span> <span class=\"token operator\">+</span> urllib<span class=\"token punctuation\">.</span>parse<span class=\"token punctuation\">.</span>quote<span class=\"token punctuation\">(</span>\n        q<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">'&amp;from='</span> <span class=\"token operator\">+</span> fromLang <span class=\"token operator\">+</span> <span class=\"token string\">'&amp;to='</span> <span class=\"token operator\">+</span> toLang <span class=\"token operator\">+</span> <span class=\"token string\">'&amp;appid='</span><span class=\"token operator\">+</span> appid <span class=\"token operator\">+</span> <span class=\"token string\">'&amp;salt='</span> <span class=\"token operator\">+</span> str<span class=\"token punctuation\">(</span>salt<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">'&amp;sign='</span> <span class=\"token operator\">+</span> sign                                     <span class=\"token comment\" spellcheck=\"true\">#拼接字符串1+mdk5加密生成的计算签名生产的翻译网页</span>\n    <span class=\"token keyword\">return</span> myur1                                                          <span class=\"token comment\" spellcheck=\"true\">#函数返回翻译网页</span>\n\nurl_path <span class=\"token operator\">=</span> <span class=\"token string\">'https://unsplash.com/s/photos/'</span>         <span class=\"token comment\" spellcheck=\"true\">#我爬取的是国外的unsplash网站的图片</span>\nword<span class=\"token operator\">=</span> input<span class=\"token punctuation\">(</span><span class=\"token string\">'请输入你要下载的图片：'</span><span class=\"token punctuation\">)</span>                                      <span class=\"token comment\" spellcheck=\"true\">#输入中文要下载的图片</span>\nenglish_data <span class=\"token operator\">=</span> requests<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span>baidu_translate<span class=\"token punctuation\">(</span>word<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>                       <span class=\"token comment\" spellcheck=\"true\">#请求百度翻译api的翻译                                          </span>\njs_data <span class=\"token operator\">=</span> json<span class=\"token punctuation\">.</span>loads<span class=\"token punctuation\">(</span>english_data<span class=\"token punctuation\">.</span>text<span class=\"token punctuation\">)</span>                                  <span class=\"token comment\" spellcheck=\"true\">#下载翻译网页返回的json数据                          </span>\ncontent <span class=\"token operator\">=</span> js_data<span class=\"token punctuation\">[</span><span class=\"token string\">'trans_result'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token string\">'dst'</span><span class=\"token punctuation\">]</span>                              <span class=\"token comment\" spellcheck=\"true\">#提取其中的英文翻译</span>\nurl <span class=\"token operator\">=</span> url_path <span class=\"token operator\">+</span> content <span class=\"token operator\">+</span> <span class=\"token string\">'/'</span>                      <span class=\"token comment\" spellcheck=\"true\">#将英文翻译添加到图片网站上形成你要访问的图片主页</span>\n\nwb_data <span class=\"token operator\">=</span> requests<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">,</span>headers<span class=\"token operator\">=</span>headers<span class=\"token punctuation\">)</span>                              <span class=\"token comment\" spellcheck=\"true\">#请求图片网站数据</span>\nsoup <span class=\"token operator\">=</span> BeautifulSoup<span class=\"token punctuation\">(</span>wb_data<span class=\"token punctuation\">.</span>text<span class=\"token punctuation\">,</span><span class=\"token string\">'lxml'</span><span class=\"token punctuation\">)</span>                                <span class=\"token comment\" spellcheck=\"true\">#解析数据</span>\nimgs <span class=\"token operator\">=</span> soup<span class=\"token punctuation\">.</span>select<span class=\"token punctuation\">(</span><span class=\"token string\">'a > div > img'</span><span class=\"token punctuation\">)</span>                                      <span class=\"token comment\" spellcheck=\"true\">#定位到图片的网页地址</span>\n\n<span class=\"token keyword\">for</span> img <span class=\"token keyword\">in</span> imgs<span class=\"token punctuation\">:</span>                                                         <span class=\"token comment\" spellcheck=\"true\">#将所有的图片url都下载到list中</span>\n    photo <span class=\"token operator\">=</span> img<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span><span class=\"token string\">'src'</span><span class=\"token punctuation\">)</span>                                               <span class=\"token comment\" spellcheck=\"true\">#提取src节点的数据</span>\n    list<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>photo<span class=\"token punctuation\">)</span>                                                   <span class=\"token comment\" spellcheck=\"true\">#得到图片的url</span>\n\npath <span class=\"token operator\">=</span> <span class=\"token string\">'C:/Users/qq/Pictures/Camera Roll/'</span>                               <span class=\"token comment\" spellcheck=\"true\">#我的保存路径</span>\n<span class=\"token keyword\">for</span> item <span class=\"token keyword\">in</span> list<span class=\"token punctuation\">:</span>                                                        <span class=\"token comment\" spellcheck=\"true\">#读取每个图片的url</span>\n        data <span class=\"token operator\">=</span> requests<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">,</span>headers<span class=\"token operator\">=</span>headers<span class=\"token punctuation\">)</span>                        <span class=\"token comment\" spellcheck=\"true\">#请求url</span>\n        fp <span class=\"token operator\">=</span> open<span class=\"token punctuation\">(</span>path<span class=\"token operator\">+</span>item<span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token string\">'?'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">27</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span><span class=\"token operator\">+</span><span class=\"token string\">'.jpg'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'wb'</span><span class=\"token punctuation\">)</span>             <span class=\"token comment\" spellcheck=\"true\">#图片的名字</span>\n        fp<span class=\"token punctuation\">.</span>write<span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">.</span>content<span class=\"token punctuation\">)</span>                                           <span class=\"token comment\" spellcheck=\"true\">#下载图片</span>\n        fp<span class=\"token punctuation\">.</span>close<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>                                                       <span class=\"token comment\" spellcheck=\"true\">#下载完成关闭图片</span>\n\n\n</code></pre>\n<p>下面说下重点<br>1.百度翻译的实现过程，请看下面的文章：<a href=\"https://blog.csdn.net/weixin_43495433/article/details/104608087\" target=\"_blank\" rel=\"noopener\">百度API的使用方法</a><br>2.图片网站和图片的url：<br>   图片网站是指查找图片的网站!<img src=\"/2022/01/chao-xiang-xi-jie-xi-python-pa-qu-wai-wang-tu-pian/20200302110709393.png\" alt><br>   这个是图片的url<img src=\"/2022/01/chao-xiang-xi-jie-xi-python-pa-qu-wai-wang-tu-pian/20200302111109517.png\" alt=\"这个是图片的url\"></p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<p>废话不多说直接上货</p>\n<pre><code class=\"python\">from bs4 import BeautifulSoup          #网页解析库\nimport requests                        #网页请求库\nimport json                            #json数据解析库\nimport random                          #随机数产生库\nimport hashlib                         #MD5加密算法的模块\nimport urllib                          #python自带的http请求库\n\nlist = []                              #存放图片的网站\n\nheaders ={\n    &#39;accept&#39;:&#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&#39;,\n    &#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:73.0) Gecko/20100101 Firefox/73.0&#39;\n}                                      #我用的是Firefox浏览器伪造请求头\ndef baidu_translate(text, fromLang=&#39;zh&#39;, toLang=&#39;en&#39;):                    #中文翻译函数（不懂请看下面链接）\n    appid = &#39;xxxxxxxxxxxxxx&#39;                                              #每个账号的appid\n    secretKey = &#39;xxxxxxxxxxxxx&#39;                                           #每个账号的钥匙\n\n    myurl = &#39;http://api.fanyi.baidu.com/api/trans/vip/translate&#39;          #百度翻译必须带上的头部\n    q = text                                                              #需要翻译的中文\n    salt = random.randint(32768, 65536)                                   #salt是产生的随机数\n\n    sign = appid + q + str(salt) + secretKey                              #拼接字符串1\n    m1 = hashlib.md5()                                                 \n    m1.update(sign.encode(&#39;utf-8&#39;))                             \n    sign = m1.hexdigest()                                                 #mdk5加密生成的计算签名\n    myur1 = myurl  + &#39;?q=&#39; + urllib.parse.quote(\n        q) + &#39;&amp;from=&#39; + fromLang + &#39;&amp;to=&#39; + toLang + &#39;&amp;appid=&#39;+ appid + &#39;&amp;salt=&#39; + str(salt) + &#39;&amp;sign=&#39; + sign                                     #拼接字符串1+mdk5加密生成的计算签名生产的翻译网页\n    return myur1                                                          #函数返回翻译网页\n\nurl_path = &#39;https://unsplash.com/s/photos/&#39;         #我爬取的是国外的unsplash网站的图片\nword= input(&#39;请输入你要下载的图片：&#39;)                                      #输入中文要下载的图片\nenglish_data = requests.get(baidu_translate(word))                       #请求百度翻译api的翻译                                          \njs_data = json.loads(english_data.text)                                  #下载翻译网页返回的json数据                          \ncontent = js_data[&#39;trans_result&#39;][0][&#39;dst&#39;]                              #提取其中的英文翻译\nurl = url_path + content + &#39;/&#39;                      #将英文翻译添加到图片网站上形成你要访问的图片主页\n\nwb_data = requests.get(url,headers=headers)                              #请求图片网站数据\nsoup = BeautifulSoup(wb_data.text,&#39;lxml&#39;)                                #解析数据\nimgs = soup.select(&#39;a &gt; div &gt; img&#39;)                                      #定位到图片的网页地址\n\nfor img in imgs:                                                         #将所有的图片url都下载到list中\n    photo = img.get(&#39;src&#39;)                                               #提取src节点的数据\n    list.append(photo)                                                   #得到图片的url\n\npath = &#39;C:/Users/qq/Pictures/Camera Roll/&#39;                               #我的保存路径\nfor item in list:                                                        #读取每个图片的url\n        data = requests.get(item,headers=headers)                        #请求url\n        fp = open(path+item.split(&#39;?&#39;)[0][-27:]+&#39;.jpg&#39;,&#39;wb&#39;)             #图片的名字\n        fp.write(data.content)                                           #下载图片\n        fp.close()                                                       #下载完成关闭图片\n\n\n</code></pre>\n<p>下面说下重点<br>1.百度翻译的实现过程，请看下面的文章：<a href=\"https://blog.csdn.net/weixin_43495433/article/details/104608087\" target=\"_blank\" rel=\"noopener\">百度API的使用方法</a><br>2.图片网站和图片的url：<br>   图片网站是指查找图片的网站!<img src=\"/2022/01/chao-xiang-xi-jie-xi-python-pa-qu-wai-wang-tu-pian/20200302110709393.png\" alt><br>   这个是图片的url<img src=\"/2022/01/chao-xiang-xi-jie-xi-python-pa-qu-wai-wang-tu-pian/20200302111109517.png\" alt=\"这个是图片的url\"></p>\n"},{"title":"上海","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-04-02T15:09:12.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"\n![20230403160820.jpg](20230403160820.jpg)\n![20230403160809.jpg](20230403160809.jpg)\n![20230403160752.jpg](20230403160752.jpg)\n![20230403160815.jpg](20230403160815.jpg)\n","source":"_posts/2023/04/上海.md","raw":"---\ntitle: 上海\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-04-02 23:09:12\npassword:\nsummary:\ntags:\n- gallery-上海\ncategories:\n- gallery\nkeywords:\ndescription:\n---\n\n![20230403160820.jpg](20230403160820.jpg)\n![20230403160809.jpg](20230403160809.jpg)\n![20230403160752.jpg](20230403160752.jpg)\n![20230403160815.jpg](20230403160815.jpg)\n","slug":"上海","published":1,"updated":"2024-01-05T08:12:19.338Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clru1g20q000ss4fup0eq2s1f","content":"<p><img src=\"/2023/04/shang-hai/20230403160820.jpg\" alt=\"20230403160820.jpg\"><br><img src=\"/2023/04/shang-hai/20230403160809.jpg\" alt=\"20230403160809.jpg\"><br><img src=\"/2023/04/shang-hai/20230403160752.jpg\" alt=\"20230403160752.jpg\"><br><img src=\"/2023/04/shang-hai/20230403160815.jpg\" alt=\"20230403160815.jpg\"></p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<p><img src=\"/2023/04/shang-hai/20230403160820.jpg\" alt=\"20230403160820.jpg\"><br><img src=\"/2023/04/shang-hai/20230403160809.jpg\" alt=\"20230403160809.jpg\"><br><img src=\"/2023/04/shang-hai/20230403160752.jpg\" alt=\"20230403160752.jpg\"><br><img src=\"/2023/04/shang-hai/20230403160815.jpg\" alt=\"20230403160815.jpg\"></p>\n"},{"title":"北京","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-04-17T06:02:09.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"\n![DSC01755.JPG](DSC01755.JPG)\n![DSC01687.JPG](DSC01687.JPG)\n![IMG_6717.JPG](IMG_6717.JPG)\n![DSC01645.JPG](DSC01645.JPG)\n![DSC01697.JPG](DSC01697.JPG)\n![DSC01821.JPG](DSC01821.JPG)\n![DSC01699.JPG](DSC01699.JPG)\n![DSC01827.JPG](DSC01827.JPG)\n![IMG_6716.JPG](IMG_6716.JPG)\n![DSC01722.JPG](DSC01722.JPG)\n","source":"_posts/2023/04/北京.md","raw":"---\ntitle: 北京\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-04-17 14:02:09\npassword:\nsummary:\ntags:\n- gallery-北京\ncategories:\n- gallery\nkeywords:\ndescription:\n---\n\n![DSC01755.JPG](DSC01755.JPG)\n![DSC01687.JPG](DSC01687.JPG)\n![IMG_6717.JPG](IMG_6717.JPG)\n![DSC01645.JPG](DSC01645.JPG)\n![DSC01697.JPG](DSC01697.JPG)\n![DSC01821.JPG](DSC01821.JPG)\n![DSC01699.JPG](DSC01699.JPG)\n![DSC01827.JPG](DSC01827.JPG)\n![IMG_6716.JPG](IMG_6716.JPG)\n![DSC01722.JPG](DSC01722.JPG)\n","slug":"北京","published":1,"updated":"2024-01-05T08:12:19.483Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clru1g20u000us4fup0iw7xda","content":"<p><img src=\"/2023/04/bei-jing/DSC01755.JPG\" alt=\"DSC01755.JPG\"><br><img src=\"/2023/04/bei-jing/DSC01687.JPG\" alt=\"DSC01687.JPG\"><br><img src=\"/2023/04/bei-jing/IMG_6717.JPG\" alt=\"IMG_6717.JPG\"><br><img src=\"/2023/04/bei-jing/DSC01645.JPG\" alt=\"DSC01645.JPG\"><br><img src=\"/2023/04/bei-jing/DSC01697.JPG\" alt=\"DSC01697.JPG\"><br><img src=\"/2023/04/bei-jing/DSC01821.JPG\" alt=\"DSC01821.JPG\"><br><img src=\"/2023/04/bei-jing/DSC01699.JPG\" alt=\"DSC01699.JPG\"><br><img src=\"/2023/04/bei-jing/DSC01827.JPG\" alt=\"DSC01827.JPG\"><br><img src=\"/2023/04/bei-jing/IMG_6716.JPG\" alt=\"IMG_6716.JPG\"><br><img src=\"/2023/04/bei-jing/DSC01722.JPG\" alt=\"DSC01722.JPG\"></p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<p><img src=\"/2023/04/bei-jing/DSC01755.JPG\" alt=\"DSC01755.JPG\"><br><img src=\"/2023/04/bei-jing/DSC01687.JPG\" alt=\"DSC01687.JPG\"><br><img src=\"/2023/04/bei-jing/IMG_6717.JPG\" alt=\"IMG_6717.JPG\"><br><img src=\"/2023/04/bei-jing/DSC01645.JPG\" alt=\"DSC01645.JPG\"><br><img src=\"/2023/04/bei-jing/DSC01697.JPG\" alt=\"DSC01697.JPG\"><br><img src=\"/2023/04/bei-jing/DSC01821.JPG\" alt=\"DSC01821.JPG\"><br><img src=\"/2023/04/bei-jing/DSC01699.JPG\" alt=\"DSC01699.JPG\"><br><img src=\"/2023/04/bei-jing/DSC01827.JPG\" alt=\"DSC01827.JPG\"><br><img src=\"/2023/04/bei-jing/IMG_6716.JPG\" alt=\"IMG_6716.JPG\"><br><img src=\"/2023/04/bei-jing/DSC01722.JPG\" alt=\"DSC01722.JPG\"></p>\n"},{"title":"新疆","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-04-02T15:09:07.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"\n![a2a9265c2707c16b5a1ca704a4d0856d.JPG](a2a9265c2707c16b5a1ca704a4d0856d.JPG)\n![88a98ae85a4705294439aca39ae07d672.JPG](88a98ae85a4705294439aca39ae07d672.JPG)\n![XRBQ0574.JPG](XRBQ0574.JPG)\n![MOVG5083.JPG](MOVG5083.JPG)\n![ANKG1449.JPG](ANKG1449.JPG)\n![1b706b934fc955412e3ed163fd0b7cbc2.JPG](1b706b934fc955412e3ed163fd0b7cbc2.JPG)\n![a51d80549e7edc0d1ba69a885aa946ff2.JPG](a51d80549e7edc0d1ba69a885aa946ff2.JPG)\n![95d557eb4ef2235d74a45743be1b05842.JPG](95d557eb4ef2235d74a45743be1b05842.JPG)\n![76d386e1b8eeeb85abab758cefc855e0.JPG](76d386e1b8eeeb85abab758cefc855e0.JPG)\n![AQSR2937.JPG](AQSR2937.JPG)\n![AZQE3071.JPG](AZQE3071.JPG)\n![YJUM1401.JPG](YJUM1401.JPG)\n![89c05a76a9273811c585c395890c9f522.JPG](89c05a76a9273811c585c395890c9f522.JPG)\n![BBOD4958.JPG](BBOD4958.JPG)\n![2d25bdf0ce35910c874badcedff928002.JPG](2d25bdf0ce35910c874badcedff928002.JPG)\n![IGAX1811.JPG](IGAX1811.JPG)\n![5d0b74a8910a3abba7e860149b9d40e12.JPG](5d0b74a8910a3abba7e860149b9d40e12.JPG)\n","source":"_posts/2023/04/新疆.md","raw":"---\ntitle: 新疆\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-04-02 23:09:07\npassword:\nsummary:\ntags: \n- gallery-新疆\ncategories:\n- gallery\nkeywords:\ndescription:\n---\n\n![a2a9265c2707c16b5a1ca704a4d0856d.JPG](a2a9265c2707c16b5a1ca704a4d0856d.JPG)\n![88a98ae85a4705294439aca39ae07d672.JPG](88a98ae85a4705294439aca39ae07d672.JPG)\n![XRBQ0574.JPG](XRBQ0574.JPG)\n![MOVG5083.JPG](MOVG5083.JPG)\n![ANKG1449.JPG](ANKG1449.JPG)\n![1b706b934fc955412e3ed163fd0b7cbc2.JPG](1b706b934fc955412e3ed163fd0b7cbc2.JPG)\n![a51d80549e7edc0d1ba69a885aa946ff2.JPG](a51d80549e7edc0d1ba69a885aa946ff2.JPG)\n![95d557eb4ef2235d74a45743be1b05842.JPG](95d557eb4ef2235d74a45743be1b05842.JPG)\n![76d386e1b8eeeb85abab758cefc855e0.JPG](76d386e1b8eeeb85abab758cefc855e0.JPG)\n![AQSR2937.JPG](AQSR2937.JPG)\n![AZQE3071.JPG](AZQE3071.JPG)\n![YJUM1401.JPG](YJUM1401.JPG)\n![89c05a76a9273811c585c395890c9f522.JPG](89c05a76a9273811c585c395890c9f522.JPG)\n![BBOD4958.JPG](BBOD4958.JPG)\n![2d25bdf0ce35910c874badcedff928002.JPG](2d25bdf0ce35910c874badcedff928002.JPG)\n![IGAX1811.JPG](IGAX1811.JPG)\n![5d0b74a8910a3abba7e860149b9d40e12.JPG](5d0b74a8910a3abba7e860149b9d40e12.JPG)\n","slug":"新疆","published":1,"updated":"2024-01-05T08:12:19.518Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clru1g211000ys4fuin3pfiq8","content":"<p><img src=\"/2023/04/xin-jiang/a2a9265c2707c16b5a1ca704a4d0856d.JPG\" alt=\"a2a9265c2707c16b5a1ca704a4d0856d.JPG\"><br><img src=\"/2023/04/xin-jiang/88a98ae85a4705294439aca39ae07d672.JPG\" alt=\"88a98ae85a4705294439aca39ae07d672.JPG\"><br><img src=\"/2023/04/xin-jiang/XRBQ0574.JPG\" alt=\"XRBQ0574.JPG\"><br><img src=\"/2023/04/xin-jiang/MOVG5083.JPG\" alt=\"MOVG5083.JPG\"><br><img src=\"/2023/04/xin-jiang/ANKG1449.JPG\" alt=\"ANKG1449.JPG\"><br><img src=\"/2023/04/xin-jiang/1b706b934fc955412e3ed163fd0b7cbc2.JPG\" alt=\"1b706b934fc955412e3ed163fd0b7cbc2.JPG\"><br><img src=\"/2023/04/xin-jiang/a51d80549e7edc0d1ba69a885aa946ff2.JPG\" alt=\"a51d80549e7edc0d1ba69a885aa946ff2.JPG\"><br><img src=\"/2023/04/xin-jiang/95d557eb4ef2235d74a45743be1b05842.JPG\" alt=\"95d557eb4ef2235d74a45743be1b05842.JPG\"><br><img src=\"/2023/04/xin-jiang/76d386e1b8eeeb85abab758cefc855e0.JPG\" alt=\"76d386e1b8eeeb85abab758cefc855e0.JPG\"><br><img src=\"/2023/04/xin-jiang/AQSR2937.JPG\" alt=\"AQSR2937.JPG\"><br><img src=\"/2023/04/xin-jiang/AZQE3071.JPG\" alt=\"AZQE3071.JPG\"><br><img src=\"/2023/04/xin-jiang/YJUM1401.JPG\" alt=\"YJUM1401.JPG\"><br><img src=\"/2023/04/xin-jiang/89c05a76a9273811c585c395890c9f522.JPG\" alt=\"89c05a76a9273811c585c395890c9f522.JPG\"><br><img src=\"/2023/04/xin-jiang/BBOD4958.JPG\" alt=\"BBOD4958.JPG\"><br><img src=\"/2023/04/xin-jiang/2d25bdf0ce35910c874badcedff928002.JPG\" alt=\"2d25bdf0ce35910c874badcedff928002.JPG\"><br><img src=\"/2023/04/xin-jiang/IGAX1811.JPG\" alt=\"IGAX1811.JPG\"><br><img src=\"/2023/04/xin-jiang/5d0b74a8910a3abba7e860149b9d40e12.JPG\" alt=\"5d0b74a8910a3abba7e860149b9d40e12.JPG\"></p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<p><img src=\"/2023/04/xin-jiang/a2a9265c2707c16b5a1ca704a4d0856d.JPG\" alt=\"a2a9265c2707c16b5a1ca704a4d0856d.JPG\"><br><img src=\"/2023/04/xin-jiang/88a98ae85a4705294439aca39ae07d672.JPG\" alt=\"88a98ae85a4705294439aca39ae07d672.JPG\"><br><img src=\"/2023/04/xin-jiang/XRBQ0574.JPG\" alt=\"XRBQ0574.JPG\"><br><img src=\"/2023/04/xin-jiang/MOVG5083.JPG\" alt=\"MOVG5083.JPG\"><br><img src=\"/2023/04/xin-jiang/ANKG1449.JPG\" alt=\"ANKG1449.JPG\"><br><img src=\"/2023/04/xin-jiang/1b706b934fc955412e3ed163fd0b7cbc2.JPG\" alt=\"1b706b934fc955412e3ed163fd0b7cbc2.JPG\"><br><img src=\"/2023/04/xin-jiang/a51d80549e7edc0d1ba69a885aa946ff2.JPG\" alt=\"a51d80549e7edc0d1ba69a885aa946ff2.JPG\"><br><img src=\"/2023/04/xin-jiang/95d557eb4ef2235d74a45743be1b05842.JPG\" alt=\"95d557eb4ef2235d74a45743be1b05842.JPG\"><br><img src=\"/2023/04/xin-jiang/76d386e1b8eeeb85abab758cefc855e0.JPG\" alt=\"76d386e1b8eeeb85abab758cefc855e0.JPG\"><br><img src=\"/2023/04/xin-jiang/AQSR2937.JPG\" alt=\"AQSR2937.JPG\"><br><img src=\"/2023/04/xin-jiang/AZQE3071.JPG\" alt=\"AZQE3071.JPG\"><br><img src=\"/2023/04/xin-jiang/YJUM1401.JPG\" alt=\"YJUM1401.JPG\"><br><img src=\"/2023/04/xin-jiang/89c05a76a9273811c585c395890c9f522.JPG\" alt=\"89c05a76a9273811c585c395890c9f522.JPG\"><br><img src=\"/2023/04/xin-jiang/BBOD4958.JPG\" alt=\"BBOD4958.JPG\"><br><img src=\"/2023/04/xin-jiang/2d25bdf0ce35910c874badcedff928002.JPG\" alt=\"2d25bdf0ce35910c874badcedff928002.JPG\"><br><img src=\"/2023/04/xin-jiang/IGAX1811.JPG\" alt=\"IGAX1811.JPG\"><br><img src=\"/2023/04/xin-jiang/5d0b74a8910a3abba7e860149b9d40e12.JPG\" alt=\"5d0b74a8910a3abba7e860149b9d40e12.JPG\"></p>\n"},{"title":"衡山","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-04-03T08:11:43.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"![20230403161412.jpg](20230403161412.jpg)\n![20230403161440.jpg](20230403161440.jpg)\n![20230403161404.jpg](20230403161404.jpg)\n![20230403161331.jpg](20230403161331.jpg)\n![20230403161427.jpg](20230403161427.jpg)\n![20230403161419.jpg](20230403161419.jpg)\n![20230403161434.jpg](20230403161434.jpg)\n","source":"_posts/2023/04/衡山.md","raw":"---\ntitle: 衡山\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-04-03 16:11:43\npassword:\nsummary:\ntags:\n- gallery-衡山\ncategories:\n- gallery\nkeywords:\ndescription:\n---\n![20230403161412.jpg](20230403161412.jpg)\n![20230403161440.jpg](20230403161440.jpg)\n![20230403161404.jpg](20230403161404.jpg)\n![20230403161331.jpg](20230403161331.jpg)\n![20230403161427.jpg](20230403161427.jpg)\n![20230403161419.jpg](20230403161419.jpg)\n![20230403161434.jpg](20230403161434.jpg)\n","slug":"衡山","published":1,"updated":"2024-01-05T08:12:19.738Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clru1g2120011s4fuickg00wo","content":"<p><img src=\"/2023/04/heng-shan/20230403161412.jpg\" alt=\"20230403161412.jpg\"><br><img src=\"/2023/04/heng-shan/20230403161440.jpg\" alt=\"20230403161440.jpg\"><br><img src=\"/2023/04/heng-shan/20230403161404.jpg\" alt=\"20230403161404.jpg\"><br><img src=\"/2023/04/heng-shan/20230403161331.jpg\" alt=\"20230403161331.jpg\"><br><img src=\"/2023/04/heng-shan/20230403161427.jpg\" alt=\"20230403161427.jpg\"><br><img src=\"/2023/04/heng-shan/20230403161419.jpg\" alt=\"20230403161419.jpg\"><br><img src=\"/2023/04/heng-shan/20230403161434.jpg\" alt=\"20230403161434.jpg\"></p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<p><img src=\"/2023/04/heng-shan/20230403161412.jpg\" alt=\"20230403161412.jpg\"><br><img src=\"/2023/04/heng-shan/20230403161440.jpg\" alt=\"20230403161440.jpg\"><br><img src=\"/2023/04/heng-shan/20230403161404.jpg\" alt=\"20230403161404.jpg\"><br><img src=\"/2023/04/heng-shan/20230403161331.jpg\" alt=\"20230403161331.jpg\"><br><img src=\"/2023/04/heng-shan/20230403161427.jpg\" alt=\"20230403161427.jpg\"><br><img src=\"/2023/04/heng-shan/20230403161419.jpg\" alt=\"20230403161419.jpg\"><br><img src=\"/2023/04/heng-shan/20230403161434.jpg\" alt=\"20230403161434.jpg\"></p>\n"},{"title":"如何写一份需求","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-04-17T03:30:46.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"# Q：如何写好一个需求\n\n**使用以下模板写出滴滴出行软件的需求**\n![模板](业务功能-业务流程-业务规则分析/模板.png)\n\n# A：迭代需求\n## 第一版（分析起步）\n\n![分析起步](业务功能-业务流程-业务规则分析/分析起步.png)\n\t\n## 第二版（主干流程）\n\n![主干流程](业务功能-业务流程-业务规则分析/主干流程.png)\n\n## 第三版（探索分支）\n\n![探索分支](业务功能-业务流程-业务规则分析/探索分支.png)\n\n## 第四版（穷尽分支）\n\n![穷尽分支](业务功能-业务流程-业务规则分析/穷尽分支.png)\n\n## 第五版（业务规则）\n\n![业务规则](业务功能-业务流程-业务规则分析/业务规则.png)\n\n\n","source":"_posts/2023/04/业务功能-业务流程-业务规则分析.md","raw":"---\ntitle: 如何写一份需求\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-04-17 11:30:46\npassword:\nsummary:\ntags: Embedded system\ncategories: Embedded system\nkeywords:\ndescription:\n---\n# Q：如何写好一个需求\n\n**使用以下模板写出滴滴出行软件的需求**\n![模板](业务功能-业务流程-业务规则分析/模板.png)\n\n# A：迭代需求\n## 第一版（分析起步）\n\n![分析起步](业务功能-业务流程-业务规则分析/分析起步.png)\n\t\n## 第二版（主干流程）\n\n![主干流程](业务功能-业务流程-业务规则分析/主干流程.png)\n\n## 第三版（探索分支）\n\n![探索分支](业务功能-业务流程-业务规则分析/探索分支.png)\n\n## 第四版（穷尽分支）\n\n![穷尽分支](业务功能-业务流程-业务规则分析/穷尽分支.png)\n\n## 第五版（业务规则）\n\n![业务规则](业务功能-业务流程-业务规则分析/业务规则.png)\n\n\n","slug":"业务功能-业务流程-业务规则分析","published":1,"updated":"2024-01-05T08:12:19.467Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clru1g2140016s4fueh5sbcf2","content":"<h1 id=\"Q：如何写好一个需求\"><a href=\"#Q：如何写好一个需求\" class=\"headerlink\" title=\"Q：如何写好一个需求\"></a>Q：如何写好一个需求</h1><p><strong>使用以下模板写出滴滴出行软件的需求</strong><br><img src=\"/2023/04/ye-wu-gong-neng-ye-wu-liu-cheng-ye-wu-gui-ze-fen-xi/%E6%A8%A1%E6%9D%BF.png\" alt=\"模板\"></p>\n<h1 id=\"A：迭代需求\"><a href=\"#A：迭代需求\" class=\"headerlink\" title=\"A：迭代需求\"></a>A：迭代需求</h1><h2 id=\"第一版（分析起步）\"><a href=\"#第一版（分析起步）\" class=\"headerlink\" title=\"第一版（分析起步）\"></a>第一版（分析起步）</h2><p><img src=\"/2023/04/ye-wu-gong-neng-ye-wu-liu-cheng-ye-wu-gui-ze-fen-xi/%E5%88%86%E6%9E%90%E8%B5%B7%E6%AD%A5.png\" alt=\"分析起步\"></p>\n<h2 id=\"第二版（主干流程）\"><a href=\"#第二版（主干流程）\" class=\"headerlink\" title=\"第二版（主干流程）\"></a>第二版（主干流程）</h2><p><img src=\"/2023/04/ye-wu-gong-neng-ye-wu-liu-cheng-ye-wu-gui-ze-fen-xi/%E4%B8%BB%E5%B9%B2%E6%B5%81%E7%A8%8B.png\" alt=\"主干流程\"></p>\n<h2 id=\"第三版（探索分支）\"><a href=\"#第三版（探索分支）\" class=\"headerlink\" title=\"第三版（探索分支）\"></a>第三版（探索分支）</h2><p><img src=\"/2023/04/ye-wu-gong-neng-ye-wu-liu-cheng-ye-wu-gui-ze-fen-xi/%E6%8E%A2%E7%B4%A2%E5%88%86%E6%94%AF.png\" alt=\"探索分支\"></p>\n<h2 id=\"第四版（穷尽分支）\"><a href=\"#第四版（穷尽分支）\" class=\"headerlink\" title=\"第四版（穷尽分支）\"></a>第四版（穷尽分支）</h2><p><img src=\"/2023/04/ye-wu-gong-neng-ye-wu-liu-cheng-ye-wu-gui-ze-fen-xi/%E7%A9%B7%E5%B0%BD%E5%88%86%E6%94%AF.png\" alt=\"穷尽分支\"></p>\n<h2 id=\"第五版（业务规则）\"><a href=\"#第五版（业务规则）\" class=\"headerlink\" title=\"第五版（业务规则）\"></a>第五版（业务规则）</h2><p><img src=\"/2023/04/ye-wu-gong-neng-ye-wu-liu-cheng-ye-wu-gui-ze-fen-xi/%E4%B8%9A%E5%8A%A1%E8%A7%84%E5%88%99.png\" alt=\"业务规则\"></p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<h1 id=\"Q：如何写好一个需求\"><a href=\"#Q：如何写好一个需求\" class=\"headerlink\" title=\"Q：如何写好一个需求\"></a>Q：如何写好一个需求</h1><p><strong>使用以下模板写出滴滴出行软件的需求</strong><br><img src=\"/2023/04/ye-wu-gong-neng-ye-wu-liu-cheng-ye-wu-gui-ze-fen-xi/%E6%A8%A1%E6%9D%BF.png\" alt=\"模板\"></p>\n<h1 id=\"A：迭代需求\"><a href=\"#A：迭代需求\" class=\"headerlink\" title=\"A：迭代需求\"></a>A：迭代需求</h1><h2 id=\"第一版（分析起步）\"><a href=\"#第一版（分析起步）\" class=\"headerlink\" title=\"第一版（分析起步）\"></a>第一版（分析起步）</h2><p><img src=\"/2023/04/ye-wu-gong-neng-ye-wu-liu-cheng-ye-wu-gui-ze-fen-xi/%E5%88%86%E6%9E%90%E8%B5%B7%E6%AD%A5.png\" alt=\"分析起步\"></p>\n<h2 id=\"第二版（主干流程）\"><a href=\"#第二版（主干流程）\" class=\"headerlink\" title=\"第二版（主干流程）\"></a>第二版（主干流程）</h2><p><img src=\"/2023/04/ye-wu-gong-neng-ye-wu-liu-cheng-ye-wu-gui-ze-fen-xi/%E4%B8%BB%E5%B9%B2%E6%B5%81%E7%A8%8B.png\" alt=\"主干流程\"></p>\n<h2 id=\"第三版（探索分支）\"><a href=\"#第三版（探索分支）\" class=\"headerlink\" title=\"第三版（探索分支）\"></a>第三版（探索分支）</h2><p><img src=\"/2023/04/ye-wu-gong-neng-ye-wu-liu-cheng-ye-wu-gui-ze-fen-xi/%E6%8E%A2%E7%B4%A2%E5%88%86%E6%94%AF.png\" alt=\"探索分支\"></p>\n<h2 id=\"第四版（穷尽分支）\"><a href=\"#第四版（穷尽分支）\" class=\"headerlink\" title=\"第四版（穷尽分支）\"></a>第四版（穷尽分支）</h2><p><img src=\"/2023/04/ye-wu-gong-neng-ye-wu-liu-cheng-ye-wu-gui-ze-fen-xi/%E7%A9%B7%E5%B0%BD%E5%88%86%E6%94%AF.png\" alt=\"穷尽分支\"></p>\n<h2 id=\"第五版（业务规则）\"><a href=\"#第五版（业务规则）\" class=\"headerlink\" title=\"第五版（业务规则）\"></a>第五版（业务规则）</h2><p><img src=\"/2023/04/ye-wu-gong-neng-ye-wu-liu-cheng-ye-wu-gui-ze-fen-xi/%E4%B8%9A%E5%8A%A1%E8%A7%84%E5%88%99.png\" alt=\"业务规则\"></p>\n"},{"title":"深圳梧桐山-毛棉杜鹃","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-04-03T05:08:19.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"![2b135a37c965e856f04d4a5faf8d2f2b2.JPG](2b135a37c965e856f04d4a5faf8d2f2b2.JPG)\n![f4e3370968454b29062472df853b648e.JPG](f4e3370968454b29062472df853b648e.JPG)\n![d2a7004a2e039c3f37d5fef10c7cc28a2.JPG](d2a7004a2e039c3f37d5fef10c7cc28a2.JPG)\n![7d011510a39a8f6e23429fa828448a7c2.JPG](7d011510a39a8f6e23429fa828448a7c2.JPG)\n![0a32e20ee914cca207bd5e0446eca332.JPG](0a32e20ee914cca207bd5e0446eca332.JPG)\n![6f19a8a8bff80c030eeba535032db0f6.JPG](6f19a8a8bff80c030eeba535032db0f6.JPG)\n","source":"_posts/2023/04/深圳梧桐山-毛棉杜鹃.md","raw":"---\ntitle: 深圳梧桐山-毛棉杜鹃\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-04-03 13:08:19\npassword:\nsummary:\ntags:\n- gallery-深圳梧桐山-毛棉杜鹃\ncategories:\n- gallery\nkeywords:\ndescription:\n---\n![2b135a37c965e856f04d4a5faf8d2f2b2.JPG](2b135a37c965e856f04d4a5faf8d2f2b2.JPG)\n![f4e3370968454b29062472df853b648e.JPG](f4e3370968454b29062472df853b648e.JPG)\n![d2a7004a2e039c3f37d5fef10c7cc28a2.JPG](d2a7004a2e039c3f37d5fef10c7cc28a2.JPG)\n![7d011510a39a8f6e23429fa828448a7c2.JPG](7d011510a39a8f6e23429fa828448a7c2.JPG)\n![0a32e20ee914cca207bd5e0446eca332.JPG](0a32e20ee914cca207bd5e0446eca332.JPG)\n![6f19a8a8bff80c030eeba535032db0f6.JPG](6f19a8a8bff80c030eeba535032db0f6.JPG)\n","slug":"深圳梧桐山-毛棉杜鹃","published":1,"updated":"2024-01-05T08:12:19.710Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clru1g2160018s4fuh2gi8y1v","content":"<p><img src=\"/2023/04/shen-zhen-wu-tong-shan-mao-mian-du-juan/2b135a37c965e856f04d4a5faf8d2f2b2.JPG\" alt=\"2b135a37c965e856f04d4a5faf8d2f2b2.JPG\"><br><img src=\"/2023/04/shen-zhen-wu-tong-shan-mao-mian-du-juan/f4e3370968454b29062472df853b648e.JPG\" alt=\"f4e3370968454b29062472df853b648e.JPG\"><br><img src=\"/2023/04/shen-zhen-wu-tong-shan-mao-mian-du-juan/d2a7004a2e039c3f37d5fef10c7cc28a2.JPG\" alt=\"d2a7004a2e039c3f37d5fef10c7cc28a2.JPG\"><br><img src=\"/2023/04/shen-zhen-wu-tong-shan-mao-mian-du-juan/7d011510a39a8f6e23429fa828448a7c2.JPG\" alt=\"7d011510a39a8f6e23429fa828448a7c2.JPG\"><br><img src=\"/2023/04/shen-zhen-wu-tong-shan-mao-mian-du-juan/0a32e20ee914cca207bd5e0446eca332.JPG\" alt=\"0a32e20ee914cca207bd5e0446eca332.JPG\"><br><img src=\"/2023/04/shen-zhen-wu-tong-shan-mao-mian-du-juan/6f19a8a8bff80c030eeba535032db0f6.JPG\" alt=\"6f19a8a8bff80c030eeba535032db0f6.JPG\"></p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<p><img src=\"/2023/04/shen-zhen-wu-tong-shan-mao-mian-du-juan/2b135a37c965e856f04d4a5faf8d2f2b2.JPG\" alt=\"2b135a37c965e856f04d4a5faf8d2f2b2.JPG\"><br><img src=\"/2023/04/shen-zhen-wu-tong-shan-mao-mian-du-juan/f4e3370968454b29062472df853b648e.JPG\" alt=\"f4e3370968454b29062472df853b648e.JPG\"><br><img src=\"/2023/04/shen-zhen-wu-tong-shan-mao-mian-du-juan/d2a7004a2e039c3f37d5fef10c7cc28a2.JPG\" alt=\"d2a7004a2e039c3f37d5fef10c7cc28a2.JPG\"><br><img src=\"/2023/04/shen-zhen-wu-tong-shan-mao-mian-du-juan/7d011510a39a8f6e23429fa828448a7c2.JPG\" alt=\"7d011510a39a8f6e23429fa828448a7c2.JPG\"><br><img src=\"/2023/04/shen-zhen-wu-tong-shan-mao-mian-du-juan/0a32e20ee914cca207bd5e0446eca332.JPG\" alt=\"0a32e20ee914cca207bd5e0446eca332.JPG\"><br><img src=\"/2023/04/shen-zhen-wu-tong-shan-mao-mian-du-juan/6f19a8a8bff80c030eeba535032db0f6.JPG\" alt=\"6f19a8a8bff80c030eeba535032db0f6.JPG\"></p>\n"},{"title":"PIN->GPIO","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-05-20T17:14:31.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"\n# A：在linux中你会如何设计gpio的管理系统？\n# Q：分层 分模块\n\n> 概念：设备树/platform驱动/pinctrl（pic）/gpio\n\n## 分层： 应用层->pin contrl core->pin contrl driverx->hw layer\n\n![pin contrl mode](PIN-GPIO/Pinctrl.png)\n\n应用层：就是为某种设备写的驱动调用了pic的接口\npin contrl core：pic的核心管理层，解决pic的内部问题\npin contrl driverx：每个芯片的架构可能不同，就有不同的实现方式给到pic中\nhw layer：硬件最底层的实现\n\n## 模块： pin contrl模块 gpio模块 I2C模块 PWM模块....\n\npin contrl模块是最核心的模块，gpio模块 I2C模块 PWM模块等都是调用了pin contrl模块的api\n\n![gpio mode](PIN-GPIO/gpio.png)\n你以为两者是分离的，实际上不是的，gpio模块是基于pinctrl模块的，gpio的API接口的实现很多都是基于pinctrl模块的函数\n\n# A：现在是不是能实现外设的管理和控制了，接下来你会如何设计代码？\n# Q：我也不知道 分析源码\n\n## 源码架构\n\n![pinctrl 源码架构](PIN-GPIO/pinctrl_system.png)\n\n在此框架中，（1）、（2）、（3）由半导体厂商搞定，半导体厂商会利用 Linux 提供的框架，根据自己的芯片，客制化代码。普通的驱动工程师就是调用 API 即可，就算是写驱动了。\n着重讲解（2），所以由图我们知道，pinctrl 子系统和 gpio 子系统都依赖于（2）的驱动。\n\n## 设计思路\n\n### 抽象出pinctrl的类\n类的成员经过总结应该设计有：A:操作函数 B:和设备树相关的部分 C：gpio相关的部分\n\n于是linux出现了这样的数据结构\n![pinctrl-class](PIN-GPIO/pinctrl%20struct.png)\n\npinctrl_dev（kernel/drivers/pinctrl/core.h）是 pinctrl 子系统的根源结构体，它主要包含三条路：\n\n1、pinctrl_desc：这里包含了pinctrl 子系统三个最重要的结构体，有三个操作函数集，pinctrl_ops 包含了对 PIN 的操作函数集，pinmux_ops 包含了对 PIN 的复用函数集，pinconf_ops 包含了对 PIN 的配置函数，大家可以在自己平台中点进去看看自己平台实现了哪个函数，如何实现的。\n\n2、pinctrl 结构体：这里包含了 PIN 控制器所控制 PIN 的状态 state，state 里面包含了 setting，这个 setting 就是在设备树中对PIN的设置，大家点进去看相关数据结构就可以看到自己在设备树中用到的字符串。\n\n3、gpio 相关的结构体，我们说过 pinctrl 子系统和 gpio 子系统是耦合的，我们从结构体就可以看得出来，它包含了最重要的结构体 gpio_chip。\n\n### pinctrl子系统源码\n\nkernel/drivers/pinctrl/core.c 文件初始化pinctrl子系统\n>1：初始化阶段开启调试文件目录 /sys/kernel/debug/pinctrl# ls\n20e0000.iomuxc  2290000.iomuxc-snvs  pinctrl-devices  pinctrl-handles  pinctrl-maps\n2:提供pinctrl_register函数\n3:形成pinctrl核心层 提供API\n\n### 芯片厂商的pinctrl驱动\n\ndrivers/pinctrl/freescale/pinctrl-imx6ul.c 文件\n![imx6ull pinctrl driver](PIN-GPIO/imx6ull%20pinctrl.png)\nimx6ul_pinctrl_of_match.compatible 就是你设备树定义的数据 如果匹配上了就执行imx6ul_pinctrl_probe函数\n![imx6ull pin](PIN-GPIO/iomuxc.png)\n\nso 看下probe干了啥：\n![imx6ul_pinctrl_probe 函数执行流程](PIN-GPIO/probe.png)\n\n`imx_pinctrl_probe`函数是i.MX平台的引脚控制器驱动的探测函数，用于在设备探测阶段进行引脚控制器的初始化和注册。\n\n该函数的主要步骤如下：\n\n1. 验证传入的`info`参数和相关字段是否有效，包括`pins`和`npins`字段。\n2. 为`imx_pinctrl_desc`和`ipctl`分配内存，并进行初始化。\n3. 为引脚寄存器数组`info->pin_regs`分配内存，并进行初始化。\n4. 获取引脚控制器的物理内存资源并进行映射。\n5. 如果设备树中定义了\"fsl,input-sel\"属性，读取并映射输入选择寄存器的物理地址。\n6. 设置`imx_pinctrl_desc`的相关字段，如名称、引脚数组、操作函数等。\n7. 调用`imx_pinctrl_probe_dt`函数解析设备树中的属性并配置引脚控制器。\n8. 设置`ipctl`的相关字段。\n9. 调用`pinctrl_register`函数注册引脚控制器设备。\n10. 如果注册成功，打印初始化完成的信息。\n11. 返回操作结果，成功返回0，否则返回相应的错误码。\n\n总体来说，`imx_pinctrl_probe`函数完成了引脚控制器设备的初始化、资源分配、设备树属性解析以及注册到内核的引脚控制器子系统中的过程。\n\n就不继续深入研究，有兴趣自己看代码，介绍下pinctrl_register（）函数\n\n`pinctrl_register`函数用于注册一个引脚控制器设备，并返回一个指向注册设备的指针。\n\n函数的具体步骤如下：\n\n1. 检查传入的`pctldesc`参数是否有效，包括检查描述符指针和名称是否为空。\n2. 使用`kzalloc`为引脚控制器设备分配内存，并进行初始化。\n3. 设置引脚控制器设备的相关字段，如所有者、描述符、驱动程序数据等。\n4. 初始化引脚描述符的radix树和GPIO范围链表。\n5. 初始化互斥锁。\n6. 检查引脚控制器核心操作函数的正确性。\n7. 如果实现了引脚复用功能，检查引脚复用操作函数的正确性。\n8. 如果实现了引脚配置功能，检查引脚配置操作函数的正确性。\n9. 注册所有的引脚。\n10. 将引脚控制器设备添加到全局引脚控制器设备列表中。\n11. 获取引脚控制器设备的默认状态和睡眠状态，并进行相应的设置。\n12. 初始化引脚控制器设备的debugfs调试文件系统。\n13. 返回注册后的引脚控制器设备结构体指针。\n\n如果在注册过程中出现错误，将释放已分配的内存，并返回`NULL`。\n\n总之，`pinctrl_register`函数完成了引脚控制器设备的注册，包括分配内存、设置相关字段、注册引脚、添加到全局列表以及初始化调试功能等操作。\n\n### 使用pinctrl的API\n\n经过前面的设备厂商提供的pinctrl驱动代码，注册到pinctrl中后就可以调用pinctrl的API了。\n要调用`pinctrl`的API，你需要按照以下步骤进行操作：\n\n1. 引入相关头文件：\n   ```c\n   #include <linux/pinctrl/pinctrl.h>\n   ```\n\n2. 获取指向`struct pinctrl_dev`的指针，该指针代表已注册的引脚控制器设备。\n\n   - 如果你已经有一个指向设备结构体（如`struct device`）的指针 `dev`，可以通过以下方式获取 `struct pinctrl_dev` 指针：\n     ```c\n     struct pinctrl_dev *pctldev = dev_get_drvdata(dev);\n     ```\n   - 如果你知道设备的名称，可以使用以下函数获取 `struct pinctrl_dev` 指针：\n     ```c\n     struct pinctrl_dev *pctldev = pinctrl_get(pinctrl_dev_name);\n     ```\n\n3. 使用获得的 `struct pinctrl_dev` 指针调用相应的 `pinctrl` API 函数。例如，要选择引脚控制器设备上的某个引脚状态，可以使用 `pinctrl_select_state` 函数：\n   ```c\n   int ret = pinctrl_select_state(pctldev, state_name);\n   ```\n\n   其中，`state_name` 是要选择的引脚状态的名称。具体的 API 函数和参数将取决于你要执行的具体操作，例如配置引脚功能、设置引脚属性等。\n\n   请注意，在使用 `pinctrl` API 之前，你需要确保已正确初始化和注册了引脚控制器设备，并且你具有适当的权限来执行相关操作。\n\n## GPIO模块\n   GPIO模块的核心层调用了很多的pinctrl的函数，可以去看下源码的设计，设计思路和pinctrl是一样的就不重复了。\n   可以看下这篇文章的调用方式：[手把手教你使用 gpio 子系统 API](https://mp.weixin.qq.com/s/iquUV-xzx1c08spOeW-vPg)。\n\n","source":"_posts/2023/05/PIN-GPIO.md","raw":"---\ntitle: PIN->GPIO\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-05-21 01:14:31\npassword:\nsummary:\ntags:\n- PIN GPIO\n- linux\ncategories:\n- linux\nkeywords:\ndescription:\n---\n\n# A：在linux中你会如何设计gpio的管理系统？\n# Q：分层 分模块\n\n> 概念：设备树/platform驱动/pinctrl（pic）/gpio\n\n## 分层： 应用层->pin contrl core->pin contrl driverx->hw layer\n\n![pin contrl mode](PIN-GPIO/Pinctrl.png)\n\n应用层：就是为某种设备写的驱动调用了pic的接口\npin contrl core：pic的核心管理层，解决pic的内部问题\npin contrl driverx：每个芯片的架构可能不同，就有不同的实现方式给到pic中\nhw layer：硬件最底层的实现\n\n## 模块： pin contrl模块 gpio模块 I2C模块 PWM模块....\n\npin contrl模块是最核心的模块，gpio模块 I2C模块 PWM模块等都是调用了pin contrl模块的api\n\n![gpio mode](PIN-GPIO/gpio.png)\n你以为两者是分离的，实际上不是的，gpio模块是基于pinctrl模块的，gpio的API接口的实现很多都是基于pinctrl模块的函数\n\n# A：现在是不是能实现外设的管理和控制了，接下来你会如何设计代码？\n# Q：我也不知道 分析源码\n\n## 源码架构\n\n![pinctrl 源码架构](PIN-GPIO/pinctrl_system.png)\n\n在此框架中，（1）、（2）、（3）由半导体厂商搞定，半导体厂商会利用 Linux 提供的框架，根据自己的芯片，客制化代码。普通的驱动工程师就是调用 API 即可，就算是写驱动了。\n着重讲解（2），所以由图我们知道，pinctrl 子系统和 gpio 子系统都依赖于（2）的驱动。\n\n## 设计思路\n\n### 抽象出pinctrl的类\n类的成员经过总结应该设计有：A:操作函数 B:和设备树相关的部分 C：gpio相关的部分\n\n于是linux出现了这样的数据结构\n![pinctrl-class](PIN-GPIO/pinctrl%20struct.png)\n\npinctrl_dev（kernel/drivers/pinctrl/core.h）是 pinctrl 子系统的根源结构体，它主要包含三条路：\n\n1、pinctrl_desc：这里包含了pinctrl 子系统三个最重要的结构体，有三个操作函数集，pinctrl_ops 包含了对 PIN 的操作函数集，pinmux_ops 包含了对 PIN 的复用函数集，pinconf_ops 包含了对 PIN 的配置函数，大家可以在自己平台中点进去看看自己平台实现了哪个函数，如何实现的。\n\n2、pinctrl 结构体：这里包含了 PIN 控制器所控制 PIN 的状态 state，state 里面包含了 setting，这个 setting 就是在设备树中对PIN的设置，大家点进去看相关数据结构就可以看到自己在设备树中用到的字符串。\n\n3、gpio 相关的结构体，我们说过 pinctrl 子系统和 gpio 子系统是耦合的，我们从结构体就可以看得出来，它包含了最重要的结构体 gpio_chip。\n\n### pinctrl子系统源码\n\nkernel/drivers/pinctrl/core.c 文件初始化pinctrl子系统\n>1：初始化阶段开启调试文件目录 /sys/kernel/debug/pinctrl# ls\n20e0000.iomuxc  2290000.iomuxc-snvs  pinctrl-devices  pinctrl-handles  pinctrl-maps\n2:提供pinctrl_register函数\n3:形成pinctrl核心层 提供API\n\n### 芯片厂商的pinctrl驱动\n\ndrivers/pinctrl/freescale/pinctrl-imx6ul.c 文件\n![imx6ull pinctrl driver](PIN-GPIO/imx6ull%20pinctrl.png)\nimx6ul_pinctrl_of_match.compatible 就是你设备树定义的数据 如果匹配上了就执行imx6ul_pinctrl_probe函数\n![imx6ull pin](PIN-GPIO/iomuxc.png)\n\nso 看下probe干了啥：\n![imx6ul_pinctrl_probe 函数执行流程](PIN-GPIO/probe.png)\n\n`imx_pinctrl_probe`函数是i.MX平台的引脚控制器驱动的探测函数，用于在设备探测阶段进行引脚控制器的初始化和注册。\n\n该函数的主要步骤如下：\n\n1. 验证传入的`info`参数和相关字段是否有效，包括`pins`和`npins`字段。\n2. 为`imx_pinctrl_desc`和`ipctl`分配内存，并进行初始化。\n3. 为引脚寄存器数组`info->pin_regs`分配内存，并进行初始化。\n4. 获取引脚控制器的物理内存资源并进行映射。\n5. 如果设备树中定义了\"fsl,input-sel\"属性，读取并映射输入选择寄存器的物理地址。\n6. 设置`imx_pinctrl_desc`的相关字段，如名称、引脚数组、操作函数等。\n7. 调用`imx_pinctrl_probe_dt`函数解析设备树中的属性并配置引脚控制器。\n8. 设置`ipctl`的相关字段。\n9. 调用`pinctrl_register`函数注册引脚控制器设备。\n10. 如果注册成功，打印初始化完成的信息。\n11. 返回操作结果，成功返回0，否则返回相应的错误码。\n\n总体来说，`imx_pinctrl_probe`函数完成了引脚控制器设备的初始化、资源分配、设备树属性解析以及注册到内核的引脚控制器子系统中的过程。\n\n就不继续深入研究，有兴趣自己看代码，介绍下pinctrl_register（）函数\n\n`pinctrl_register`函数用于注册一个引脚控制器设备，并返回一个指向注册设备的指针。\n\n函数的具体步骤如下：\n\n1. 检查传入的`pctldesc`参数是否有效，包括检查描述符指针和名称是否为空。\n2. 使用`kzalloc`为引脚控制器设备分配内存，并进行初始化。\n3. 设置引脚控制器设备的相关字段，如所有者、描述符、驱动程序数据等。\n4. 初始化引脚描述符的radix树和GPIO范围链表。\n5. 初始化互斥锁。\n6. 检查引脚控制器核心操作函数的正确性。\n7. 如果实现了引脚复用功能，检查引脚复用操作函数的正确性。\n8. 如果实现了引脚配置功能，检查引脚配置操作函数的正确性。\n9. 注册所有的引脚。\n10. 将引脚控制器设备添加到全局引脚控制器设备列表中。\n11. 获取引脚控制器设备的默认状态和睡眠状态，并进行相应的设置。\n12. 初始化引脚控制器设备的debugfs调试文件系统。\n13. 返回注册后的引脚控制器设备结构体指针。\n\n如果在注册过程中出现错误，将释放已分配的内存，并返回`NULL`。\n\n总之，`pinctrl_register`函数完成了引脚控制器设备的注册，包括分配内存、设置相关字段、注册引脚、添加到全局列表以及初始化调试功能等操作。\n\n### 使用pinctrl的API\n\n经过前面的设备厂商提供的pinctrl驱动代码，注册到pinctrl中后就可以调用pinctrl的API了。\n要调用`pinctrl`的API，你需要按照以下步骤进行操作：\n\n1. 引入相关头文件：\n   ```c\n   #include <linux/pinctrl/pinctrl.h>\n   ```\n\n2. 获取指向`struct pinctrl_dev`的指针，该指针代表已注册的引脚控制器设备。\n\n   - 如果你已经有一个指向设备结构体（如`struct device`）的指针 `dev`，可以通过以下方式获取 `struct pinctrl_dev` 指针：\n     ```c\n     struct pinctrl_dev *pctldev = dev_get_drvdata(dev);\n     ```\n   - 如果你知道设备的名称，可以使用以下函数获取 `struct pinctrl_dev` 指针：\n     ```c\n     struct pinctrl_dev *pctldev = pinctrl_get(pinctrl_dev_name);\n     ```\n\n3. 使用获得的 `struct pinctrl_dev` 指针调用相应的 `pinctrl` API 函数。例如，要选择引脚控制器设备上的某个引脚状态，可以使用 `pinctrl_select_state` 函数：\n   ```c\n   int ret = pinctrl_select_state(pctldev, state_name);\n   ```\n\n   其中，`state_name` 是要选择的引脚状态的名称。具体的 API 函数和参数将取决于你要执行的具体操作，例如配置引脚功能、设置引脚属性等。\n\n   请注意，在使用 `pinctrl` API 之前，你需要确保已正确初始化和注册了引脚控制器设备，并且你具有适当的权限来执行相关操作。\n\n## GPIO模块\n   GPIO模块的核心层调用了很多的pinctrl的函数，可以去看下源码的设计，设计思路和pinctrl是一样的就不重复了。\n   可以看下这篇文章的调用方式：[手把手教你使用 gpio 子系统 API](https://mp.weixin.qq.com/s/iquUV-xzx1c08spOeW-vPg)。\n\n","slug":"PIN-GPIO","published":1,"updated":"2024-01-05T08:12:19.754Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clru1g219001as4fu1zngclnp","content":"<h1 id=\"A：在linux中你会如何设计gpio的管理系统？\"><a href=\"#A：在linux中你会如何设计gpio的管理系统？\" class=\"headerlink\" title=\"A：在linux中你会如何设计gpio的管理系统？\"></a>A：在linux中你会如何设计gpio的管理系统？</h1><h1 id=\"Q：分层-分模块\"><a href=\"#Q：分层-分模块\" class=\"headerlink\" title=\"Q：分层 分模块\"></a>Q：分层 分模块</h1><blockquote>\n<p>概念：设备树/platform驱动/pinctrl（pic）/gpio</p>\n</blockquote>\n<h2 id=\"分层：-应用层-gt-pin-contrl-core-gt-pin-contrl-driverx-gt-hw-layer\"><a href=\"#分层：-应用层-gt-pin-contrl-core-gt-pin-contrl-driverx-gt-hw-layer\" class=\"headerlink\" title=\"分层： 应用层-&gt;pin contrl core-&gt;pin contrl driverx-&gt;hw layer\"></a>分层： 应用层-&gt;pin contrl core-&gt;pin contrl driverx-&gt;hw layer</h2><p><img src=\"/2023/05/pin-gpio/Pinctrl.png\" alt=\"pin contrl mode\"></p>\n<p>应用层：就是为某种设备写的驱动调用了pic的接口<br>pin contrl core：pic的核心管理层，解决pic的内部问题<br>pin contrl driverx：每个芯片的架构可能不同，就有不同的实现方式给到pic中<br>hw layer：硬件最底层的实现</p>\n<h2 id=\"模块：-pin-contrl模块-gpio模块-I2C模块-PWM模块…\"><a href=\"#模块：-pin-contrl模块-gpio模块-I2C模块-PWM模块…\" class=\"headerlink\" title=\"模块： pin contrl模块 gpio模块 I2C模块 PWM模块….\"></a>模块： pin contrl模块 gpio模块 I2C模块 PWM模块….</h2><p>pin contrl模块是最核心的模块，gpio模块 I2C模块 PWM模块等都是调用了pin contrl模块的api</p>\n<p><img src=\"/2023/05/pin-gpio/gpio.png\" alt=\"gpio mode\"><br>你以为两者是分离的，实际上不是的，gpio模块是基于pinctrl模块的，gpio的API接口的实现很多都是基于pinctrl模块的函数</p>\n<h1 id=\"A：现在是不是能实现外设的管理和控制了，接下来你会如何设计代码？\"><a href=\"#A：现在是不是能实现外设的管理和控制了，接下来你会如何设计代码？\" class=\"headerlink\" title=\"A：现在是不是能实现外设的管理和控制了，接下来你会如何设计代码？\"></a>A：现在是不是能实现外设的管理和控制了，接下来你会如何设计代码？</h1><h1 id=\"Q：我也不知道-分析源码\"><a href=\"#Q：我也不知道-分析源码\" class=\"headerlink\" title=\"Q：我也不知道 分析源码\"></a>Q：我也不知道 分析源码</h1><h2 id=\"源码架构\"><a href=\"#源码架构\" class=\"headerlink\" title=\"源码架构\"></a>源码架构</h2><p><img src=\"/2023/05/pin-gpio/pinctrl_system.png\" alt=\"pinctrl 源码架构\"></p>\n<p>在此框架中，（1）、（2）、（3）由半导体厂商搞定，半导体厂商会利用 Linux 提供的框架，根据自己的芯片，客制化代码。普通的驱动工程师就是调用 API 即可，就算是写驱动了。<br>着重讲解（2），所以由图我们知道，pinctrl 子系统和 gpio 子系统都依赖于（2）的驱动。</p>\n<h2 id=\"设计思路\"><a href=\"#设计思路\" class=\"headerlink\" title=\"设计思路\"></a>设计思路</h2><h3 id=\"抽象出pinctrl的类\"><a href=\"#抽象出pinctrl的类\" class=\"headerlink\" title=\"抽象出pinctrl的类\"></a>抽象出pinctrl的类</h3><p>类的成员经过总结应该设计有：A:操作函数 B:和设备树相关的部分 C：gpio相关的部分</p>\n<p>于是linux出现了这样的数据结构<br><img src=\"/2023/05/pin-gpio/pinctrl%20struct.png\" alt=\"pinctrl-class\"></p>\n<p>pinctrl_dev（kernel/drivers/pinctrl/core.h）是 pinctrl 子系统的根源结构体，它主要包含三条路：</p>\n<p>1、pinctrl_desc：这里包含了pinctrl 子系统三个最重要的结构体，有三个操作函数集，pinctrl_ops 包含了对 PIN 的操作函数集，pinmux_ops 包含了对 PIN 的复用函数集，pinconf_ops 包含了对 PIN 的配置函数，大家可以在自己平台中点进去看看自己平台实现了哪个函数，如何实现的。</p>\n<p>2、pinctrl 结构体：这里包含了 PIN 控制器所控制 PIN 的状态 state，state 里面包含了 setting，这个 setting 就是在设备树中对PIN的设置，大家点进去看相关数据结构就可以看到自己在设备树中用到的字符串。</p>\n<p>3、gpio 相关的结构体，我们说过 pinctrl 子系统和 gpio 子系统是耦合的，我们从结构体就可以看得出来，它包含了最重要的结构体 gpio_chip。</p>\n<h3 id=\"pinctrl子系统源码\"><a href=\"#pinctrl子系统源码\" class=\"headerlink\" title=\"pinctrl子系统源码\"></a>pinctrl子系统源码</h3><p>kernel/drivers/pinctrl/core.c 文件初始化pinctrl子系统</p>\n<blockquote>\n<p>1：初始化阶段开启调试文件目录 /sys/kernel/debug/pinctrl# ls<br>20e0000.iomuxc  2290000.iomuxc-snvs  pinctrl-devices  pinctrl-handles  pinctrl-maps<br>2:提供pinctrl_register函数<br>3:形成pinctrl核心层 提供API</p>\n</blockquote>\n<h3 id=\"芯片厂商的pinctrl驱动\"><a href=\"#芯片厂商的pinctrl驱动\" class=\"headerlink\" title=\"芯片厂商的pinctrl驱动\"></a>芯片厂商的pinctrl驱动</h3><p>drivers/pinctrl/freescale/pinctrl-imx6ul.c 文件<br><img src=\"/2023/05/pin-gpio/imx6ull%20pinctrl.png\" alt=\"imx6ull pinctrl driver\"><br>imx6ul_pinctrl_of_match.compatible 就是你设备树定义的数据 如果匹配上了就执行imx6ul_pinctrl_probe函数<br><img src=\"/2023/05/pin-gpio/iomuxc.png\" alt=\"imx6ull pin\"></p>\n<p>so 看下probe干了啥：<br><img src=\"/2023/05/pin-gpio/probe.png\" alt=\"imx6ul_pinctrl_probe 函数执行流程\"></p>\n<p><code>imx_pinctrl_probe</code>函数是i.MX平台的引脚控制器驱动的探测函数，用于在设备探测阶段进行引脚控制器的初始化和注册。</p>\n<p>该函数的主要步骤如下：</p>\n<ol>\n<li>验证传入的<code>info</code>参数和相关字段是否有效，包括<code>pins</code>和<code>npins</code>字段。</li>\n<li>为<code>imx_pinctrl_desc</code>和<code>ipctl</code>分配内存，并进行初始化。</li>\n<li>为引脚寄存器数组<code>info-&gt;pin_regs</code>分配内存，并进行初始化。</li>\n<li>获取引脚控制器的物理内存资源并进行映射。</li>\n<li>如果设备树中定义了”fsl,input-sel”属性，读取并映射输入选择寄存器的物理地址。</li>\n<li>设置<code>imx_pinctrl_desc</code>的相关字段，如名称、引脚数组、操作函数等。</li>\n<li>调用<code>imx_pinctrl_probe_dt</code>函数解析设备树中的属性并配置引脚控制器。</li>\n<li>设置<code>ipctl</code>的相关字段。</li>\n<li>调用<code>pinctrl_register</code>函数注册引脚控制器设备。</li>\n<li>如果注册成功，打印初始化完成的信息。</li>\n<li>返回操作结果，成功返回0，否则返回相应的错误码。</li>\n</ol>\n<p>总体来说，<code>imx_pinctrl_probe</code>函数完成了引脚控制器设备的初始化、资源分配、设备树属性解析以及注册到内核的引脚控制器子系统中的过程。</p>\n<p>就不继续深入研究，有兴趣自己看代码，介绍下pinctrl_register（）函数</p>\n<p><code>pinctrl_register</code>函数用于注册一个引脚控制器设备，并返回一个指向注册设备的指针。</p>\n<p>函数的具体步骤如下：</p>\n<ol>\n<li>检查传入的<code>pctldesc</code>参数是否有效，包括检查描述符指针和名称是否为空。</li>\n<li>使用<code>kzalloc</code>为引脚控制器设备分配内存，并进行初始化。</li>\n<li>设置引脚控制器设备的相关字段，如所有者、描述符、驱动程序数据等。</li>\n<li>初始化引脚描述符的radix树和GPIO范围链表。</li>\n<li>初始化互斥锁。</li>\n<li>检查引脚控制器核心操作函数的正确性。</li>\n<li>如果实现了引脚复用功能，检查引脚复用操作函数的正确性。</li>\n<li>如果实现了引脚配置功能，检查引脚配置操作函数的正确性。</li>\n<li>注册所有的引脚。</li>\n<li>将引脚控制器设备添加到全局引脚控制器设备列表中。</li>\n<li>获取引脚控制器设备的默认状态和睡眠状态，并进行相应的设置。</li>\n<li>初始化引脚控制器设备的debugfs调试文件系统。</li>\n<li>返回注册后的引脚控制器设备结构体指针。</li>\n</ol>\n<p>如果在注册过程中出现错误，将释放已分配的内存，并返回<code>NULL</code>。</p>\n<p>总之，<code>pinctrl_register</code>函数完成了引脚控制器设备的注册，包括分配内存、设置相关字段、注册引脚、添加到全局列表以及初始化调试功能等操作。</p>\n<h3 id=\"使用pinctrl的API\"><a href=\"#使用pinctrl的API\" class=\"headerlink\" title=\"使用pinctrl的API\"></a>使用pinctrl的API</h3><p>经过前面的设备厂商提供的pinctrl驱动代码，注册到pinctrl中后就可以调用pinctrl的API了。<br>要调用<code>pinctrl</code>的API，你需要按照以下步骤进行操作：</p>\n<ol>\n<li><p>引入相关头文件：</p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;linux/pinctrl/pinctrl.h></span></span></code></pre>\n</li>\n<li><p>获取指向<code>struct pinctrl_dev</code>的指针，该指针代表已注册的引脚控制器设备。</p>\n<ul>\n<li>如果你已经有一个指向设备结构体（如<code>struct device</code>）的指针 <code>dev</code>，可以通过以下方式获取 <code>struct pinctrl_dev</code> 指针：<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> pinctrl_dev <span class=\"token operator\">*</span>pctldev <span class=\"token operator\">=</span> <span class=\"token function\">dev_get_drvdata</span><span class=\"token punctuation\">(</span>dev<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n</li>\n<li>如果你知道设备的名称，可以使用以下函数获取 <code>struct pinctrl_dev</code> 指针：<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> pinctrl_dev <span class=\"token operator\">*</span>pctldev <span class=\"token operator\">=</span> <span class=\"token function\">pinctrl_get</span><span class=\"token punctuation\">(</span>pinctrl_dev_name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n</li>\n</ul>\n</li>\n<li><p>使用获得的 <code>struct pinctrl_dev</code> 指针调用相应的 <code>pinctrl</code> API 函数。例如，要选择引脚控制器设备上的某个引脚状态，可以使用 <code>pinctrl_select_state</code> 函数：</p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> ret <span class=\"token operator\">=</span> <span class=\"token function\">pinctrl_select_state</span><span class=\"token punctuation\">(</span>pctldev<span class=\"token punctuation\">,</span> state_name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>其中，<code>state_name</code> 是要选择的引脚状态的名称。具体的 API 函数和参数将取决于你要执行的具体操作，例如配置引脚功能、设置引脚属性等。</p>\n<p>请注意，在使用 <code>pinctrl</code> API 之前，你需要确保已正确初始化和注册了引脚控制器设备，并且你具有适当的权限来执行相关操作。</p>\n</li>\n</ol>\n<h2 id=\"GPIO模块\"><a href=\"#GPIO模块\" class=\"headerlink\" title=\"GPIO模块\"></a>GPIO模块</h2><p>   GPIO模块的核心层调用了很多的pinctrl的函数，可以去看下源码的设计，设计思路和pinctrl是一样的就不重复了。<br>   可以看下这篇文章的调用方式：<a href=\"https://mp.weixin.qq.com/s/iquUV-xzx1c08spOeW-vPg\" target=\"_blank\" rel=\"noopener\">手把手教你使用 gpio 子系统 API</a>。</p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<h1 id=\"A：在linux中你会如何设计gpio的管理系统？\"><a href=\"#A：在linux中你会如何设计gpio的管理系统？\" class=\"headerlink\" title=\"A：在linux中你会如何设计gpio的管理系统？\"></a>A：在linux中你会如何设计gpio的管理系统？</h1><h1 id=\"Q：分层-分模块\"><a href=\"#Q：分层-分模块\" class=\"headerlink\" title=\"Q：分层 分模块\"></a>Q：分层 分模块</h1><blockquote>\n<p>概念：设备树/platform驱动/pinctrl（pic）/gpio</p>\n</blockquote>\n<h2 id=\"分层：-应用层-gt-pin-contrl-core-gt-pin-contrl-driverx-gt-hw-layer\"><a href=\"#分层：-应用层-gt-pin-contrl-core-gt-pin-contrl-driverx-gt-hw-layer\" class=\"headerlink\" title=\"分层： 应用层-&gt;pin contrl core-&gt;pin contrl driverx-&gt;hw layer\"></a>分层： 应用层-&gt;pin contrl core-&gt;pin contrl driverx-&gt;hw layer</h2><p><img src=\"/2023/05/pin-gpio/Pinctrl.png\" alt=\"pin contrl mode\"></p>\n<p>应用层：就是为某种设备写的驱动调用了pic的接口<br>pin contrl core：pic的核心管理层，解决pic的内部问题<br>pin contrl driverx：每个芯片的架构可能不同，就有不同的实现方式给到pic中<br>hw layer：硬件最底层的实现</p>\n<h2 id=\"模块：-pin-contrl模块-gpio模块-I2C模块-PWM模块…\"><a href=\"#模块：-pin-contrl模块-gpio模块-I2C模块-PWM模块…\" class=\"headerlink\" title=\"模块： pin contrl模块 gpio模块 I2C模块 PWM模块….\"></a>模块： pin contrl模块 gpio模块 I2C模块 PWM模块….</h2><p>pin contrl模块是最核心的模块，gpio模块 I2C模块 PWM模块等都是调用了pin contrl模块的api</p>\n<p><img src=\"/2023/05/pin-gpio/gpio.png\" alt=\"gpio mode\"><br>你以为两者是分离的，实际上不是的，gpio模块是基于pinctrl模块的，gpio的API接口的实现很多都是基于pinctrl模块的函数</p>\n<h1 id=\"A：现在是不是能实现外设的管理和控制了，接下来你会如何设计代码？\"><a href=\"#A：现在是不是能实现外设的管理和控制了，接下来你会如何设计代码？\" class=\"headerlink\" title=\"A：现在是不是能实现外设的管理和控制了，接下来你会如何设计代码？\"></a>A：现在是不是能实现外设的管理和控制了，接下来你会如何设计代码？</h1><h1 id=\"Q：我也不知道-分析源码\"><a href=\"#Q：我也不知道-分析源码\" class=\"headerlink\" title=\"Q：我也不知道 分析源码\"></a>Q：我也不知道 分析源码</h1><h2 id=\"源码架构\"><a href=\"#源码架构\" class=\"headerlink\" title=\"源码架构\"></a>源码架构</h2><p><img src=\"/2023/05/pin-gpio/pinctrl_system.png\" alt=\"pinctrl 源码架构\"></p>\n<p>在此框架中，（1）、（2）、（3）由半导体厂商搞定，半导体厂商会利用 Linux 提供的框架，根据自己的芯片，客制化代码。普通的驱动工程师就是调用 API 即可，就算是写驱动了。<br>着重讲解（2），所以由图我们知道，pinctrl 子系统和 gpio 子系统都依赖于（2）的驱动。</p>\n<h2 id=\"设计思路\"><a href=\"#设计思路\" class=\"headerlink\" title=\"设计思路\"></a>设计思路</h2><h3 id=\"抽象出pinctrl的类\"><a href=\"#抽象出pinctrl的类\" class=\"headerlink\" title=\"抽象出pinctrl的类\"></a>抽象出pinctrl的类</h3><p>类的成员经过总结应该设计有：A:操作函数 B:和设备树相关的部分 C：gpio相关的部分</p>\n<p>于是linux出现了这样的数据结构<br><img src=\"/2023/05/pin-gpio/pinctrl%20struct.png\" alt=\"pinctrl-class\"></p>\n<p>pinctrl_dev（kernel/drivers/pinctrl/core.h）是 pinctrl 子系统的根源结构体，它主要包含三条路：</p>\n<p>1、pinctrl_desc：这里包含了pinctrl 子系统三个最重要的结构体，有三个操作函数集，pinctrl_ops 包含了对 PIN 的操作函数集，pinmux_ops 包含了对 PIN 的复用函数集，pinconf_ops 包含了对 PIN 的配置函数，大家可以在自己平台中点进去看看自己平台实现了哪个函数，如何实现的。</p>\n<p>2、pinctrl 结构体：这里包含了 PIN 控制器所控制 PIN 的状态 state，state 里面包含了 setting，这个 setting 就是在设备树中对PIN的设置，大家点进去看相关数据结构就可以看到自己在设备树中用到的字符串。</p>\n<p>3、gpio 相关的结构体，我们说过 pinctrl 子系统和 gpio 子系统是耦合的，我们从结构体就可以看得出来，它包含了最重要的结构体 gpio_chip。</p>\n<h3 id=\"pinctrl子系统源码\"><a href=\"#pinctrl子系统源码\" class=\"headerlink\" title=\"pinctrl子系统源码\"></a>pinctrl子系统源码</h3><p>kernel/drivers/pinctrl/core.c 文件初始化pinctrl子系统</p>\n<blockquote>\n<p>1：初始化阶段开启调试文件目录 /sys/kernel/debug/pinctrl# ls<br>20e0000.iomuxc  2290000.iomuxc-snvs  pinctrl-devices  pinctrl-handles  pinctrl-maps<br>2:提供pinctrl_register函数<br>3:形成pinctrl核心层 提供API</p>\n</blockquote>\n<h3 id=\"芯片厂商的pinctrl驱动\"><a href=\"#芯片厂商的pinctrl驱动\" class=\"headerlink\" title=\"芯片厂商的pinctrl驱动\"></a>芯片厂商的pinctrl驱动</h3><p>drivers/pinctrl/freescale/pinctrl-imx6ul.c 文件<br><img src=\"/2023/05/pin-gpio/imx6ull%20pinctrl.png\" alt=\"imx6ull pinctrl driver\"><br>imx6ul_pinctrl_of_match.compatible 就是你设备树定义的数据 如果匹配上了就执行imx6ul_pinctrl_probe函数<br><img src=\"/2023/05/pin-gpio/iomuxc.png\" alt=\"imx6ull pin\"></p>\n<p>so 看下probe干了啥：<br><img src=\"/2023/05/pin-gpio/probe.png\" alt=\"imx6ul_pinctrl_probe 函数执行流程\"></p>\n<p><code>imx_pinctrl_probe</code>函数是i.MX平台的引脚控制器驱动的探测函数，用于在设备探测阶段进行引脚控制器的初始化和注册。</p>\n<p>该函数的主要步骤如下：</p>\n<ol>\n<li>验证传入的<code>info</code>参数和相关字段是否有效，包括<code>pins</code>和<code>npins</code>字段。</li>\n<li>为<code>imx_pinctrl_desc</code>和<code>ipctl</code>分配内存，并进行初始化。</li>\n<li>为引脚寄存器数组<code>info-&gt;pin_regs</code>分配内存，并进行初始化。</li>\n<li>获取引脚控制器的物理内存资源并进行映射。</li>\n<li>如果设备树中定义了”fsl,input-sel”属性，读取并映射输入选择寄存器的物理地址。</li>\n<li>设置<code>imx_pinctrl_desc</code>的相关字段，如名称、引脚数组、操作函数等。</li>\n<li>调用<code>imx_pinctrl_probe_dt</code>函数解析设备树中的属性并配置引脚控制器。</li>\n<li>设置<code>ipctl</code>的相关字段。</li>\n<li>调用<code>pinctrl_register</code>函数注册引脚控制器设备。</li>\n<li>如果注册成功，打印初始化完成的信息。</li>\n<li>返回操作结果，成功返回0，否则返回相应的错误码。</li>\n</ol>\n<p>总体来说，<code>imx_pinctrl_probe</code>函数完成了引脚控制器设备的初始化、资源分配、设备树属性解析以及注册到内核的引脚控制器子系统中的过程。</p>\n<p>就不继续深入研究，有兴趣自己看代码，介绍下pinctrl_register（）函数</p>\n<p><code>pinctrl_register</code>函数用于注册一个引脚控制器设备，并返回一个指向注册设备的指针。</p>\n<p>函数的具体步骤如下：</p>\n<ol>\n<li>检查传入的<code>pctldesc</code>参数是否有效，包括检查描述符指针和名称是否为空。</li>\n<li>使用<code>kzalloc</code>为引脚控制器设备分配内存，并进行初始化。</li>\n<li>设置引脚控制器设备的相关字段，如所有者、描述符、驱动程序数据等。</li>\n<li>初始化引脚描述符的radix树和GPIO范围链表。</li>\n<li>初始化互斥锁。</li>\n<li>检查引脚控制器核心操作函数的正确性。</li>\n<li>如果实现了引脚复用功能，检查引脚复用操作函数的正确性。</li>\n<li>如果实现了引脚配置功能，检查引脚配置操作函数的正确性。</li>\n<li>注册所有的引脚。</li>\n<li>将引脚控制器设备添加到全局引脚控制器设备列表中。</li>\n<li>获取引脚控制器设备的默认状态和睡眠状态，并进行相应的设置。</li>\n<li>初始化引脚控制器设备的debugfs调试文件系统。</li>\n<li>返回注册后的引脚控制器设备结构体指针。</li>\n</ol>\n<p>如果在注册过程中出现错误，将释放已分配的内存，并返回<code>NULL</code>。</p>\n<p>总之，<code>pinctrl_register</code>函数完成了引脚控制器设备的注册，包括分配内存、设置相关字段、注册引脚、添加到全局列表以及初始化调试功能等操作。</p>\n<h3 id=\"使用pinctrl的API\"><a href=\"#使用pinctrl的API\" class=\"headerlink\" title=\"使用pinctrl的API\"></a>使用pinctrl的API</h3><p>经过前面的设备厂商提供的pinctrl驱动代码，注册到pinctrl中后就可以调用pinctrl的API了。<br>要调用<code>pinctrl</code>的API，你需要按照以下步骤进行操作：</p>\n<ol>\n<li><p>引入相关头文件：</p>\n<pre><code class=\"c\">#include &lt;linux/pinctrl/pinctrl.h&gt;</code></pre>\n</li>\n<li><p>获取指向<code>struct pinctrl_dev</code>的指针，该指针代表已注册的引脚控制器设备。</p>\n<ul>\n<li>如果你已经有一个指向设备结构体（如<code>struct device</code>）的指针 <code>dev</code>，可以通过以下方式获取 <code>struct pinctrl_dev</code> 指针：<pre><code class=\"c\">struct pinctrl_dev *pctldev = dev_get_drvdata(dev);</code></pre>\n</li>\n<li>如果你知道设备的名称，可以使用以下函数获取 <code>struct pinctrl_dev</code> 指针：<pre><code class=\"c\">struct pinctrl_dev *pctldev = pinctrl_get(pinctrl_dev_name);</code></pre>\n</li>\n</ul>\n</li>\n<li><p>使用获得的 <code>struct pinctrl_dev</code> 指针调用相应的 <code>pinctrl</code> API 函数。例如，要选择引脚控制器设备上的某个引脚状态，可以使用 <code>pinctrl_select_state</code> 函数：</p>\n<pre><code class=\"c\">int ret = pinctrl_select_state(pctldev, state_name);</code></pre>\n<p>其中，<code>state_name</code> 是要选择的引脚状态的名称。具体的 API 函数和参数将取决于你要执行的具体操作，例如配置引脚功能、设置引脚属性等。</p>\n<p>请注意，在使用 <code>pinctrl</code> API 之前，你需要确保已正确初始化和注册了引脚控制器设备，并且你具有适当的权限来执行相关操作。</p>\n</li>\n</ol>\n<h2 id=\"GPIO模块\"><a href=\"#GPIO模块\" class=\"headerlink\" title=\"GPIO模块\"></a>GPIO模块</h2><p>   GPIO模块的核心层调用了很多的pinctrl的函数，可以去看下源码的设计，设计思路和pinctrl是一样的就不重复了。<br>   可以看下这篇文章的调用方式：<a href=\"https://mp.weixin.qq.com/s/iquUV-xzx1c08spOeW-vPg\" target=\"_blank\" rel=\"noopener\">手把手教你使用 gpio 子系统 API</a>。</p>\n"},{"title":"linux内核-tool目录","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-06-06T11:14:50.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"\n# Q：tool目录在linux内核中是干嘛的\n# A：顾名思义工具文件夹\n\n> 提示：我们的代码架构是不是应该也将工具集中在一个目录\n\n## tool目录结构\n![tool目录结构](linux内核-tool目录/tool目录.png)\n首先看下文件夹的makefile文件[链接](https://elixir.bootlin.com/linux/v4.3.6/source/tools/Makefile)\n文件内容：\n    1：help告诉你有哪些工具和编译删除的方法\n    2：各工具的编译命令\n\n## 编译命令解析\n### make -C tools/ acpi_install\n以 acpi 工具为例\nhelp提示编译命令为：make -C tools/ acpi_install\n就会执行makefile文件命令：\n```\nacpi: FORCE  \n    $(call descend,power/$@)\n```\n\ndescend是一个函数在tools/scripts/Makefile，\n根据提供的代码，`descend`函数的定义如下：\n\n```tools/scripts/Makefile.include\ndescend = \\\n    +mkdir -p $(OUTPUT)$(1) && \\\n    $(MAKE) $(COMMAND_O) subdir=$(if $(subdir),$(subdir)/$(1),$(1)) $(PRINT_DIR) -C $(1) $(2)\n```\n\n这个函数是一个Makefile的宏定义。它定义了一个命令序列，用于在指定的目录中执行进一步的构建操作。下面是对该函数的解释：\n\n1. `mkdir -p $(OUTPUT)$(1)`：创建目录`$(OUTPUT)$(1)`，如果该目录不存在。`$(OUTPUT)`是一个变量，表示输出目录的路径，`$(1)`表示传递给`descend`函数的第一个参数，即目录名。\n2. `$(MAKE) $(COMMAND_O)`：使用`$(MAKE)`命令调用Make工具，`$(COMMAND_O)`是一个变量，可能包含一些Make工具的选项或参数。\n3. `subdir=$(if $(subdir),$(subdir)/$(1),$(1))`：这行代码用于设置`subdir`变量的值。`subdir`可能是一个已定义的变量，如果它有值，则将其与`$(1)`（目录名）连接起来作为新的子目录路径。如果`subdir`没有定义，则将`$(1)`作为子目录路径。\n4. `$(PRINT_DIR)`：这个变量可能包含打印目录信息的选项或命令。\n5. `-C $(1)`：指定Make工具在目录`$(1)`中执行构建操作。\n6. `$(2)`：这个参数是传递给`descend`函数的第二个参数，可能包含其他的选项或命令。\n\n综上所述，通过调用`$(call descend, power/acpi)`，将执行以下操作：\n\n1. 创建目录`$(OUTPUT)power/acpi`，如果该目录不存在，即生成在tools/power/acpi目录下\n2. 在`power/acpi`目录中执行Make工具，并传递`subdir=power/acpi`和其他可能的选项或命令。\n\n### [tools/power/acpi/Makefile](https://elixir.bootlin.com/linux/v4.2.7/source/tools/power/acpi/Makefile)\n这个makefile文件跟简单就是编译链接相应的文件设置保存路径等最后生成acpidump可执行文件，再将可执行文件拷贝到开发板或则文件系统中即可使用\n\n### 工具介绍\n以下是对所列工具的简要介绍：\n\n1. ACPI工具（acpi）：提供与ACPI（高级配置和电源接口）相关的功能和信息，用于管理和监视系统的电源管理和配置。\n\n2. cgroup工具（cgroup）：用于管理和控制Linux控制组（cgroup）的工具，cgroup用于限制、分配和监控进程组的资源（如CPU、内存、磁盘I/O等）。\n\n3. cpupower（cpupower）：用于管理和调整x86 CPU功耗和性能的工具，可以控制CPU频率、功耗模式以及其他与CPU相关的设置。\n\n4. firewire工具（firewire）：用于IEEE-1394（FireWire）总线的用户空间工具，用于监视和分析IEEE-1394网络流量。\n\n5. hv工具（hv）：用于在Hyper-V客户端环境中使用的工具集，提供与Hyper-V虚拟化平台相关的功能和管理。\n\n6. lguest（lguest）：一个最小化的32位x86虚拟化平台，用于运行客户操作系统作为虚拟机。\n\n7. perf工具（perf）：Linux性能测量和分析工具，用于收集系统和应用程序的性能数据，进行性能分析和优化。\n\n8. selftests（selftests）：包含各种内核自测（self-test）工具和测试套件，用于测试和验证Linux内核的功能和稳定性。\n\n9. turbostat（turbostat）：用于报告Intel CPU空闲状态和频率的工具，提供有关CPU功耗、频率调节和性能的信息。\n\n10. USB测试工具（usb）：用于测试和诊断USB设备和功能的工具集，用于调试和分析USB相关问题。\n\n11. virtio（virtio）：用于虚拟化环境中的vhost测试模块，提供对虚拟I/O设备（如磁盘、网络等）的性能测试和评估。\n\n12. 网络工具（net）：包含各种杂项网络工具，用于网络配置、监视和故障排除，如网络接口管理、路由设置、网络诊断等。\n\n13. VM工具（vm）：包含各种杂项虚拟机（VM）工具，用于管理和操作虚拟机，如创建、配置、迁移虚拟机等。\n\n14. x86_energy_perf_policy（x86_energy_perf_policy）：英特尔能效策略工具，用于管理和优化英特尔CPU的能效策略设置。\n\n15. tmon工具（tmon）：用于热监视和调整的工具，用于监测系统温度、风扇速度和其他与热管理相关的参数，并进行热优化和调整。\n\n这些工具提供了一系列功能，用于管理、调整和监视不同方面的系统资源和配置，以及进行性能优化、调试和故障排除。具体使用方法可以参考各自工具的文档和手册。eg:man acpidump。\n\n### menuconfig配置\n![menuconfig配置方法](linux内核-tool目录/menuconfig.png)\n配置第一个即可 注意打开depends\n\n\n","source":"_posts/2023/06/linux内核-tool目录.md","raw":"---\ntitle: linux内核-tool目录\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-06-06 19:14:50\npassword:\nsummary:\ntags:\n- tool目录\n- linux\ncategories:\n- linux\nkeywords:\ndescription:\n---\n\n# Q：tool目录在linux内核中是干嘛的\n# A：顾名思义工具文件夹\n\n> 提示：我们的代码架构是不是应该也将工具集中在一个目录\n\n## tool目录结构\n![tool目录结构](linux内核-tool目录/tool目录.png)\n首先看下文件夹的makefile文件[链接](https://elixir.bootlin.com/linux/v4.3.6/source/tools/Makefile)\n文件内容：\n    1：help告诉你有哪些工具和编译删除的方法\n    2：各工具的编译命令\n\n## 编译命令解析\n### make -C tools/ acpi_install\n以 acpi 工具为例\nhelp提示编译命令为：make -C tools/ acpi_install\n就会执行makefile文件命令：\n```\nacpi: FORCE  \n    $(call descend,power/$@)\n```\n\ndescend是一个函数在tools/scripts/Makefile，\n根据提供的代码，`descend`函数的定义如下：\n\n```tools/scripts/Makefile.include\ndescend = \\\n    +mkdir -p $(OUTPUT)$(1) && \\\n    $(MAKE) $(COMMAND_O) subdir=$(if $(subdir),$(subdir)/$(1),$(1)) $(PRINT_DIR) -C $(1) $(2)\n```\n\n这个函数是一个Makefile的宏定义。它定义了一个命令序列，用于在指定的目录中执行进一步的构建操作。下面是对该函数的解释：\n\n1. `mkdir -p $(OUTPUT)$(1)`：创建目录`$(OUTPUT)$(1)`，如果该目录不存在。`$(OUTPUT)`是一个变量，表示输出目录的路径，`$(1)`表示传递给`descend`函数的第一个参数，即目录名。\n2. `$(MAKE) $(COMMAND_O)`：使用`$(MAKE)`命令调用Make工具，`$(COMMAND_O)`是一个变量，可能包含一些Make工具的选项或参数。\n3. `subdir=$(if $(subdir),$(subdir)/$(1),$(1))`：这行代码用于设置`subdir`变量的值。`subdir`可能是一个已定义的变量，如果它有值，则将其与`$(1)`（目录名）连接起来作为新的子目录路径。如果`subdir`没有定义，则将`$(1)`作为子目录路径。\n4. `$(PRINT_DIR)`：这个变量可能包含打印目录信息的选项或命令。\n5. `-C $(1)`：指定Make工具在目录`$(1)`中执行构建操作。\n6. `$(2)`：这个参数是传递给`descend`函数的第二个参数，可能包含其他的选项或命令。\n\n综上所述，通过调用`$(call descend, power/acpi)`，将执行以下操作：\n\n1. 创建目录`$(OUTPUT)power/acpi`，如果该目录不存在，即生成在tools/power/acpi目录下\n2. 在`power/acpi`目录中执行Make工具，并传递`subdir=power/acpi`和其他可能的选项或命令。\n\n### [tools/power/acpi/Makefile](https://elixir.bootlin.com/linux/v4.2.7/source/tools/power/acpi/Makefile)\n这个makefile文件跟简单就是编译链接相应的文件设置保存路径等最后生成acpidump可执行文件，再将可执行文件拷贝到开发板或则文件系统中即可使用\n\n### 工具介绍\n以下是对所列工具的简要介绍：\n\n1. ACPI工具（acpi）：提供与ACPI（高级配置和电源接口）相关的功能和信息，用于管理和监视系统的电源管理和配置。\n\n2. cgroup工具（cgroup）：用于管理和控制Linux控制组（cgroup）的工具，cgroup用于限制、分配和监控进程组的资源（如CPU、内存、磁盘I/O等）。\n\n3. cpupower（cpupower）：用于管理和调整x86 CPU功耗和性能的工具，可以控制CPU频率、功耗模式以及其他与CPU相关的设置。\n\n4. firewire工具（firewire）：用于IEEE-1394（FireWire）总线的用户空间工具，用于监视和分析IEEE-1394网络流量。\n\n5. hv工具（hv）：用于在Hyper-V客户端环境中使用的工具集，提供与Hyper-V虚拟化平台相关的功能和管理。\n\n6. lguest（lguest）：一个最小化的32位x86虚拟化平台，用于运行客户操作系统作为虚拟机。\n\n7. perf工具（perf）：Linux性能测量和分析工具，用于收集系统和应用程序的性能数据，进行性能分析和优化。\n\n8. selftests（selftests）：包含各种内核自测（self-test）工具和测试套件，用于测试和验证Linux内核的功能和稳定性。\n\n9. turbostat（turbostat）：用于报告Intel CPU空闲状态和频率的工具，提供有关CPU功耗、频率调节和性能的信息。\n\n10. USB测试工具（usb）：用于测试和诊断USB设备和功能的工具集，用于调试和分析USB相关问题。\n\n11. virtio（virtio）：用于虚拟化环境中的vhost测试模块，提供对虚拟I/O设备（如磁盘、网络等）的性能测试和评估。\n\n12. 网络工具（net）：包含各种杂项网络工具，用于网络配置、监视和故障排除，如网络接口管理、路由设置、网络诊断等。\n\n13. VM工具（vm）：包含各种杂项虚拟机（VM）工具，用于管理和操作虚拟机，如创建、配置、迁移虚拟机等。\n\n14. x86_energy_perf_policy（x86_energy_perf_policy）：英特尔能效策略工具，用于管理和优化英特尔CPU的能效策略设置。\n\n15. tmon工具（tmon）：用于热监视和调整的工具，用于监测系统温度、风扇速度和其他与热管理相关的参数，并进行热优化和调整。\n\n这些工具提供了一系列功能，用于管理、调整和监视不同方面的系统资源和配置，以及进行性能优化、调试和故障排除。具体使用方法可以参考各自工具的文档和手册。eg:man acpidump。\n\n### menuconfig配置\n![menuconfig配置方法](linux内核-tool目录/menuconfig.png)\n配置第一个即可 注意打开depends\n\n\n","slug":"linux内核-tool目录","published":1,"updated":"2024-01-05T08:12:19.765Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clru1g21f001es4fucozngc0z","content":"<h1 id=\"Q：tool目录在linux内核中是干嘛的\"><a href=\"#Q：tool目录在linux内核中是干嘛的\" class=\"headerlink\" title=\"Q：tool目录在linux内核中是干嘛的\"></a>Q：tool目录在linux内核中是干嘛的</h1><h1 id=\"A：顾名思义工具文件夹\"><a href=\"#A：顾名思义工具文件夹\" class=\"headerlink\" title=\"A：顾名思义工具文件夹\"></a>A：顾名思义工具文件夹</h1><blockquote>\n<p>提示：我们的代码架构是不是应该也将工具集中在一个目录</p>\n</blockquote>\n<h2 id=\"tool目录结构\"><a href=\"#tool目录结构\" class=\"headerlink\" title=\"tool目录结构\"></a>tool目录结构</h2><p><img src=\"/2023/06/linux-nei-he-tool-mu-lu/tool%E7%9B%AE%E5%BD%95.png\" alt=\"tool目录结构\"><br>首先看下文件夹的makefile文件<a href=\"https://elixir.bootlin.com/linux/v4.3.6/source/tools/Makefile\" target=\"_blank\" rel=\"noopener\">链接</a><br>文件内容：<br>    1：help告诉你有哪些工具和编译删除的方法<br>    2：各工具的编译命令</p>\n<h2 id=\"编译命令解析\"><a href=\"#编译命令解析\" class=\"headerlink\" title=\"编译命令解析\"></a>编译命令解析</h2><h3 id=\"make-C-tools-acpi-install\"><a href=\"#make-C-tools-acpi-install\" class=\"headerlink\" title=\"make -C tools/ acpi_install\"></a>make -C tools/ acpi_install</h3><p>以 acpi 工具为例<br>help提示编译命令为：make -C tools/ acpi_install<br>就会执行makefile文件命令：</p>\n<pre><code>acpi: FORCE  \n    $(call descend,power/$@)</code></pre><p>descend是一个函数在tools/scripts/Makefile，<br>根据提供的代码，<code>descend</code>函数的定义如下：</p>\n<pre class=\" language-tools/scripts/Makefile.include\"><code class=\"language-tools/scripts/Makefile.include\">descend = \\\n    +mkdir -p $(OUTPUT)$(1) && \\\n    $(MAKE) $(COMMAND_O) subdir=$(if $(subdir),$(subdir)/$(1),$(1)) $(PRINT_DIR) -C $(1) $(2)</code></pre>\n<p>这个函数是一个Makefile的宏定义。它定义了一个命令序列，用于在指定的目录中执行进一步的构建操作。下面是对该函数的解释：</p>\n<ol>\n<li><code>mkdir -p $(OUTPUT)$(1)</code>：创建目录<code>$(OUTPUT)$(1)</code>，如果该目录不存在。<code>$(OUTPUT)</code>是一个变量，表示输出目录的路径，<code>$(1)</code>表示传递给<code>descend</code>函数的第一个参数，即目录名。</li>\n<li><code>$(MAKE) $(COMMAND_O)</code>：使用<code>$(MAKE)</code>命令调用Make工具，<code>$(COMMAND_O)</code>是一个变量，可能包含一些Make工具的选项或参数。</li>\n<li><code>subdir=$(if $(subdir),$(subdir)/$(1),$(1))</code>：这行代码用于设置<code>subdir</code>变量的值。<code>subdir</code>可能是一个已定义的变量，如果它有值，则将其与<code>$(1)</code>（目录名）连接起来作为新的子目录路径。如果<code>subdir</code>没有定义，则将<code>$(1)</code>作为子目录路径。</li>\n<li><code>$(PRINT_DIR)</code>：这个变量可能包含打印目录信息的选项或命令。</li>\n<li><code>-C $(1)</code>：指定Make工具在目录<code>$(1)</code>中执行构建操作。</li>\n<li><code>$(2)</code>：这个参数是传递给<code>descend</code>函数的第二个参数，可能包含其他的选项或命令。</li>\n</ol>\n<p>综上所述，通过调用<code>$(call descend, power/acpi)</code>，将执行以下操作：</p>\n<ol>\n<li>创建目录<code>$(OUTPUT)power/acpi</code>，如果该目录不存在，即生成在tools/power/acpi目录下</li>\n<li>在<code>power/acpi</code>目录中执行Make工具，并传递<code>subdir=power/acpi</code>和其他可能的选项或命令。</li>\n</ol>\n<h3 id=\"tools-power-acpi-Makefile\"><a href=\"#tools-power-acpi-Makefile\" class=\"headerlink\" title=\"tools/power/acpi/Makefile\"></a><a href=\"https://elixir.bootlin.com/linux/v4.2.7/source/tools/power/acpi/Makefile\" target=\"_blank\" rel=\"noopener\">tools/power/acpi/Makefile</a></h3><p>这个makefile文件跟简单就是编译链接相应的文件设置保存路径等最后生成acpidump可执行文件，再将可执行文件拷贝到开发板或则文件系统中即可使用</p>\n<h3 id=\"工具介绍\"><a href=\"#工具介绍\" class=\"headerlink\" title=\"工具介绍\"></a>工具介绍</h3><p>以下是对所列工具的简要介绍：</p>\n<ol>\n<li><p>ACPI工具（acpi）：提供与ACPI（高级配置和电源接口）相关的功能和信息，用于管理和监视系统的电源管理和配置。</p>\n</li>\n<li><p>cgroup工具（cgroup）：用于管理和控制Linux控制组（cgroup）的工具，cgroup用于限制、分配和监控进程组的资源（如CPU、内存、磁盘I/O等）。</p>\n</li>\n<li><p>cpupower（cpupower）：用于管理和调整x86 CPU功耗和性能的工具，可以控制CPU频率、功耗模式以及其他与CPU相关的设置。</p>\n</li>\n<li><p>firewire工具（firewire）：用于IEEE-1394（FireWire）总线的用户空间工具，用于监视和分析IEEE-1394网络流量。</p>\n</li>\n<li><p>hv工具（hv）：用于在Hyper-V客户端环境中使用的工具集，提供与Hyper-V虚拟化平台相关的功能和管理。</p>\n</li>\n<li><p>lguest（lguest）：一个最小化的32位x86虚拟化平台，用于运行客户操作系统作为虚拟机。</p>\n</li>\n<li><p>perf工具（perf）：Linux性能测量和分析工具，用于收集系统和应用程序的性能数据，进行性能分析和优化。</p>\n</li>\n<li><p>selftests（selftests）：包含各种内核自测（self-test）工具和测试套件，用于测试和验证Linux内核的功能和稳定性。</p>\n</li>\n<li><p>turbostat（turbostat）：用于报告Intel CPU空闲状态和频率的工具，提供有关CPU功耗、频率调节和性能的信息。</p>\n</li>\n<li><p>USB测试工具（usb）：用于测试和诊断USB设备和功能的工具集，用于调试和分析USB相关问题。</p>\n</li>\n<li><p>virtio（virtio）：用于虚拟化环境中的vhost测试模块，提供对虚拟I/O设备（如磁盘、网络等）的性能测试和评估。</p>\n</li>\n<li><p>网络工具（net）：包含各种杂项网络工具，用于网络配置、监视和故障排除，如网络接口管理、路由设置、网络诊断等。</p>\n</li>\n<li><p>VM工具（vm）：包含各种杂项虚拟机（VM）工具，用于管理和操作虚拟机，如创建、配置、迁移虚拟机等。</p>\n</li>\n<li><p>x86_energy_perf_policy（x86_energy_perf_policy）：英特尔能效策略工具，用于管理和优化英特尔CPU的能效策略设置。</p>\n</li>\n<li><p>tmon工具（tmon）：用于热监视和调整的工具，用于监测系统温度、风扇速度和其他与热管理相关的参数，并进行热优化和调整。</p>\n</li>\n</ol>\n<p>这些工具提供了一系列功能，用于管理、调整和监视不同方面的系统资源和配置，以及进行性能优化、调试和故障排除。具体使用方法可以参考各自工具的文档和手册。eg:man acpidump。</p>\n<h3 id=\"menuconfig配置\"><a href=\"#menuconfig配置\" class=\"headerlink\" title=\"menuconfig配置\"></a>menuconfig配置</h3><p><img src=\"/2023/06/linux-nei-he-tool-mu-lu/menuconfig.png\" alt=\"menuconfig配置方法\"><br>配置第一个即可 注意打开depends</p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<h1 id=\"Q：tool目录在linux内核中是干嘛的\"><a href=\"#Q：tool目录在linux内核中是干嘛的\" class=\"headerlink\" title=\"Q：tool目录在linux内核中是干嘛的\"></a>Q：tool目录在linux内核中是干嘛的</h1><h1 id=\"A：顾名思义工具文件夹\"><a href=\"#A：顾名思义工具文件夹\" class=\"headerlink\" title=\"A：顾名思义工具文件夹\"></a>A：顾名思义工具文件夹</h1><blockquote>\n<p>提示：我们的代码架构是不是应该也将工具集中在一个目录</p>\n</blockquote>\n<h2 id=\"tool目录结构\"><a href=\"#tool目录结构\" class=\"headerlink\" title=\"tool目录结构\"></a>tool目录结构</h2><p><img src=\"/2023/06/linux-nei-he-tool-mu-lu/tool%E7%9B%AE%E5%BD%95.png\" alt=\"tool目录结构\"><br>首先看下文件夹的makefile文件<a href=\"https://elixir.bootlin.com/linux/v4.3.6/source/tools/Makefile\" target=\"_blank\" rel=\"noopener\">链接</a><br>文件内容：<br>    1：help告诉你有哪些工具和编译删除的方法<br>    2：各工具的编译命令</p>\n<h2 id=\"编译命令解析\"><a href=\"#编译命令解析\" class=\"headerlink\" title=\"编译命令解析\"></a>编译命令解析</h2><h3 id=\"make-C-tools-acpi-install\"><a href=\"#make-C-tools-acpi-install\" class=\"headerlink\" title=\"make -C tools/ acpi_install\"></a>make -C tools/ acpi_install</h3><p>以 acpi 工具为例<br>help提示编译命令为：make -C tools/ acpi_install<br>就会执行makefile文件命令：</p>\n<pre><code>acpi: FORCE  \n    $(call descend,power/$@)</code></pre><p>descend是一个函数在tools/scripts/Makefile，<br>根据提供的代码，<code>descend</code>函数的定义如下：</p>\n<pre><code class=\"tools/scripts/Makefile.include\">descend = \\\n    +mkdir -p $(OUTPUT)$(1) &amp;&amp; \\\n    $(MAKE) $(COMMAND_O) subdir=$(if $(subdir),$(subdir)/$(1),$(1)) $(PRINT_DIR) -C $(1) $(2)</code></pre>\n<p>这个函数是一个Makefile的宏定义。它定义了一个命令序列，用于在指定的目录中执行进一步的构建操作。下面是对该函数的解释：</p>\n<ol>\n<li><code>mkdir -p $(OUTPUT)$(1)</code>：创建目录<code>$(OUTPUT)$(1)</code>，如果该目录不存在。<code>$(OUTPUT)</code>是一个变量，表示输出目录的路径，<code>$(1)</code>表示传递给<code>descend</code>函数的第一个参数，即目录名。</li>\n<li><code>$(MAKE) $(COMMAND_O)</code>：使用<code>$(MAKE)</code>命令调用Make工具，<code>$(COMMAND_O)</code>是一个变量，可能包含一些Make工具的选项或参数。</li>\n<li><code>subdir=$(if $(subdir),$(subdir)/$(1),$(1))</code>：这行代码用于设置<code>subdir</code>变量的值。<code>subdir</code>可能是一个已定义的变量，如果它有值，则将其与<code>$(1)</code>（目录名）连接起来作为新的子目录路径。如果<code>subdir</code>没有定义，则将<code>$(1)</code>作为子目录路径。</li>\n<li><code>$(PRINT_DIR)</code>：这个变量可能包含打印目录信息的选项或命令。</li>\n<li><code>-C $(1)</code>：指定Make工具在目录<code>$(1)</code>中执行构建操作。</li>\n<li><code>$(2)</code>：这个参数是传递给<code>descend</code>函数的第二个参数，可能包含其他的选项或命令。</li>\n</ol>\n<p>综上所述，通过调用<code>$(call descend, power/acpi)</code>，将执行以下操作：</p>\n<ol>\n<li>创建目录<code>$(OUTPUT)power/acpi</code>，如果该目录不存在，即生成在tools/power/acpi目录下</li>\n<li>在<code>power/acpi</code>目录中执行Make工具，并传递<code>subdir=power/acpi</code>和其他可能的选项或命令。</li>\n</ol>\n<h3 id=\"tools-power-acpi-Makefile\"><a href=\"#tools-power-acpi-Makefile\" class=\"headerlink\" title=\"tools/power/acpi/Makefile\"></a><a href=\"https://elixir.bootlin.com/linux/v4.2.7/source/tools/power/acpi/Makefile\" target=\"_blank\" rel=\"noopener\">tools/power/acpi/Makefile</a></h3><p>这个makefile文件跟简单就是编译链接相应的文件设置保存路径等最后生成acpidump可执行文件，再将可执行文件拷贝到开发板或则文件系统中即可使用</p>\n<h3 id=\"工具介绍\"><a href=\"#工具介绍\" class=\"headerlink\" title=\"工具介绍\"></a>工具介绍</h3><p>以下是对所列工具的简要介绍：</p>\n<ol>\n<li><p>ACPI工具（acpi）：提供与ACPI（高级配置和电源接口）相关的功能和信息，用于管理和监视系统的电源管理和配置。</p>\n</li>\n<li><p>cgroup工具（cgroup）：用于管理和控制Linux控制组（cgroup）的工具，cgroup用于限制、分配和监控进程组的资源（如CPU、内存、磁盘I/O等）。</p>\n</li>\n<li><p>cpupower（cpupower）：用于管理和调整x86 CPU功耗和性能的工具，可以控制CPU频率、功耗模式以及其他与CPU相关的设置。</p>\n</li>\n<li><p>firewire工具（firewire）：用于IEEE-1394（FireWire）总线的用户空间工具，用于监视和分析IEEE-1394网络流量。</p>\n</li>\n<li><p>hv工具（hv）：用于在Hyper-V客户端环境中使用的工具集，提供与Hyper-V虚拟化平台相关的功能和管理。</p>\n</li>\n<li><p>lguest（lguest）：一个最小化的32位x86虚拟化平台，用于运行客户操作系统作为虚拟机。</p>\n</li>\n<li><p>perf工具（perf）：Linux性能测量和分析工具，用于收集系统和应用程序的性能数据，进行性能分析和优化。</p>\n</li>\n<li><p>selftests（selftests）：包含各种内核自测（self-test）工具和测试套件，用于测试和验证Linux内核的功能和稳定性。</p>\n</li>\n<li><p>turbostat（turbostat）：用于报告Intel CPU空闲状态和频率的工具，提供有关CPU功耗、频率调节和性能的信息。</p>\n</li>\n<li><p>USB测试工具（usb）：用于测试和诊断USB设备和功能的工具集，用于调试和分析USB相关问题。</p>\n</li>\n<li><p>virtio（virtio）：用于虚拟化环境中的vhost测试模块，提供对虚拟I/O设备（如磁盘、网络等）的性能测试和评估。</p>\n</li>\n<li><p>网络工具（net）：包含各种杂项网络工具，用于网络配置、监视和故障排除，如网络接口管理、路由设置、网络诊断等。</p>\n</li>\n<li><p>VM工具（vm）：包含各种杂项虚拟机（VM）工具，用于管理和操作虚拟机，如创建、配置、迁移虚拟机等。</p>\n</li>\n<li><p>x86_energy_perf_policy（x86_energy_perf_policy）：英特尔能效策略工具，用于管理和优化英特尔CPU的能效策略设置。</p>\n</li>\n<li><p>tmon工具（tmon）：用于热监视和调整的工具，用于监测系统温度、风扇速度和其他与热管理相关的参数，并进行热优化和调整。</p>\n</li>\n</ol>\n<p>这些工具提供了一系列功能，用于管理、调整和监视不同方面的系统资源和配置，以及进行性能优化、调试和故障排除。具体使用方法可以参考各自工具的文档和手册。eg:man acpidump。</p>\n<h3 id=\"menuconfig配置\"><a href=\"#menuconfig配置\" class=\"headerlink\" title=\"menuconfig配置\"></a>menuconfig配置</h3><p><img src=\"/2023/06/linux-nei-he-tool-mu-lu/menuconfig.png\" alt=\"menuconfig配置方法\"><br>配置第一个即可 注意打开depends</p>\n"},{"title":"单链表-报警模块","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-05-07T11:02:38.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"\n# 报警模块\n\n单向链表的实际应用。你可以在报警系统中使用它。\n\n# 特性\n\n-不同的报警级别\n\n-易于添加错误id\n\n-高可扩展性\n\n\n# 安装\n\n克隆[源码](https://github.com/qian-qiang/Unidirectional_linked_list)以添加到项目中，并将函数thread_error_entry()添加到线程中\n\n# 先决条件\n\ngcc编译器\n\n# 使用\n\n1. “error_id.h”在error_id_t中添加你的error_id\n2. 将error_id添加到ERROR_BUF中\n3. 将error_id添加到ERROR_BUF_LVL_X\n\n示例：\n\n1. make\n2. ./error\n3. 在终端中输入 insert/delete/print 调试\n","source":"_posts/2023/05/单链表-报警模块.md","raw":"---\ntitle: 单链表-报警模块\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-05-07 19:02:38\npassword:\nsummary:\ntags:\n- 模块\ncategories:\n- Embedded system\nkeywords:\ndescription:\n---\n\n# 报警模块\n\n单向链表的实际应用。你可以在报警系统中使用它。\n\n# 特性\n\n-不同的报警级别\n\n-易于添加错误id\n\n-高可扩展性\n\n\n# 安装\n\n克隆[源码](https://github.com/qian-qiang/Unidirectional_linked_list)以添加到项目中，并将函数thread_error_entry()添加到线程中\n\n# 先决条件\n\ngcc编译器\n\n# 使用\n\n1. “error_id.h”在error_id_t中添加你的error_id\n2. 将error_id添加到ERROR_BUF中\n3. 将error_id添加到ERROR_BUF_LVL_X\n\n示例：\n\n1. make\n2. ./error\n3. 在终端中输入 insert/delete/print 调试\n","slug":"单链表-报警模块","published":1,"updated":"2024-01-05T08:12:19.764Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clru1g21g001gs4fubg5x35bg","content":"<h1 id=\"报警模块\"><a href=\"#报警模块\" class=\"headerlink\" title=\"报警模块\"></a>报警模块</h1><p>单向链表的实际应用。你可以在报警系统中使用它。</p>\n<h1 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h1><p>-不同的报警级别</p>\n<p>-易于添加错误id</p>\n<p>-高可扩展性</p>\n<h1 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h1><p>克隆<a href=\"https://github.com/qian-qiang/Unidirectional_linked_list\" target=\"_blank\" rel=\"noopener\">源码</a>以添加到项目中，并将函数thread_error_entry()添加到线程中</p>\n<h1 id=\"先决条件\"><a href=\"#先决条件\" class=\"headerlink\" title=\"先决条件\"></a>先决条件</h1><p>gcc编译器</p>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><ol>\n<li>“error_id.h”在error_id_t中添加你的error_id</li>\n<li>将error_id添加到ERROR_BUF中</li>\n<li>将error_id添加到ERROR_BUF_LVL_X</li>\n</ol>\n<p>示例：</p>\n<ol>\n<li>make</li>\n<li>./error</li>\n<li>在终端中输入 insert/delete/print 调试</li>\n</ol>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<h1 id=\"报警模块\"><a href=\"#报警模块\" class=\"headerlink\" title=\"报警模块\"></a>报警模块</h1><p>单向链表的实际应用。你可以在报警系统中使用它。</p>\n<h1 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h1><p>-不同的报警级别</p>\n<p>-易于添加错误id</p>\n<p>-高可扩展性</p>\n<h1 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h1><p>克隆<a href=\"https://github.com/qian-qiang/Unidirectional_linked_list\" target=\"_blank\" rel=\"noopener\">源码</a>以添加到项目中，并将函数thread_error_entry()添加到线程中</p>\n<h1 id=\"先决条件\"><a href=\"#先决条件\" class=\"headerlink\" title=\"先决条件\"></a>先决条件</h1><p>gcc编译器</p>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><ol>\n<li>“error_id.h”在error_id_t中添加你的error_id</li>\n<li>将error_id添加到ERROR_BUF中</li>\n<li>将error_id添加到ERROR_BUF_LVL_X</li>\n</ol>\n<p>示例：</p>\n<ol>\n<li>make</li>\n<li>./error</li>\n<li>在终端中输入 insert/delete/print 调试</li>\n</ol>\n"},{"title":"提升EMC的软件编程策略","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-05-09T01:02:29.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"\n# EMC [简介](https://qian-qiang.github.io/2023/04/emc-emi.html)\n\n# 有哪些电磁失效可能？\n\n由于EMC干扰的注入，对于一个电子系统而言，可能会引起哪些功能失效呢？\n\n- 微控制器无响应 ：怎么会呢？比如因为干扰原因，软件采集的一个错误的输入值，导致进入了死锁。\n- PC指针失控，软件跑飞\n- 执行意外指令\n- 错误的地址指向，数据损坏或丢失\n- 子例程执行错误\n- 设备重启和/或外部异常中断\n- IP 配置损坏 \n- I/O表现异常，比如显示屏花屏，按键功能失效，继电器乱动，模数采样噪声增加，数模输出异常.......\n\n软件故障的后果示例：\n- 产品意外响应 \n- 上下文丢失\n- 进程中的意外分支 \n- 中断丢失 \n- 数据完整性缺失\n- 输入值误读\n\n# 软件编程策略\n\n## 使用硬件&软件看门狗\n为了确保MCU能够从软件失控故障中恢复，看门狗是最有效的可用工具。\n软件看门狗的原理：它是一个在计数结束时产生MCU复位的定时器。一旦看门狗启动，\n防止看门狗复位控制器的唯一方式就是在程序中周期性更新计数器。\n硬件看门狗：单独的看门狗芯片（eg:tps3823），在单位时间内软件没进行喂狗操作看门狗芯\n片就会输出硬件复位信号到MCU芯片进行复位\n\n## 保护闲置程序存储区域\n在大多数应用中，程序存储空间并没有完全被用户代码占满。为了更强的安全性，如果你不想产\n生复位，可以使用代码填满闲置存储位置，这样会强制看门狗复位或者跳向已知的程序位置。 \n    即使程序计数器损坏，并且跳向闲置存储位置，这都将确保MCU恢复和返回到正常操作。在这个闲\n置区域，还可以跳转到恢复故障安全子程序，通过该子程序可恢复正常运行。\n    带有 ARM® Cortex®-M 内核的 STM32 微控制器使用故障异常，当系统遭受EMC干扰时， 它可\n以捕获可能发生的非法存储访问和非法编程行为。未定义的指令操作代码可以用来填充STM32微控制器的闲置存储，在程序计数器失控的情况下，提高故障异常使用率，使得故障安全程序从错误中恢复。\n\n## 闲置中断向量管理\n为了避免意外中断事件导致的问题（无论是什么来源），建议在相应的向量中加入一个有效的中\n断程序地址，以管理所有可能的中断来源。未使用的中断向量指向故障管理程序标签，该标签中填充了简单的 “ 从中断返回 ” 指令\n\nvoid exception_isr（void）\n{\n    //将异常中断记录或者如有可能显示\n    record_exception_isr（）;\n    //让程序一直在这里死循环，通过看门狗让系统自动重启\n    while（1）;\n}\n在可能的情况下将出现这种异常中断记录并显示，同时进入死循环，利用前面说的看门狗技术让系统重启，或者进入设备安全状态。\n\n## 谨慎IO策略\n为啥干扰会注入，下图就是一个直观的例子，干扰最终会在数字系统中引起输入脉冲，这是异常行为:\n输入通道**：包括开关量输入，模数采样输入，可以采用滤波策略。比如开关量输入在既有的硬件输入滤波措施的基础上，可以采用诸如多次检测去抖动策略。\n\n/*伪码描述一下思路*/\n#define FILTER_TIMES  6\n#define SAMPLE_TIMES  10\n#define GET_IO_BIT（X） PA##X //硬件体系不同，具体实现修改\nbool read_io（）\n{\n    uint8 counter = 0;\n    for（int i=0;i < SAMPLE_TIMES;i++）\n        counter += GET_IO_BIT（0）;\n    /*大于门限占比则认为是高电平状态*/\n    if（counter>=FILTER_TIMES）\n        return true;\n    else\n        return false;\n}\n这里仅仅描述一个思路，具体实现时，还需要考虑多次采样，中间是否需要加延时，你可以看成对开关量调整其采样率，进而做出合理判断。如果只读一次，则在干扰注入时，非常容易读取错误的信息。\n\n对于一个模数采样而言，可以利用数字滤波器技术滤除噪声，消除噪声对系统的影响，在一些资源相对有限的系统，推荐使用一阶数字滤波器或者移动均值滤波器去处理。当然使用时需要合理选择截至频率，防止将真实有用信号频率干掉，导致正常功能也无法使用\n\n输出通道：比如显示输出，比如LCD显示屏，可以增加刷新率，这样即使在某个瞬态设备被干扰了，由于刷新及时，那么外在显示就不会出现。人眼就可能无法识别，当然这是一个健壮措施。如果遇到这样的问题，还是建议从硬件上尽量将干扰切断或者降低注入的程度。\n\n## 掉电检测存储技术\n一个电子系统的供电最容易被干扰，因此可以结合硬件设计一个掉电检测及短时板级UPS电路，检测出系统单片机/DSP供电被干扰到可能将要重启时，电路将备用供电切上，同时将关键运行时参数马上存储在非易失介质中（比如EEPROM/FRAM），如果系统真的无法抵抗干扰导致设备重启，在系统上电时，检测重启原因以及数据，如果识别出是由于短时掉电重启的，将介质中数据导入，恢复现场，系统继续执行。\n\n## 冗余数据存储和交换\n数据在EMC场景下遭受磨坏，如果内部没有恢复机制，设备可能出现意想不到的表现。尤其在功能\n安全性要求很高行业，比如航空、医疗、汽车、工业等环境下。电子设备编程都会采用数据备份策略，对于关键安全功能链的内存数据都会强制要求采用备份数据机制，比如在IEC61508中就有强制要求。\n\n将关键功能对应的运行时参数（在内存中的全局变量），都做3个备份。并利用链接绑定技术，将\n这些参数存储在三片连续的内存区中。在写某个参数时，同时也写备份参数。然后在后台中去检查另外两块区域是否相等，如果不相等则可能发生了致命的错误，可以采集故障报警或者设备重启的策略\n\n## 健壮的通信协议设计\n电子系统或多或少都需要与其他设备进行通信，那么设计一个健壮的通信协议也是提高抗干扰措施的一个重要手段，比如增加CRC报文完整性检查，增加错误重传机制，通信故障检测机制等等\n\n## 留意低频信号\n比如系统中出现喇叭。RGB灯等相对系统来说比较高频率的信号需要特别留意。这些信号有可能会和安装和设计问题结合起来形成一个射频天线产生额外的辐射。这些高频信号应该及时提供给硬件工程师分析。\n\n# 总结\nEMC就是个无聊的游戏","source":"_posts/2023/05/提升EMC的软件编程策略.md","raw":"---\ntitle: 提升EMC的软件编程策略\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-05-09 09:02:29\npassword:\nsummary:\ntags:\n- EMC-EMI\ncategories:\n- Embedded system\nkeywords:\ndescription:\n---\n\n# EMC [简介](https://qian-qiang.github.io/2023/04/emc-emi.html)\n\n# 有哪些电磁失效可能？\n\n由于EMC干扰的注入，对于一个电子系统而言，可能会引起哪些功能失效呢？\n\n- 微控制器无响应 ：怎么会呢？比如因为干扰原因，软件采集的一个错误的输入值，导致进入了死锁。\n- PC指针失控，软件跑飞\n- 执行意外指令\n- 错误的地址指向，数据损坏或丢失\n- 子例程执行错误\n- 设备重启和/或外部异常中断\n- IP 配置损坏 \n- I/O表现异常，比如显示屏花屏，按键功能失效，继电器乱动，模数采样噪声增加，数模输出异常.......\n\n软件故障的后果示例：\n- 产品意外响应 \n- 上下文丢失\n- 进程中的意外分支 \n- 中断丢失 \n- 数据完整性缺失\n- 输入值误读\n\n# 软件编程策略\n\n## 使用硬件&软件看门狗\n为了确保MCU能够从软件失控故障中恢复，看门狗是最有效的可用工具。\n软件看门狗的原理：它是一个在计数结束时产生MCU复位的定时器。一旦看门狗启动，\n防止看门狗复位控制器的唯一方式就是在程序中周期性更新计数器。\n硬件看门狗：单独的看门狗芯片（eg:tps3823），在单位时间内软件没进行喂狗操作看门狗芯\n片就会输出硬件复位信号到MCU芯片进行复位\n\n## 保护闲置程序存储区域\n在大多数应用中，程序存储空间并没有完全被用户代码占满。为了更强的安全性，如果你不想产\n生复位，可以使用代码填满闲置存储位置，这样会强制看门狗复位或者跳向已知的程序位置。 \n    即使程序计数器损坏，并且跳向闲置存储位置，这都将确保MCU恢复和返回到正常操作。在这个闲\n置区域，还可以跳转到恢复故障安全子程序，通过该子程序可恢复正常运行。\n    带有 ARM® Cortex®-M 内核的 STM32 微控制器使用故障异常，当系统遭受EMC干扰时， 它可\n以捕获可能发生的非法存储访问和非法编程行为。未定义的指令操作代码可以用来填充STM32微控制器的闲置存储，在程序计数器失控的情况下，提高故障异常使用率，使得故障安全程序从错误中恢复。\n\n## 闲置中断向量管理\n为了避免意外中断事件导致的问题（无论是什么来源），建议在相应的向量中加入一个有效的中\n断程序地址，以管理所有可能的中断来源。未使用的中断向量指向故障管理程序标签，该标签中填充了简单的 “ 从中断返回 ” 指令\n\nvoid exception_isr（void）\n{\n    //将异常中断记录或者如有可能显示\n    record_exception_isr（）;\n    //让程序一直在这里死循环，通过看门狗让系统自动重启\n    while（1）;\n}\n在可能的情况下将出现这种异常中断记录并显示，同时进入死循环，利用前面说的看门狗技术让系统重启，或者进入设备安全状态。\n\n## 谨慎IO策略\n为啥干扰会注入，下图就是一个直观的例子，干扰最终会在数字系统中引起输入脉冲，这是异常行为:\n输入通道**：包括开关量输入，模数采样输入，可以采用滤波策略。比如开关量输入在既有的硬件输入滤波措施的基础上，可以采用诸如多次检测去抖动策略。\n\n/*伪码描述一下思路*/\n#define FILTER_TIMES  6\n#define SAMPLE_TIMES  10\n#define GET_IO_BIT（X） PA##X //硬件体系不同，具体实现修改\nbool read_io（）\n{\n    uint8 counter = 0;\n    for（int i=0;i < SAMPLE_TIMES;i++）\n        counter += GET_IO_BIT（0）;\n    /*大于门限占比则认为是高电平状态*/\n    if（counter>=FILTER_TIMES）\n        return true;\n    else\n        return false;\n}\n这里仅仅描述一个思路，具体实现时，还需要考虑多次采样，中间是否需要加延时，你可以看成对开关量调整其采样率，进而做出合理判断。如果只读一次，则在干扰注入时，非常容易读取错误的信息。\n\n对于一个模数采样而言，可以利用数字滤波器技术滤除噪声，消除噪声对系统的影响，在一些资源相对有限的系统，推荐使用一阶数字滤波器或者移动均值滤波器去处理。当然使用时需要合理选择截至频率，防止将真实有用信号频率干掉，导致正常功能也无法使用\n\n输出通道：比如显示输出，比如LCD显示屏，可以增加刷新率，这样即使在某个瞬态设备被干扰了，由于刷新及时，那么外在显示就不会出现。人眼就可能无法识别，当然这是一个健壮措施。如果遇到这样的问题，还是建议从硬件上尽量将干扰切断或者降低注入的程度。\n\n## 掉电检测存储技术\n一个电子系统的供电最容易被干扰，因此可以结合硬件设计一个掉电检测及短时板级UPS电路，检测出系统单片机/DSP供电被干扰到可能将要重启时，电路将备用供电切上，同时将关键运行时参数马上存储在非易失介质中（比如EEPROM/FRAM），如果系统真的无法抵抗干扰导致设备重启，在系统上电时，检测重启原因以及数据，如果识别出是由于短时掉电重启的，将介质中数据导入，恢复现场，系统继续执行。\n\n## 冗余数据存储和交换\n数据在EMC场景下遭受磨坏，如果内部没有恢复机制，设备可能出现意想不到的表现。尤其在功能\n安全性要求很高行业，比如航空、医疗、汽车、工业等环境下。电子设备编程都会采用数据备份策略，对于关键安全功能链的内存数据都会强制要求采用备份数据机制，比如在IEC61508中就有强制要求。\n\n将关键功能对应的运行时参数（在内存中的全局变量），都做3个备份。并利用链接绑定技术，将\n这些参数存储在三片连续的内存区中。在写某个参数时，同时也写备份参数。然后在后台中去检查另外两块区域是否相等，如果不相等则可能发生了致命的错误，可以采集故障报警或者设备重启的策略\n\n## 健壮的通信协议设计\n电子系统或多或少都需要与其他设备进行通信，那么设计一个健壮的通信协议也是提高抗干扰措施的一个重要手段，比如增加CRC报文完整性检查，增加错误重传机制，通信故障检测机制等等\n\n## 留意低频信号\n比如系统中出现喇叭。RGB灯等相对系统来说比较高频率的信号需要特别留意。这些信号有可能会和安装和设计问题结合起来形成一个射频天线产生额外的辐射。这些高频信号应该及时提供给硬件工程师分析。\n\n# 总结\nEMC就是个无聊的游戏","slug":"提升EMC的软件编程策略","published":1,"updated":"2024-01-05T08:12:19.764Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clru1g21i001ks4fuecq8g83h","content":"<h1 id=\"EMC-简介\"><a href=\"#EMC-简介\" class=\"headerlink\" title=\"EMC 简介\"></a>EMC <a href=\"https://qian-qiang.github.io/2023/04/emc-emi.html\">简介</a></h1><h1 id=\"有哪些电磁失效可能？\"><a href=\"#有哪些电磁失效可能？\" class=\"headerlink\" title=\"有哪些电磁失效可能？\"></a>有哪些电磁失效可能？</h1><p>由于EMC干扰的注入，对于一个电子系统而言，可能会引起哪些功能失效呢？</p>\n<ul>\n<li>微控制器无响应 ：怎么会呢？比如因为干扰原因，软件采集的一个错误的输入值，导致进入了死锁。</li>\n<li>PC指针失控，软件跑飞</li>\n<li>执行意外指令</li>\n<li>错误的地址指向，数据损坏或丢失</li>\n<li>子例程执行错误</li>\n<li>设备重启和/或外部异常中断</li>\n<li>IP 配置损坏 </li>\n<li>I/O表现异常，比如显示屏花屏，按键功能失效，继电器乱动，模数采样噪声增加，数模输出异常…….</li>\n</ul>\n<p>软件故障的后果示例：</p>\n<ul>\n<li>产品意外响应 </li>\n<li>上下文丢失</li>\n<li>进程中的意外分支 </li>\n<li>中断丢失 </li>\n<li>数据完整性缺失</li>\n<li>输入值误读</li>\n</ul>\n<h1 id=\"软件编程策略\"><a href=\"#软件编程策略\" class=\"headerlink\" title=\"软件编程策略\"></a>软件编程策略</h1><h2 id=\"使用硬件-amp-软件看门狗\"><a href=\"#使用硬件-amp-软件看门狗\" class=\"headerlink\" title=\"使用硬件&amp;软件看门狗\"></a>使用硬件&amp;软件看门狗</h2><p>为了确保MCU能够从软件失控故障中恢复，看门狗是最有效的可用工具。<br>软件看门狗的原理：它是一个在计数结束时产生MCU复位的定时器。一旦看门狗启动，<br>防止看门狗复位控制器的唯一方式就是在程序中周期性更新计数器。<br>硬件看门狗：单独的看门狗芯片（eg:tps3823），在单位时间内软件没进行喂狗操作看门狗芯<br>片就会输出硬件复位信号到MCU芯片进行复位</p>\n<h2 id=\"保护闲置程序存储区域\"><a href=\"#保护闲置程序存储区域\" class=\"headerlink\" title=\"保护闲置程序存储区域\"></a>保护闲置程序存储区域</h2><p>在大多数应用中，程序存储空间并没有完全被用户代码占满。为了更强的安全性，如果你不想产<br>生复位，可以使用代码填满闲置存储位置，这样会强制看门狗复位或者跳向已知的程序位置。<br>    即使程序计数器损坏，并且跳向闲置存储位置，这都将确保MCU恢复和返回到正常操作。在这个闲<br>置区域，还可以跳转到恢复故障安全子程序，通过该子程序可恢复正常运行。<br>    带有 ARM® Cortex®-M 内核的 STM32 微控制器使用故障异常，当系统遭受EMC干扰时， 它可<br>以捕获可能发生的非法存储访问和非法编程行为。未定义的指令操作代码可以用来填充STM32微控制器的闲置存储，在程序计数器失控的情况下，提高故障异常使用率，使得故障安全程序从错误中恢复。</p>\n<h2 id=\"闲置中断向量管理\"><a href=\"#闲置中断向量管理\" class=\"headerlink\" title=\"闲置中断向量管理\"></a>闲置中断向量管理</h2><p>为了避免意外中断事件导致的问题（无论是什么来源），建议在相应的向量中加入一个有效的中<br>断程序地址，以管理所有可能的中断来源。未使用的中断向量指向故障管理程序标签，该标签中填充了简单的 “ 从中断返回 ” 指令</p>\n<p>void exception_isr（void）<br>{<br>    //将异常中断记录或者如有可能显示<br>    record_exception_isr（）;<br>    //让程序一直在这里死循环，通过看门狗让系统自动重启<br>    while（1）;<br>}<br>在可能的情况下将出现这种异常中断记录并显示，同时进入死循环，利用前面说的看门狗技术让系统重启，或者进入设备安全状态。</p>\n<h2 id=\"谨慎IO策略\"><a href=\"#谨慎IO策略\" class=\"headerlink\" title=\"谨慎IO策略\"></a>谨慎IO策略</h2><p>为啥干扰会注入，下图就是一个直观的例子，干扰最终会在数字系统中引起输入脉冲，这是异常行为:<br>输入通道**：包括开关量输入，模数采样输入，可以采用滤波策略。比如开关量输入在既有的硬件输入滤波措施的基础上，可以采用诸如多次检测去抖动策略。</p>\n<p>/<em>伪码描述一下思路</em>/</p>\n<p>#define FILTER_TIMES  6</p>\n<p>#define SAMPLE_TIMES  10</p>\n<p>#define GET_IO_BIT（X） PA##X //硬件体系不同，具体实现修改<br>bool read_io（）<br>{<br>    uint8 counter = 0;<br>    for（int i=0;i &lt; SAMPLE_TIMES;i++）<br>        counter += GET_IO_BIT（0）;<br>    /<em>大于门限占比则认为是高电平状态</em>/<br>    if（counter&gt;=FILTER_TIMES）<br>        return true;<br>    else<br>        return false;<br>}<br>这里仅仅描述一个思路，具体实现时，还需要考虑多次采样，中间是否需要加延时，你可以看成对开关量调整其采样率，进而做出合理判断。如果只读一次，则在干扰注入时，非常容易读取错误的信息。</p>\n<p>对于一个模数采样而言，可以利用数字滤波器技术滤除噪声，消除噪声对系统的影响，在一些资源相对有限的系统，推荐使用一阶数字滤波器或者移动均值滤波器去处理。当然使用时需要合理选择截至频率，防止将真实有用信号频率干掉，导致正常功能也无法使用</p>\n<p>输出通道：比如显示输出，比如LCD显示屏，可以增加刷新率，这样即使在某个瞬态设备被干扰了，由于刷新及时，那么外在显示就不会出现。人眼就可能无法识别，当然这是一个健壮措施。如果遇到这样的问题，还是建议从硬件上尽量将干扰切断或者降低注入的程度。</p>\n<h2 id=\"掉电检测存储技术\"><a href=\"#掉电检测存储技术\" class=\"headerlink\" title=\"掉电检测存储技术\"></a>掉电检测存储技术</h2><p>一个电子系统的供电最容易被干扰，因此可以结合硬件设计一个掉电检测及短时板级UPS电路，检测出系统单片机/DSP供电被干扰到可能将要重启时，电路将备用供电切上，同时将关键运行时参数马上存储在非易失介质中（比如EEPROM/FRAM），如果系统真的无法抵抗干扰导致设备重启，在系统上电时，检测重启原因以及数据，如果识别出是由于短时掉电重启的，将介质中数据导入，恢复现场，系统继续执行。</p>\n<h2 id=\"冗余数据存储和交换\"><a href=\"#冗余数据存储和交换\" class=\"headerlink\" title=\"冗余数据存储和交换\"></a>冗余数据存储和交换</h2><p>数据在EMC场景下遭受磨坏，如果内部没有恢复机制，设备可能出现意想不到的表现。尤其在功能<br>安全性要求很高行业，比如航空、医疗、汽车、工业等环境下。电子设备编程都会采用数据备份策略，对于关键安全功能链的内存数据都会强制要求采用备份数据机制，比如在IEC61508中就有强制要求。</p>\n<p>将关键功能对应的运行时参数（在内存中的全局变量），都做3个备份。并利用链接绑定技术，将<br>这些参数存储在三片连续的内存区中。在写某个参数时，同时也写备份参数。然后在后台中去检查另外两块区域是否相等，如果不相等则可能发生了致命的错误，可以采集故障报警或者设备重启的策略</p>\n<h2 id=\"健壮的通信协议设计\"><a href=\"#健壮的通信协议设计\" class=\"headerlink\" title=\"健壮的通信协议设计\"></a>健壮的通信协议设计</h2><p>电子系统或多或少都需要与其他设备进行通信，那么设计一个健壮的通信协议也是提高抗干扰措施的一个重要手段，比如增加CRC报文完整性检查，增加错误重传机制，通信故障检测机制等等</p>\n<h2 id=\"留意低频信号\"><a href=\"#留意低频信号\" class=\"headerlink\" title=\"留意低频信号\"></a>留意低频信号</h2><p>比如系统中出现喇叭。RGB灯等相对系统来说比较高频率的信号需要特别留意。这些信号有可能会和安装和设计问题结合起来形成一个射频天线产生额外的辐射。这些高频信号应该及时提供给硬件工程师分析。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>EMC就是个无聊的游戏</p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<h1 id=\"EMC-简介\"><a href=\"#EMC-简介\" class=\"headerlink\" title=\"EMC 简介\"></a>EMC <a href=\"https://qian-qiang.github.io/2023/04/emc-emi.html\">简介</a></h1><h1 id=\"有哪些电磁失效可能？\"><a href=\"#有哪些电磁失效可能？\" class=\"headerlink\" title=\"有哪些电磁失效可能？\"></a>有哪些电磁失效可能？</h1><p>由于EMC干扰的注入，对于一个电子系统而言，可能会引起哪些功能失效呢？</p>\n<ul>\n<li>微控制器无响应 ：怎么会呢？比如因为干扰原因，软件采集的一个错误的输入值，导致进入了死锁。</li>\n<li>PC指针失控，软件跑飞</li>\n<li>执行意外指令</li>\n<li>错误的地址指向，数据损坏或丢失</li>\n<li>子例程执行错误</li>\n<li>设备重启和/或外部异常中断</li>\n<li>IP 配置损坏 </li>\n<li>I/O表现异常，比如显示屏花屏，按键功能失效，继电器乱动，模数采样噪声增加，数模输出异常…….</li>\n</ul>\n<p>软件故障的后果示例：</p>\n<ul>\n<li>产品意外响应 </li>\n<li>上下文丢失</li>\n<li>进程中的意外分支 </li>\n<li>中断丢失 </li>\n<li>数据完整性缺失</li>\n<li>输入值误读</li>\n</ul>\n<h1 id=\"软件编程策略\"><a href=\"#软件编程策略\" class=\"headerlink\" title=\"软件编程策略\"></a>软件编程策略</h1><h2 id=\"使用硬件-amp-软件看门狗\"><a href=\"#使用硬件-amp-软件看门狗\" class=\"headerlink\" title=\"使用硬件&amp;软件看门狗\"></a>使用硬件&amp;软件看门狗</h2><p>为了确保MCU能够从软件失控故障中恢复，看门狗是最有效的可用工具。<br>软件看门狗的原理：它是一个在计数结束时产生MCU复位的定时器。一旦看门狗启动，<br>防止看门狗复位控制器的唯一方式就是在程序中周期性更新计数器。<br>硬件看门狗：单独的看门狗芯片（eg:tps3823），在单位时间内软件没进行喂狗操作看门狗芯<br>片就会输出硬件复位信号到MCU芯片进行复位</p>\n<h2 id=\"保护闲置程序存储区域\"><a href=\"#保护闲置程序存储区域\" class=\"headerlink\" title=\"保护闲置程序存储区域\"></a>保护闲置程序存储区域</h2><p>在大多数应用中，程序存储空间并没有完全被用户代码占满。为了更强的安全性，如果你不想产<br>生复位，可以使用代码填满闲置存储位置，这样会强制看门狗复位或者跳向已知的程序位置。<br>    即使程序计数器损坏，并且跳向闲置存储位置，这都将确保MCU恢复和返回到正常操作。在这个闲<br>置区域，还可以跳转到恢复故障安全子程序，通过该子程序可恢复正常运行。<br>    带有 ARM® Cortex®-M 内核的 STM32 微控制器使用故障异常，当系统遭受EMC干扰时， 它可<br>以捕获可能发生的非法存储访问和非法编程行为。未定义的指令操作代码可以用来填充STM32微控制器的闲置存储，在程序计数器失控的情况下，提高故障异常使用率，使得故障安全程序从错误中恢复。</p>\n<h2 id=\"闲置中断向量管理\"><a href=\"#闲置中断向量管理\" class=\"headerlink\" title=\"闲置中断向量管理\"></a>闲置中断向量管理</h2><p>为了避免意外中断事件导致的问题（无论是什么来源），建议在相应的向量中加入一个有效的中<br>断程序地址，以管理所有可能的中断来源。未使用的中断向量指向故障管理程序标签，该标签中填充了简单的 “ 从中断返回 ” 指令</p>\n<p>void exception_isr（void）<br>{<br>    //将异常中断记录或者如有可能显示<br>    record_exception_isr（）;<br>    //让程序一直在这里死循环，通过看门狗让系统自动重启<br>    while（1）;<br>}<br>在可能的情况下将出现这种异常中断记录并显示，同时进入死循环，利用前面说的看门狗技术让系统重启，或者进入设备安全状态。</p>\n<h2 id=\"谨慎IO策略\"><a href=\"#谨慎IO策略\" class=\"headerlink\" title=\"谨慎IO策略\"></a>谨慎IO策略</h2><p>为啥干扰会注入，下图就是一个直观的例子，干扰最终会在数字系统中引起输入脉冲，这是异常行为:<br>输入通道**：包括开关量输入，模数采样输入，可以采用滤波策略。比如开关量输入在既有的硬件输入滤波措施的基础上，可以采用诸如多次检测去抖动策略。</p>\n<p>/<em>伪码描述一下思路</em>/</p>\n<p>#define FILTER_TIMES  6</p>\n<p>#define SAMPLE_TIMES  10</p>\n<p>#define GET_IO_BIT（X） PA##X //硬件体系不同，具体实现修改<br>bool read_io（）<br>{<br>    uint8 counter = 0;<br>    for（int i=0;i &lt; SAMPLE_TIMES;i++）<br>        counter += GET_IO_BIT（0）;<br>    /<em>大于门限占比则认为是高电平状态</em>/<br>    if（counter&gt;=FILTER_TIMES）<br>        return true;<br>    else<br>        return false;<br>}<br>这里仅仅描述一个思路，具体实现时，还需要考虑多次采样，中间是否需要加延时，你可以看成对开关量调整其采样率，进而做出合理判断。如果只读一次，则在干扰注入时，非常容易读取错误的信息。</p>\n<p>对于一个模数采样而言，可以利用数字滤波器技术滤除噪声，消除噪声对系统的影响，在一些资源相对有限的系统，推荐使用一阶数字滤波器或者移动均值滤波器去处理。当然使用时需要合理选择截至频率，防止将真实有用信号频率干掉，导致正常功能也无法使用</p>\n<p>输出通道：比如显示输出，比如LCD显示屏，可以增加刷新率，这样即使在某个瞬态设备被干扰了，由于刷新及时，那么外在显示就不会出现。人眼就可能无法识别，当然这是一个健壮措施。如果遇到这样的问题，还是建议从硬件上尽量将干扰切断或者降低注入的程度。</p>\n<h2 id=\"掉电检测存储技术\"><a href=\"#掉电检测存储技术\" class=\"headerlink\" title=\"掉电检测存储技术\"></a>掉电检测存储技术</h2><p>一个电子系统的供电最容易被干扰，因此可以结合硬件设计一个掉电检测及短时板级UPS电路，检测出系统单片机/DSP供电被干扰到可能将要重启时，电路将备用供电切上，同时将关键运行时参数马上存储在非易失介质中（比如EEPROM/FRAM），如果系统真的无法抵抗干扰导致设备重启，在系统上电时，检测重启原因以及数据，如果识别出是由于短时掉电重启的，将介质中数据导入，恢复现场，系统继续执行。</p>\n<h2 id=\"冗余数据存储和交换\"><a href=\"#冗余数据存储和交换\" class=\"headerlink\" title=\"冗余数据存储和交换\"></a>冗余数据存储和交换</h2><p>数据在EMC场景下遭受磨坏，如果内部没有恢复机制，设备可能出现意想不到的表现。尤其在功能<br>安全性要求很高行业，比如航空、医疗、汽车、工业等环境下。电子设备编程都会采用数据备份策略，对于关键安全功能链的内存数据都会强制要求采用备份数据机制，比如在IEC61508中就有强制要求。</p>\n<p>将关键功能对应的运行时参数（在内存中的全局变量），都做3个备份。并利用链接绑定技术，将<br>这些参数存储在三片连续的内存区中。在写某个参数时，同时也写备份参数。然后在后台中去检查另外两块区域是否相等，如果不相等则可能发生了致命的错误，可以采集故障报警或者设备重启的策略</p>\n<h2 id=\"健壮的通信协议设计\"><a href=\"#健壮的通信协议设计\" class=\"headerlink\" title=\"健壮的通信协议设计\"></a>健壮的通信协议设计</h2><p>电子系统或多或少都需要与其他设备进行通信，那么设计一个健壮的通信协议也是提高抗干扰措施的一个重要手段，比如增加CRC报文完整性检查，增加错误重传机制，通信故障检测机制等等</p>\n<h2 id=\"留意低频信号\"><a href=\"#留意低频信号\" class=\"headerlink\" title=\"留意低频信号\"></a>留意低频信号</h2><p>比如系统中出现喇叭。RGB灯等相对系统来说比较高频率的信号需要特别留意。这些信号有可能会和安装和设计问题结合起来形成一个射频天线产生额外的辐射。这些高频信号应该及时提供给硬件工程师分析。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>EMC就是个无聊的游戏</p>\n"},{"title":"ttymxx(UART)","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-06-27T11:04:26.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"\n#  Q：linux中如何控制串口？\n#  A：模块化设计\n\n## 第一步：设置设备树中关于串口的信息（设备树模块）\n```\n    uart1: serial@02020000 {\n        compatible = \"fsl,imx6ul-uart\",\n                    \"fsl,imx6q-uart\", \"fsl,imx21-uart\";\n        reg = <0x02020000 0x4000>;\n        interrupts = <GIC_SPI 26 IRQ_TYPE_LEVEL_HIGH>;\n        clocks = <&clks IMX6UL_CLK_UART1_IPG>,\n                <&clks IMX6UL_CLK_UART1_SERIAL>;\n        clock-names = \"ipg\", \"per\";\n        status = \"disabled\";\n    };\n    uart3: serial@021ec000 {\n        compatible = \"fsl,imx6ul-uart\",\n                    \"fsl,imx6q-uart\", \"fsl,imx21-uart\";\n        reg = <0x021ec000 0x4000>;\n        interrupts = <GIC_SPI 28 IRQ_TYPE_LEVEL_HIGH>;\n        clocks = <&clks IMX6UL_CLK_UART3_IPG>,\n                <&clks IMX6UL_CLK_UART3_SERIAL>;\n        clock-names = \"ipg\", \"per\";\n        dmas = <&sdma 29 4 0>, <&sdma 30 4 0>;\n        dma-names = \"rx\", \"tx\";\n        status = \"disabled\";\n    };   \n```\n\n## 第二步：驱动获取设备树生成设备（驱动模块）\n\ndrivers/tty/serial/imx.c文件中有如下内容：\n ```\nstatic struct platform_device_id imx_uart_devtype[] = {\n\t{\n\t\t.name = \"imx1-uart\",\n\t\t.driver_data = (kernel_ulong_t) &imx_uart_devdata[IMX1_UART],\n\t}, {\n\t\t.name = \"imx21-uart\",\n\t\t.driver_data = (kernel_ulong_t) &imx_uart_devdata[IMX21_UART],\n\t}, {\n\t\t.name = \"imx6q-uart\",\n\t\t.driver_data = (kernel_ulong_t) &imx_uart_devdata[IMX6Q_UART],\n\t}, {\n\t\t/* sentinel */\n\t}\n};\nMODULE_DEVICE_TABLE(platform, imx_uart_devtype);\n```\n\n```\nstatic struct uart_driver imx_reg = {\n\t.owner          = THIS_MODULE,\n\t.driver_name    = DRIVER_NAME,  //\"IMX-uart\"\n\t.dev_name       = DEV_NAME,     //\"ttymxc\"\n\t.major          = SERIAL_IMX_MAJOR, //207\n\t.minor          = MINOR_START,      //16\n\t.nr             = ARRAY_SIZE(imx_ports),    //8\n\t.cons           = IMX_CONSOLE,      //NULL\n};\n```\n\nplatform平台对比到相同的设备树中的compatible到驱动中的name的时候就执行probe函数：\n\n<details><summary>static int serial_imx_probe（struct platform_device *pdev）</summary>\n<pre><code>\n{\n\tstruct imx_port *sport;\n\tvoid __iomem *base;\n\tint ret = 0;\n\tstruct resource *res;\n\tint txirq, rxirq, rtsirq;\n\tsport = devm_kzalloc(&pdev->dev, sizeof(*sport), GFP_KERNEL);\n\tif (!sport)\n\t\treturn -ENOMEM;\n\tret = serial_imx_probe_dt(sport, pdev);\n\tif (ret > 0)\n\t\tserial_imx_probe_pdata(sport, pdev);\n\telse if (ret < 0)\n\t\treturn ret;\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tbase = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\trxirq = platform_get_irq(pdev, 0);\n\ttxirq = platform_get_irq(pdev, 1);\n\trtsirq = platform_get_irq(pdev, 2);\n\tsport->port.dev = &pdev->dev;\n\tsport->port.mapbase = res->start;\n\tsport->port.membase = base;\n\tsport->port.type = PORT_IMX,\n\tsport->port.iotype = UPIO_MEM;\n\tsport->port.irq = rxirq;\n\tsport->port.fifosize = 32;\n\tsport->port.ops = &imx_pops;\n\tsport->port.rs485_config = imx_rs485_config;\n\tsport->port.rs485.flags =\n\t\tSER_RS485_RTS_ON_SEND | SER_RS485_RX_DURING_TX;\n\tsport->port.flags = UPF_BOOT_AUTOCONF;\n\tinit_timer(&sport->timer);\n\tsport->timer.function = imx_timeout;\n\tsport->timer.data     = (unsigned long)sport;\n\tsport->clk_ipg = devm_clk_get(&pdev->dev, \"ipg\");\n\tif (IS_ERR(sport->clk_ipg)) {\n\t\tret = PTR_ERR(sport->clk_ipg);\n\t\tdev_err(&pdev->dev, \"failed to get ipg clk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tsport->clk_per = devm_clk_get(&pdev->dev, \"per\");\n\tif (IS_ERR(sport->clk_per)) {\n\t\tret = PTR_ERR(sport->clk_per);\n\t\tdev_err(&pdev->dev, \"failed to get per clk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tsport->port.uartclk = clk_get_rate(sport->clk_per);\n\tif (sport->port.uartclk > IMX_MODULE_MAX_CLK_RATE) {\n\t\tret = clk_set_rate(sport->clk_per, IMX_MODULE_MAX_CLK_RATE);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&pdev->dev, \"clk_set_rate() failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\tsport->port.uartclk = clk_get_rate(sport->clk_per);\n\tif (txirq > 0) {\n\t\tret = devm_request_irq(&pdev->dev, rxirq, imx_rxint, 0,\n\t\t\t\t       dev_name(&pdev->dev), sport);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = devm_request_irq(&pdev->dev, txirq, imx_txint, 0,\n\t\t\t\t       dev_name(&pdev->dev), sport);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tret = devm_request_irq(&pdev->dev, rxirq, imx_int, 0,\n\t\t\t\t       dev_name(&pdev->dev), sport);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\timx_ports[sport->port.line] = sport;\n\tplatform_set_drvdata(pdev, sport);\n\treturn uart_add_one_port(&imx_reg, &sport->port);\n}\n</code></pre></details>\n\n`serial_imx_probe`函数是针对i.MX系列平台设备的串口驱动的探测函数。该函数的功能是在系统启动时，当检测到与i.MX系列平台相关的串口设备时，自动初始化和注册相应的串口驱动程序。\n\n具体功能包括：\n\n1. 识别并验证与i.MX平台相关的串口设备资源。通过检查设备树（device tree）或其他平台特定的数据结构，确定该平台上的串口设备的物理地址、中断号、时钟等信息，并进行验证。\n\n2. 为每个串口设备分配和初始化相应的`struct uart_port`结构体。该结构体用于表示一个串口设备的相关参数和状态信息，如设备的基地址、中断号、波特率等。\n\n3. 注册串口驱动程序。调用`uart_add_one_port`函数将初始化好的`struct uart_port`结构体注册到串口子系统中，以便操作系统可以管理和操作该串口设备。\n\n4. 执行其他平台特定的初始化操作。根据i.MX平台的要求，可能需要进行其他特定于该平台的初始化步骤，如设置GPIO引脚、时钟源等。\n\n总而言之，`serial_imx_probe`函数的功能是在系统启动时，自动探测和初始化i.MX平台上的串口设备，并注册相应的串口驱动程序，以便后续操作系统和用户空间程序可以与这些串口设备进行通信和交互。\n\n数据结构的关系：\n内核串口驱动结构uart_driver（imx_reg）在 imx_serial_init 函数中向 Linux 内核注册了 imx_reg。\n当 UART 设备和驱动匹配成功以后 serial_imx_probe 函数就会执行，此函数的重点工作就\n是初始化 uart_port，然后将其添加到对应的 uart_driver 中。imx驱动自己创建了imx_port 结构体里面有一个成员就是uart_port，最后通过uart_add_one_port注册。\n\n所以在dev目录下就会有：![ls /dev](ttymxx-UART/ls-dev.png) 对应到uart1->ttymxc0和uart3->ttymxc2\n设备号：![设备号](ttymxx-UART/ttymxc.png)\n设备：![设备](ttymxx-UART/cat-proc-devices.png)\n\n## 第三步：使用串口（应用模块）\n通过串口发送数据到ttymxc2,执行cat /dev/ttymxc2：![ttymxc2](ttymxx-UART/cat-ttymxc2.png) 应该是和串口发送的十六进制数据是一样的。所以所有的操作都应该是基于此文件或则设备相关的硬件信号。\n\n### 方法一：轮询\n1. 打开串口\n```\nfd = open(port, O_RDWR | O_NOCTTY | O_NDELAY);\nif (fd == -1) \n{\n    perror(\"open_port: Unable to open serial port\");\n    return -1;\n}\n```\n2. 配置串口\n```\ntcgetattr(fd, &options);\ncfsetispeed(&options, B115200);\ncfsetospeed(&options, B115200);\noptions.c_cflag |= (CLOCAL | CREAD);\noptions.c_cflag &= ~PARENB;\noptions.c_cflag &= ~CSTOPB;\noptions.c_cflag &= ~CSIZE;\noptions.c_cflag |= CS8;\noptions.c_cflag &= ~CRTSCTS;\ntcsetattr(fd, TCSANOW, &options);\n```\n其中，tcgetattr 和 tcsetattr 函数用于获取和设置串口参数。cfsetispeed 和 cfsetospeed 函数用于设置串口的输入和输出波特率，这里设置为 115200。options.c_cflag 表示控制标志位，用于配置串口控制参数，具体含义如下：\n\n    CLOCAL：忽略调制解调器的状态线，只允许本地使用串口。\n\n    CREAD：允许从串口读取数据。\n\n    PARENB：启用奇偶校验。&= ~PARENB则为禁用校验。\n\n    CSTOPB：使用两个停止位而不是一个。&= ~CSTOPB停止位为1。\n\n    CSIZE：表示字符长度的位掩码。在这里设置为 0，表示使用默认的 8 位数据位。\n\n    CS8：表示使用 8 位数据位。\n\n    CRTSCTS：启用硬件流控制，即使用 RTS 和 CTS 状态线进行流控制。\n\n在示例程序中，我们将 CLOCAL 和 CREAD 标志位置为 1，表示允许本地使用串口，并允许从串口读取数据。我们将 PARENB、CSTOPB 和 CRTSCTS 标志位都设置为 0，表示不启用奇偶校验、使用一个停止位和禁用硬件流控制。最后，我们将 CSIZE 标志位设置为 0，然后将 CS8 标志位设置为 1，以表示使用 8 位数据位。\n3. 读写\n```\nread(fd, buf, sizeof(buf)); // 返回接收个数\nwrite(fd, buf, strlen(buf)); // 返回发送长度,负值表示发送失败\n```\n4. 关闭串口\n```\nclose(fd);\n```\n完整示例\n<details><summary>轮询code</summary>\n<pre><code>\n    int main()\n    {\n        int fd;\n        char buf[255];\n        int n;\n        fd = open_port(\"/dev/ttyUSB0\");\n        if (fd == -1) {\n\n            printf(\"open err\\n\");\n            exit(1);\n        }\n        while (1)\n        {\n            n = read(fd, buf, sizeof(buf));\n            if (n > 0) {\n                printf(\"Received: %.*s\\n\", n, buf);\n            }\n            strcpy(buf, \"Hello, world!\\n\");\n            n = write(fd, buf, strlen(buf));\n            if (n < 0) {\n                perror(\"write failed\\n\");\n            }\n            usleep(10 * 1000);\n        }\n        close(fd);\n        printf(\"close uart\\n\");\n        return 0;\n    }\n\n    int open_port(const char *port)\n    {\n        int fd;\n        struct termios options;\n        fd = open(port, O_RDWR | O_NOCTTY | O_NDELAY);\n        if (fd == -1) {\n            perror(\"open_port: Unable to open serial port\");\n            return -1;\n        }\n        tcgetattr(fd, &options);\n        cfsetispeed(&options, B115200);\n        cfsetospeed(&options, B115200);\n        options.c_cflag |= (CLOCAL | CREAD);\n        options.c_cflag &= ~PARENB;\n        options.c_cflag &= ~CSTOPB;\n        options.c_cflag &= ~CSIZE;\n        options.c_cflag |= CS8;\n        options.c_cflag &= ~CRTSCTS;\n        tcsetattr(fd, TCSANOW, &options);\n        return fd;\n    }\n</code></pre></details>\n\n### 方法二：中断读取示例\n上面给出的串口示例是使用轮询的方式读取串口数据，这种方式在某些场景下可能会占用大量 CPU 资源。实际上，对于 Linux 系统来说，还可以使用中断方式接收串口数据，这样可以大大减少 CPU 的占用率，并且能够更快地响应串口数据。\n\n要使用中断方式接收串口数据，可以使用 select 函数来监听串口文件描述符的可读事件。当串口数据可读时，select 函数将返回，并且可以调用 read 函数来读取串口数据。这种方式可以避免轮询操作，只有在串口数据可读时才会执行读取操作，因此能够减少 CPU 的占用率。\n\n以下是一个简单的使用中断方式接收串口数据的示例程序：\n<details><summary>中断读取code</summary>\n<pre><code>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <termios.h>\n#include <sys/select.h>\n\nint main() {\n    int fd;\n    struct termios options;\n    fd_set rfds;\n\n    // 打开串口设备\n    fd = open(\"/dev/ttyUSB0\", O_RDWR | O_NOCTTY);\n    if (fd < 0) {\n        perror(\"open\");\n        return -1;\n    }\n\n    // 配置串口参数\n    tcgetattr(fd, &options);\n    options.c_cflag = B9600 | CS8 | CLOCAL | CREAD;\n    options.c_iflag = IGNPAR;\n    options.c_oflag = 0;\n    options.c_lflag = 0;\n    options.c_cc[VTIME] = 0;\n    options.c_cc[VMIN] = 1;\n    tcsetattr(fd, TCSANOW, &options);\n\n    while (1) {\n        // 使用 select 函数监听串口文件描述符的可读事件\n        FD_ZERO(&rfds);\n        FD_SET(fd, &rfds);\n        select(fd + 1, &rfds, NULL, NULL, NULL);\n\n        // 读取串口数据\n        char buf[256];\n        int n = read(fd, buf, sizeof(buf));\n        if (n > 0) {\n            printf(\"Received data: %.*s\\n\", n, buf);\n        }\n    }\n\n    // 关闭串口设备\n    close(fd);\n\n    return 0;\n}\n</code></pre></details>\n需要注意的是，在使用中断方式接收串口数据时，需要对串口文件描述符设置为非阻塞模式，以便在 select 函数返回时立即读取串口数据。可以使用 fcntl 函数来设置文件描述符的标志位，如下所示：\n```\n// 设置串口文件描述符为非阻塞模式\nint flags = fcntl(fd, F_GETFL, 0);\nfcntl(fd, F_SETFL, flags | O_NONBLOCK);\n```\n\n### 方法三：信号的方式接收数据\n<details><summary>信号的方式接收code</summary>\n<pre><code>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <termios.h>\n#include <signal.h>\n\nint fd;\n\nvoid sigio_handler(int sig) {\n    char buf[256];\n    int n = read(fd, buf, sizeof(buf));\n    if (n > 0) {\n        printf(\"Received data: %.*s\\n\", n, buf);\n    }\n}\n\nint main() {\n    struct termios options;\n    struct sigaction sa;\n\n    // 打开串口设备\n    fd = open(\"/dev/ttyS0\", O_RDWR | O_NOCTTY);\n    if (fd < 0) {\n        perror(\"open\");\n        return -1;\n    }\n\n    // 配置串口参数\n    tcgetattr(fd, &options);\n    options.c_cflag = B9600 | CS8 | CLOCAL | CREAD;\n    options.c_iflag = IGNPAR;\n    options.c_oflag = 0;\n    options.c_lflag = 0;\n    options.c_cc[VTIME] = 0;\n    options.c_cc[VMIN] = 1;\n    tcsetattr(fd, TCSANOW, &options);\n\n    // 设置串口文件描述符为异步通知模式\n    /* 将串口文件描述符设置为当前进程的拥有者，从而接收该文件描述符相关的信号。*/\n    fcntl(fd, F_SETOWN, getpid()); \n    int flags = fcntl(fd, F_GETFL, 0); // 先获取当前配置, 下面只更改O_ASYNC标志\n    /* 将串口文件描述符设置为非阻塞模式，从而允许该文件描述符异步地接收数据和信号。*/\n    fcntl(fd, F_SETFL, flags | O_ASYNC);\n\n    // 设置 SIGIO 信号的处理函数\n    sa.sa_handler = sigio_handler;\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = 0;\n    /* 设置了 SIGIO 信号的处理函数为 sigio_handler，从而在该信号被触发时读取串口数据并进行处理。*/\n    sigaction(SIGIO, &sa, NULL);\n\n    while (1) {\n        // 等待 SIGIO 信号\n        sleep(1);\n    }\n\n    // 关闭串口设备\n    close(fd);\n\n    return 0;\n}\n</code></pre></details>\n上述代码中，使用了 fcntl 函数将串口文件描述符设置为异步通知模式，并使用 SIGIO 信号来通知程序串口数据已经可读。当程序接收到 SIGIO 信号时，会调用 sigio_handler 函数来读取并处理串口数据。\n\n在这段代码中，sigemptyset（&sa.sa_mask）;的作用是将信号处理函数在执行时要屏蔽的信号集合清空，即将其设置为空集。\n\n每个进程都有一个信号屏蔽字，它表示了当前被阻塞的信号集合。当一个信号被阻塞时，它将被加入到信号屏蔽字中，而当信号被解除阻塞时，它将被从信号屏蔽字中移除。如果信号处理函数在执行时需要屏蔽其他的信号，则可以使用sigaddset等函数将需要屏蔽的信号添加到信号屏蔽字中。但是，在本例中，我们需要处理的信号是SIGIO，它通常不需要被屏蔽，因此我们使用sigemptyset函数将信号屏蔽字清空，以确保在处理SIGIO信号时不会屏蔽任何其他信号。\n\n在Linux系统中，使用sigaction函数注册信号处理函数时，可以设置一些标志来指定信号处理的行为。例如，可以使用SA_RESTART标志来指定当系统调用被信号中断时自动重启该系统调用。在本例中，由于我们并不需要设置任何标志，因此将sa.sa_flags字段设置为0即可。这表示信号处理函数不需要任何特殊的行为，只需要按照默认的方式处理信号即可。\n\n### 方法四：使用线程接收串口数据\n<details><summary>使用线程接收code</summary>\n<pre><code>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <termios.h>\n#include <pthread.h>\n\nvoid *read_thread(void *arg) {\n    int fd = *(int *)arg;\n    char buf[256];\n    int n;\n\n    while (1) {\n        // 读取串口数据\n        n = read(fd, buf, sizeof(buf));\n        if (n > 0) {\n            printf(\"Received data: %.*s\\n\", n, buf);\n        }\n    }\n\n    return NULL;\n}\n\nint main() {\n    int fd;\n    struct termios options;\n    pthread_t tid;\n\n    // 打开串口设备\n    fd = open(\"/dev/ttyS0\", O_RDWR | O_NOCTTY);\n    if (fd < 0) {\n        perror(\"open\");\n        return -1;\n    }\n\n    // 配置串口参数\n    tcgetattr(fd, &options);\n    options.c_cflag = B9600 | CS8 | CLOCAL | CREAD;\n    options.c_iflag = IGNPAR;\n    options.c_oflag = 0;\n    options.c_lflag = 0;\n    options.c_cc[VTIME] = 0;\n    options.c_cc[VMIN] = 1;\n    tcsetattr(fd, TCSANOW, &options);\n\n    // 创建读取线程\n    if (pthread_create(&tid, NULL, read_thread, &fd) != 0) {\n        perror(\"pthread_create\");\n        return -1;\n    }\n\n    while (1) {\n        // 主线程的其他处理逻辑\n        sleep(1);\n    }\n\n    // 关闭串口设备\n    close(fd);\n\n    return 0;\n}\n</code></pre></details>\n上述代码中，创建了一个读取线程，不断读取串口数据并进行处理。主线程可以在读取线程运行的同时进行其他处理逻辑。","source":"_posts/2023/06/ttymxx-UART.md","raw":"---\ntitle: ttymxx(UART)\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-06-27 19:04:26\npassword:\nsummary:\ntags:\n- linux\ncategories:\n- linux\nkeywords:\ndescription:\n---\n\n#  Q：linux中如何控制串口？\n#  A：模块化设计\n\n## 第一步：设置设备树中关于串口的信息（设备树模块）\n```\n    uart1: serial@02020000 {\n        compatible = \"fsl,imx6ul-uart\",\n                    \"fsl,imx6q-uart\", \"fsl,imx21-uart\";\n        reg = <0x02020000 0x4000>;\n        interrupts = <GIC_SPI 26 IRQ_TYPE_LEVEL_HIGH>;\n        clocks = <&clks IMX6UL_CLK_UART1_IPG>,\n                <&clks IMX6UL_CLK_UART1_SERIAL>;\n        clock-names = \"ipg\", \"per\";\n        status = \"disabled\";\n    };\n    uart3: serial@021ec000 {\n        compatible = \"fsl,imx6ul-uart\",\n                    \"fsl,imx6q-uart\", \"fsl,imx21-uart\";\n        reg = <0x021ec000 0x4000>;\n        interrupts = <GIC_SPI 28 IRQ_TYPE_LEVEL_HIGH>;\n        clocks = <&clks IMX6UL_CLK_UART3_IPG>,\n                <&clks IMX6UL_CLK_UART3_SERIAL>;\n        clock-names = \"ipg\", \"per\";\n        dmas = <&sdma 29 4 0>, <&sdma 30 4 0>;\n        dma-names = \"rx\", \"tx\";\n        status = \"disabled\";\n    };   \n```\n\n## 第二步：驱动获取设备树生成设备（驱动模块）\n\ndrivers/tty/serial/imx.c文件中有如下内容：\n ```\nstatic struct platform_device_id imx_uart_devtype[] = {\n\t{\n\t\t.name = \"imx1-uart\",\n\t\t.driver_data = (kernel_ulong_t) &imx_uart_devdata[IMX1_UART],\n\t}, {\n\t\t.name = \"imx21-uart\",\n\t\t.driver_data = (kernel_ulong_t) &imx_uart_devdata[IMX21_UART],\n\t}, {\n\t\t.name = \"imx6q-uart\",\n\t\t.driver_data = (kernel_ulong_t) &imx_uart_devdata[IMX6Q_UART],\n\t}, {\n\t\t/* sentinel */\n\t}\n};\nMODULE_DEVICE_TABLE(platform, imx_uart_devtype);\n```\n\n```\nstatic struct uart_driver imx_reg = {\n\t.owner          = THIS_MODULE,\n\t.driver_name    = DRIVER_NAME,  //\"IMX-uart\"\n\t.dev_name       = DEV_NAME,     //\"ttymxc\"\n\t.major          = SERIAL_IMX_MAJOR, //207\n\t.minor          = MINOR_START,      //16\n\t.nr             = ARRAY_SIZE(imx_ports),    //8\n\t.cons           = IMX_CONSOLE,      //NULL\n};\n```\n\nplatform平台对比到相同的设备树中的compatible到驱动中的name的时候就执行probe函数：\n\n<details><summary>static int serial_imx_probe（struct platform_device *pdev）</summary>\n<pre><code>\n{\n\tstruct imx_port *sport;\n\tvoid __iomem *base;\n\tint ret = 0;\n\tstruct resource *res;\n\tint txirq, rxirq, rtsirq;\n\tsport = devm_kzalloc(&pdev->dev, sizeof(*sport), GFP_KERNEL);\n\tif (!sport)\n\t\treturn -ENOMEM;\n\tret = serial_imx_probe_dt(sport, pdev);\n\tif (ret > 0)\n\t\tserial_imx_probe_pdata(sport, pdev);\n\telse if (ret < 0)\n\t\treturn ret;\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tbase = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\trxirq = platform_get_irq(pdev, 0);\n\ttxirq = platform_get_irq(pdev, 1);\n\trtsirq = platform_get_irq(pdev, 2);\n\tsport->port.dev = &pdev->dev;\n\tsport->port.mapbase = res->start;\n\tsport->port.membase = base;\n\tsport->port.type = PORT_IMX,\n\tsport->port.iotype = UPIO_MEM;\n\tsport->port.irq = rxirq;\n\tsport->port.fifosize = 32;\n\tsport->port.ops = &imx_pops;\n\tsport->port.rs485_config = imx_rs485_config;\n\tsport->port.rs485.flags =\n\t\tSER_RS485_RTS_ON_SEND | SER_RS485_RX_DURING_TX;\n\tsport->port.flags = UPF_BOOT_AUTOCONF;\n\tinit_timer(&sport->timer);\n\tsport->timer.function = imx_timeout;\n\tsport->timer.data     = (unsigned long)sport;\n\tsport->clk_ipg = devm_clk_get(&pdev->dev, \"ipg\");\n\tif (IS_ERR(sport->clk_ipg)) {\n\t\tret = PTR_ERR(sport->clk_ipg);\n\t\tdev_err(&pdev->dev, \"failed to get ipg clk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tsport->clk_per = devm_clk_get(&pdev->dev, \"per\");\n\tif (IS_ERR(sport->clk_per)) {\n\t\tret = PTR_ERR(sport->clk_per);\n\t\tdev_err(&pdev->dev, \"failed to get per clk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tsport->port.uartclk = clk_get_rate(sport->clk_per);\n\tif (sport->port.uartclk > IMX_MODULE_MAX_CLK_RATE) {\n\t\tret = clk_set_rate(sport->clk_per, IMX_MODULE_MAX_CLK_RATE);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&pdev->dev, \"clk_set_rate() failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\tsport->port.uartclk = clk_get_rate(sport->clk_per);\n\tif (txirq > 0) {\n\t\tret = devm_request_irq(&pdev->dev, rxirq, imx_rxint, 0,\n\t\t\t\t       dev_name(&pdev->dev), sport);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = devm_request_irq(&pdev->dev, txirq, imx_txint, 0,\n\t\t\t\t       dev_name(&pdev->dev), sport);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tret = devm_request_irq(&pdev->dev, rxirq, imx_int, 0,\n\t\t\t\t       dev_name(&pdev->dev), sport);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\timx_ports[sport->port.line] = sport;\n\tplatform_set_drvdata(pdev, sport);\n\treturn uart_add_one_port(&imx_reg, &sport->port);\n}\n</code></pre></details>\n\n`serial_imx_probe`函数是针对i.MX系列平台设备的串口驱动的探测函数。该函数的功能是在系统启动时，当检测到与i.MX系列平台相关的串口设备时，自动初始化和注册相应的串口驱动程序。\n\n具体功能包括：\n\n1. 识别并验证与i.MX平台相关的串口设备资源。通过检查设备树（device tree）或其他平台特定的数据结构，确定该平台上的串口设备的物理地址、中断号、时钟等信息，并进行验证。\n\n2. 为每个串口设备分配和初始化相应的`struct uart_port`结构体。该结构体用于表示一个串口设备的相关参数和状态信息，如设备的基地址、中断号、波特率等。\n\n3. 注册串口驱动程序。调用`uart_add_one_port`函数将初始化好的`struct uart_port`结构体注册到串口子系统中，以便操作系统可以管理和操作该串口设备。\n\n4. 执行其他平台特定的初始化操作。根据i.MX平台的要求，可能需要进行其他特定于该平台的初始化步骤，如设置GPIO引脚、时钟源等。\n\n总而言之，`serial_imx_probe`函数的功能是在系统启动时，自动探测和初始化i.MX平台上的串口设备，并注册相应的串口驱动程序，以便后续操作系统和用户空间程序可以与这些串口设备进行通信和交互。\n\n数据结构的关系：\n内核串口驱动结构uart_driver（imx_reg）在 imx_serial_init 函数中向 Linux 内核注册了 imx_reg。\n当 UART 设备和驱动匹配成功以后 serial_imx_probe 函数就会执行，此函数的重点工作就\n是初始化 uart_port，然后将其添加到对应的 uart_driver 中。imx驱动自己创建了imx_port 结构体里面有一个成员就是uart_port，最后通过uart_add_one_port注册。\n\n所以在dev目录下就会有：![ls /dev](ttymxx-UART/ls-dev.png) 对应到uart1->ttymxc0和uart3->ttymxc2\n设备号：![设备号](ttymxx-UART/ttymxc.png)\n设备：![设备](ttymxx-UART/cat-proc-devices.png)\n\n## 第三步：使用串口（应用模块）\n通过串口发送数据到ttymxc2,执行cat /dev/ttymxc2：![ttymxc2](ttymxx-UART/cat-ttymxc2.png) 应该是和串口发送的十六进制数据是一样的。所以所有的操作都应该是基于此文件或则设备相关的硬件信号。\n\n### 方法一：轮询\n1. 打开串口\n```\nfd = open(port, O_RDWR | O_NOCTTY | O_NDELAY);\nif (fd == -1) \n{\n    perror(\"open_port: Unable to open serial port\");\n    return -1;\n}\n```\n2. 配置串口\n```\ntcgetattr(fd, &options);\ncfsetispeed(&options, B115200);\ncfsetospeed(&options, B115200);\noptions.c_cflag |= (CLOCAL | CREAD);\noptions.c_cflag &= ~PARENB;\noptions.c_cflag &= ~CSTOPB;\noptions.c_cflag &= ~CSIZE;\noptions.c_cflag |= CS8;\noptions.c_cflag &= ~CRTSCTS;\ntcsetattr(fd, TCSANOW, &options);\n```\n其中，tcgetattr 和 tcsetattr 函数用于获取和设置串口参数。cfsetispeed 和 cfsetospeed 函数用于设置串口的输入和输出波特率，这里设置为 115200。options.c_cflag 表示控制标志位，用于配置串口控制参数，具体含义如下：\n\n    CLOCAL：忽略调制解调器的状态线，只允许本地使用串口。\n\n    CREAD：允许从串口读取数据。\n\n    PARENB：启用奇偶校验。&= ~PARENB则为禁用校验。\n\n    CSTOPB：使用两个停止位而不是一个。&= ~CSTOPB停止位为1。\n\n    CSIZE：表示字符长度的位掩码。在这里设置为 0，表示使用默认的 8 位数据位。\n\n    CS8：表示使用 8 位数据位。\n\n    CRTSCTS：启用硬件流控制，即使用 RTS 和 CTS 状态线进行流控制。\n\n在示例程序中，我们将 CLOCAL 和 CREAD 标志位置为 1，表示允许本地使用串口，并允许从串口读取数据。我们将 PARENB、CSTOPB 和 CRTSCTS 标志位都设置为 0，表示不启用奇偶校验、使用一个停止位和禁用硬件流控制。最后，我们将 CSIZE 标志位设置为 0，然后将 CS8 标志位设置为 1，以表示使用 8 位数据位。\n3. 读写\n```\nread(fd, buf, sizeof(buf)); // 返回接收个数\nwrite(fd, buf, strlen(buf)); // 返回发送长度,负值表示发送失败\n```\n4. 关闭串口\n```\nclose(fd);\n```\n完整示例\n<details><summary>轮询code</summary>\n<pre><code>\n    int main()\n    {\n        int fd;\n        char buf[255];\n        int n;\n        fd = open_port(\"/dev/ttyUSB0\");\n        if (fd == -1) {\n\n            printf(\"open err\\n\");\n            exit(1);\n        }\n        while (1)\n        {\n            n = read(fd, buf, sizeof(buf));\n            if (n > 0) {\n                printf(\"Received: %.*s\\n\", n, buf);\n            }\n            strcpy(buf, \"Hello, world!\\n\");\n            n = write(fd, buf, strlen(buf));\n            if (n < 0) {\n                perror(\"write failed\\n\");\n            }\n            usleep(10 * 1000);\n        }\n        close(fd);\n        printf(\"close uart\\n\");\n        return 0;\n    }\n\n    int open_port(const char *port)\n    {\n        int fd;\n        struct termios options;\n        fd = open(port, O_RDWR | O_NOCTTY | O_NDELAY);\n        if (fd == -1) {\n            perror(\"open_port: Unable to open serial port\");\n            return -1;\n        }\n        tcgetattr(fd, &options);\n        cfsetispeed(&options, B115200);\n        cfsetospeed(&options, B115200);\n        options.c_cflag |= (CLOCAL | CREAD);\n        options.c_cflag &= ~PARENB;\n        options.c_cflag &= ~CSTOPB;\n        options.c_cflag &= ~CSIZE;\n        options.c_cflag |= CS8;\n        options.c_cflag &= ~CRTSCTS;\n        tcsetattr(fd, TCSANOW, &options);\n        return fd;\n    }\n</code></pre></details>\n\n### 方法二：中断读取示例\n上面给出的串口示例是使用轮询的方式读取串口数据，这种方式在某些场景下可能会占用大量 CPU 资源。实际上，对于 Linux 系统来说，还可以使用中断方式接收串口数据，这样可以大大减少 CPU 的占用率，并且能够更快地响应串口数据。\n\n要使用中断方式接收串口数据，可以使用 select 函数来监听串口文件描述符的可读事件。当串口数据可读时，select 函数将返回，并且可以调用 read 函数来读取串口数据。这种方式可以避免轮询操作，只有在串口数据可读时才会执行读取操作，因此能够减少 CPU 的占用率。\n\n以下是一个简单的使用中断方式接收串口数据的示例程序：\n<details><summary>中断读取code</summary>\n<pre><code>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <termios.h>\n#include <sys/select.h>\n\nint main() {\n    int fd;\n    struct termios options;\n    fd_set rfds;\n\n    // 打开串口设备\n    fd = open(\"/dev/ttyUSB0\", O_RDWR | O_NOCTTY);\n    if (fd < 0) {\n        perror(\"open\");\n        return -1;\n    }\n\n    // 配置串口参数\n    tcgetattr(fd, &options);\n    options.c_cflag = B9600 | CS8 | CLOCAL | CREAD;\n    options.c_iflag = IGNPAR;\n    options.c_oflag = 0;\n    options.c_lflag = 0;\n    options.c_cc[VTIME] = 0;\n    options.c_cc[VMIN] = 1;\n    tcsetattr(fd, TCSANOW, &options);\n\n    while (1) {\n        // 使用 select 函数监听串口文件描述符的可读事件\n        FD_ZERO(&rfds);\n        FD_SET(fd, &rfds);\n        select(fd + 1, &rfds, NULL, NULL, NULL);\n\n        // 读取串口数据\n        char buf[256];\n        int n = read(fd, buf, sizeof(buf));\n        if (n > 0) {\n            printf(\"Received data: %.*s\\n\", n, buf);\n        }\n    }\n\n    // 关闭串口设备\n    close(fd);\n\n    return 0;\n}\n</code></pre></details>\n需要注意的是，在使用中断方式接收串口数据时，需要对串口文件描述符设置为非阻塞模式，以便在 select 函数返回时立即读取串口数据。可以使用 fcntl 函数来设置文件描述符的标志位，如下所示：\n```\n// 设置串口文件描述符为非阻塞模式\nint flags = fcntl(fd, F_GETFL, 0);\nfcntl(fd, F_SETFL, flags | O_NONBLOCK);\n```\n\n### 方法三：信号的方式接收数据\n<details><summary>信号的方式接收code</summary>\n<pre><code>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <termios.h>\n#include <signal.h>\n\nint fd;\n\nvoid sigio_handler(int sig) {\n    char buf[256];\n    int n = read(fd, buf, sizeof(buf));\n    if (n > 0) {\n        printf(\"Received data: %.*s\\n\", n, buf);\n    }\n}\n\nint main() {\n    struct termios options;\n    struct sigaction sa;\n\n    // 打开串口设备\n    fd = open(\"/dev/ttyS0\", O_RDWR | O_NOCTTY);\n    if (fd < 0) {\n        perror(\"open\");\n        return -1;\n    }\n\n    // 配置串口参数\n    tcgetattr(fd, &options);\n    options.c_cflag = B9600 | CS8 | CLOCAL | CREAD;\n    options.c_iflag = IGNPAR;\n    options.c_oflag = 0;\n    options.c_lflag = 0;\n    options.c_cc[VTIME] = 0;\n    options.c_cc[VMIN] = 1;\n    tcsetattr(fd, TCSANOW, &options);\n\n    // 设置串口文件描述符为异步通知模式\n    /* 将串口文件描述符设置为当前进程的拥有者，从而接收该文件描述符相关的信号。*/\n    fcntl(fd, F_SETOWN, getpid()); \n    int flags = fcntl(fd, F_GETFL, 0); // 先获取当前配置, 下面只更改O_ASYNC标志\n    /* 将串口文件描述符设置为非阻塞模式，从而允许该文件描述符异步地接收数据和信号。*/\n    fcntl(fd, F_SETFL, flags | O_ASYNC);\n\n    // 设置 SIGIO 信号的处理函数\n    sa.sa_handler = sigio_handler;\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = 0;\n    /* 设置了 SIGIO 信号的处理函数为 sigio_handler，从而在该信号被触发时读取串口数据并进行处理。*/\n    sigaction(SIGIO, &sa, NULL);\n\n    while (1) {\n        // 等待 SIGIO 信号\n        sleep(1);\n    }\n\n    // 关闭串口设备\n    close(fd);\n\n    return 0;\n}\n</code></pre></details>\n上述代码中，使用了 fcntl 函数将串口文件描述符设置为异步通知模式，并使用 SIGIO 信号来通知程序串口数据已经可读。当程序接收到 SIGIO 信号时，会调用 sigio_handler 函数来读取并处理串口数据。\n\n在这段代码中，sigemptyset（&sa.sa_mask）;的作用是将信号处理函数在执行时要屏蔽的信号集合清空，即将其设置为空集。\n\n每个进程都有一个信号屏蔽字，它表示了当前被阻塞的信号集合。当一个信号被阻塞时，它将被加入到信号屏蔽字中，而当信号被解除阻塞时，它将被从信号屏蔽字中移除。如果信号处理函数在执行时需要屏蔽其他的信号，则可以使用sigaddset等函数将需要屏蔽的信号添加到信号屏蔽字中。但是，在本例中，我们需要处理的信号是SIGIO，它通常不需要被屏蔽，因此我们使用sigemptyset函数将信号屏蔽字清空，以确保在处理SIGIO信号时不会屏蔽任何其他信号。\n\n在Linux系统中，使用sigaction函数注册信号处理函数时，可以设置一些标志来指定信号处理的行为。例如，可以使用SA_RESTART标志来指定当系统调用被信号中断时自动重启该系统调用。在本例中，由于我们并不需要设置任何标志，因此将sa.sa_flags字段设置为0即可。这表示信号处理函数不需要任何特殊的行为，只需要按照默认的方式处理信号即可。\n\n### 方法四：使用线程接收串口数据\n<details><summary>使用线程接收code</summary>\n<pre><code>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <termios.h>\n#include <pthread.h>\n\nvoid *read_thread(void *arg) {\n    int fd = *(int *)arg;\n    char buf[256];\n    int n;\n\n    while (1) {\n        // 读取串口数据\n        n = read(fd, buf, sizeof(buf));\n        if (n > 0) {\n            printf(\"Received data: %.*s\\n\", n, buf);\n        }\n    }\n\n    return NULL;\n}\n\nint main() {\n    int fd;\n    struct termios options;\n    pthread_t tid;\n\n    // 打开串口设备\n    fd = open(\"/dev/ttyS0\", O_RDWR | O_NOCTTY);\n    if (fd < 0) {\n        perror(\"open\");\n        return -1;\n    }\n\n    // 配置串口参数\n    tcgetattr(fd, &options);\n    options.c_cflag = B9600 | CS8 | CLOCAL | CREAD;\n    options.c_iflag = IGNPAR;\n    options.c_oflag = 0;\n    options.c_lflag = 0;\n    options.c_cc[VTIME] = 0;\n    options.c_cc[VMIN] = 1;\n    tcsetattr(fd, TCSANOW, &options);\n\n    // 创建读取线程\n    if (pthread_create(&tid, NULL, read_thread, &fd) != 0) {\n        perror(\"pthread_create\");\n        return -1;\n    }\n\n    while (1) {\n        // 主线程的其他处理逻辑\n        sleep(1);\n    }\n\n    // 关闭串口设备\n    close(fd);\n\n    return 0;\n}\n</code></pre></details>\n上述代码中，创建了一个读取线程，不断读取串口数据并进行处理。主线程可以在读取线程运行的同时进行其他处理逻辑。","slug":"ttymxx-UART","published":1,"updated":"2024-01-05T08:12:19.767Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clru1g21j001ns4fumvse5sfz","content":"<h1 id=\"Q：linux中如何控制串口？\"><a href=\"#Q：linux中如何控制串口？\" class=\"headerlink\" title=\"Q：linux中如何控制串口？\"></a>Q：linux中如何控制串口？</h1><h1 id=\"A：模块化设计\"><a href=\"#A：模块化设计\" class=\"headerlink\" title=\"A：模块化设计\"></a>A：模块化设计</h1><h2 id=\"第一步：设置设备树中关于串口的信息（设备树模块）\"><a href=\"#第一步：设置设备树中关于串口的信息（设备树模块）\" class=\"headerlink\" title=\"第一步：设置设备树中关于串口的信息（设备树模块）\"></a>第一步：设置设备树中关于串口的信息（设备树模块）</h2><pre><code>    uart1: serial@02020000 {\n        compatible = &quot;fsl,imx6ul-uart&quot;,\n                    &quot;fsl,imx6q-uart&quot;, &quot;fsl,imx21-uart&quot;;\n        reg = &lt;0x02020000 0x4000&gt;;\n        interrupts = &lt;GIC_SPI 26 IRQ_TYPE_LEVEL_HIGH&gt;;\n        clocks = &lt;&amp;clks IMX6UL_CLK_UART1_IPG&gt;,\n                &lt;&amp;clks IMX6UL_CLK_UART1_SERIAL&gt;;\n        clock-names = &quot;ipg&quot;, &quot;per&quot;;\n        status = &quot;disabled&quot;;\n    };\n    uart3: serial@021ec000 {\n        compatible = &quot;fsl,imx6ul-uart&quot;,\n                    &quot;fsl,imx6q-uart&quot;, &quot;fsl,imx21-uart&quot;;\n        reg = &lt;0x021ec000 0x4000&gt;;\n        interrupts = &lt;GIC_SPI 28 IRQ_TYPE_LEVEL_HIGH&gt;;\n        clocks = &lt;&amp;clks IMX6UL_CLK_UART3_IPG&gt;,\n                &lt;&amp;clks IMX6UL_CLK_UART3_SERIAL&gt;;\n        clock-names = &quot;ipg&quot;, &quot;per&quot;;\n        dmas = &lt;&amp;sdma 29 4 0&gt;, &lt;&amp;sdma 30 4 0&gt;;\n        dma-names = &quot;rx&quot;, &quot;tx&quot;;\n        status = &quot;disabled&quot;;\n    };   </code></pre><h2 id=\"第二步：驱动获取设备树生成设备（驱动模块）\"><a href=\"#第二步：驱动获取设备树生成设备（驱动模块）\" class=\"headerlink\" title=\"第二步：驱动获取设备树生成设备（驱动模块）\"></a>第二步：驱动获取设备树生成设备（驱动模块）</h2><p>drivers/tty/serial/imx.c文件中有如下内容：</p>\n<pre><code>static struct platform_device_id imx_uart_devtype[] = {\n    {\n        .name = &quot;imx1-uart&quot;,\n        .driver_data = (kernel_ulong_t) &amp;imx_uart_devdata[IMX1_UART],\n    }, {\n        .name = &quot;imx21-uart&quot;,\n        .driver_data = (kernel_ulong_t) &amp;imx_uart_devdata[IMX21_UART],\n    }, {\n        .name = &quot;imx6q-uart&quot;,\n        .driver_data = (kernel_ulong_t) &amp;imx_uart_devdata[IMX6Q_UART],\n    }, {\n        /* sentinel */\n    }\n};\nMODULE_DEVICE_TABLE(platform, imx_uart_devtype);</code></pre><pre><code>static struct uart_driver imx_reg = {\n    .owner          = THIS_MODULE,\n    .driver_name    = DRIVER_NAME,  //&quot;IMX-uart&quot;\n    .dev_name       = DEV_NAME,     //&quot;ttymxc&quot;\n    .major          = SERIAL_IMX_MAJOR, //207\n    .minor          = MINOR_START,      //16\n    .nr             = ARRAY_SIZE(imx_ports),    //8\n    .cons           = IMX_CONSOLE,      //NULL\n};</code></pre><p>platform平台对比到相同的设备树中的compatible到驱动中的name的时候就执行probe函数：</p>\n<details><summary>static int serial_imx_probe（struct platform_device *pdev）</summary>\n<pre><code>\n{\n    struct imx_port *sport;\n    void __iomem *base;\n    int ret = 0;\n    struct resource *res;\n    int txirq, rxirq, rtsirq;\n    sport = devm_kzalloc(&pdev->dev, sizeof(*sport), GFP_KERNEL);\n    if (!sport)\n        return -ENOMEM;\n    ret = serial_imx_probe_dt(sport, pdev);\n    if (ret > 0)\n        serial_imx_probe_pdata(sport, pdev);\n    else if (ret < 0)\n        return ret;\n    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n    base = devm_ioremap_resource(&pdev->dev, res);\n    if (IS_ERR(base))\n        return PTR_ERR(base);\n    rxirq = platform_get_irq(pdev, 0);\n    txirq = platform_get_irq(pdev, 1);\n    rtsirq = platform_get_irq(pdev, 2);\n    sport->port.dev = &pdev->dev;\n    sport->port.mapbase = res->start;\n    sport->port.membase = base;\n    sport->port.type = PORT_IMX,\n    sport->port.iotype = UPIO_MEM;\n    sport->port.irq = rxirq;\n    sport->port.fifosize = 32;\n    sport->port.ops = &imx_pops;\n    sport->port.rs485_config = imx_rs485_config;\n    sport->port.rs485.flags =\n        SER_RS485_RTS_ON_SEND | SER_RS485_RX_DURING_TX;\n    sport->port.flags = UPF_BOOT_AUTOCONF;\n    init_timer(&sport->timer);\n    sport->timer.function = imx_timeout;\n    sport->timer.data     = (unsigned long)sport;\n    sport->clk_ipg = devm_clk_get(&pdev->dev, \"ipg\");\n    if (IS_ERR(sport->clk_ipg)) {\n        ret = PTR_ERR(sport->clk_ipg);\n        dev_err(&pdev->dev, \"failed to get ipg clk: %d\\n\", ret);\n        return ret;\n    }\n    sport->clk_per = devm_clk_get(&pdev->dev, \"per\");\n    if (IS_ERR(sport->clk_per)) {\n        ret = PTR_ERR(sport->clk_per);\n        dev_err(&pdev->dev, \"failed to get per clk: %d\\n\", ret);\n        return ret;\n    }\n    sport->port.uartclk = clk_get_rate(sport->clk_per);\n    if (sport->port.uartclk > IMX_MODULE_MAX_CLK_RATE) {\n        ret = clk_set_rate(sport->clk_per, IMX_MODULE_MAX_CLK_RATE);\n        if (ret < 0) {\n            dev_err(&pdev->dev, \"clk_set_rate() failed\\n\");\n            return ret;\n        }\n    }\n    sport->port.uartclk = clk_get_rate(sport->clk_per);\n    if (txirq > 0) {\n        ret = devm_request_irq(&pdev->dev, rxirq, imx_rxint, 0,\n                       dev_name(&pdev->dev), sport);\n        if (ret)\n            return ret;\n\n<pre><code>    ret = devm_request_irq(&amp;pdev-&gt;dev, txirq, imx_txint, 0,\n                   dev_name(&amp;pdev-&gt;dev), sport);\n    if (ret)\n        return ret;\n} else {\n    ret = devm_request_irq(&amp;pdev-&gt;dev, rxirq, imx_int, 0,\n                   dev_name(&amp;pdev-&gt;dev), sport);\n    if (ret)\n        return ret;\n}\nimx_ports[sport-&gt;port.line] = sport;\nplatform_set_drvdata(pdev, sport);\nreturn uart_add_one_port(&amp;imx_reg, &amp;sport-&gt;port);</code></pre><p>}<br></p></code></pre></details><p></p>\n<p><code>serial_imx_probe</code>函数是针对i.MX系列平台设备的串口驱动的探测函数。该函数的功能是在系统启动时，当检测到与i.MX系列平台相关的串口设备时，自动初始化和注册相应的串口驱动程序。</p>\n<p>具体功能包括：</p>\n<ol>\n<li><p>识别并验证与i.MX平台相关的串口设备资源。通过检查设备树（device tree）或其他平台特定的数据结构，确定该平台上的串口设备的物理地址、中断号、时钟等信息，并进行验证。</p>\n</li>\n<li><p>为每个串口设备分配和初始化相应的<code>struct uart_port</code>结构体。该结构体用于表示一个串口设备的相关参数和状态信息，如设备的基地址、中断号、波特率等。</p>\n</li>\n<li><p>注册串口驱动程序。调用<code>uart_add_one_port</code>函数将初始化好的<code>struct uart_port</code>结构体注册到串口子系统中，以便操作系统可以管理和操作该串口设备。</p>\n</li>\n<li><p>执行其他平台特定的初始化操作。根据i.MX平台的要求，可能需要进行其他特定于该平台的初始化步骤，如设置GPIO引脚、时钟源等。</p>\n</li>\n</ol>\n<p>总而言之，<code>serial_imx_probe</code>函数的功能是在系统启动时，自动探测和初始化i.MX平台上的串口设备，并注册相应的串口驱动程序，以便后续操作系统和用户空间程序可以与这些串口设备进行通信和交互。</p>\n<p>数据结构的关系：<br>内核串口驱动结构uart_driver（imx_reg）在 imx_serial_init 函数中向 Linux 内核注册了 imx_reg。<br>当 UART 设备和驱动匹配成功以后 serial_imx_probe 函数就会执行，此函数的重点工作就<br>是初始化 uart_port，然后将其添加到对应的 uart_driver 中。imx驱动自己创建了imx_port 结构体里面有一个成员就是uart_port，最后通过uart_add_one_port注册。</p>\n<p>所以在dev目录下就会有：<img src=\"/2023/06/ttymxx-uart/ls-dev.png\" alt=\"ls /dev\"> 对应到uart1-&gt;ttymxc0和uart3-&gt;ttymxc2<br>设备号：<img src=\"/2023/06/ttymxx-uart/ttymxc.png\" alt=\"设备号\"><br>设备：<img src=\"/2023/06/ttymxx-uart/cat-proc-devices.png\" alt=\"设备\"></p>\n<h2 id=\"第三步：使用串口（应用模块）\"><a href=\"#第三步：使用串口（应用模块）\" class=\"headerlink\" title=\"第三步：使用串口（应用模块）\"></a>第三步：使用串口（应用模块）</h2><p>通过串口发送数据到ttymxc2,执行cat /dev/ttymxc2：<img src=\"/2023/06/ttymxx-uart/cat-ttymxc2.png\" alt=\"ttymxc2\"> 应该是和串口发送的十六进制数据是一样的。所以所有的操作都应该是基于此文件或则设备相关的硬件信号。</p>\n<h3 id=\"方法一：轮询\"><a href=\"#方法一：轮询\" class=\"headerlink\" title=\"方法一：轮询\"></a>方法一：轮询</h3><ol>\n<li><p>打开串口</p>\n<pre><code>fd = open(port, O_RDWR | O_NOCTTY | O_NDELAY);\nif (fd == -1) \n{\n perror(&quot;open_port: Unable to open serial port&quot;);\n return -1;\n}</code></pre></li>\n<li><p>配置串口</p>\n<pre><code>tcgetattr(fd, &amp;options);\ncfsetispeed(&amp;options, B115200);\ncfsetospeed(&amp;options, B115200);\noptions.c_cflag |= (CLOCAL | CREAD);\noptions.c_cflag &amp;= ~PARENB;\noptions.c_cflag &amp;= ~CSTOPB;\noptions.c_cflag &amp;= ~CSIZE;\noptions.c_cflag |= CS8;\noptions.c_cflag &amp;= ~CRTSCTS;\ntcsetattr(fd, TCSANOW, &amp;options);</code></pre><p>其中，tcgetattr 和 tcsetattr 函数用于获取和设置串口参数。cfsetispeed 和 cfsetospeed 函数用于设置串口的输入和输出波特率，这里设置为 115200。options.c_cflag 表示控制标志位，用于配置串口控制参数，具体含义如下：</p>\n<p> CLOCAL：忽略调制解调器的状态线，只允许本地使用串口。</p>\n<p> CREAD：允许从串口读取数据。</p>\n<p> PARENB：启用奇偶校验。&amp;= ~PARENB则为禁用校验。</p>\n<p> CSTOPB：使用两个停止位而不是一个。&amp;= ~CSTOPB停止位为1。</p>\n<p> CSIZE：表示字符长度的位掩码。在这里设置为 0，表示使用默认的 8 位数据位。</p>\n<p> CS8：表示使用 8 位数据位。</p>\n<p> CRTSCTS：启用硬件流控制，即使用 RTS 和 CTS 状态线进行流控制。</p>\n</li>\n</ol>\n<p>在示例程序中，我们将 CLOCAL 和 CREAD 标志位置为 1，表示允许本地使用串口，并允许从串口读取数据。我们将 PARENB、CSTOPB 和 CRTSCTS 标志位都设置为 0，表示不启用奇偶校验、使用一个停止位和禁用硬件流控制。最后，我们将 CSIZE 标志位设置为 0，然后将 CS8 标志位设置为 1，以表示使用 8 位数据位。</p>\n<ol start=\"3\">\n<li><p>读写</p>\n<pre><code>read(fd, buf, sizeof(buf)); // 返回接收个数\nwrite(fd, buf, strlen(buf)); // 返回发送长度,负值表示发送失败</code></pre></li>\n<li><p>关闭串口</p>\n<pre><code>close(fd);</code></pre><p>完整示例</p>\n<details><summary>轮询code</summary>\n<pre><code>\n int main()\n {\n     int fd;\n     char buf[255];\n     int n;\n     fd = open_port(\"/dev/ttyUSB0\");\n     if (fd == -1) {\n\n<pre><code>     printf(&quot;open err\\n&quot;);\n     exit(1);\n }\n while (1)\n {\n     n = read(fd, buf, sizeof(buf));\n     if (n &gt; 0) {\n         printf(&quot;Received: %.*s\\n&quot;, n, buf);\n     }\n     strcpy(buf, &quot;Hello, world!\\n&quot;);\n     n = write(fd, buf, strlen(buf));\n     if (n &lt; 0) {\n         perror(&quot;write failed\\n&quot;);\n     }\n     usleep(10 * 1000);\n }\n close(fd);\n printf(&quot;close uart\\n&quot;);\n return 0;</code></pre><p> }</p>\n<p> int open_port(const char *port)<br> {</p>\n<pre><code> int fd;\n struct termios options;\n fd = open(port, O_RDWR | O_NOCTTY | O_NDELAY);\n if (fd == -1) {\n     perror(&quot;open_port: Unable to open serial port&quot;);\n     return -1;\n }\n tcgetattr(fd, &amp;options);\n cfsetispeed(&amp;options, B115200);\n cfsetospeed(&amp;options, B115200);\n options.c_cflag |= (CLOCAL | CREAD);\n options.c_cflag &amp;= ~PARENB;\n options.c_cflag &amp;= ~CSTOPB;\n options.c_cflag &amp;= ~CSIZE;\n options.c_cflag |= CS8;\n options.c_cflag &amp;= ~CRTSCTS;\n tcsetattr(fd, TCSANOW, &amp;options);\n return fd;</code></pre><p> }<br></p></code></pre></details><p></p>\n</li>\n</ol>\n<h3 id=\"方法二：中断读取示例\"><a href=\"#方法二：中断读取示例\" class=\"headerlink\" title=\"方法二：中断读取示例\"></a>方法二：中断读取示例</h3><p>上面给出的串口示例是使用轮询的方式读取串口数据，这种方式在某些场景下可能会占用大量 CPU 资源。实际上，对于 Linux 系统来说，还可以使用中断方式接收串口数据，这样可以大大减少 CPU 的占用率，并且能够更快地响应串口数据。</p>\n<p>要使用中断方式接收串口数据，可以使用 select 函数来监听串口文件描述符的可读事件。当串口数据可读时，select 函数将返回，并且可以调用 read 函数来读取串口数据。这种方式可以避免轮询操作，只有在串口数据可读时才会执行读取操作，因此能够减少 CPU 的占用率。</p>\n<p>以下是一个简单的使用中断方式接收串口数据的示例程序：</p>\n<details><summary>中断读取code</summary>\n<pre><code>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <termios.h>\n#include <sys select.h>\n\n<p>int main() {<br>    int fd;<br>    struct termios options;<br>    fd_set rfds;</p>\n<pre><code>// 打开串口设备\nfd = open(&quot;/dev/ttyUSB0&quot;, O_RDWR | O_NOCTTY);\nif (fd &lt; 0) {\n    perror(&quot;open&quot;);\n    return -1;\n}\n\n// 配置串口参数\ntcgetattr(fd, &amp;options);\noptions.c_cflag = B9600 | CS8 | CLOCAL | CREAD;\noptions.c_iflag = IGNPAR;\noptions.c_oflag = 0;\noptions.c_lflag = 0;\noptions.c_cc[VTIME] = 0;\noptions.c_cc[VMIN] = 1;\ntcsetattr(fd, TCSANOW, &amp;options);\n\nwhile (1) {\n    // 使用 select 函数监听串口文件描述符的可读事件\n    FD_ZERO(&amp;rfds);\n    FD_SET(fd, &amp;rfds);\n    select(fd + 1, &amp;rfds, NULL, NULL, NULL);\n\n    // 读取串口数据\n    char buf[256];\n    int n = read(fd, buf, sizeof(buf));\n    if (n &gt; 0) {\n        printf(&quot;Received data: %.*s\\n&quot;, n, buf);\n    }\n}\n\n// 关闭串口设备\nclose(fd);\n\nreturn 0;</code></pre><p>}<br></p></sys></termios.h></fcntl.h></unistd.h></stdlib.h></stdio.h></code></pre></details><br>需要注意的是，在使用中断方式接收串口数据时，需要对串口文件描述符设置为非阻塞模式，以便在 select 函数返回时立即读取串口数据。可以使用 fcntl 函数来设置文件描述符的标志位，如下所示：<p></p>\n<pre><code>// 设置串口文件描述符为非阻塞模式\nint flags = fcntl(fd, F_GETFL, 0);\nfcntl(fd, F_SETFL, flags | O_NONBLOCK);</code></pre><h3 id=\"方法三：信号的方式接收数据\"><a href=\"#方法三：信号的方式接收数据\" class=\"headerlink\" title=\"方法三：信号的方式接收数据\"></a>方法三：信号的方式接收数据</h3><details><summary>信号的方式接收code</summary>\n<pre><code>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <termios.h>\n#include <signal.h>\n\n<p>int fd;</p>\n<p>void sigio_handler(int sig) {<br>    char buf[256];<br>    int n = read(fd, buf, sizeof(buf));<br>    if (n &gt; 0) {<br>        printf(“Received data: %.*s\\n”, n, buf);<br>    }<br>}</p>\n<p>int main() {<br>    struct termios options;<br>    struct sigaction sa;</p>\n<pre><code>// 打开串口设备\nfd = open(&quot;/dev/ttyS0&quot;, O_RDWR | O_NOCTTY);\nif (fd &lt; 0) {\n    perror(&quot;open&quot;);\n    return -1;\n}\n\n// 配置串口参数\ntcgetattr(fd, &amp;options);\noptions.c_cflag = B9600 | CS8 | CLOCAL | CREAD;\noptions.c_iflag = IGNPAR;\noptions.c_oflag = 0;\noptions.c_lflag = 0;\noptions.c_cc[VTIME] = 0;\noptions.c_cc[VMIN] = 1;\ntcsetattr(fd, TCSANOW, &amp;options);\n\n// 设置串口文件描述符为异步通知模式\n/* 将串口文件描述符设置为当前进程的拥有者，从而接收该文件描述符相关的信号。*/\nfcntl(fd, F_SETOWN, getpid()); \nint flags = fcntl(fd, F_GETFL, 0); // 先获取当前配置, 下面只更改O_ASYNC标志\n/* 将串口文件描述符设置为非阻塞模式，从而允许该文件描述符异步地接收数据和信号。*/\nfcntl(fd, F_SETFL, flags | O_ASYNC);\n\n// 设置 SIGIO 信号的处理函数\nsa.sa_handler = sigio_handler;\nsigemptyset(&amp;sa.sa_mask);\nsa.sa_flags = 0;\n/* 设置了 SIGIO 信号的处理函数为 sigio_handler，从而在该信号被触发时读取串口数据并进行处理。*/\nsigaction(SIGIO, &amp;sa, NULL);\n\nwhile (1) {\n    // 等待 SIGIO 信号\n    sleep(1);\n}\n\n// 关闭串口设备\nclose(fd);\n\nreturn 0;</code></pre><p>}<br></p></signal.h></termios.h></fcntl.h></unistd.h></stdlib.h></stdio.h></code></pre></details><br>上述代码中，使用了 fcntl 函数将串口文件描述符设置为异步通知模式，并使用 SIGIO 信号来通知程序串口数据已经可读。当程序接收到 SIGIO 信号时，会调用 sigio_handler 函数来读取并处理串口数据。<p></p>\n<p>在这段代码中，sigemptyset（&amp;sa.sa_mask）;的作用是将信号处理函数在执行时要屏蔽的信号集合清空，即将其设置为空集。</p>\n<p>每个进程都有一个信号屏蔽字，它表示了当前被阻塞的信号集合。当一个信号被阻塞时，它将被加入到信号屏蔽字中，而当信号被解除阻塞时，它将被从信号屏蔽字中移除。如果信号处理函数在执行时需要屏蔽其他的信号，则可以使用sigaddset等函数将需要屏蔽的信号添加到信号屏蔽字中。但是，在本例中，我们需要处理的信号是SIGIO，它通常不需要被屏蔽，因此我们使用sigemptyset函数将信号屏蔽字清空，以确保在处理SIGIO信号时不会屏蔽任何其他信号。</p>\n<p>在Linux系统中，使用sigaction函数注册信号处理函数时，可以设置一些标志来指定信号处理的行为。例如，可以使用SA_RESTART标志来指定当系统调用被信号中断时自动重启该系统调用。在本例中，由于我们并不需要设置任何标志，因此将sa.sa_flags字段设置为0即可。这表示信号处理函数不需要任何特殊的行为，只需要按照默认的方式处理信号即可。</p>\n<h3 id=\"方法四：使用线程接收串口数据\"><a href=\"#方法四：使用线程接收串口数据\" class=\"headerlink\" title=\"方法四：使用线程接收串口数据\"></a>方法四：使用线程接收串口数据</h3><details><summary>使用线程接收code</summary>\n<pre><code>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <termios.h>\n#include <pthread.h>\n\n<p>void *read_thread(void *arg) {<br>    int fd = *(int *)arg;<br>    char buf[256];<br>    int n;</p>\n<pre><code>while (1) {\n    // 读取串口数据\n    n = read(fd, buf, sizeof(buf));\n    if (n &gt; 0) {\n        printf(&quot;Received data: %.*s\\n&quot;, n, buf);\n    }\n}\n\nreturn NULL;</code></pre><p>}</p>\n<p>int main() {<br>    int fd;<br>    struct termios options;<br>    pthread_t tid;</p>\n<pre><code>// 打开串口设备\nfd = open(&quot;/dev/ttyS0&quot;, O_RDWR | O_NOCTTY);\nif (fd &lt; 0) {\n    perror(&quot;open&quot;);\n    return -1;\n}\n\n// 配置串口参数\ntcgetattr(fd, &amp;options);\noptions.c_cflag = B9600 | CS8 | CLOCAL | CREAD;\noptions.c_iflag = IGNPAR;\noptions.c_oflag = 0;\noptions.c_lflag = 0;\noptions.c_cc[VTIME] = 0;\noptions.c_cc[VMIN] = 1;\ntcsetattr(fd, TCSANOW, &amp;options);\n\n// 创建读取线程\nif (pthread_create(&amp;tid, NULL, read_thread, &amp;fd) != 0) {\n    perror(&quot;pthread_create&quot;);\n    return -1;\n}\n\nwhile (1) {\n    // 主线程的其他处理逻辑\n    sleep(1);\n}\n\n// 关闭串口设备\nclose(fd);\n\nreturn 0;</code></pre><p>}<br></p></pthread.h></termios.h></fcntl.h></unistd.h></stdlib.h></stdio.h></code></pre></details><br>上述代码中，创建了一个读取线程，不断读取串口数据并进行处理。主线程可以在读取线程运行的同时进行其他处理逻辑。<p></p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<h1 id=\"Q：linux中如何控制串口？\"><a href=\"#Q：linux中如何控制串口？\" class=\"headerlink\" title=\"Q：linux中如何控制串口？\"></a>Q：linux中如何控制串口？</h1><h1 id=\"A：模块化设计\"><a href=\"#A：模块化设计\" class=\"headerlink\" title=\"A：模块化设计\"></a>A：模块化设计</h1><h2 id=\"第一步：设置设备树中关于串口的信息（设备树模块）\"><a href=\"#第一步：设置设备树中关于串口的信息（设备树模块）\" class=\"headerlink\" title=\"第一步：设置设备树中关于串口的信息（设备树模块）\"></a>第一步：设置设备树中关于串口的信息（设备树模块）</h2><pre><code>    uart1: serial@02020000 {\n        compatible = &quot;fsl,imx6ul-uart&quot;,\n                    &quot;fsl,imx6q-uart&quot;, &quot;fsl,imx21-uart&quot;;\n        reg = &lt;0x02020000 0x4000&gt;;\n        interrupts = &lt;GIC_SPI 26 IRQ_TYPE_LEVEL_HIGH&gt;;\n        clocks = &lt;&amp;clks IMX6UL_CLK_UART1_IPG&gt;,\n                &lt;&amp;clks IMX6UL_CLK_UART1_SERIAL&gt;;\n        clock-names = &quot;ipg&quot;, &quot;per&quot;;\n        status = &quot;disabled&quot;;\n    };\n    uart3: serial@021ec000 {\n        compatible = &quot;fsl,imx6ul-uart&quot;,\n                    &quot;fsl,imx6q-uart&quot;, &quot;fsl,imx21-uart&quot;;\n        reg = &lt;0x021ec000 0x4000&gt;;\n        interrupts = &lt;GIC_SPI 28 IRQ_TYPE_LEVEL_HIGH&gt;;\n        clocks = &lt;&amp;clks IMX6UL_CLK_UART3_IPG&gt;,\n                &lt;&amp;clks IMX6UL_CLK_UART3_SERIAL&gt;;\n        clock-names = &quot;ipg&quot;, &quot;per&quot;;\n        dmas = &lt;&amp;sdma 29 4 0&gt;, &lt;&amp;sdma 30 4 0&gt;;\n        dma-names = &quot;rx&quot;, &quot;tx&quot;;\n        status = &quot;disabled&quot;;\n    };   </code></pre><h2 id=\"第二步：驱动获取设备树生成设备（驱动模块）\"><a href=\"#第二步：驱动获取设备树生成设备（驱动模块）\" class=\"headerlink\" title=\"第二步：驱动获取设备树生成设备（驱动模块）\"></a>第二步：驱动获取设备树生成设备（驱动模块）</h2><p>drivers/tty/serial/imx.c文件中有如下内容：</p>\n<pre><code>static struct platform_device_id imx_uart_devtype[] = {\n    {\n        .name = &quot;imx1-uart&quot;,\n        .driver_data = (kernel_ulong_t) &amp;imx_uart_devdata[IMX1_UART],\n    }, {\n        .name = &quot;imx21-uart&quot;,\n        .driver_data = (kernel_ulong_t) &amp;imx_uart_devdata[IMX21_UART],\n    }, {\n        .name = &quot;imx6q-uart&quot;,\n        .driver_data = (kernel_ulong_t) &amp;imx_uart_devdata[IMX6Q_UART],\n    }, {\n        /* sentinel */\n    }\n};\nMODULE_DEVICE_TABLE(platform, imx_uart_devtype);</code></pre><pre><code>static struct uart_driver imx_reg = {\n    .owner          = THIS_MODULE,\n    .driver_name    = DRIVER_NAME,  //&quot;IMX-uart&quot;\n    .dev_name       = DEV_NAME,     //&quot;ttymxc&quot;\n    .major          = SERIAL_IMX_MAJOR, //207\n    .minor          = MINOR_START,      //16\n    .nr             = ARRAY_SIZE(imx_ports),    //8\n    .cons           = IMX_CONSOLE,      //NULL\n};</code></pre><p>platform平台对比到相同的设备树中的compatible到驱动中的name的时候就执行probe函数：</p>\n<details><summary>static int serial_imx_probe（struct platform_device *pdev）</summary>\n<pre><code>\n{\n    struct imx_port *sport;\n    void __iomem *base;\n    int ret = 0;\n    struct resource *res;\n    int txirq, rxirq, rtsirq;\n    sport = devm_kzalloc(&pdev->dev, sizeof(*sport), GFP_KERNEL);\n    if (!sport)\n        return -ENOMEM;\n    ret = serial_imx_probe_dt(sport, pdev);\n    if (ret > 0)\n        serial_imx_probe_pdata(sport, pdev);\n    else if (ret < 0)\n        return ret;\n    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n    base = devm_ioremap_resource(&pdev->dev, res);\n    if (IS_ERR(base))\n        return PTR_ERR(base);\n    rxirq = platform_get_irq(pdev, 0);\n    txirq = platform_get_irq(pdev, 1);\n    rtsirq = platform_get_irq(pdev, 2);\n    sport->port.dev = &pdev->dev;\n    sport->port.mapbase = res->start;\n    sport->port.membase = base;\n    sport->port.type = PORT_IMX,\n    sport->port.iotype = UPIO_MEM;\n    sport->port.irq = rxirq;\n    sport->port.fifosize = 32;\n    sport->port.ops = &imx_pops;\n    sport->port.rs485_config = imx_rs485_config;\n    sport->port.rs485.flags =\n        SER_RS485_RTS_ON_SEND | SER_RS485_RX_DURING_TX;\n    sport->port.flags = UPF_BOOT_AUTOCONF;\n    init_timer(&sport->timer);\n    sport->timer.function = imx_timeout;\n    sport->timer.data     = (unsigned long)sport;\n    sport->clk_ipg = devm_clk_get(&pdev->dev, \"ipg\");\n    if (IS_ERR(sport->clk_ipg)) {\n        ret = PTR_ERR(sport->clk_ipg);\n        dev_err(&pdev->dev, \"failed to get ipg clk: %d\\n\", ret);\n        return ret;\n    }\n    sport->clk_per = devm_clk_get(&pdev->dev, \"per\");\n    if (IS_ERR(sport->clk_per)) {\n        ret = PTR_ERR(sport->clk_per);\n        dev_err(&pdev->dev, \"failed to get per clk: %d\\n\", ret);\n        return ret;\n    }\n    sport->port.uartclk = clk_get_rate(sport->clk_per);\n    if (sport->port.uartclk > IMX_MODULE_MAX_CLK_RATE) {\n        ret = clk_set_rate(sport->clk_per, IMX_MODULE_MAX_CLK_RATE);\n        if (ret < 0) {\n            dev_err(&pdev->dev, \"clk_set_rate() failed\\n\");\n            return ret;\n        }\n    }\n    sport->port.uartclk = clk_get_rate(sport->clk_per);\n    if (txirq > 0) {\n        ret = devm_request_irq(&pdev->dev, rxirq, imx_rxint, 0,\n                       dev_name(&pdev->dev), sport);\n        if (ret)\n            return ret;\n\n<pre><code>    ret = devm_request_irq(&amp;pdev-&gt;dev, txirq, imx_txint, 0,\n                   dev_name(&amp;pdev-&gt;dev), sport);\n    if (ret)\n        return ret;\n} else {\n    ret = devm_request_irq(&amp;pdev-&gt;dev, rxirq, imx_int, 0,\n                   dev_name(&amp;pdev-&gt;dev), sport);\n    if (ret)\n        return ret;\n}\nimx_ports[sport-&gt;port.line] = sport;\nplatform_set_drvdata(pdev, sport);\nreturn uart_add_one_port(&amp;imx_reg, &amp;sport-&gt;port);</code></pre><p>}<br></p></code></pre></details><p></p>\n<p><code>serial_imx_probe</code>函数是针对i.MX系列平台设备的串口驱动的探测函数。该函数的功能是在系统启动时，当检测到与i.MX系列平台相关的串口设备时，自动初始化和注册相应的串口驱动程序。</p>\n<p>具体功能包括：</p>\n<ol>\n<li><p>识别并验证与i.MX平台相关的串口设备资源。通过检查设备树（device tree）或其他平台特定的数据结构，确定该平台上的串口设备的物理地址、中断号、时钟等信息，并进行验证。</p>\n</li>\n<li><p>为每个串口设备分配和初始化相应的<code>struct uart_port</code>结构体。该结构体用于表示一个串口设备的相关参数和状态信息，如设备的基地址、中断号、波特率等。</p>\n</li>\n<li><p>注册串口驱动程序。调用<code>uart_add_one_port</code>函数将初始化好的<code>struct uart_port</code>结构体注册到串口子系统中，以便操作系统可以管理和操作该串口设备。</p>\n</li>\n<li><p>执行其他平台特定的初始化操作。根据i.MX平台的要求，可能需要进行其他特定于该平台的初始化步骤，如设置GPIO引脚、时钟源等。</p>\n</li>\n</ol>\n<p>总而言之，<code>serial_imx_probe</code>函数的功能是在系统启动时，自动探测和初始化i.MX平台上的串口设备，并注册相应的串口驱动程序，以便后续操作系统和用户空间程序可以与这些串口设备进行通信和交互。</p>\n<p>数据结构的关系：<br>内核串口驱动结构uart_driver（imx_reg）在 imx_serial_init 函数中向 Linux 内核注册了 imx_reg。<br>当 UART 设备和驱动匹配成功以后 serial_imx_probe 函数就会执行，此函数的重点工作就<br>是初始化 uart_port，然后将其添加到对应的 uart_driver 中。imx驱动自己创建了imx_port 结构体里面有一个成员就是uart_port，最后通过uart_add_one_port注册。</p>\n<p>所以在dev目录下就会有：<img src=\"/2023/06/ttymxx-uart/ls-dev.png\" alt=\"ls /dev\"> 对应到uart1-&gt;ttymxc0和uart3-&gt;ttymxc2<br>设备号：<img src=\"/2023/06/ttymxx-uart/ttymxc.png\" alt=\"设备号\"><br>设备：<img src=\"/2023/06/ttymxx-uart/cat-proc-devices.png\" alt=\"设备\"></p>\n<h2 id=\"第三步：使用串口（应用模块）\"><a href=\"#第三步：使用串口（应用模块）\" class=\"headerlink\" title=\"第三步：使用串口（应用模块）\"></a>第三步：使用串口（应用模块）</h2><p>通过串口发送数据到ttymxc2,执行cat /dev/ttymxc2：<img src=\"/2023/06/ttymxx-uart/cat-ttymxc2.png\" alt=\"ttymxc2\"> 应该是和串口发送的十六进制数据是一样的。所以所有的操作都应该是基于此文件或则设备相关的硬件信号。</p>\n<h3 id=\"方法一：轮询\"><a href=\"#方法一：轮询\" class=\"headerlink\" title=\"方法一：轮询\"></a>方法一：轮询</h3><ol>\n<li><p>打开串口</p>\n<pre><code>fd = open(port, O_RDWR | O_NOCTTY | O_NDELAY);\nif (fd == -1) \n{\n perror(&quot;open_port: Unable to open serial port&quot;);\n return -1;\n}</code></pre></li>\n<li><p>配置串口</p>\n<pre><code>tcgetattr(fd, &amp;options);\ncfsetispeed(&amp;options, B115200);\ncfsetospeed(&amp;options, B115200);\noptions.c_cflag |= (CLOCAL | CREAD);\noptions.c_cflag &amp;= ~PARENB;\noptions.c_cflag &amp;= ~CSTOPB;\noptions.c_cflag &amp;= ~CSIZE;\noptions.c_cflag |= CS8;\noptions.c_cflag &amp;= ~CRTSCTS;\ntcsetattr(fd, TCSANOW, &amp;options);</code></pre><p>其中，tcgetattr 和 tcsetattr 函数用于获取和设置串口参数。cfsetispeed 和 cfsetospeed 函数用于设置串口的输入和输出波特率，这里设置为 115200。options.c_cflag 表示控制标志位，用于配置串口控制参数，具体含义如下：</p>\n<p> CLOCAL：忽略调制解调器的状态线，只允许本地使用串口。</p>\n<p> CREAD：允许从串口读取数据。</p>\n<p> PARENB：启用奇偶校验。&amp;= ~PARENB则为禁用校验。</p>\n<p> CSTOPB：使用两个停止位而不是一个。&amp;= ~CSTOPB停止位为1。</p>\n<p> CSIZE：表示字符长度的位掩码。在这里设置为 0，表示使用默认的 8 位数据位。</p>\n<p> CS8：表示使用 8 位数据位。</p>\n<p> CRTSCTS：启用硬件流控制，即使用 RTS 和 CTS 状态线进行流控制。</p>\n</li>\n</ol>\n<p>在示例程序中，我们将 CLOCAL 和 CREAD 标志位置为 1，表示允许本地使用串口，并允许从串口读取数据。我们将 PARENB、CSTOPB 和 CRTSCTS 标志位都设置为 0，表示不启用奇偶校验、使用一个停止位和禁用硬件流控制。最后，我们将 CSIZE 标志位设置为 0，然后将 CS8 标志位设置为 1，以表示使用 8 位数据位。</p>\n<ol start=\"3\">\n<li><p>读写</p>\n<pre><code>read(fd, buf, sizeof(buf)); // 返回接收个数\nwrite(fd, buf, strlen(buf)); // 返回发送长度,负值表示发送失败</code></pre></li>\n<li><p>关闭串口</p>\n<pre><code>close(fd);</code></pre><p>完整示例</p>\n<details><summary>轮询code</summary>\n<pre><code>\n int main()\n {\n     int fd;\n     char buf[255];\n     int n;\n     fd = open_port(\"/dev/ttyUSB0\");\n     if (fd == -1) {\n\n<pre><code>     printf(&quot;open err\\n&quot;);\n     exit(1);\n }\n while (1)\n {\n     n = read(fd, buf, sizeof(buf));\n     if (n &gt; 0) {\n         printf(&quot;Received: %.*s\\n&quot;, n, buf);\n     }\n     strcpy(buf, &quot;Hello, world!\\n&quot;);\n     n = write(fd, buf, strlen(buf));\n     if (n &lt; 0) {\n         perror(&quot;write failed\\n&quot;);\n     }\n     usleep(10 * 1000);\n }\n close(fd);\n printf(&quot;close uart\\n&quot;);\n return 0;</code></pre><p> }</p>\n<p> int open_port(const char *port)<br> {</p>\n<pre><code> int fd;\n struct termios options;\n fd = open(port, O_RDWR | O_NOCTTY | O_NDELAY);\n if (fd == -1) {\n     perror(&quot;open_port: Unable to open serial port&quot;);\n     return -1;\n }\n tcgetattr(fd, &amp;options);\n cfsetispeed(&amp;options, B115200);\n cfsetospeed(&amp;options, B115200);\n options.c_cflag |= (CLOCAL | CREAD);\n options.c_cflag &amp;= ~PARENB;\n options.c_cflag &amp;= ~CSTOPB;\n options.c_cflag &amp;= ~CSIZE;\n options.c_cflag |= CS8;\n options.c_cflag &amp;= ~CRTSCTS;\n tcsetattr(fd, TCSANOW, &amp;options);\n return fd;</code></pre><p> }<br></p></code></pre></details><p></p>\n</li>\n</ol>\n<h3 id=\"方法二：中断读取示例\"><a href=\"#方法二：中断读取示例\" class=\"headerlink\" title=\"方法二：中断读取示例\"></a>方法二：中断读取示例</h3><p>上面给出的串口示例是使用轮询的方式读取串口数据，这种方式在某些场景下可能会占用大量 CPU 资源。实际上，对于 Linux 系统来说，还可以使用中断方式接收串口数据，这样可以大大减少 CPU 的占用率，并且能够更快地响应串口数据。</p>\n<p>要使用中断方式接收串口数据，可以使用 select 函数来监听串口文件描述符的可读事件。当串口数据可读时，select 函数将返回，并且可以调用 read 函数来读取串口数据。这种方式可以避免轮询操作，只有在串口数据可读时才会执行读取操作，因此能够减少 CPU 的占用率。</p>\n<p>以下是一个简单的使用中断方式接收串口数据的示例程序：</p>\n<details><summary>中断读取code</summary>\n<pre><code>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <termios.h>\n#include <sys select.h>\n\n<p>int main() {<br>    int fd;<br>    struct termios options;<br>    fd_set rfds;</p>\n<pre><code>// 打开串口设备\nfd = open(&quot;/dev/ttyUSB0&quot;, O_RDWR | O_NOCTTY);\nif (fd &lt; 0) {\n    perror(&quot;open&quot;);\n    return -1;\n}\n\n// 配置串口参数\ntcgetattr(fd, &amp;options);\noptions.c_cflag = B9600 | CS8 | CLOCAL | CREAD;\noptions.c_iflag = IGNPAR;\noptions.c_oflag = 0;\noptions.c_lflag = 0;\noptions.c_cc[VTIME] = 0;\noptions.c_cc[VMIN] = 1;\ntcsetattr(fd, TCSANOW, &amp;options);\n\nwhile (1) {\n    // 使用 select 函数监听串口文件描述符的可读事件\n    FD_ZERO(&amp;rfds);\n    FD_SET(fd, &amp;rfds);\n    select(fd + 1, &amp;rfds, NULL, NULL, NULL);\n\n    // 读取串口数据\n    char buf[256];\n    int n = read(fd, buf, sizeof(buf));\n    if (n &gt; 0) {\n        printf(&quot;Received data: %.*s\\n&quot;, n, buf);\n    }\n}\n\n// 关闭串口设备\nclose(fd);\n\nreturn 0;</code></pre><p>}<br></p></sys></termios.h></fcntl.h></unistd.h></stdlib.h></stdio.h></code></pre></details><br>需要注意的是，在使用中断方式接收串口数据时，需要对串口文件描述符设置为非阻塞模式，以便在 select 函数返回时立即读取串口数据。可以使用 fcntl 函数来设置文件描述符的标志位，如下所示：<p></p>\n<pre><code>// 设置串口文件描述符为非阻塞模式\nint flags = fcntl(fd, F_GETFL, 0);\nfcntl(fd, F_SETFL, flags | O_NONBLOCK);</code></pre><h3 id=\"方法三：信号的方式接收数据\"><a href=\"#方法三：信号的方式接收数据\" class=\"headerlink\" title=\"方法三：信号的方式接收数据\"></a>方法三：信号的方式接收数据</h3><details><summary>信号的方式接收code</summary>\n<pre><code>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <termios.h>\n#include <signal.h>\n\n<p>int fd;</p>\n<p>void sigio_handler(int sig) {<br>    char buf[256];<br>    int n = read(fd, buf, sizeof(buf));<br>    if (n &gt; 0) {<br>        printf(“Received data: %.*s\\n”, n, buf);<br>    }<br>}</p>\n<p>int main() {<br>    struct termios options;<br>    struct sigaction sa;</p>\n<pre><code>// 打开串口设备\nfd = open(&quot;/dev/ttyS0&quot;, O_RDWR | O_NOCTTY);\nif (fd &lt; 0) {\n    perror(&quot;open&quot;);\n    return -1;\n}\n\n// 配置串口参数\ntcgetattr(fd, &amp;options);\noptions.c_cflag = B9600 | CS8 | CLOCAL | CREAD;\noptions.c_iflag = IGNPAR;\noptions.c_oflag = 0;\noptions.c_lflag = 0;\noptions.c_cc[VTIME] = 0;\noptions.c_cc[VMIN] = 1;\ntcsetattr(fd, TCSANOW, &amp;options);\n\n// 设置串口文件描述符为异步通知模式\n/* 将串口文件描述符设置为当前进程的拥有者，从而接收该文件描述符相关的信号。*/\nfcntl(fd, F_SETOWN, getpid()); \nint flags = fcntl(fd, F_GETFL, 0); // 先获取当前配置, 下面只更改O_ASYNC标志\n/* 将串口文件描述符设置为非阻塞模式，从而允许该文件描述符异步地接收数据和信号。*/\nfcntl(fd, F_SETFL, flags | O_ASYNC);\n\n// 设置 SIGIO 信号的处理函数\nsa.sa_handler = sigio_handler;\nsigemptyset(&amp;sa.sa_mask);\nsa.sa_flags = 0;\n/* 设置了 SIGIO 信号的处理函数为 sigio_handler，从而在该信号被触发时读取串口数据并进行处理。*/\nsigaction(SIGIO, &amp;sa, NULL);\n\nwhile (1) {\n    // 等待 SIGIO 信号\n    sleep(1);\n}\n\n// 关闭串口设备\nclose(fd);\n\nreturn 0;</code></pre><p>}<br></p></signal.h></termios.h></fcntl.h></unistd.h></stdlib.h></stdio.h></code></pre></details><br>上述代码中，使用了 fcntl 函数将串口文件描述符设置为异步通知模式，并使用 SIGIO 信号来通知程序串口数据已经可读。当程序接收到 SIGIO 信号时，会调用 sigio_handler 函数来读取并处理串口数据。<p></p>\n<p>在这段代码中，sigemptyset（&amp;sa.sa_mask）;的作用是将信号处理函数在执行时要屏蔽的信号集合清空，即将其设置为空集。</p>\n<p>每个进程都有一个信号屏蔽字，它表示了当前被阻塞的信号集合。当一个信号被阻塞时，它将被加入到信号屏蔽字中，而当信号被解除阻塞时，它将被从信号屏蔽字中移除。如果信号处理函数在执行时需要屏蔽其他的信号，则可以使用sigaddset等函数将需要屏蔽的信号添加到信号屏蔽字中。但是，在本例中，我们需要处理的信号是SIGIO，它通常不需要被屏蔽，因此我们使用sigemptyset函数将信号屏蔽字清空，以确保在处理SIGIO信号时不会屏蔽任何其他信号。</p>\n<p>在Linux系统中，使用sigaction函数注册信号处理函数时，可以设置一些标志来指定信号处理的行为。例如，可以使用SA_RESTART标志来指定当系统调用被信号中断时自动重启该系统调用。在本例中，由于我们并不需要设置任何标志，因此将sa.sa_flags字段设置为0即可。这表示信号处理函数不需要任何特殊的行为，只需要按照默认的方式处理信号即可。</p>\n<h3 id=\"方法四：使用线程接收串口数据\"><a href=\"#方法四：使用线程接收串口数据\" class=\"headerlink\" title=\"方法四：使用线程接收串口数据\"></a>方法四：使用线程接收串口数据</h3><details><summary>使用线程接收code</summary>\n<pre><code>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <termios.h>\n#include <pthread.h>\n\n<p>void *read_thread(void *arg) {<br>    int fd = *(int *)arg;<br>    char buf[256];<br>    int n;</p>\n<pre><code>while (1) {\n    // 读取串口数据\n    n = read(fd, buf, sizeof(buf));\n    if (n &gt; 0) {\n        printf(&quot;Received data: %.*s\\n&quot;, n, buf);\n    }\n}\n\nreturn NULL;</code></pre><p>}</p>\n<p>int main() {<br>    int fd;<br>    struct termios options;<br>    pthread_t tid;</p>\n<pre><code>// 打开串口设备\nfd = open(&quot;/dev/ttyS0&quot;, O_RDWR | O_NOCTTY);\nif (fd &lt; 0) {\n    perror(&quot;open&quot;);\n    return -1;\n}\n\n// 配置串口参数\ntcgetattr(fd, &amp;options);\noptions.c_cflag = B9600 | CS8 | CLOCAL | CREAD;\noptions.c_iflag = IGNPAR;\noptions.c_oflag = 0;\noptions.c_lflag = 0;\noptions.c_cc[VTIME] = 0;\noptions.c_cc[VMIN] = 1;\ntcsetattr(fd, TCSANOW, &amp;options);\n\n// 创建读取线程\nif (pthread_create(&amp;tid, NULL, read_thread, &amp;fd) != 0) {\n    perror(&quot;pthread_create&quot;);\n    return -1;\n}\n\nwhile (1) {\n    // 主线程的其他处理逻辑\n    sleep(1);\n}\n\n// 关闭串口设备\nclose(fd);\n\nreturn 0;</code></pre><p>}<br></p></pthread.h></termios.h></fcntl.h></unistd.h></stdlib.h></stdio.h></code></pre></details><br>上述代码中，创建了一个读取线程，不断读取串口数据并进行处理。主线程可以在读取线程运行的同时进行其他处理逻辑。<p></p>\n"},{"title":"url","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-06-19T11:28:58.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"\n# 学习网站\n[bash语法](https://www.gnu.org/software/bash/manual/bash.pdf)\n[POSIX标准](https://pubs.opengroup.org/onlinepubs/9699919799.2018edition/)\n[glibc](https://www.gnu.org/software/libc/)\n[linux kernel](https://linux-kernel-labs.github.io/refs/heads/master/labs/deferred_work.html)","source":"_posts/2023/06/url.md","raw":"---\ntitle: url\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-06-19 19:28:58\npassword:\nsummary:\ntags: \n- study\ncategories:\n- study\nkeywords:\ndescription:\n---\n\n# 学习网站\n[bash语法](https://www.gnu.org/software/bash/manual/bash.pdf)\n[POSIX标准](https://pubs.opengroup.org/onlinepubs/9699919799.2018edition/)\n[glibc](https://www.gnu.org/software/libc/)\n[linux kernel](https://linux-kernel-labs.github.io/refs/heads/master/labs/deferred_work.html)","slug":"url","published":1,"updated":"2024-01-05T08:12:19.774Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clru1g21k001rs4fupgmvlkq6","content":"<h1 id=\"学习网站\"><a href=\"#学习网站\" class=\"headerlink\" title=\"学习网站\"></a>学习网站</h1><p><a href=\"https://www.gnu.org/software/bash/manual/bash.pdf\" target=\"_blank\" rel=\"noopener\">bash语法</a><br><a href=\"https://pubs.opengroup.org/onlinepubs/9699919799.2018edition/\" target=\"_blank\" rel=\"noopener\">POSIX标准</a><br><a href=\"https://www.gnu.org/software/libc/\" target=\"_blank\" rel=\"noopener\">glibc</a><br><a href=\"https://linux-kernel-labs.github.io/refs/heads/master/labs/deferred_work.html\" target=\"_blank\" rel=\"noopener\">linux kernel</a></p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<h1 id=\"学习网站\"><a href=\"#学习网站\" class=\"headerlink\" title=\"学习网站\"></a>学习网站</h1><p><a href=\"https://www.gnu.org/software/bash/manual/bash.pdf\" target=\"_blank\" rel=\"noopener\">bash语法</a><br><a href=\"https://pubs.opengroup.org/onlinepubs/9699919799.2018edition/\" target=\"_blank\" rel=\"noopener\">POSIX标准</a><br><a href=\"https://www.gnu.org/software/libc/\" target=\"_blank\" rel=\"noopener\">glibc</a><br><a href=\"https://linux-kernel-labs.github.io/refs/heads/master/labs/deferred_work.html\" target=\"_blank\" rel=\"noopener\">linux kernel</a></p>\n"},{"title":"linux-platform","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-07-05T12:35:21.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"\n#  Q：如果你的项目中出现大量的外设你会如何设接代码（外设>10000+）\n#  A：外设驱动分工+分层系统设计\n\n# 外设驱动分工\n先讨论分工，分工很简单不同职能的工程师输出自己部分的设备和驱动的代码，首先区分两个观点\n1：设备代码（include/linux/platform_device.h--> platform_device结构体）\n    这个结构体 `platform_device` 是用于描述平台设备的数据结构。它包含以下字段：\n\n    - `name`: 平台设备的名称。\n    - `id`: 平台设备的标识符。\n    - `id_auto`: 表示标识符是否自动分配的标志。\n    - `dev`: 嵌套的 `struct device` 结构，用于表示设备的通用属性和行为。\n    - `num_resources`: 平台设备所使用的资源数量。\n    - `resource`: 指向资源数组的指针，描述平台设备所需的资源。\n    - `id_entry`: 指向匹配平台设备的 id 表项的指针。\n    - `driver_override`: 强制指定驱动程序名称以进行匹配的字符串。\n    - `mfd_cell`: 指向多功能设备 (MFD) 单元的指针，如果该平台设备属于 MFD 子系统。\n    - `archdata`: 架构特定的数据，用于存储与特定架构相关的平台设备信息。\n\n2：驱动代码（include/linux/platform_device.h--> platform_driver结构体）\n    这个结构体 `platform_driver` 是用于描述平台驱动程序的数据结构。它包含以下字段：\n\n    - `probe`: 平台设备的探测函数，在设备与驱动程序匹配成功时调用，用于初始化和配置设备。\n    - `remove`: 平台设备的移除函数，在设备与驱动程序解绑时调用，用于清理和释放设备资源。\n    - `shutdown`: 平台设备的关机函数，在系统关机时调用，用于执行设备的关机处理。\n    - `suspend`: 平台设备的挂起函数，在设备进入挂起状态时调用，用于执行设备的挂起操作。\n    - `resume`: 平台设备的恢复函数，在设备从挂起状态恢复时调用，用于执行设备的恢复操作。\n    - `driver`: 嵌套的 `struct device_driver` 结构，用于表示驱动程序的通用属性和行为。\n    - `id_table`: 指向平台设备 id 表的指针，用于指定与该驱动程序匹配的平台设备。\n    - `prevent_deferred_probe`: 阻止延迟探测的标志，用于指示驱动程序是否允许延迟探测机制。\n\n这样就可以系统工程师输出代码的同时，驱动工程师同时输出驱动，如果系统已经定义好标准的设备接口的话。应用工程师就可以在没有驱动的情况也可以开始应用层的工作。前提是系统的接口定义的足够清晰，重点是对需求的理解透彻，分析出所有的需求结构。\n\n# 分层系统设计\n现在设备和设备的驱动有了，剩下就是系统工程师的事情了，系统采用分层的设计![分层](linux-platform/device-driver.png).剩下的就是你会如何去设计这条linux的总线，对设备和驱动的匹配。最简单的设计思路就是建立两条链表，设备链表和驱动链表，在设备和驱动中设置一个成员相同用于匹配上设备和驱动，匹配成功就将设备回调函数注册成驱动中的函数。基本是这么实现的不详细讨论，linux中很复杂还有一大堆其他的工作。下面贴出一张网图画得很清楚：![platform](linux-platform/platform.png)\n详细的代码注释可以看我的[github仓库](https://gitee.com/qian-qiang/imx6ull_linux)\n\n# 进阶设计：使用设备树作为设备代码\nplatform 驱动框架分为总线、设备和驱动，其中总线不需要我们这些驱动程序员去管理，这\n个是 Linux 内核提供的，我们在编写驱动的时候只要关注于设备和驱动的具体实现即可。在没\n有设备树的 Linux 内核下，我们需要分别编写并注册 platform_device 和 platform_driver，分别代\n表设备和驱动。在使用设备树的时候，设备的描述被放到了设备树中，因此 platform_device 就\n不需要我们去编写了，我们只需要实现 platform_driver 即可。在编写基于设备树的 platform 驱\n动的时候我们需要注意一下几点\n    1、在设备树中创建设备节点\n    2、编写 platform 驱动的时候要注意兼容属性\n    3、编写 platform 驱动","source":"_posts/2023/07/linux-platform.md","raw":"---\ntitle: linux-platform\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-07-05 20:35:21\npassword:\nsummary:\ntags:\n- platform\n- linux\ncategories:\n- linux\nkeywords:\ndescription:\n---\n\n#  Q：如果你的项目中出现大量的外设你会如何设接代码（外设>10000+）\n#  A：外设驱动分工+分层系统设计\n\n# 外设驱动分工\n先讨论分工，分工很简单不同职能的工程师输出自己部分的设备和驱动的代码，首先区分两个观点\n1：设备代码（include/linux/platform_device.h--> platform_device结构体）\n    这个结构体 `platform_device` 是用于描述平台设备的数据结构。它包含以下字段：\n\n    - `name`: 平台设备的名称。\n    - `id`: 平台设备的标识符。\n    - `id_auto`: 表示标识符是否自动分配的标志。\n    - `dev`: 嵌套的 `struct device` 结构，用于表示设备的通用属性和行为。\n    - `num_resources`: 平台设备所使用的资源数量。\n    - `resource`: 指向资源数组的指针，描述平台设备所需的资源。\n    - `id_entry`: 指向匹配平台设备的 id 表项的指针。\n    - `driver_override`: 强制指定驱动程序名称以进行匹配的字符串。\n    - `mfd_cell`: 指向多功能设备 (MFD) 单元的指针，如果该平台设备属于 MFD 子系统。\n    - `archdata`: 架构特定的数据，用于存储与特定架构相关的平台设备信息。\n\n2：驱动代码（include/linux/platform_device.h--> platform_driver结构体）\n    这个结构体 `platform_driver` 是用于描述平台驱动程序的数据结构。它包含以下字段：\n\n    - `probe`: 平台设备的探测函数，在设备与驱动程序匹配成功时调用，用于初始化和配置设备。\n    - `remove`: 平台设备的移除函数，在设备与驱动程序解绑时调用，用于清理和释放设备资源。\n    - `shutdown`: 平台设备的关机函数，在系统关机时调用，用于执行设备的关机处理。\n    - `suspend`: 平台设备的挂起函数，在设备进入挂起状态时调用，用于执行设备的挂起操作。\n    - `resume`: 平台设备的恢复函数，在设备从挂起状态恢复时调用，用于执行设备的恢复操作。\n    - `driver`: 嵌套的 `struct device_driver` 结构，用于表示驱动程序的通用属性和行为。\n    - `id_table`: 指向平台设备 id 表的指针，用于指定与该驱动程序匹配的平台设备。\n    - `prevent_deferred_probe`: 阻止延迟探测的标志，用于指示驱动程序是否允许延迟探测机制。\n\n这样就可以系统工程师输出代码的同时，驱动工程师同时输出驱动，如果系统已经定义好标准的设备接口的话。应用工程师就可以在没有驱动的情况也可以开始应用层的工作。前提是系统的接口定义的足够清晰，重点是对需求的理解透彻，分析出所有的需求结构。\n\n# 分层系统设计\n现在设备和设备的驱动有了，剩下就是系统工程师的事情了，系统采用分层的设计![分层](linux-platform/device-driver.png).剩下的就是你会如何去设计这条linux的总线，对设备和驱动的匹配。最简单的设计思路就是建立两条链表，设备链表和驱动链表，在设备和驱动中设置一个成员相同用于匹配上设备和驱动，匹配成功就将设备回调函数注册成驱动中的函数。基本是这么实现的不详细讨论，linux中很复杂还有一大堆其他的工作。下面贴出一张网图画得很清楚：![platform](linux-platform/platform.png)\n详细的代码注释可以看我的[github仓库](https://gitee.com/qian-qiang/imx6ull_linux)\n\n# 进阶设计：使用设备树作为设备代码\nplatform 驱动框架分为总线、设备和驱动，其中总线不需要我们这些驱动程序员去管理，这\n个是 Linux 内核提供的，我们在编写驱动的时候只要关注于设备和驱动的具体实现即可。在没\n有设备树的 Linux 内核下，我们需要分别编写并注册 platform_device 和 platform_driver，分别代\n表设备和驱动。在使用设备树的时候，设备的描述被放到了设备树中，因此 platform_device 就\n不需要我们去编写了，我们只需要实现 platform_driver 即可。在编写基于设备树的 platform 驱\n动的时候我们需要注意一下几点\n    1、在设备树中创建设备节点\n    2、编写 platform 驱动的时候要注意兼容属性\n    3、编写 platform 驱动","slug":"linux-platform","published":1,"updated":"2024-01-05T08:12:19.775Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clru1g21l001us4fuc513tgh7","content":"<h1 id=\"Q：如果你的项目中出现大量的外设你会如何设接代码（外设-gt-10000-）\"><a href=\"#Q：如果你的项目中出现大量的外设你会如何设接代码（外设-gt-10000-）\" class=\"headerlink\" title=\"Q：如果你的项目中出现大量的外设你会如何设接代码（外设&gt;10000+）\"></a>Q：如果你的项目中出现大量的外设你会如何设接代码（外设&gt;10000+）</h1><h1 id=\"A：外设驱动分工-分层系统设计\"><a href=\"#A：外设驱动分工-分层系统设计\" class=\"headerlink\" title=\"A：外设驱动分工+分层系统设计\"></a>A：外设驱动分工+分层系统设计</h1><h1 id=\"外设驱动分工\"><a href=\"#外设驱动分工\" class=\"headerlink\" title=\"外设驱动分工\"></a>外设驱动分工</h1><p>先讨论分工，分工很简单不同职能的工程师输出自己部分的设备和驱动的代码，首先区分两个观点<br>1：设备代码（include/linux/platform_device.h–&gt; platform_device结构体）<br>    这个结构体 <code>platform_device</code> 是用于描述平台设备的数据结构。它包含以下字段：</p>\n<pre><code>- `name`: 平台设备的名称。\n- `id`: 平台设备的标识符。\n- `id_auto`: 表示标识符是否自动分配的标志。\n- `dev`: 嵌套的 `struct device` 结构，用于表示设备的通用属性和行为。\n- `num_resources`: 平台设备所使用的资源数量。\n- `resource`: 指向资源数组的指针，描述平台设备所需的资源。\n- `id_entry`: 指向匹配平台设备的 id 表项的指针。\n- `driver_override`: 强制指定驱动程序名称以进行匹配的字符串。\n- `mfd_cell`: 指向多功能设备 (MFD) 单元的指针，如果该平台设备属于 MFD 子系统。\n- `archdata`: 架构特定的数据，用于存储与特定架构相关的平台设备信息。</code></pre><p>2：驱动代码（include/linux/platform_device.h–&gt; platform_driver结构体）<br>    这个结构体 <code>platform_driver</code> 是用于描述平台驱动程序的数据结构。它包含以下字段：</p>\n<pre><code>- `probe`: 平台设备的探测函数，在设备与驱动程序匹配成功时调用，用于初始化和配置设备。\n- `remove`: 平台设备的移除函数，在设备与驱动程序解绑时调用，用于清理和释放设备资源。\n- `shutdown`: 平台设备的关机函数，在系统关机时调用，用于执行设备的关机处理。\n- `suspend`: 平台设备的挂起函数，在设备进入挂起状态时调用，用于执行设备的挂起操作。\n- `resume`: 平台设备的恢复函数，在设备从挂起状态恢复时调用，用于执行设备的恢复操作。\n- `driver`: 嵌套的 `struct device_driver` 结构，用于表示驱动程序的通用属性和行为。\n- `id_table`: 指向平台设备 id 表的指针，用于指定与该驱动程序匹配的平台设备。\n- `prevent_deferred_probe`: 阻止延迟探测的标志，用于指示驱动程序是否允许延迟探测机制。</code></pre><p>这样就可以系统工程师输出代码的同时，驱动工程师同时输出驱动，如果系统已经定义好标准的设备接口的话。应用工程师就可以在没有驱动的情况也可以开始应用层的工作。前提是系统的接口定义的足够清晰，重点是对需求的理解透彻，分析出所有的需求结构。</p>\n<h1 id=\"分层系统设计\"><a href=\"#分层系统设计\" class=\"headerlink\" title=\"分层系统设计\"></a>分层系统设计</h1><p>现在设备和设备的驱动有了，剩下就是系统工程师的事情了，系统采用分层的设计<img src=\"/2023/07/linux-platform/device-driver.png\" alt=\"分层\">.剩下的就是你会如何去设计这条linux的总线，对设备和驱动的匹配。最简单的设计思路就是建立两条链表，设备链表和驱动链表，在设备和驱动中设置一个成员相同用于匹配上设备和驱动，匹配成功就将设备回调函数注册成驱动中的函数。基本是这么实现的不详细讨论，linux中很复杂还有一大堆其他的工作。下面贴出一张网图画得很清楚：<img src=\"/2023/07/linux-platform/platform.png\" alt=\"platform\"><br>详细的代码注释可以看我的<a href=\"https://gitee.com/qian-qiang/imx6ull_linux\" target=\"_blank\" rel=\"noopener\">github仓库</a></p>\n<h1 id=\"进阶设计：使用设备树作为设备代码\"><a href=\"#进阶设计：使用设备树作为设备代码\" class=\"headerlink\" title=\"进阶设计：使用设备树作为设备代码\"></a>进阶设计：使用设备树作为设备代码</h1><p>platform 驱动框架分为总线、设备和驱动，其中总线不需要我们这些驱动程序员去管理，这<br>个是 Linux 内核提供的，我们在编写驱动的时候只要关注于设备和驱动的具体实现即可。在没<br>有设备树的 Linux 内核下，我们需要分别编写并注册 platform_device 和 platform_driver，分别代<br>表设备和驱动。在使用设备树的时候，设备的描述被放到了设备树中，因此 platform_device 就<br>不需要我们去编写了，我们只需要实现 platform_driver 即可。在编写基于设备树的 platform 驱<br>动的时候我们需要注意一下几点<br>    1、在设备树中创建设备节点<br>    2、编写 platform 驱动的时候要注意兼容属性<br>    3、编写 platform 驱动</p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<h1 id=\"Q：如果你的项目中出现大量的外设你会如何设接代码（外设-gt-10000-）\"><a href=\"#Q：如果你的项目中出现大量的外设你会如何设接代码（外设-gt-10000-）\" class=\"headerlink\" title=\"Q：如果你的项目中出现大量的外设你会如何设接代码（外设&gt;10000+）\"></a>Q：如果你的项目中出现大量的外设你会如何设接代码（外设&gt;10000+）</h1><h1 id=\"A：外设驱动分工-分层系统设计\"><a href=\"#A：外设驱动分工-分层系统设计\" class=\"headerlink\" title=\"A：外设驱动分工+分层系统设计\"></a>A：外设驱动分工+分层系统设计</h1><h1 id=\"外设驱动分工\"><a href=\"#外设驱动分工\" class=\"headerlink\" title=\"外设驱动分工\"></a>外设驱动分工</h1><p>先讨论分工，分工很简单不同职能的工程师输出自己部分的设备和驱动的代码，首先区分两个观点<br>1：设备代码（include/linux/platform_device.h–&gt; platform_device结构体）<br>    这个结构体 <code>platform_device</code> 是用于描述平台设备的数据结构。它包含以下字段：</p>\n<pre><code>- `name`: 平台设备的名称。\n- `id`: 平台设备的标识符。\n- `id_auto`: 表示标识符是否自动分配的标志。\n- `dev`: 嵌套的 `struct device` 结构，用于表示设备的通用属性和行为。\n- `num_resources`: 平台设备所使用的资源数量。\n- `resource`: 指向资源数组的指针，描述平台设备所需的资源。\n- `id_entry`: 指向匹配平台设备的 id 表项的指针。\n- `driver_override`: 强制指定驱动程序名称以进行匹配的字符串。\n- `mfd_cell`: 指向多功能设备 (MFD) 单元的指针，如果该平台设备属于 MFD 子系统。\n- `archdata`: 架构特定的数据，用于存储与特定架构相关的平台设备信息。</code></pre><p>2：驱动代码（include/linux/platform_device.h–&gt; platform_driver结构体）<br>    这个结构体 <code>platform_driver</code> 是用于描述平台驱动程序的数据结构。它包含以下字段：</p>\n<pre><code>- `probe`: 平台设备的探测函数，在设备与驱动程序匹配成功时调用，用于初始化和配置设备。\n- `remove`: 平台设备的移除函数，在设备与驱动程序解绑时调用，用于清理和释放设备资源。\n- `shutdown`: 平台设备的关机函数，在系统关机时调用，用于执行设备的关机处理。\n- `suspend`: 平台设备的挂起函数，在设备进入挂起状态时调用，用于执行设备的挂起操作。\n- `resume`: 平台设备的恢复函数，在设备从挂起状态恢复时调用，用于执行设备的恢复操作。\n- `driver`: 嵌套的 `struct device_driver` 结构，用于表示驱动程序的通用属性和行为。\n- `id_table`: 指向平台设备 id 表的指针，用于指定与该驱动程序匹配的平台设备。\n- `prevent_deferred_probe`: 阻止延迟探测的标志，用于指示驱动程序是否允许延迟探测机制。</code></pre><p>这样就可以系统工程师输出代码的同时，驱动工程师同时输出驱动，如果系统已经定义好标准的设备接口的话。应用工程师就可以在没有驱动的情况也可以开始应用层的工作。前提是系统的接口定义的足够清晰，重点是对需求的理解透彻，分析出所有的需求结构。</p>\n<h1 id=\"分层系统设计\"><a href=\"#分层系统设计\" class=\"headerlink\" title=\"分层系统设计\"></a>分层系统设计</h1><p>现在设备和设备的驱动有了，剩下就是系统工程师的事情了，系统采用分层的设计<img src=\"/2023/07/linux-platform/device-driver.png\" alt=\"分层\">.剩下的就是你会如何去设计这条linux的总线，对设备和驱动的匹配。最简单的设计思路就是建立两条链表，设备链表和驱动链表，在设备和驱动中设置一个成员相同用于匹配上设备和驱动，匹配成功就将设备回调函数注册成驱动中的函数。基本是这么实现的不详细讨论，linux中很复杂还有一大堆其他的工作。下面贴出一张网图画得很清楚：<img src=\"/2023/07/linux-platform/platform.png\" alt=\"platform\"><br>详细的代码注释可以看我的<a href=\"https://gitee.com/qian-qiang/imx6ull_linux\" target=\"_blank\" rel=\"noopener\">github仓库</a></p>\n<h1 id=\"进阶设计：使用设备树作为设备代码\"><a href=\"#进阶设计：使用设备树作为设备代码\" class=\"headerlink\" title=\"进阶设计：使用设备树作为设备代码\"></a>进阶设计：使用设备树作为设备代码</h1><p>platform 驱动框架分为总线、设备和驱动，其中总线不需要我们这些驱动程序员去管理，这<br>个是 Linux 内核提供的，我们在编写驱动的时候只要关注于设备和驱动的具体实现即可。在没<br>有设备树的 Linux 内核下，我们需要分别编写并注册 platform_device 和 platform_driver，分别代<br>表设备和驱动。在使用设备树的时候，设备的描述被放到了设备树中，因此 platform_device 就<br>不需要我们去编写了，我们只需要实现 platform_driver 即可。在编写基于设备树的 platform 驱<br>动的时候我们需要注意一下几点<br>    1、在设备树中创建设备节点<br>    2、编写 platform 驱动的时候要注意兼容属性<br>    3、编写 platform 驱动</p>\n"},{"title":"kill命令","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-08-09T03:32:53.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"\n# kill命令是如何执行的\n## kill发送信号\n文件kernel/signal.c\n ```c\n /**\n *  sys_kill - send a signal to a process\n *  @pid: the PID of the process\n *  @sig: signal to be sent\n */\nSYSCALL_DEFINE2(kill, pid_t, pid, int, sig)\n{\n\tstruct siginfo info;\n\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code = SI_USER;\n\tinfo.si_pid = task_tgid_vnr(current);\n\tinfo.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\n\treturn kill_something_info(sig, &info, pid);\n}\n ```\n 这段代码是 Linux 内核中实现 `kill` 系统调用的部分。让我们逐步分析这段代码的功能：\n\n1. `SYSCALL_DEFINE2(kill, pid_t, pid, int, sig)`：这是一个宏，用于定义带有两个参数的系统调用 `kill`。`pid_t` 和 `int` 是参数的类型，`pid` 是要发送信号的目标进程的 ID，`sig` 是要发送的信号编号。\n\n2. `struct siginfo info`：这是一个结构体，用于保存信号的附加信息。\n\n3. `info.si_signo = sig`：将信号编号赋值给 `si_signo` 字段，表示要发送的信号的编号。\n\n4. `info.si_errno = 0`：将错误编号字段置为 0，表示没有错误。\n\n5. `info.si_code = SI_USER`：将信号代码字段设置为 `SI_USER`，表示该信号是由用户空间进程发送的。\n\n6. `info.si_pid = task_tgid_vnr(current)`：将当前进程的 TGID（线程组ID）作为发送信号的进程ID。\n\n7. `info.si_uid = from_kuid_munged(current_user_ns(), current_uid())`：将当前进程的有效用户ID转换为用户命名空间中的用户ID，并将结果赋值给发送信号的用户ID字段。\n\n8. `return kill_something_info(sig, &info, pid)`：调用 `kill_something_info` 函数，将信号编号、信号信息结构体和目标进程的ID作为参数传递，并返回结果。这个函数的功能是根据给定的参数发送信号给目标进程。\n\n这段代码实现了 `kill` 系统调用的功能。它接受一个目标进程ID和信号编号作为参数，然后构建一个带有信号信息的结构体，并调用相应的函数将信号发送给目标进程。这是 Linux 内核中管理进程间通信的一部分，允许一个进程向另一个进程发送信号以通知或影响其行为。\n\n ```c\n/*\n * kill_something_info() interprets pid in interesting ways just like kill(2).\n *\n * POSIX specifies that kill(-1,sig) is unspecified, but what we have\n * is probably wrong.  Should make it like BSD or SYSV.\n */\n\nstatic int kill_something_info(int sig, struct siginfo *info, pid_t pid)\n{\n\tint ret;\n\n\tif (pid > 0) {\n\t\trcu_read_lock();\n\t\tret = kill_pid_info(sig, info, find_vpid(pid));\n\t\trcu_read_unlock();\n\t\treturn ret;\n\t}\n\n\tread_lock(&tasklist_lock);\n\tif (pid != -1) {\n\t\tret = __kill_pgrp_info(sig, info,\n\t\t\t\tpid ? find_vpid(-pid) : task_pgrp(current));\n\t} else {\n\t\tint retval = 0, count = 0;\n\t\tstruct task_struct * p;\n\n\t\tfor_each_process(p) {\n\t\t\tif (task_pid_vnr(p) > 1 &&\n\t\t\t\t\t!same_thread_group(p, current)) {\n\t\t\t\tint err = group_send_sig_info(sig, info, p);\n\t\t\t\t++count;\n\t\t\t\tif (err != -EPERM)\n\t\t\t\t\tretval = err;\n\t\t\t}\n\t\t}\n\t\tret = count ? retval : -ESRCH;\n\t}\n\tread_unlock(&tasklist_lock);\n\n\treturn ret;\n}\n ```\n\n这段代码是 Linux 内核中用于实现 `kill_something_info` 函数的部分。这个函数用于向一个或多个进程发送信号，具体操作取决于传递的参数。让我们逐步解释这段代码的功能：\n\n1. `static int kill_something_info(int sig, struct siginfo *info, pid_t pid)`：这是一个静态函数，用于发送信号给一个或多个进程。它接受信号编号 `sig`、信号信息结构体 `info` 和目标进程的ID `pid` 作为参数。\n\n2. `if (pid > 0)`：如果目标进程ID大于0，表示要向指定PID的进程发送信号。\n\n   - `rcu_read_lock()`：获取 RCU（Read-Copy-Update）读取锁，确保在读取期间不会发生数据修改。\n\n   - `ret = kill_pid_info(sig, info, find_vpid(pid))`：调用 `kill_pid_info` 函数，向指定的进程发送信号，并传递信号编号、信号信息和目标进程的虚拟PID（vpid）。\n\n   - `rcu_read_unlock()`：释放 RCU 读取锁。\n\n   - 返回 `ret`，表示操作的结果。\n\n3. 如果 `pid` 不大于0：\n\n   - `read_lock(&tasklist_lock)`：获取进程列表读取锁，以确保在遍历进程列表期间不会发生修改。\n\n   - 如果 `pid` 不等于-1，表示要发送信号给指定的进程组：\n\n     - `ret = __kill_pgrp_info(sig, info, pid ? find_vpid(-pid) : task_pgrp(current))`：调用 `__kill_pgrp_info` 函数，向指定的进程组发送信号。如果 `pid` 不为0，表示发送给指定的进程组，否则发送给当前进程组。\n\n   - 否则，表示要向所有非当前线程组中的进程发送信号：\n\n     - `int retval = 0, count = 0;`：初始化变量 `retval` 和 `count`，用于跟踪操作结果和计数。\n\n     - `struct task_struct * p;`：定义一个指向进程结构体的指针。\n\n     - `for_each_process(p)`：遍历所有进程。\n\n       - `if (task_pid_vnr(p) > 1 && !same_thread_group(p, current))`：检查进程的虚拟PID是否大于1（排除init进程和内核线程）以及是否属于与当前进程不同的线程组。\n\n         - `group_send_sig_info(sig, info, p)`：调用 `group_send_sig_info` 函数，向指定进程发送信号。\n\n         - `++count`：递增计数器。\n\n         - 如果返回值不是 `-EPERM`，将 `err` 赋值给 `retval`。\n\n     - `ret = count ? retval : -ESRCH;`：根据计数器判断是否有进程接收到信号，如果有则返回 `retval`，否则返回 `-ESRCH` 表示没有匹配的进程。\n\n   - `read_unlock(&tasklist_lock)`：释放进程列表读取锁。\n\n   - 返回 `ret`，表示操作的结果。\n\n参数 pid 不同取值含义：\n⚫ 如果 pid 为正，则信号 sig 将发送到 pid 指定的进程。\n⚫ 如果 pid 等于 0，则将 sig 发送到当前进程的进程组中的每个进程。\n⚫ 如果 pid 等于-1，则将 sig 发送到当前进程有权发送信号的每个进程，但进程 1（init）除外。\n⚫ 如果 pid 小于-1，则将 sig 发送到 ID 为-pid 的进程组中的每个进程。\n进程中将信号发送给另一个进程是需要权限的，并不是可以随便给任何一个进程发送信号，超级用户\nroot 进程可以将信号发送给任何进程，但对于非超级用户（普通用户）进程来说，其基本规则是发送者进程\n的实际用户 ID 或有效用户 ID 必须等于接收者进程的实际用户 ID 或有效用户 ID。\n\n## 信号传输的途径\n ```c\nint kill_pid_info(int sig, struct siginfo *info, struct pid *pid)\n{\n\tint error = -ESRCH;\n\tstruct task_struct *p;\n\n\tfor (;;) {\n\t\trcu_read_lock();\n\t\tp = pid_task(pid, PIDTYPE_PID);\n\t\tif (p)\n\t\t\terror = group_send_sig_info(sig, info, p);\n\t\trcu_read_unlock();\n\t\tif (likely(!p || error != -ESRCH))\n\t\t\treturn error;\n\n\t\t/*\n\t\t * The task was unhashed in between, try again.  If it\n\t\t * is dead, pid_task() will return NULL, if we race with\n\t\t * de_thread() it will find the new leader.\n\t\t */\n\t}\n}\n ```\n这段代码实现了 `kill_pid_info` 函数，它用于向指定的进程发送信号，并且会不断尝试直到发送成功或者出现错误。让我们逐步解释这段代码的功能：\n\n1. `int kill_pid_info(int sig, struct siginfo *info, struct pid *pid)`：这个函数用于向指定的进程发送信号。它接受信号编号 `sig`、信号信息结构体 `info` 和指向目标进程 `struct pid` 的指针作为参数。\n\n2. `int error = -ESRCH;`：初始化错误码为 `-ESRCH`，表示最初的状态是没有找到匹配的进程。\n\n3. `struct task_struct *p;`：定义一个指向进程结构体的指针。\n\n4. `for (;;) {`：进入无限循环，直到发送成功或出现错误。\n\n   - `rcu_read_lock();`：获取 RCU 读取锁。\n\n   - `p = pid_task(pid, PIDTYPE_PID);`：通过给定的 `struct pid` 和 `PIDTYPE_PID` 类型，获取与该PID相关联的进程的指针。\n\n   - `if (p)`：如果找到了相关的进程。\n\n     - `error = group_send_sig_info(sig, info, p);`：调用 `group_send_sig_info` 函数，向指定的进程发送信号，将结果保存在 `error` 中。\n\n   - `rcu_read_unlock();`：释放 RCU 读取锁。\n\n   - `if (likely(!p || error != -ESRCH))`：如果找不到相关进程，或者已经成功发送了信号，跳出循环。\n\n     - `return error;`：返回错误码。\n\n   - 如果进程不在哈希表中，很可能在 `pid_task` 调用期间被取消注册（unhashed），进程结构体可能已经不再可用。\n\n     - 循环重新开始，进行新一轮的尝试。\n\n   这个无限循环会不断尝试发送信号，直到成功发送信号给目标进程或出现错误。如果进程在循环中被取消注册，将会继续尝试直到进程结构体可用。\n\n这段代码实现了一个循环发送信号给指定进程的过程，如果目标进程存在，则发送信号并返回结果，如果目标进程不存在或出现错误，则会不断尝试直到发送成功或者出现无法恢复的错误。\n\n ```c\n int group_send_sig_info(int sig, struct siginfo *info, struct task_struct *p)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = check_kill_permission(sig, info, p);\n\trcu_read_unlock();\n\n\tif (!ret && sig)\n\t\tret = do_send_sig_info(sig, info, p, true);\n\n\treturn ret;\n}\n ```\n\n这段代码执行了以下操作：\n\n1. `rcu_read_lock();`：获取RCU（Read-Copy-Update）读取锁，确保在读取期间不会发生数据修改。\n\n2. `ret = check_kill_permission(sig, info, p);`：调用 `check_kill_permission` 函数，检查是否具有权限向进程组中的进程发送信号，并将结果保存在 `ret` 变量中。\n\n3. `rcu_read_unlock();`：释放RCU读取锁，允许其他线程继续操作。\n\n4. `if (!ret && sig)`：如果没有权限问题（`ret` 为0）且信号编号不为0（表示有信号需要发送）。\n\n   - `ret = do_send_sig_info(sig, info, p, true);`：调用 `do_send_sig_info` 函数，向进程组中的所有进程发送信号，将结果保存在 `ret` 中。\n\n5. 返回 `ret`，表示信号发送操作的结果。\n\n这段代码的目标是向一个进程组中的所有进程发送信号。在执行之前，它会检查是否具有足够的权限来发送信号。然后，如果有信号需要发送，它会调用 `do_send_sig_info` 函数来实际执行信号发送操作。\n\n ```c\nint do_send_sig_info(int sig, struct siginfo *info, struct task_struct *p,\n\t\t\tbool group)\n{\n\tunsigned long flags;\n\tint ret = -ESRCH;\n\n\tif (lock_task_sighand(p, &flags)) {\n\t\tret = send_signal(sig, info, p, group);\n\t\tunlock_task_sighand(p, &flags);\n\t}\n\n\treturn ret;\n}\n ```\n`do_send_sig_info` 函数，用于向一个特定进程发送信号，并且可以选择是否发送给整个进程组：\n\n1. `int do_send_sig_info(int sig, struct siginfo *info, struct task_struct *p, bool group)`：这个函数用于向指定的进程发送信号，可以选择是否发送给整个进程组。它接受信号编号 `sig`、信号信息结构体 `info`、目标进程结构体 `p`，以及一个布尔值 `group` 作为参数。\n\n2. `unsigned long flags;`：定义一个无符号长整型变量，用于保存中断标志。\n\n3. `int ret = -ESRCH;`：初始化结果变量为 `-ESRCH`，表示最初状态下信号发送操作没有成功。\n\n4. `if (lock_task_sighand(p, &flags))`：如果成功获取目标进程的信号处理锁。\n\n   - `lock_task_sighand` 会锁定进程的信号处理数据结构，以确保在发送信号的过程中没有其他线程干扰。\n\n5. `ret = send_signal(sig, info, p, group);`：调用 `send_signal` 函数，实际发送信号给目标进程。根据 `group` 参数的值，可以选择是否发送给整个进程组。\n\n6. `unlock_task_sighand(p, &flags);`：解锁目标进程的信号处理数据结构。\n\n7. 返回 `ret`，表示信号发送操作的结果。\n\n这段代码的目标是向指定的进程发送信号，并且根据传递的参数决定是否将信号发送给整个进程组。它会尝试锁定目标进程的信号处理数据结构，然后调用 `send_signal` 函数来实际发送信号。发送完成后，它会解锁信号处理数据结构并返回信号发送的结果。\n\n ```c\nstatic int send_signal(int sig, struct siginfo *info, struct task_struct *t,\n\t\t\tint group)\n{\n\tint from_ancestor_ns = 0;\n\n#ifdef CONFIG_PID_NS\n\tfrom_ancestor_ns = si_fromuser(info) &&\n\t\t\t   !task_pid_nr_ns(current, task_active_pid_ns(t));\n#endif\n\n\treturn __send_signal(sig, info, t, group, from_ancestor_ns);\n}\n ```\n\n  ```c\n\nstatic int __send_signal(int sig, struct siginfo *info, struct task_struct *t,\n\t\t\tint group, int from_ancestor_ns)\n{\n\tstruct sigpending *pending;\n\tstruct sigqueue *q;\n\tint override_rlimit;\n\tint ret = 0, result;\n\n\tassert_spin_locked(&t->sighand->siglock);\n\n\tresult = TRACE_SIGNAL_IGNORED;\n\tif (!prepare_signal(sig, t,\n\t\t\tfrom_ancestor_ns || (info == SEND_SIG_FORCED)))\n\t\tgoto ret;\n\n\tpending = group ? &t->signal->shared_pending : &t->pending;\n\t/*\n\t * Short-circuit ignored signals and support queuing\n\t * exactly one non-rt signal, so that we can get more\n\t * detailed information about the cause of the signal.\n\t */\n\tresult = TRACE_SIGNAL_ALREADY_PENDING;\n\tif (legacy_queue(pending, sig))\n\t\tgoto ret;\n\n\tresult = TRACE_SIGNAL_DELIVERED;\n\t/*\n\t * fast-pathed signals for kernel-internal things like SIGSTOP\n\t * or SIGKILL.\n\t */\n\tif (info == SEND_SIG_FORCED)\n\t\tgoto out_set;\n\n\t/*\n\t * Real-time signals must be queued if sent by sigqueue, or\n\t * some other real-time mechanism.  It is implementation\n\t * defined whether kill() does so.  We attempt to do so, on\n\t * the principle of least surprise, but since kill is not\n\t * allowed to fail with EAGAIN when low on memory we just\n\t * make sure at least one signal gets delivered and don't\n\t * pass on the info struct.\n\t */\n\tif (sig < SIGRTMIN)\n\t\toverride_rlimit = (is_si_special(info) || info->si_code >= 0);\n\telse\n\t\toverride_rlimit = 0;\n\n\tq = __sigqueue_alloc(sig, t, GFP_ATOMIC | __GFP_NOTRACK_FALSE_POSITIVE,\n\t\toverride_rlimit);\n\tif (q) {\n\t\tlist_add_tail(&q->list, &pending->list);\n\t\tswitch ((unsigned long) info) {\n\t\tcase (unsigned long) SEND_SIG_NOINFO:\n\t\t\tq->info.si_signo = sig;\n\t\t\tq->info.si_errno = 0;\n\t\t\tq->info.si_code = SI_USER;\n\t\t\tq->info.si_pid = task_tgid_nr_ns(current,\n\t\t\t\t\t\t\ttask_active_pid_ns(t));\n\t\t\tq->info.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\t\t\tbreak;\n\t\tcase (unsigned long) SEND_SIG_PRIV:\n\t\t\tq->info.si_signo = sig;\n\t\t\tq->info.si_errno = 0;\n\t\t\tq->info.si_code = SI_KERNEL;\n\t\t\tq->info.si_pid = 0;\n\t\t\tq->info.si_uid = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcopy_siginfo(&q->info, info);\n\t\t\tif (from_ancestor_ns)\n\t\t\t\tq->info.si_pid = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tuserns_fixup_signal_uid(&q->info, t);\n\n\t} else if (!is_si_special(info)) {\n\t\tif (sig >= SIGRTMIN && info->si_code != SI_USER) {\n\t\t\t/*\n\t\t\t * Queue overflow, abort.  We may abort if the\n\t\t\t * signal was rt and sent by user using something\n\t\t\t * other than kill().\n\t\t\t */\n\t\t\tresult = TRACE_SIGNAL_OVERFLOW_FAIL;\n\t\t\tret = -EAGAIN;\n\t\t\tgoto ret;\n\t\t} else {\n\t\t\t/*\n\t\t\t * This is a silent loss of information.  We still\n\t\t\t * send the signal, but the *info bits are lost.\n\t\t\t */\n\t\t\tresult = TRACE_SIGNAL_LOSE_INFO;\n\t\t}\n\t}\n\nout_set:\n\tsignalfd_notify(t, sig);\n\tsigaddset(&pending->signal, sig);\n\tcomplete_signal(sig, t, group);\nret:\n\ttrace_signal_generate(sig, info, t, group, result);\n\treturn ret;\n}\n ```\n\n这段代码实现了 `__send_signal` 函数，用于实际将信号发送给指定进程。这个函数是信号发送过程的核心部分：\n\n1. `int __send_signal(int sig, struct siginfo *info, struct task_struct *t, int group, int from_ancestor_ns)`：这个函数用于实际将信号发送给指定进程。它接受信号编号 `sig`、信号信息结构体 `info`、目标进程结构体 `t`、发送方式 `group` 和一个整数 `from_ancestor_ns` 作为参数。\n\n2. `assert_spin_locked(&t->sighand->siglock);`：确保当前进程已经获取了目标进程信号处理锁，以保证在信号发送过程中没有其他线程干扰。\n\n3. `result = TRACE_SIGNAL_IGNORED;`：初始化结果变量为 `TRACE_SIGNAL_IGNORED`，表示最初状态下信号被忽略。\n\n4. `if (!prepare_signal(sig, t, from_ancestor_ns || (info == SEND_SIG_FORCED)))`：如果无法准备发送信号。\n\n   - 调用 `prepare_signal` 函数来检查是否可以发送信号。如果无法准备发送，跳转到 `ret` 处返回结果。\n\n5. `pending = group ? &t->signal->shared_pending : &t->pending;`：根据 `group` 参数决定要使用的挂起信号列表，如果 `group` 为真，使用共享挂起信号列表，否则使用目标进程的挂起信号列表。\n\n6. `if (legacy_queue(pending, sig))`：如果将信号添加到挂起信号列表中。\n\n   - 调用 `legacy_queue` 函数，如果挂起信号列表中已经存在相同的信号，则表示该信号已经被挂起，跳转到 `ret` 处返回结果。\n\n7. `if (info == SEND_SIG_FORCED)`：如果信号信息是 `SEND_SIG_FORCED`。\n\n   - 直接跳转到 `out_set` 处，表示将信号添加到挂起信号列表中。\n\n8. 检查信号是否为实时信号或普通信号，并设置是否覆盖资源限制的标志。\n\n9. `q = __sigqueue_alloc(sig, t, GFP_ATOMIC | __GFP_NOTRACK_FALSE_POSITIVE, override_rlimit);`：调用 `__sigqueue_alloc` 函数分配一个信号队列节点，用于存储信号信息。\n\n10. 如果成功分配了信号队列节点 `q`，则将其添加到相应的挂起信号列表中，并根据 `info` 的情况填充信号信息结构体 `q->info`。\n\n11. 如果无法分配信号队列节点，判断是否为特殊信号，如果不是则处理队列溢出，如果是实时信号则返回失败。\n\n12. 调用 `signalfd_notify` 函数，通知与目标进程关联的 `signalfd` 文件描述符。\n\n13. 调用 `sigaddset` 函数，将信号添加到挂起信号集合中。\n\n14. 调用 `complete_signal` 函数函数会调用signal_wake_up。这个函数会将线程的TIF_SIGPENDING标志设为1。这样后面就可以快速检测是否有未处理的信号了\n\n15. 返回结果 `ret`，表示信号发送的结果。\n\n16. 最后，调用 `trace_signal_generate` 函数，记录信号发送的跟踪事件，并返回结果 `ret`。\n\n这段代码实现了实际的信号发送操作。它准备发送信号，判断是否需要加入挂起信号列表，处理特殊信号和实时信号，分配和填充信号信息结构体，通知 `signalfd` 文件描述符，添加信号到挂起信号集合，并最终完成信号发送的过程。\n\n## 信号被线程处理\n***当前进程陷入内核态，并准备返回用户态时处理信号***\n现在，当前进程正在正常执行。刚才已经有进程发送信号，通过send_signal将信号存储在了当前进程的Pending queue当中。当前进程显然不会立刻处理这个信号。处理信号的时机，实际上是当前进程因为一些原因陷入内核态，然后返回用户态的时候。\n\n现在，假设当前进程因为下面的原因进入内核态：\n⚫中断\n⚫系统调用\n⚫异常\n执行完内核态的操作之后，返回用户态。返回用户态内核内部将会使用这个函数：do_notify_resume函数：\n```c\nwork_pending:\n\ttbnz\tx1, #TIF_NEED_RESCHED, work_resched\n\t/* TIF_SIGPENDING, TIF_NOTIFY_RESUME or TIF_FOREIGN_FPSTATE case */\n\tldr\tx2, [sp, #S_PSTATE]\n\tmov\tx0, sp\t\t\t\t// 'regs'\n\ttst\tx2, #PSR_MODE_MASK\t\t// user mode regs?\n\tb.ne\tno_work_pending\t\t\t// returning to kernel\n\tenable_irq\t\t\t\t// enable interrupts for do_notify_resume()\n\tbl\tdo_notify_resume\n\tb\tret_to_user\nwork_resched:\n\tbl\tschedule\n\n/*\n * \"slow\" syscall return path.\n */\nret_to_user:\n\tdisable_irq\t\t\t\t// disable interrupts\n\tldr\tx1, [tsk, #TI_FLAGS]\n\tand\tx2, x1, #_TIF_WORK_MASK\n\tcbnz\tx2, work_pending\n\tenable_step_tsk x1, x2\nno_work_pending:\n\tkernel_exit 0, ret = 0\nENDPROC(ret_to_user)\n```\n\n```c\nasmlinkage void do_notify_resume(struct pt_regs *regs,\n                                 unsigned int thread_flags)\n{\n    // 如果线程标志中存在 _TIF_SIGPENDING 标志\n    if (thread_flags & _TIF_SIGPENDING)\n        // 调用 do_signal 函数来处理挂起的信号\n        do_signal(regs);\n\n    // 如果线程标志中存在 _TIF_NOTIFY_RESUME 标志\n    if (thread_flags & _TIF_NOTIFY_RESUME) {\n        // 清除线程标志中的 TIF_NOTIFY_RESUME 标志\n        clear_thread_flag(TIF_NOTIFY_RESUME);\n        // 调用 tracehook_notify_resume 函数来处理通知并恢复执行\n        tracehook_notify_resume(regs);\n    }\n\n    // 如果线程标志中存在 _TIF_FOREIGN_FPSTATE 标志\n    if (thread_flags & _TIF_FOREIGN_FPSTATE)\n        // 恢复当前状态的浮点寄存器/向量寄存器状态\n        fpsimd_restore_current_state();\n}\n```\n\n```c\nstatic void do_signal(struct pt_regs *regs)\n{\n\tunsigned long continue_addr = 0, restart_addr = 0;\n\tint retval = 0;\n\tint syscall = (int)regs->syscallno;\n\tstruct ksignal ksig;\n\n\t/*\n\t * 如果之前是从系统调用返回，检查是否需要重新启动系统调用...\n\t */\n\tif (syscall >= 0) {\n\t\tcontinue_addr = regs->pc;\n\t\trestart_addr = continue_addr - (compat_thumb_mode(regs) ? 2 : 4);\n\t\tretval = regs->regs[0];\n\n\t\t/*\n\t\t * 避免通过 ret_to_user 陷入额外的系统调用重新启动。\n\t\t */\n\t\tregs->syscallno = ~0UL;\n\n\t\t/*\n\t\t * 为系统调用重新启动做准备。我们在这里这样做是为了调试器能够看到已经更改的 PC。\n\t\t */\n\t\tswitch (retval) {\n\t\tcase -ERESTARTNOHAND:\n\t\tcase -ERESTARTSYS:\n\t\tcase -ERESTARTNOINTR:\n\t\tcase -ERESTART_RESTARTBLOCK:\n\t\t\tregs->regs[0] = regs->orig_x0;\n\t\t\tregs->pc = restart_addr;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * 获取要传递的信号。在运行时使用 ptrace 时，此时调试器可能会更改我们的所有寄存器。\n\t */\n\tif (get_signal(&ksig)) {\n\t\t/*\n\t\t * 根据信号的设置，可能需要撤消重新启动系统调用的决定，但如果调试器已选择在不同的 PC 上重新启动，则跳过此步骤。\n\t\t */\n\t\tif (regs->pc == restart_addr &&\n\t\t    (retval == -ERESTARTNOHAND ||\n\t\t     retval == -ERESTART_RESTARTBLOCK ||\n\t\t     (retval == -ERESTARTSYS &&\n\t\t      !(ksig.ka.sa.sa_flags & SA_RESTART)))) {\n\t\t\tregs->regs[0] = -EINTR;\n\t\t\tregs->pc = continue_addr;\n\t\t}\n\n\t\thandle_signal(&ksig, regs);\n\t\treturn;\n\t}\n\n\t/*\n\t * 处理重新启动不同的系统调用。与上述类似，如果调试器已选择在不同的 PC 上重新启动，则忽略重新启动。\n\t */\n\tif (syscall >= 0 && regs->pc == restart_addr) {\n\t\tif (retval == -ERESTART_RESTARTBLOCK)\n\t\t\tsetup_restart_syscall(regs);\n\t\tuser_rewind_single_step(current);\n\t}\n\n\trestore_saved_sigmask();\n}\n```\n可以看出，do_signal的核心是handle_signal\n\n```c\nstatic void handle_signal(struct ksignal *ksig, struct pt_regs *regs)\n{\n\tstruct task_struct *tsk = current;\n\tsigset_t *oldset = sigmask_to_save();\n\tint usig = ksig->sig;\n\tint ret;\n\n\t/*\n\t * Set up the stack frame\n\t */\n\tif (is_compat_task()) {\n\t\tif (ksig->ka.sa.sa_flags & SA_SIGINFO)\n\t\t\tret = compat_setup_rt_frame(usig, ksig, oldset, regs);\n\t\telse\n\t\t\tret = compat_setup_frame(usig, ksig, oldset, regs);\n\t} else {\n\t\tret = setup_rt_frame(usig, ksig, oldset, regs);\n\t}\n\n\t/*\n\t * Check that the resulting registers are actually sane.\n\t */\n\tret |= !valid_user_regs(&regs->user_regs);\n\n\t/*\n\t * Fast forward the stepping logic so we step into the signal\n\t * handler.\n\t */\n\tif (!ret)\n\t\tuser_fastforward_single_step(tsk);\n\n\tsignal_setup_done(ret, ksig, 0);\n}\n```\n这段代码实现了 `handle_signal` 函数，它负责在接收到信号时设置信号处理函数的栈帧并执行一些相关的处理：\n\n1. `struct task_struct *tsk = current;`：获取当前正在运行的任务的指针，也就是当前进程的任务结构体。\n\n2. `sigset_t *oldset = sigmask_to_save();`：获取当前进程的旧信号屏蔽集。\n\n3. `int usig = ksig->sig;`：获取要处理的信号的编号。\n\n4. `int ret;`：定义变量用于存储函数的返回值。\n\n5. 设置栈帧：\n\n   - 根据当前进程是否为兼容模式任务（32位应用程序在64位内核中运行），以及信号的设置情况，选择不同的栈帧设置函数。如果信号设置了 `SA_SIGINFO` 标志，调用对应的栈帧设置函数 `compat_setup_rt_frame`，否则调用 `compat_setup_frame`。\n   - 如果当前进程不是兼容模式任务，调用 `setup_rt_frame` 来设置栈帧。\n\n6. 检查生成的寄存器是否合理：\n\n   - 检查之前设置的用户寄存器是否合理。如果栈帧设置函数返回非零，或者用户寄存器不合理，将 `ret` 的相应位设置为 1，表示出现问题。\n\n7. 快速前进步进逻辑：\n\n   - 如果之前的操作没有问题，调用 `user_fastforward_single_step` 函数，以便能够在信号处理函数中进行单步调试。\n\n8. 完成信号设置：\n\n   - 调用 `signal_setup_done` 函数，将栈帧设置的结果、信号信息和其他参数传递给它。这个函数会通知调度程序信号处理已经准备完成。\n\n`handle_signal` 函数负责为信号处理函数设置栈帧，并根据情况执行相关处理，以确保信号的适当处理。这涉及了栈帧的设置、寄存器的检查、单步调试逻辑的前进，最终通知调度程序信号处理准备已完成，是通过setup_rt_frame来设定的。\n\n```c\nstatic int setup_rt_frame(int usig, struct ksignal *ksig, sigset_t *set,\n                          struct pt_regs *regs)\n{\n    struct rt_sigframe __user *frame; // 声明一个指向用户空间的信号栈帧结构体指针\n    int err = 0; // 初始化错误码变量\n\n    frame = get_sigframe(ksig, regs); // 获取适合信号处理函数的用户空间栈帧\n    if (!frame)\n        return 1; // 如果获取失败，返回错误码 1 表示出现问题\n\n    // 设置信号栈帧中的字段\n    __put_user_error(0, &frame->uc.uc_flags, err); // 将值 0 存储到 uc_flags 字段\n    __put_user_error(NULL, &frame->uc.uc_link, err); // 将 NULL 存储到 uc_link 字段\n\n    // 保存备用堆栈信息\n    err |= __save_altstack(&frame->uc.uc_stack, regs->sp);\n\n    err |= setup_sigframe(frame, regs, set); // 设置信号栈帧的其他字段\n    if (err == 0) {\n        setup_return(regs, &ksig->ka, frame, usig); // 设置返回点，用于信号处理函数返回时\n        if (ksig->ka.sa.sa_flags & SA_SIGINFO) {\n            err |= copy_siginfo_to_user(&frame->info, &ksig->info); // 将信号信息复制到栈帧中\n            regs->regs[1] = (unsigned long)&frame->info; // 设置寄存器中对应参数的值\n            regs->regs[2] = (unsigned long)&frame->uc;\n        }\n    }\n\n    return err; // 返回错误码，表示函数执行是否成功\n}\n```\n先看get_sigframe函数\n```c\nstatic struct rt_sigframe __user *get_sigframe(struct ksignal *ksig,\n                                               struct pt_regs *regs)\n{\n    unsigned long sp, sp_top;\n    struct rt_sigframe __user *frame; // 声明一个指向用户空间信号栈帧结构体的指针\n\n    sp = sp_top = sigsp(regs->sp, ksig); // 计算信号栈的起始地址\n\n    sp = (sp - sizeof(struct rt_sigframe)) & ~15; // 根据信号栈帧的大小和对齐要求调整栈指针\n    frame = (struct rt_sigframe __user *)sp; // 将栈指针指向调整后的位置，作为信号栈帧的起始地址\n\n    /*\n     * 检查我们是否可以实际写入信号栈帧。\n     */\n    if (!access_ok(VERIFY_WRITE, frame, sp_top - sp))\n        frame = NULL; // 如果无法写入信号栈帧，将 frame 设为 NULL\n\n    return frame; // 返回适合信号处理函数的用户空间栈帧指针\n}\n```\n注意，这里的一堆操作就是将sig值给寄存器，ip寄存器设置成信号处理函数指针。具体的堆栈以及寄存器的配置还不是太懂后续研究。\n处理完信号函数之后，进行一系列地恢复操作即可。首先恢复寄存器到陷入内核态之前的状态，然后恢复栈。这就是完整的信号生命周期\n\n## signal函数\n这段代码是 Linux 内核中 `signal` 系统调用的实现，用于设置信号的处理函数。以下是对代码中每一行的解释：\n\n```c\nSYSCALL_DEFINE2(signal, int, sig, __sighandler_t, handler)\n{\n    struct k_sigaction new_sa, old_sa; // 声明新旧信号处理动作的结构体\n    int ret; // 存储函数返回值的变量\n\n    new_sa.sa.sa_handler = handler; // 设置新的信号处理函数\n    new_sa.sa.sa_flags = SA_ONESHOT | SA_NOMASK; // 设置信号处理标志\n    sigemptyset(&new_sa.sa.sa_mask); // 初始化信号屏蔽集为空集\n\n    // 调用内核函数 do_sigaction 来设置信号处理动作\n    ret = do_sigaction(sig, &new_sa, &old_sa);\n\n    // 如果设置信号处理动作失败，返回错误码；否则返回旧的信号处理函数指针\n    return ret ? ret : (unsigned long)old_sa.sa.sa_handler;\n}\n```\n\n解释每个部分：\n\n- `struct k_sigaction new_sa, old_sa;`: 声明用于存储新旧信号处理动作的结构体。\n\n- `new_sa.sa.sa_handler = handler;`: 设置新的信号处理函数为传入的 `handler` 函数指针。\n\n- `new_sa.sa.sa_flags = SA_ONESHOT | SA_NOMASK;`: 设置新的信号处理标志，其中 `SA_ONESHOT` 表示信号处理函数只会执行一次，`SA_NOMASK` 表示在信号处理函数执行期间不会阻塞其他信号。\n\n- `sigemptyset(&new_sa.sa.sa_mask);`: 初始化新的信号处理函数的屏蔽信号集为空集，即在信号处理函数执行期间不会阻塞任何信号。\n\n- `ret = do_sigaction(sig, &new_sa, &old_sa);`: 调用内核函数 `do_sigaction` 来设置信号的处理动作，并将旧的信号处理动作保存在 `old_sa` 中。\n\n- `return ret ? ret : (unsigned long)old_sa.sa.sa_handler;`: 如果设置信号处理动作失败，返回错误码；否则返回旧的信号处理函数指针。\n\n这段代码实现了用户空间程序通过系统调用 `signal` 来设置指定信号的处理函数。新的信号处理动作由一个结构体表示，其中包含处理函数、处理标志等信息。然后，调用内核函数 `do_sigaction` 来将新的信号处理动作应用于进程的信号处理表，并返回旧的信号处理函数指针。\n\n这段代码是 Linux 内核中的 `do_sigaction` 函数，用于设置信号的处理动作。以下是对代码中每一行的解释：\n\n```c\nint do_sigaction(int sig, struct k_sigaction *act, struct k_sigaction *oact)\n{\n    struct task_struct *p = current, *t; // 获取当前进程和线程\n    struct k_sigaction *k; // 指向当前进程的信号处理表项的指针\n    sigset_t mask; // 信号屏蔽集\n\n    // 检查信号编号的有效性，以及是否是仅内核处理的信号\n    if (!valid_signal(sig) || sig < 1 || (act && sig_kernel_only(sig)))\n        return -EINVAL;\n\n    // 获取当前进程的信号处理表项\n    k = &p->sighand->action[sig-1];\n\n    spin_lock_irq(&p->sighand->siglock); // 获取信号处理表锁\n    if (oact)\n        *oact = *k; // 复制当前信号处理动作到旧的信号处理动作结构体\n\n    if (act) {\n        // 设置新信号处理动作，并从新动作的屏蔽集中排除 SIGKILL 和 SIGSTOP\n        sigdelsetmask(&act->sa.sa_mask,\n                      sigmask(SIGKILL) | sigmask(SIGSTOP));\n        *k = *act; // 复制新信号处理动作到当前信号处理表项\n\n        /*\n         * POSIX 3.3.1.3 规定：\n         * \"如果将挂起的信号的处理动作设置为 SIG_IGN，无论是否阻塞，都应将挂起的信号丢弃。\"\n         * \"如果将挂起的默认动作为 SIG_DFL，且默认动作是忽略信号（例如 SIGCHLD），则无论是否阻塞，都应将挂起的信号丢弃。\"\n         */\n        if (sig_handler_ignored(sig_handler(p, sig), sig)) {\n            sigemptyset(&mask);\n            sigaddset(&mask, sig);\n            flush_sigqueue_mask(&mask, &p->signal->shared_pending); // 清除挂起的共享信号队列中的对应信号\n            for_each_thread(p, t)\n                flush_sigqueue_mask(&mask, &t->pending); // 清除每个线程的挂起信号队列中的对应信号\n        }\n    }\n\n    spin_unlock_irq(&p->sighand->siglock); // 释放信号处理表锁\n    return 0; // 返回成功\n}\n```\n\n解释每个部分：\n\n- `struct task_struct *p = current, *t;`: 获取当前进程的 `task_struct` 结构体指针，并声明一个用于遍历线程的指针。\n\n- `k = &p->sighand->action[sig-1];`: 获取当前进程的信号处理表项，其中 `sighand` 是进程的信号处理句柄，`action` 是信号处理表数组。\n\n- `spin_lock_irq(&p->sighand->siglock);`: 获取当前进程信号处理表的锁，以确保多线程并发修改信号处理表时的同步。\n\n- `if (oact) *oact = *k;`: 如果传入了旧的信号处理动作指针 `oact`，则将当前信号处理表项的内容复制到旧的动作结构体中。\n\n- `if (act) { ... }`: 如果传入了新的信号处理动作指针 `act`，则进行以下操作：\n\n  - `sigdelsetmask(&act->sa.sa_mask, sigmask(SIGKILL) | sigmask(SIGSTOP));`: 从新的信号处理动作的屏蔽集中排除 `SIGKILL` 和 `SIGSTOP`，确保这两个信号不会被阻塞。\n\n  - `*k = *act;`: 复制新的信号处理动作到当前信号处理表项。\n\n  - 根据 POSIX 规定，如果新的信号处理动作是忽略信号或恢复默认动作，需要丢弃已挂起的对应信号。\n\n- `spin_unlock_irq(&p->sighand->siglock);`: 释放当前进程信号处理表的锁。\n\n- `return 0;`: 返回成功标志。\n\n综合来看，`do_sigaction` 函数用于设置信号的处理动作，根据传入的参数进行相应的处理，包括设置新的处理动作、排除某些屏蔽信号、丢弃已挂起的信号等操作。这是 Linux 内核中信号处理机制的一部分。\n\n## 内核signal handlers结构\n```c\nstruct task_struct {\n    *****************\n/* signal handlers */\n\tstruct signal_struct *signal;\n\tstruct sighand_struct *sighand;\n\n\tsigset_t blocked, real_blocked;\n\tsigset_t saved_sigmask;\t/* restored if set_restore_sigmask() was used */\n\tstruct sigpending pending;\n\n\tunsigned long sas_ss_sp;\n\tsize_t sas_ss_size;\n\tint (*notifier)(void *priv);\n\tvoid *notifier_data;\n\tsigset_t *notifier_mask;\n\tstruct callback_head *task_works;\n\n\tstruct audit_context *audit_context;\n#ifdef CONFIG_AUDITSYSCALL\n\tkuid_t loginuid;\n\tunsigned int sessionid;\n#endif\n\tstruct seccomp seccomp;\n    ****************\n}\n```\n- `signal_struct` 数据结构，用于表示进程的信号相关信息。\n\n- `struct sighand_struct *sighand;`: 指向进程的信号处理句柄（signal handler）的指针，其中包含有关进程信号处理函数的信息。\n\n- `sigset_t blocked, real_blocked;`: 分别表示进程当前阻塞的信号集合和实际阻塞的信号集合。\n\n- `sigset_t saved_sigmask;`: 保存在设置了 `set_restore_sigmask()` 时被恢复的信号掩码。\n\n- `struct sigpending pending;`: 挂起信号队列，包含了已经发送但尚未处理的信号。\n\n- `unsigned long sas_ss_sp;` 和 `size_t sas_ss_size;`: 用户态的备用信号栈（Alternate Signal Stack）的起始地址和大小。\n\n- `int (*notifier)(void *priv);`: 用于通知回调的函数指针。\n\n- `void *notifier_data;`: 传递给通知回调函数的私有数据。\n\n- `sigset_t *notifier_mask;`: 指向一个信号集，用于通知回调函数决定哪些信号需要通知。\n\n- `struct callback_head *task_works;`: 与进程关联的回调函数链表。\n\n- `struct audit_context *audit_context;`: 用于存储与审计相关的上下文信息。\n\n- `kuid_t loginuid;` 和 `unsigned int sessionid;`: 用于记录登录用户的用户ID和会话ID。\n\n- `struct seccomp seccomp;`: 用于存储与 seccomp（安全计算模式）相关的信息。\n\n这个数据结构存储了与进程信号相关的各种信息，包括信号处理函数、阻塞信号、挂起信号、备用信号栈、通知回调等。这些信息在 Linux 内核中用于管理和处理进程接收到的各种信号。\n```c\nstruct sighand_struct {\n\tatomic_t\t\tcount;\n\tstruct k_sigaction\taction[_NSIG];\n\tspinlock_t\t\tsiglock;\n\twait_queue_head_t\tsignalfd_wqh;\n};\n```\n其中的action是我们最需要关注的。它是一个长度为_NSIG的数组。下标为k的元素，就代表编号为k的信号的处理函数。k_sigaction实际上就是在内核态中对于sigaction的一个包装，signal函数就是将struct k_sigaction\taction[_NSIG]的相应为设置成指定的函数。\n\n","source":"_posts/2023/08/kill命令.md","raw":"---\ntitle: kill命令\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-08-09 11:32:53\npassword:\nsummary:\ntags:\n- linux\ncategories:\n- linux\nkeywords:\ndescription:\n---\n\n# kill命令是如何执行的\n## kill发送信号\n文件kernel/signal.c\n ```c\n /**\n *  sys_kill - send a signal to a process\n *  @pid: the PID of the process\n *  @sig: signal to be sent\n */\nSYSCALL_DEFINE2(kill, pid_t, pid, int, sig)\n{\n\tstruct siginfo info;\n\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code = SI_USER;\n\tinfo.si_pid = task_tgid_vnr(current);\n\tinfo.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\n\treturn kill_something_info(sig, &info, pid);\n}\n ```\n 这段代码是 Linux 内核中实现 `kill` 系统调用的部分。让我们逐步分析这段代码的功能：\n\n1. `SYSCALL_DEFINE2(kill, pid_t, pid, int, sig)`：这是一个宏，用于定义带有两个参数的系统调用 `kill`。`pid_t` 和 `int` 是参数的类型，`pid` 是要发送信号的目标进程的 ID，`sig` 是要发送的信号编号。\n\n2. `struct siginfo info`：这是一个结构体，用于保存信号的附加信息。\n\n3. `info.si_signo = sig`：将信号编号赋值给 `si_signo` 字段，表示要发送的信号的编号。\n\n4. `info.si_errno = 0`：将错误编号字段置为 0，表示没有错误。\n\n5. `info.si_code = SI_USER`：将信号代码字段设置为 `SI_USER`，表示该信号是由用户空间进程发送的。\n\n6. `info.si_pid = task_tgid_vnr(current)`：将当前进程的 TGID（线程组ID）作为发送信号的进程ID。\n\n7. `info.si_uid = from_kuid_munged(current_user_ns(), current_uid())`：将当前进程的有效用户ID转换为用户命名空间中的用户ID，并将结果赋值给发送信号的用户ID字段。\n\n8. `return kill_something_info(sig, &info, pid)`：调用 `kill_something_info` 函数，将信号编号、信号信息结构体和目标进程的ID作为参数传递，并返回结果。这个函数的功能是根据给定的参数发送信号给目标进程。\n\n这段代码实现了 `kill` 系统调用的功能。它接受一个目标进程ID和信号编号作为参数，然后构建一个带有信号信息的结构体，并调用相应的函数将信号发送给目标进程。这是 Linux 内核中管理进程间通信的一部分，允许一个进程向另一个进程发送信号以通知或影响其行为。\n\n ```c\n/*\n * kill_something_info() interprets pid in interesting ways just like kill(2).\n *\n * POSIX specifies that kill(-1,sig) is unspecified, but what we have\n * is probably wrong.  Should make it like BSD or SYSV.\n */\n\nstatic int kill_something_info(int sig, struct siginfo *info, pid_t pid)\n{\n\tint ret;\n\n\tif (pid > 0) {\n\t\trcu_read_lock();\n\t\tret = kill_pid_info(sig, info, find_vpid(pid));\n\t\trcu_read_unlock();\n\t\treturn ret;\n\t}\n\n\tread_lock(&tasklist_lock);\n\tif (pid != -1) {\n\t\tret = __kill_pgrp_info(sig, info,\n\t\t\t\tpid ? find_vpid(-pid) : task_pgrp(current));\n\t} else {\n\t\tint retval = 0, count = 0;\n\t\tstruct task_struct * p;\n\n\t\tfor_each_process(p) {\n\t\t\tif (task_pid_vnr(p) > 1 &&\n\t\t\t\t\t!same_thread_group(p, current)) {\n\t\t\t\tint err = group_send_sig_info(sig, info, p);\n\t\t\t\t++count;\n\t\t\t\tif (err != -EPERM)\n\t\t\t\t\tretval = err;\n\t\t\t}\n\t\t}\n\t\tret = count ? retval : -ESRCH;\n\t}\n\tread_unlock(&tasklist_lock);\n\n\treturn ret;\n}\n ```\n\n这段代码是 Linux 内核中用于实现 `kill_something_info` 函数的部分。这个函数用于向一个或多个进程发送信号，具体操作取决于传递的参数。让我们逐步解释这段代码的功能：\n\n1. `static int kill_something_info(int sig, struct siginfo *info, pid_t pid)`：这是一个静态函数，用于发送信号给一个或多个进程。它接受信号编号 `sig`、信号信息结构体 `info` 和目标进程的ID `pid` 作为参数。\n\n2. `if (pid > 0)`：如果目标进程ID大于0，表示要向指定PID的进程发送信号。\n\n   - `rcu_read_lock()`：获取 RCU（Read-Copy-Update）读取锁，确保在读取期间不会发生数据修改。\n\n   - `ret = kill_pid_info(sig, info, find_vpid(pid))`：调用 `kill_pid_info` 函数，向指定的进程发送信号，并传递信号编号、信号信息和目标进程的虚拟PID（vpid）。\n\n   - `rcu_read_unlock()`：释放 RCU 读取锁。\n\n   - 返回 `ret`，表示操作的结果。\n\n3. 如果 `pid` 不大于0：\n\n   - `read_lock(&tasklist_lock)`：获取进程列表读取锁，以确保在遍历进程列表期间不会发生修改。\n\n   - 如果 `pid` 不等于-1，表示要发送信号给指定的进程组：\n\n     - `ret = __kill_pgrp_info(sig, info, pid ? find_vpid(-pid) : task_pgrp(current))`：调用 `__kill_pgrp_info` 函数，向指定的进程组发送信号。如果 `pid` 不为0，表示发送给指定的进程组，否则发送给当前进程组。\n\n   - 否则，表示要向所有非当前线程组中的进程发送信号：\n\n     - `int retval = 0, count = 0;`：初始化变量 `retval` 和 `count`，用于跟踪操作结果和计数。\n\n     - `struct task_struct * p;`：定义一个指向进程结构体的指针。\n\n     - `for_each_process(p)`：遍历所有进程。\n\n       - `if (task_pid_vnr(p) > 1 && !same_thread_group(p, current))`：检查进程的虚拟PID是否大于1（排除init进程和内核线程）以及是否属于与当前进程不同的线程组。\n\n         - `group_send_sig_info(sig, info, p)`：调用 `group_send_sig_info` 函数，向指定进程发送信号。\n\n         - `++count`：递增计数器。\n\n         - 如果返回值不是 `-EPERM`，将 `err` 赋值给 `retval`。\n\n     - `ret = count ? retval : -ESRCH;`：根据计数器判断是否有进程接收到信号，如果有则返回 `retval`，否则返回 `-ESRCH` 表示没有匹配的进程。\n\n   - `read_unlock(&tasklist_lock)`：释放进程列表读取锁。\n\n   - 返回 `ret`，表示操作的结果。\n\n参数 pid 不同取值含义：\n⚫ 如果 pid 为正，则信号 sig 将发送到 pid 指定的进程。\n⚫ 如果 pid 等于 0，则将 sig 发送到当前进程的进程组中的每个进程。\n⚫ 如果 pid 等于-1，则将 sig 发送到当前进程有权发送信号的每个进程，但进程 1（init）除外。\n⚫ 如果 pid 小于-1，则将 sig 发送到 ID 为-pid 的进程组中的每个进程。\n进程中将信号发送给另一个进程是需要权限的，并不是可以随便给任何一个进程发送信号，超级用户\nroot 进程可以将信号发送给任何进程，但对于非超级用户（普通用户）进程来说，其基本规则是发送者进程\n的实际用户 ID 或有效用户 ID 必须等于接收者进程的实际用户 ID 或有效用户 ID。\n\n## 信号传输的途径\n ```c\nint kill_pid_info(int sig, struct siginfo *info, struct pid *pid)\n{\n\tint error = -ESRCH;\n\tstruct task_struct *p;\n\n\tfor (;;) {\n\t\trcu_read_lock();\n\t\tp = pid_task(pid, PIDTYPE_PID);\n\t\tif (p)\n\t\t\terror = group_send_sig_info(sig, info, p);\n\t\trcu_read_unlock();\n\t\tif (likely(!p || error != -ESRCH))\n\t\t\treturn error;\n\n\t\t/*\n\t\t * The task was unhashed in between, try again.  If it\n\t\t * is dead, pid_task() will return NULL, if we race with\n\t\t * de_thread() it will find the new leader.\n\t\t */\n\t}\n}\n ```\n这段代码实现了 `kill_pid_info` 函数，它用于向指定的进程发送信号，并且会不断尝试直到发送成功或者出现错误。让我们逐步解释这段代码的功能：\n\n1. `int kill_pid_info(int sig, struct siginfo *info, struct pid *pid)`：这个函数用于向指定的进程发送信号。它接受信号编号 `sig`、信号信息结构体 `info` 和指向目标进程 `struct pid` 的指针作为参数。\n\n2. `int error = -ESRCH;`：初始化错误码为 `-ESRCH`，表示最初的状态是没有找到匹配的进程。\n\n3. `struct task_struct *p;`：定义一个指向进程结构体的指针。\n\n4. `for (;;) {`：进入无限循环，直到发送成功或出现错误。\n\n   - `rcu_read_lock();`：获取 RCU 读取锁。\n\n   - `p = pid_task(pid, PIDTYPE_PID);`：通过给定的 `struct pid` 和 `PIDTYPE_PID` 类型，获取与该PID相关联的进程的指针。\n\n   - `if (p)`：如果找到了相关的进程。\n\n     - `error = group_send_sig_info(sig, info, p);`：调用 `group_send_sig_info` 函数，向指定的进程发送信号，将结果保存在 `error` 中。\n\n   - `rcu_read_unlock();`：释放 RCU 读取锁。\n\n   - `if (likely(!p || error != -ESRCH))`：如果找不到相关进程，或者已经成功发送了信号，跳出循环。\n\n     - `return error;`：返回错误码。\n\n   - 如果进程不在哈希表中，很可能在 `pid_task` 调用期间被取消注册（unhashed），进程结构体可能已经不再可用。\n\n     - 循环重新开始，进行新一轮的尝试。\n\n   这个无限循环会不断尝试发送信号，直到成功发送信号给目标进程或出现错误。如果进程在循环中被取消注册，将会继续尝试直到进程结构体可用。\n\n这段代码实现了一个循环发送信号给指定进程的过程，如果目标进程存在，则发送信号并返回结果，如果目标进程不存在或出现错误，则会不断尝试直到发送成功或者出现无法恢复的错误。\n\n ```c\n int group_send_sig_info(int sig, struct siginfo *info, struct task_struct *p)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = check_kill_permission(sig, info, p);\n\trcu_read_unlock();\n\n\tif (!ret && sig)\n\t\tret = do_send_sig_info(sig, info, p, true);\n\n\treturn ret;\n}\n ```\n\n这段代码执行了以下操作：\n\n1. `rcu_read_lock();`：获取RCU（Read-Copy-Update）读取锁，确保在读取期间不会发生数据修改。\n\n2. `ret = check_kill_permission(sig, info, p);`：调用 `check_kill_permission` 函数，检查是否具有权限向进程组中的进程发送信号，并将结果保存在 `ret` 变量中。\n\n3. `rcu_read_unlock();`：释放RCU读取锁，允许其他线程继续操作。\n\n4. `if (!ret && sig)`：如果没有权限问题（`ret` 为0）且信号编号不为0（表示有信号需要发送）。\n\n   - `ret = do_send_sig_info(sig, info, p, true);`：调用 `do_send_sig_info` 函数，向进程组中的所有进程发送信号，将结果保存在 `ret` 中。\n\n5. 返回 `ret`，表示信号发送操作的结果。\n\n这段代码的目标是向一个进程组中的所有进程发送信号。在执行之前，它会检查是否具有足够的权限来发送信号。然后，如果有信号需要发送，它会调用 `do_send_sig_info` 函数来实际执行信号发送操作。\n\n ```c\nint do_send_sig_info(int sig, struct siginfo *info, struct task_struct *p,\n\t\t\tbool group)\n{\n\tunsigned long flags;\n\tint ret = -ESRCH;\n\n\tif (lock_task_sighand(p, &flags)) {\n\t\tret = send_signal(sig, info, p, group);\n\t\tunlock_task_sighand(p, &flags);\n\t}\n\n\treturn ret;\n}\n ```\n`do_send_sig_info` 函数，用于向一个特定进程发送信号，并且可以选择是否发送给整个进程组：\n\n1. `int do_send_sig_info(int sig, struct siginfo *info, struct task_struct *p, bool group)`：这个函数用于向指定的进程发送信号，可以选择是否发送给整个进程组。它接受信号编号 `sig`、信号信息结构体 `info`、目标进程结构体 `p`，以及一个布尔值 `group` 作为参数。\n\n2. `unsigned long flags;`：定义一个无符号长整型变量，用于保存中断标志。\n\n3. `int ret = -ESRCH;`：初始化结果变量为 `-ESRCH`，表示最初状态下信号发送操作没有成功。\n\n4. `if (lock_task_sighand(p, &flags))`：如果成功获取目标进程的信号处理锁。\n\n   - `lock_task_sighand` 会锁定进程的信号处理数据结构，以确保在发送信号的过程中没有其他线程干扰。\n\n5. `ret = send_signal(sig, info, p, group);`：调用 `send_signal` 函数，实际发送信号给目标进程。根据 `group` 参数的值，可以选择是否发送给整个进程组。\n\n6. `unlock_task_sighand(p, &flags);`：解锁目标进程的信号处理数据结构。\n\n7. 返回 `ret`，表示信号发送操作的结果。\n\n这段代码的目标是向指定的进程发送信号，并且根据传递的参数决定是否将信号发送给整个进程组。它会尝试锁定目标进程的信号处理数据结构，然后调用 `send_signal` 函数来实际发送信号。发送完成后，它会解锁信号处理数据结构并返回信号发送的结果。\n\n ```c\nstatic int send_signal(int sig, struct siginfo *info, struct task_struct *t,\n\t\t\tint group)\n{\n\tint from_ancestor_ns = 0;\n\n#ifdef CONFIG_PID_NS\n\tfrom_ancestor_ns = si_fromuser(info) &&\n\t\t\t   !task_pid_nr_ns(current, task_active_pid_ns(t));\n#endif\n\n\treturn __send_signal(sig, info, t, group, from_ancestor_ns);\n}\n ```\n\n  ```c\n\nstatic int __send_signal(int sig, struct siginfo *info, struct task_struct *t,\n\t\t\tint group, int from_ancestor_ns)\n{\n\tstruct sigpending *pending;\n\tstruct sigqueue *q;\n\tint override_rlimit;\n\tint ret = 0, result;\n\n\tassert_spin_locked(&t->sighand->siglock);\n\n\tresult = TRACE_SIGNAL_IGNORED;\n\tif (!prepare_signal(sig, t,\n\t\t\tfrom_ancestor_ns || (info == SEND_SIG_FORCED)))\n\t\tgoto ret;\n\n\tpending = group ? &t->signal->shared_pending : &t->pending;\n\t/*\n\t * Short-circuit ignored signals and support queuing\n\t * exactly one non-rt signal, so that we can get more\n\t * detailed information about the cause of the signal.\n\t */\n\tresult = TRACE_SIGNAL_ALREADY_PENDING;\n\tif (legacy_queue(pending, sig))\n\t\tgoto ret;\n\n\tresult = TRACE_SIGNAL_DELIVERED;\n\t/*\n\t * fast-pathed signals for kernel-internal things like SIGSTOP\n\t * or SIGKILL.\n\t */\n\tif (info == SEND_SIG_FORCED)\n\t\tgoto out_set;\n\n\t/*\n\t * Real-time signals must be queued if sent by sigqueue, or\n\t * some other real-time mechanism.  It is implementation\n\t * defined whether kill() does so.  We attempt to do so, on\n\t * the principle of least surprise, but since kill is not\n\t * allowed to fail with EAGAIN when low on memory we just\n\t * make sure at least one signal gets delivered and don't\n\t * pass on the info struct.\n\t */\n\tif (sig < SIGRTMIN)\n\t\toverride_rlimit = (is_si_special(info) || info->si_code >= 0);\n\telse\n\t\toverride_rlimit = 0;\n\n\tq = __sigqueue_alloc(sig, t, GFP_ATOMIC | __GFP_NOTRACK_FALSE_POSITIVE,\n\t\toverride_rlimit);\n\tif (q) {\n\t\tlist_add_tail(&q->list, &pending->list);\n\t\tswitch ((unsigned long) info) {\n\t\tcase (unsigned long) SEND_SIG_NOINFO:\n\t\t\tq->info.si_signo = sig;\n\t\t\tq->info.si_errno = 0;\n\t\t\tq->info.si_code = SI_USER;\n\t\t\tq->info.si_pid = task_tgid_nr_ns(current,\n\t\t\t\t\t\t\ttask_active_pid_ns(t));\n\t\t\tq->info.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\t\t\tbreak;\n\t\tcase (unsigned long) SEND_SIG_PRIV:\n\t\t\tq->info.si_signo = sig;\n\t\t\tq->info.si_errno = 0;\n\t\t\tq->info.si_code = SI_KERNEL;\n\t\t\tq->info.si_pid = 0;\n\t\t\tq->info.si_uid = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcopy_siginfo(&q->info, info);\n\t\t\tif (from_ancestor_ns)\n\t\t\t\tq->info.si_pid = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tuserns_fixup_signal_uid(&q->info, t);\n\n\t} else if (!is_si_special(info)) {\n\t\tif (sig >= SIGRTMIN && info->si_code != SI_USER) {\n\t\t\t/*\n\t\t\t * Queue overflow, abort.  We may abort if the\n\t\t\t * signal was rt and sent by user using something\n\t\t\t * other than kill().\n\t\t\t */\n\t\t\tresult = TRACE_SIGNAL_OVERFLOW_FAIL;\n\t\t\tret = -EAGAIN;\n\t\t\tgoto ret;\n\t\t} else {\n\t\t\t/*\n\t\t\t * This is a silent loss of information.  We still\n\t\t\t * send the signal, but the *info bits are lost.\n\t\t\t */\n\t\t\tresult = TRACE_SIGNAL_LOSE_INFO;\n\t\t}\n\t}\n\nout_set:\n\tsignalfd_notify(t, sig);\n\tsigaddset(&pending->signal, sig);\n\tcomplete_signal(sig, t, group);\nret:\n\ttrace_signal_generate(sig, info, t, group, result);\n\treturn ret;\n}\n ```\n\n这段代码实现了 `__send_signal` 函数，用于实际将信号发送给指定进程。这个函数是信号发送过程的核心部分：\n\n1. `int __send_signal(int sig, struct siginfo *info, struct task_struct *t, int group, int from_ancestor_ns)`：这个函数用于实际将信号发送给指定进程。它接受信号编号 `sig`、信号信息结构体 `info`、目标进程结构体 `t`、发送方式 `group` 和一个整数 `from_ancestor_ns` 作为参数。\n\n2. `assert_spin_locked(&t->sighand->siglock);`：确保当前进程已经获取了目标进程信号处理锁，以保证在信号发送过程中没有其他线程干扰。\n\n3. `result = TRACE_SIGNAL_IGNORED;`：初始化结果变量为 `TRACE_SIGNAL_IGNORED`，表示最初状态下信号被忽略。\n\n4. `if (!prepare_signal(sig, t, from_ancestor_ns || (info == SEND_SIG_FORCED)))`：如果无法准备发送信号。\n\n   - 调用 `prepare_signal` 函数来检查是否可以发送信号。如果无法准备发送，跳转到 `ret` 处返回结果。\n\n5. `pending = group ? &t->signal->shared_pending : &t->pending;`：根据 `group` 参数决定要使用的挂起信号列表，如果 `group` 为真，使用共享挂起信号列表，否则使用目标进程的挂起信号列表。\n\n6. `if (legacy_queue(pending, sig))`：如果将信号添加到挂起信号列表中。\n\n   - 调用 `legacy_queue` 函数，如果挂起信号列表中已经存在相同的信号，则表示该信号已经被挂起，跳转到 `ret` 处返回结果。\n\n7. `if (info == SEND_SIG_FORCED)`：如果信号信息是 `SEND_SIG_FORCED`。\n\n   - 直接跳转到 `out_set` 处，表示将信号添加到挂起信号列表中。\n\n8. 检查信号是否为实时信号或普通信号，并设置是否覆盖资源限制的标志。\n\n9. `q = __sigqueue_alloc(sig, t, GFP_ATOMIC | __GFP_NOTRACK_FALSE_POSITIVE, override_rlimit);`：调用 `__sigqueue_alloc` 函数分配一个信号队列节点，用于存储信号信息。\n\n10. 如果成功分配了信号队列节点 `q`，则将其添加到相应的挂起信号列表中，并根据 `info` 的情况填充信号信息结构体 `q->info`。\n\n11. 如果无法分配信号队列节点，判断是否为特殊信号，如果不是则处理队列溢出，如果是实时信号则返回失败。\n\n12. 调用 `signalfd_notify` 函数，通知与目标进程关联的 `signalfd` 文件描述符。\n\n13. 调用 `sigaddset` 函数，将信号添加到挂起信号集合中。\n\n14. 调用 `complete_signal` 函数函数会调用signal_wake_up。这个函数会将线程的TIF_SIGPENDING标志设为1。这样后面就可以快速检测是否有未处理的信号了\n\n15. 返回结果 `ret`，表示信号发送的结果。\n\n16. 最后，调用 `trace_signal_generate` 函数，记录信号发送的跟踪事件，并返回结果 `ret`。\n\n这段代码实现了实际的信号发送操作。它准备发送信号，判断是否需要加入挂起信号列表，处理特殊信号和实时信号，分配和填充信号信息结构体，通知 `signalfd` 文件描述符，添加信号到挂起信号集合，并最终完成信号发送的过程。\n\n## 信号被线程处理\n***当前进程陷入内核态，并准备返回用户态时处理信号***\n现在，当前进程正在正常执行。刚才已经有进程发送信号，通过send_signal将信号存储在了当前进程的Pending queue当中。当前进程显然不会立刻处理这个信号。处理信号的时机，实际上是当前进程因为一些原因陷入内核态，然后返回用户态的时候。\n\n现在，假设当前进程因为下面的原因进入内核态：\n⚫中断\n⚫系统调用\n⚫异常\n执行完内核态的操作之后，返回用户态。返回用户态内核内部将会使用这个函数：do_notify_resume函数：\n```c\nwork_pending:\n\ttbnz\tx1, #TIF_NEED_RESCHED, work_resched\n\t/* TIF_SIGPENDING, TIF_NOTIFY_RESUME or TIF_FOREIGN_FPSTATE case */\n\tldr\tx2, [sp, #S_PSTATE]\n\tmov\tx0, sp\t\t\t\t// 'regs'\n\ttst\tx2, #PSR_MODE_MASK\t\t// user mode regs?\n\tb.ne\tno_work_pending\t\t\t// returning to kernel\n\tenable_irq\t\t\t\t// enable interrupts for do_notify_resume()\n\tbl\tdo_notify_resume\n\tb\tret_to_user\nwork_resched:\n\tbl\tschedule\n\n/*\n * \"slow\" syscall return path.\n */\nret_to_user:\n\tdisable_irq\t\t\t\t// disable interrupts\n\tldr\tx1, [tsk, #TI_FLAGS]\n\tand\tx2, x1, #_TIF_WORK_MASK\n\tcbnz\tx2, work_pending\n\tenable_step_tsk x1, x2\nno_work_pending:\n\tkernel_exit 0, ret = 0\nENDPROC(ret_to_user)\n```\n\n```c\nasmlinkage void do_notify_resume(struct pt_regs *regs,\n                                 unsigned int thread_flags)\n{\n    // 如果线程标志中存在 _TIF_SIGPENDING 标志\n    if (thread_flags & _TIF_SIGPENDING)\n        // 调用 do_signal 函数来处理挂起的信号\n        do_signal(regs);\n\n    // 如果线程标志中存在 _TIF_NOTIFY_RESUME 标志\n    if (thread_flags & _TIF_NOTIFY_RESUME) {\n        // 清除线程标志中的 TIF_NOTIFY_RESUME 标志\n        clear_thread_flag(TIF_NOTIFY_RESUME);\n        // 调用 tracehook_notify_resume 函数来处理通知并恢复执行\n        tracehook_notify_resume(regs);\n    }\n\n    // 如果线程标志中存在 _TIF_FOREIGN_FPSTATE 标志\n    if (thread_flags & _TIF_FOREIGN_FPSTATE)\n        // 恢复当前状态的浮点寄存器/向量寄存器状态\n        fpsimd_restore_current_state();\n}\n```\n\n```c\nstatic void do_signal(struct pt_regs *regs)\n{\n\tunsigned long continue_addr = 0, restart_addr = 0;\n\tint retval = 0;\n\tint syscall = (int)regs->syscallno;\n\tstruct ksignal ksig;\n\n\t/*\n\t * 如果之前是从系统调用返回，检查是否需要重新启动系统调用...\n\t */\n\tif (syscall >= 0) {\n\t\tcontinue_addr = regs->pc;\n\t\trestart_addr = continue_addr - (compat_thumb_mode(regs) ? 2 : 4);\n\t\tretval = regs->regs[0];\n\n\t\t/*\n\t\t * 避免通过 ret_to_user 陷入额外的系统调用重新启动。\n\t\t */\n\t\tregs->syscallno = ~0UL;\n\n\t\t/*\n\t\t * 为系统调用重新启动做准备。我们在这里这样做是为了调试器能够看到已经更改的 PC。\n\t\t */\n\t\tswitch (retval) {\n\t\tcase -ERESTARTNOHAND:\n\t\tcase -ERESTARTSYS:\n\t\tcase -ERESTARTNOINTR:\n\t\tcase -ERESTART_RESTARTBLOCK:\n\t\t\tregs->regs[0] = regs->orig_x0;\n\t\t\tregs->pc = restart_addr;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * 获取要传递的信号。在运行时使用 ptrace 时，此时调试器可能会更改我们的所有寄存器。\n\t */\n\tif (get_signal(&ksig)) {\n\t\t/*\n\t\t * 根据信号的设置，可能需要撤消重新启动系统调用的决定，但如果调试器已选择在不同的 PC 上重新启动，则跳过此步骤。\n\t\t */\n\t\tif (regs->pc == restart_addr &&\n\t\t    (retval == -ERESTARTNOHAND ||\n\t\t     retval == -ERESTART_RESTARTBLOCK ||\n\t\t     (retval == -ERESTARTSYS &&\n\t\t      !(ksig.ka.sa.sa_flags & SA_RESTART)))) {\n\t\t\tregs->regs[0] = -EINTR;\n\t\t\tregs->pc = continue_addr;\n\t\t}\n\n\t\thandle_signal(&ksig, regs);\n\t\treturn;\n\t}\n\n\t/*\n\t * 处理重新启动不同的系统调用。与上述类似，如果调试器已选择在不同的 PC 上重新启动，则忽略重新启动。\n\t */\n\tif (syscall >= 0 && regs->pc == restart_addr) {\n\t\tif (retval == -ERESTART_RESTARTBLOCK)\n\t\t\tsetup_restart_syscall(regs);\n\t\tuser_rewind_single_step(current);\n\t}\n\n\trestore_saved_sigmask();\n}\n```\n可以看出，do_signal的核心是handle_signal\n\n```c\nstatic void handle_signal(struct ksignal *ksig, struct pt_regs *regs)\n{\n\tstruct task_struct *tsk = current;\n\tsigset_t *oldset = sigmask_to_save();\n\tint usig = ksig->sig;\n\tint ret;\n\n\t/*\n\t * Set up the stack frame\n\t */\n\tif (is_compat_task()) {\n\t\tif (ksig->ka.sa.sa_flags & SA_SIGINFO)\n\t\t\tret = compat_setup_rt_frame(usig, ksig, oldset, regs);\n\t\telse\n\t\t\tret = compat_setup_frame(usig, ksig, oldset, regs);\n\t} else {\n\t\tret = setup_rt_frame(usig, ksig, oldset, regs);\n\t}\n\n\t/*\n\t * Check that the resulting registers are actually sane.\n\t */\n\tret |= !valid_user_regs(&regs->user_regs);\n\n\t/*\n\t * Fast forward the stepping logic so we step into the signal\n\t * handler.\n\t */\n\tif (!ret)\n\t\tuser_fastforward_single_step(tsk);\n\n\tsignal_setup_done(ret, ksig, 0);\n}\n```\n这段代码实现了 `handle_signal` 函数，它负责在接收到信号时设置信号处理函数的栈帧并执行一些相关的处理：\n\n1. `struct task_struct *tsk = current;`：获取当前正在运行的任务的指针，也就是当前进程的任务结构体。\n\n2. `sigset_t *oldset = sigmask_to_save();`：获取当前进程的旧信号屏蔽集。\n\n3. `int usig = ksig->sig;`：获取要处理的信号的编号。\n\n4. `int ret;`：定义变量用于存储函数的返回值。\n\n5. 设置栈帧：\n\n   - 根据当前进程是否为兼容模式任务（32位应用程序在64位内核中运行），以及信号的设置情况，选择不同的栈帧设置函数。如果信号设置了 `SA_SIGINFO` 标志，调用对应的栈帧设置函数 `compat_setup_rt_frame`，否则调用 `compat_setup_frame`。\n   - 如果当前进程不是兼容模式任务，调用 `setup_rt_frame` 来设置栈帧。\n\n6. 检查生成的寄存器是否合理：\n\n   - 检查之前设置的用户寄存器是否合理。如果栈帧设置函数返回非零，或者用户寄存器不合理，将 `ret` 的相应位设置为 1，表示出现问题。\n\n7. 快速前进步进逻辑：\n\n   - 如果之前的操作没有问题，调用 `user_fastforward_single_step` 函数，以便能够在信号处理函数中进行单步调试。\n\n8. 完成信号设置：\n\n   - 调用 `signal_setup_done` 函数，将栈帧设置的结果、信号信息和其他参数传递给它。这个函数会通知调度程序信号处理已经准备完成。\n\n`handle_signal` 函数负责为信号处理函数设置栈帧，并根据情况执行相关处理，以确保信号的适当处理。这涉及了栈帧的设置、寄存器的检查、单步调试逻辑的前进，最终通知调度程序信号处理准备已完成，是通过setup_rt_frame来设定的。\n\n```c\nstatic int setup_rt_frame(int usig, struct ksignal *ksig, sigset_t *set,\n                          struct pt_regs *regs)\n{\n    struct rt_sigframe __user *frame; // 声明一个指向用户空间的信号栈帧结构体指针\n    int err = 0; // 初始化错误码变量\n\n    frame = get_sigframe(ksig, regs); // 获取适合信号处理函数的用户空间栈帧\n    if (!frame)\n        return 1; // 如果获取失败，返回错误码 1 表示出现问题\n\n    // 设置信号栈帧中的字段\n    __put_user_error(0, &frame->uc.uc_flags, err); // 将值 0 存储到 uc_flags 字段\n    __put_user_error(NULL, &frame->uc.uc_link, err); // 将 NULL 存储到 uc_link 字段\n\n    // 保存备用堆栈信息\n    err |= __save_altstack(&frame->uc.uc_stack, regs->sp);\n\n    err |= setup_sigframe(frame, regs, set); // 设置信号栈帧的其他字段\n    if (err == 0) {\n        setup_return(regs, &ksig->ka, frame, usig); // 设置返回点，用于信号处理函数返回时\n        if (ksig->ka.sa.sa_flags & SA_SIGINFO) {\n            err |= copy_siginfo_to_user(&frame->info, &ksig->info); // 将信号信息复制到栈帧中\n            regs->regs[1] = (unsigned long)&frame->info; // 设置寄存器中对应参数的值\n            regs->regs[2] = (unsigned long)&frame->uc;\n        }\n    }\n\n    return err; // 返回错误码，表示函数执行是否成功\n}\n```\n先看get_sigframe函数\n```c\nstatic struct rt_sigframe __user *get_sigframe(struct ksignal *ksig,\n                                               struct pt_regs *regs)\n{\n    unsigned long sp, sp_top;\n    struct rt_sigframe __user *frame; // 声明一个指向用户空间信号栈帧结构体的指针\n\n    sp = sp_top = sigsp(regs->sp, ksig); // 计算信号栈的起始地址\n\n    sp = (sp - sizeof(struct rt_sigframe)) & ~15; // 根据信号栈帧的大小和对齐要求调整栈指针\n    frame = (struct rt_sigframe __user *)sp; // 将栈指针指向调整后的位置，作为信号栈帧的起始地址\n\n    /*\n     * 检查我们是否可以实际写入信号栈帧。\n     */\n    if (!access_ok(VERIFY_WRITE, frame, sp_top - sp))\n        frame = NULL; // 如果无法写入信号栈帧，将 frame 设为 NULL\n\n    return frame; // 返回适合信号处理函数的用户空间栈帧指针\n}\n```\n注意，这里的一堆操作就是将sig值给寄存器，ip寄存器设置成信号处理函数指针。具体的堆栈以及寄存器的配置还不是太懂后续研究。\n处理完信号函数之后，进行一系列地恢复操作即可。首先恢复寄存器到陷入内核态之前的状态，然后恢复栈。这就是完整的信号生命周期\n\n## signal函数\n这段代码是 Linux 内核中 `signal` 系统调用的实现，用于设置信号的处理函数。以下是对代码中每一行的解释：\n\n```c\nSYSCALL_DEFINE2(signal, int, sig, __sighandler_t, handler)\n{\n    struct k_sigaction new_sa, old_sa; // 声明新旧信号处理动作的结构体\n    int ret; // 存储函数返回值的变量\n\n    new_sa.sa.sa_handler = handler; // 设置新的信号处理函数\n    new_sa.sa.sa_flags = SA_ONESHOT | SA_NOMASK; // 设置信号处理标志\n    sigemptyset(&new_sa.sa.sa_mask); // 初始化信号屏蔽集为空集\n\n    // 调用内核函数 do_sigaction 来设置信号处理动作\n    ret = do_sigaction(sig, &new_sa, &old_sa);\n\n    // 如果设置信号处理动作失败，返回错误码；否则返回旧的信号处理函数指针\n    return ret ? ret : (unsigned long)old_sa.sa.sa_handler;\n}\n```\n\n解释每个部分：\n\n- `struct k_sigaction new_sa, old_sa;`: 声明用于存储新旧信号处理动作的结构体。\n\n- `new_sa.sa.sa_handler = handler;`: 设置新的信号处理函数为传入的 `handler` 函数指针。\n\n- `new_sa.sa.sa_flags = SA_ONESHOT | SA_NOMASK;`: 设置新的信号处理标志，其中 `SA_ONESHOT` 表示信号处理函数只会执行一次，`SA_NOMASK` 表示在信号处理函数执行期间不会阻塞其他信号。\n\n- `sigemptyset(&new_sa.sa.sa_mask);`: 初始化新的信号处理函数的屏蔽信号集为空集，即在信号处理函数执行期间不会阻塞任何信号。\n\n- `ret = do_sigaction(sig, &new_sa, &old_sa);`: 调用内核函数 `do_sigaction` 来设置信号的处理动作，并将旧的信号处理动作保存在 `old_sa` 中。\n\n- `return ret ? ret : (unsigned long)old_sa.sa.sa_handler;`: 如果设置信号处理动作失败，返回错误码；否则返回旧的信号处理函数指针。\n\n这段代码实现了用户空间程序通过系统调用 `signal` 来设置指定信号的处理函数。新的信号处理动作由一个结构体表示，其中包含处理函数、处理标志等信息。然后，调用内核函数 `do_sigaction` 来将新的信号处理动作应用于进程的信号处理表，并返回旧的信号处理函数指针。\n\n这段代码是 Linux 内核中的 `do_sigaction` 函数，用于设置信号的处理动作。以下是对代码中每一行的解释：\n\n```c\nint do_sigaction(int sig, struct k_sigaction *act, struct k_sigaction *oact)\n{\n    struct task_struct *p = current, *t; // 获取当前进程和线程\n    struct k_sigaction *k; // 指向当前进程的信号处理表项的指针\n    sigset_t mask; // 信号屏蔽集\n\n    // 检查信号编号的有效性，以及是否是仅内核处理的信号\n    if (!valid_signal(sig) || sig < 1 || (act && sig_kernel_only(sig)))\n        return -EINVAL;\n\n    // 获取当前进程的信号处理表项\n    k = &p->sighand->action[sig-1];\n\n    spin_lock_irq(&p->sighand->siglock); // 获取信号处理表锁\n    if (oact)\n        *oact = *k; // 复制当前信号处理动作到旧的信号处理动作结构体\n\n    if (act) {\n        // 设置新信号处理动作，并从新动作的屏蔽集中排除 SIGKILL 和 SIGSTOP\n        sigdelsetmask(&act->sa.sa_mask,\n                      sigmask(SIGKILL) | sigmask(SIGSTOP));\n        *k = *act; // 复制新信号处理动作到当前信号处理表项\n\n        /*\n         * POSIX 3.3.1.3 规定：\n         * \"如果将挂起的信号的处理动作设置为 SIG_IGN，无论是否阻塞，都应将挂起的信号丢弃。\"\n         * \"如果将挂起的默认动作为 SIG_DFL，且默认动作是忽略信号（例如 SIGCHLD），则无论是否阻塞，都应将挂起的信号丢弃。\"\n         */\n        if (sig_handler_ignored(sig_handler(p, sig), sig)) {\n            sigemptyset(&mask);\n            sigaddset(&mask, sig);\n            flush_sigqueue_mask(&mask, &p->signal->shared_pending); // 清除挂起的共享信号队列中的对应信号\n            for_each_thread(p, t)\n                flush_sigqueue_mask(&mask, &t->pending); // 清除每个线程的挂起信号队列中的对应信号\n        }\n    }\n\n    spin_unlock_irq(&p->sighand->siglock); // 释放信号处理表锁\n    return 0; // 返回成功\n}\n```\n\n解释每个部分：\n\n- `struct task_struct *p = current, *t;`: 获取当前进程的 `task_struct` 结构体指针，并声明一个用于遍历线程的指针。\n\n- `k = &p->sighand->action[sig-1];`: 获取当前进程的信号处理表项，其中 `sighand` 是进程的信号处理句柄，`action` 是信号处理表数组。\n\n- `spin_lock_irq(&p->sighand->siglock);`: 获取当前进程信号处理表的锁，以确保多线程并发修改信号处理表时的同步。\n\n- `if (oact) *oact = *k;`: 如果传入了旧的信号处理动作指针 `oact`，则将当前信号处理表项的内容复制到旧的动作结构体中。\n\n- `if (act) { ... }`: 如果传入了新的信号处理动作指针 `act`，则进行以下操作：\n\n  - `sigdelsetmask(&act->sa.sa_mask, sigmask(SIGKILL) | sigmask(SIGSTOP));`: 从新的信号处理动作的屏蔽集中排除 `SIGKILL` 和 `SIGSTOP`，确保这两个信号不会被阻塞。\n\n  - `*k = *act;`: 复制新的信号处理动作到当前信号处理表项。\n\n  - 根据 POSIX 规定，如果新的信号处理动作是忽略信号或恢复默认动作，需要丢弃已挂起的对应信号。\n\n- `spin_unlock_irq(&p->sighand->siglock);`: 释放当前进程信号处理表的锁。\n\n- `return 0;`: 返回成功标志。\n\n综合来看，`do_sigaction` 函数用于设置信号的处理动作，根据传入的参数进行相应的处理，包括设置新的处理动作、排除某些屏蔽信号、丢弃已挂起的信号等操作。这是 Linux 内核中信号处理机制的一部分。\n\n## 内核signal handlers结构\n```c\nstruct task_struct {\n    *****************\n/* signal handlers */\n\tstruct signal_struct *signal;\n\tstruct sighand_struct *sighand;\n\n\tsigset_t blocked, real_blocked;\n\tsigset_t saved_sigmask;\t/* restored if set_restore_sigmask() was used */\n\tstruct sigpending pending;\n\n\tunsigned long sas_ss_sp;\n\tsize_t sas_ss_size;\n\tint (*notifier)(void *priv);\n\tvoid *notifier_data;\n\tsigset_t *notifier_mask;\n\tstruct callback_head *task_works;\n\n\tstruct audit_context *audit_context;\n#ifdef CONFIG_AUDITSYSCALL\n\tkuid_t loginuid;\n\tunsigned int sessionid;\n#endif\n\tstruct seccomp seccomp;\n    ****************\n}\n```\n- `signal_struct` 数据结构，用于表示进程的信号相关信息。\n\n- `struct sighand_struct *sighand;`: 指向进程的信号处理句柄（signal handler）的指针，其中包含有关进程信号处理函数的信息。\n\n- `sigset_t blocked, real_blocked;`: 分别表示进程当前阻塞的信号集合和实际阻塞的信号集合。\n\n- `sigset_t saved_sigmask;`: 保存在设置了 `set_restore_sigmask()` 时被恢复的信号掩码。\n\n- `struct sigpending pending;`: 挂起信号队列，包含了已经发送但尚未处理的信号。\n\n- `unsigned long sas_ss_sp;` 和 `size_t sas_ss_size;`: 用户态的备用信号栈（Alternate Signal Stack）的起始地址和大小。\n\n- `int (*notifier)(void *priv);`: 用于通知回调的函数指针。\n\n- `void *notifier_data;`: 传递给通知回调函数的私有数据。\n\n- `sigset_t *notifier_mask;`: 指向一个信号集，用于通知回调函数决定哪些信号需要通知。\n\n- `struct callback_head *task_works;`: 与进程关联的回调函数链表。\n\n- `struct audit_context *audit_context;`: 用于存储与审计相关的上下文信息。\n\n- `kuid_t loginuid;` 和 `unsigned int sessionid;`: 用于记录登录用户的用户ID和会话ID。\n\n- `struct seccomp seccomp;`: 用于存储与 seccomp（安全计算模式）相关的信息。\n\n这个数据结构存储了与进程信号相关的各种信息，包括信号处理函数、阻塞信号、挂起信号、备用信号栈、通知回调等。这些信息在 Linux 内核中用于管理和处理进程接收到的各种信号。\n```c\nstruct sighand_struct {\n\tatomic_t\t\tcount;\n\tstruct k_sigaction\taction[_NSIG];\n\tspinlock_t\t\tsiglock;\n\twait_queue_head_t\tsignalfd_wqh;\n};\n```\n其中的action是我们最需要关注的。它是一个长度为_NSIG的数组。下标为k的元素，就代表编号为k的信号的处理函数。k_sigaction实际上就是在内核态中对于sigaction的一个包装，signal函数就是将struct k_sigaction\taction[_NSIG]的相应为设置成指定的函数。\n\n","slug":"kill命令","published":1,"updated":"2024-01-05T08:12:19.803Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clru1g21n001zs4fu9pug0u4i","content":"<h1 id=\"kill命令是如何执行的\"><a href=\"#kill命令是如何执行的\" class=\"headerlink\" title=\"kill命令是如何执行的\"></a>kill命令是如何执行的</h1><h2 id=\"kill发送信号\"><a href=\"#kill发送信号\" class=\"headerlink\" title=\"kill发送信号\"></a>kill发送信号</h2><p>文件kernel/signal.c</p>\n<pre class=\" language-c\"><code class=\"language-c\"> <span class=\"token comment\" spellcheck=\"true\">/**\n *  sys_kill - send a signal to a process\n *  @pid: the PID of the process\n *  @sig: signal to be sent\n */</span>\n<span class=\"token function\">SYSCALL_DEFINE2</span><span class=\"token punctuation\">(</span>kill<span class=\"token punctuation\">,</span> pid_t<span class=\"token punctuation\">,</span> pid<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> sig<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">struct</span> siginfo info<span class=\"token punctuation\">;</span>\n\n    info<span class=\"token punctuation\">.</span>si_signo <span class=\"token operator\">=</span> sig<span class=\"token punctuation\">;</span>\n    info<span class=\"token punctuation\">.</span>si_errno <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    info<span class=\"token punctuation\">.</span>si_code <span class=\"token operator\">=</span> SI_USER<span class=\"token punctuation\">;</span>\n    info<span class=\"token punctuation\">.</span>si_pid <span class=\"token operator\">=</span> <span class=\"token function\">task_tgid_vnr</span><span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    info<span class=\"token punctuation\">.</span>si_uid <span class=\"token operator\">=</span> <span class=\"token function\">from_kuid_munged</span><span class=\"token punctuation\">(</span><span class=\"token function\">current_user_ns</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">current_uid</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token function\">kill_something_info</span><span class=\"token punctuation\">(</span>sig<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>info<span class=\"token punctuation\">,</span> pid<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p> 这段代码是 Linux 内核中实现 <code>kill</code> 系统调用的部分。让我们逐步分析这段代码的功能：</p>\n<ol>\n<li><p><code>SYSCALL_DEFINE2(kill, pid_t, pid, int, sig)</code>：这是一个宏，用于定义带有两个参数的系统调用 <code>kill</code>。<code>pid_t</code> 和 <code>int</code> 是参数的类型，<code>pid</code> 是要发送信号的目标进程的 ID，<code>sig</code> 是要发送的信号编号。</p>\n</li>\n<li><p><code>struct siginfo info</code>：这是一个结构体，用于保存信号的附加信息。</p>\n</li>\n<li><p><code>info.si_signo = sig</code>：将信号编号赋值给 <code>si_signo</code> 字段，表示要发送的信号的编号。</p>\n</li>\n<li><p><code>info.si_errno = 0</code>：将错误编号字段置为 0，表示没有错误。</p>\n</li>\n<li><p><code>info.si_code = SI_USER</code>：将信号代码字段设置为 <code>SI_USER</code>，表示该信号是由用户空间进程发送的。</p>\n</li>\n<li><p><code>info.si_pid = task_tgid_vnr(current)</code>：将当前进程的 TGID（线程组ID）作为发送信号的进程ID。</p>\n</li>\n<li><p><code>info.si_uid = from_kuid_munged(current_user_ns(), current_uid())</code>：将当前进程的有效用户ID转换为用户命名空间中的用户ID，并将结果赋值给发送信号的用户ID字段。</p>\n</li>\n<li><p><code>return kill_something_info(sig, &amp;info, pid)</code>：调用 <code>kill_something_info</code> 函数，将信号编号、信号信息结构体和目标进程的ID作为参数传递，并返回结果。这个函数的功能是根据给定的参数发送信号给目标进程。</p>\n</li>\n</ol>\n<p>这段代码实现了 <code>kill</code> 系统调用的功能。它接受一个目标进程ID和信号编号作为参数，然后构建一个带有信号信息的结构体，并调用相应的函数将信号发送给目标进程。这是 Linux 内核中管理进程间通信的一部分，允许一个进程向另一个进程发送信号以通知或影响其行为。</p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token comment\" spellcheck=\"true\">/*\n * kill_something_info() interprets pid in interesting ways just like kill(2).\n *\n * POSIX specifies that kill(-1,sig) is unspecified, but what we have\n * is probably wrong.  Should make it like BSD or SYSV.\n */</span>\n\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">kill_something_info</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> sig<span class=\"token punctuation\">,</span> <span class=\"token keyword\">struct</span> siginfo <span class=\"token operator\">*</span>info<span class=\"token punctuation\">,</span> pid_t pid<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> ret<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pid <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">rcu_read_lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        ret <span class=\"token operator\">=</span> <span class=\"token function\">kill_pid_info</span><span class=\"token punctuation\">(</span>sig<span class=\"token punctuation\">,</span> info<span class=\"token punctuation\">,</span> <span class=\"token function\">find_vpid</span><span class=\"token punctuation\">(</span>pid<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">rcu_read_unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> ret<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">read_lock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>tasklist_lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pid <span class=\"token operator\">!=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        ret <span class=\"token operator\">=</span> <span class=\"token function\">__kill_pgrp_info</span><span class=\"token punctuation\">(</span>sig<span class=\"token punctuation\">,</span> info<span class=\"token punctuation\">,</span>\n                pid <span class=\"token operator\">?</span> <span class=\"token function\">find_vpid</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span>pid<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span> <span class=\"token function\">task_pgrp</span><span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> retval <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> count <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">struct</span> task_struct <span class=\"token operator\">*</span> p<span class=\"token punctuation\">;</span>\n\n        <span class=\"token function\">for_each_process</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">task_pid_vnr</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span>\n                    <span class=\"token operator\">!</span><span class=\"token function\">same_thread_group</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">,</span> current<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">int</span> err <span class=\"token operator\">=</span> <span class=\"token function\">group_send_sig_info</span><span class=\"token punctuation\">(</span>sig<span class=\"token punctuation\">,</span> info<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token operator\">++</span>count<span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>err <span class=\"token operator\">!=</span> <span class=\"token operator\">-</span>EPERM<span class=\"token punctuation\">)</span>\n                    retval <span class=\"token operator\">=</span> err<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        ret <span class=\"token operator\">=</span> count <span class=\"token operator\">?</span> retval <span class=\"token punctuation\">:</span> <span class=\"token operator\">-</span>ESRCH<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">read_unlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>tasklist_lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> ret<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>这段代码是 Linux 内核中用于实现 <code>kill_something_info</code> 函数的部分。这个函数用于向一个或多个进程发送信号，具体操作取决于传递的参数。让我们逐步解释这段代码的功能：</p>\n<ol>\n<li><p><code>static int kill_something_info(int sig, struct siginfo *info, pid_t pid)</code>：这是一个静态函数，用于发送信号给一个或多个进程。它接受信号编号 <code>sig</code>、信号信息结构体 <code>info</code> 和目标进程的ID <code>pid</code> 作为参数。</p>\n</li>\n<li><p><code>if (pid &gt; 0)</code>：如果目标进程ID大于0，表示要向指定PID的进程发送信号。</p>\n<ul>\n<li><p><code>rcu_read_lock()</code>：获取 RCU（Read-Copy-Update）读取锁，确保在读取期间不会发生数据修改。</p>\n</li>\n<li><p><code>ret = kill_pid_info(sig, info, find_vpid(pid))</code>：调用 <code>kill_pid_info</code> 函数，向指定的进程发送信号，并传递信号编号、信号信息和目标进程的虚拟PID（vpid）。</p>\n</li>\n<li><p><code>rcu_read_unlock()</code>：释放 RCU 读取锁。</p>\n</li>\n<li><p>返回 <code>ret</code>，表示操作的结果。</p>\n</li>\n</ul>\n</li>\n<li><p>如果 <code>pid</code> 不大于0：</p>\n<ul>\n<li><p><code>read_lock(&amp;tasklist_lock)</code>：获取进程列表读取锁，以确保在遍历进程列表期间不会发生修改。</p>\n</li>\n<li><p>如果 <code>pid</code> 不等于-1，表示要发送信号给指定的进程组：</p>\n<ul>\n<li><code>ret = __kill_pgrp_info(sig, info, pid ? find_vpid(-pid) : task_pgrp(current))</code>：调用 <code>__kill_pgrp_info</code> 函数，向指定的进程组发送信号。如果 <code>pid</code> 不为0，表示发送给指定的进程组，否则发送给当前进程组。</li>\n</ul>\n</li>\n<li><p>否则，表示要向所有非当前线程组中的进程发送信号：</p>\n<ul>\n<li><p><code>int retval = 0, count = 0;</code>：初始化变量 <code>retval</code> 和 <code>count</code>，用于跟踪操作结果和计数。</p>\n</li>\n<li><p><code>struct task_struct * p;</code>：定义一个指向进程结构体的指针。</p>\n</li>\n<li><p><code>for_each_process(p)</code>：遍历所有进程。</p>\n<ul>\n<li><p><code>if (task_pid_vnr(p) &gt; 1 &amp;&amp; !same_thread_group(p, current))</code>：检查进程的虚拟PID是否大于1（排除init进程和内核线程）以及是否属于与当前进程不同的线程组。</p>\n<ul>\n<li><p><code>group_send_sig_info(sig, info, p)</code>：调用 <code>group_send_sig_info</code> 函数，向指定进程发送信号。</p>\n</li>\n<li><p><code>++count</code>：递增计数器。</p>\n</li>\n<li><p>如果返回值不是 <code>-EPERM</code>，将 <code>err</code> 赋值给 <code>retval</code>。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><code>ret = count ? retval : -ESRCH;</code>：根据计数器判断是否有进程接收到信号，如果有则返回 <code>retval</code>，否则返回 <code>-ESRCH</code> 表示没有匹配的进程。</p>\n</li>\n</ul>\n</li>\n<li><p><code>read_unlock(&amp;tasklist_lock)</code>：释放进程列表读取锁。</p>\n</li>\n<li><p>返回 <code>ret</code>，表示操作的结果。</p>\n</li>\n</ul>\n</li>\n</ol>\n<p>参数 pid 不同取值含义：<br>⚫ 如果 pid 为正，则信号 sig 将发送到 pid 指定的进程。<br>⚫ 如果 pid 等于 0，则将 sig 发送到当前进程的进程组中的每个进程。<br>⚫ 如果 pid 等于-1，则将 sig 发送到当前进程有权发送信号的每个进程，但进程 1（init）除外。<br>⚫ 如果 pid 小于-1，则将 sig 发送到 ID 为-pid 的进程组中的每个进程。<br>进程中将信号发送给另一个进程是需要权限的，并不是可以随便给任何一个进程发送信号，超级用户<br>root 进程可以将信号发送给任何进程，但对于非超级用户（普通用户）进程来说，其基本规则是发送者进程<br>的实际用户 ID 或有效用户 ID 必须等于接收者进程的实际用户 ID 或有效用户 ID。</p>\n<h2 id=\"信号传输的途径\"><a href=\"#信号传输的途径\" class=\"headerlink\" title=\"信号传输的途径\"></a>信号传输的途径</h2><pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">kill_pid_info</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> sig<span class=\"token punctuation\">,</span> <span class=\"token keyword\">struct</span> siginfo <span class=\"token operator\">*</span>info<span class=\"token punctuation\">,</span> <span class=\"token keyword\">struct</span> pid <span class=\"token operator\">*</span>pid<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> error <span class=\"token operator\">=</span> <span class=\"token operator\">-</span>ESRCH<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">struct</span> task_struct <span class=\"token operator\">*</span>p<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">rcu_read_lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        p <span class=\"token operator\">=</span> <span class=\"token function\">pid_task</span><span class=\"token punctuation\">(</span>pid<span class=\"token punctuation\">,</span> PIDTYPE_PID<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span>\n            error <span class=\"token operator\">=</span> <span class=\"token function\">group_send_sig_info</span><span class=\"token punctuation\">(</span>sig<span class=\"token punctuation\">,</span> info<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">rcu_read_unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">likely</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>p <span class=\"token operator\">||</span> error <span class=\"token operator\">!=</span> <span class=\"token operator\">-</span>ESRCH<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> error<span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">/*\n         * The task was unhashed in between, try again.  If it\n         * is dead, pid_task() will return NULL, if we race with\n         * de_thread() it will find the new leader.\n         */</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>这段代码实现了 <code>kill_pid_info</code> 函数，它用于向指定的进程发送信号，并且会不断尝试直到发送成功或者出现错误。让我们逐步解释这段代码的功能：</p>\n<ol>\n<li><p><code>int kill_pid_info(int sig, struct siginfo *info, struct pid *pid)</code>：这个函数用于向指定的进程发送信号。它接受信号编号 <code>sig</code>、信号信息结构体 <code>info</code> 和指向目标进程 <code>struct pid</code> 的指针作为参数。</p>\n</li>\n<li><p><code>int error = -ESRCH;</code>：初始化错误码为 <code>-ESRCH</code>，表示最初的状态是没有找到匹配的进程。</p>\n</li>\n<li><p><code>struct task_struct *p;</code>：定义一个指向进程结构体的指针。</p>\n</li>\n<li><p><code>for (;;) {</code>：进入无限循环，直到发送成功或出现错误。</p>\n<ul>\n<li><p><code>rcu_read_lock();</code>：获取 RCU 读取锁。</p>\n</li>\n<li><p><code>p = pid_task(pid, PIDTYPE_PID);</code>：通过给定的 <code>struct pid</code> 和 <code>PIDTYPE_PID</code> 类型，获取与该PID相关联的进程的指针。</p>\n</li>\n<li><p><code>if (p)</code>：如果找到了相关的进程。</p>\n<ul>\n<li><code>error = group_send_sig_info(sig, info, p);</code>：调用 <code>group_send_sig_info</code> 函数，向指定的进程发送信号，将结果保存在 <code>error</code> 中。</li>\n</ul>\n</li>\n<li><p><code>rcu_read_unlock();</code>：释放 RCU 读取锁。</p>\n</li>\n<li><p><code>if (likely(!p || error != -ESRCH))</code>：如果找不到相关进程，或者已经成功发送了信号，跳出循环。</p>\n<ul>\n<li><code>return error;</code>：返回错误码。</li>\n</ul>\n</li>\n<li><p>如果进程不在哈希表中，很可能在 <code>pid_task</code> 调用期间被取消注册（unhashed），进程结构体可能已经不再可用。</p>\n<ul>\n<li>循环重新开始，进行新一轮的尝试。</li>\n</ul>\n</li>\n</ul>\n<p>这个无限循环会不断尝试发送信号，直到成功发送信号给目标进程或出现错误。如果进程在循环中被取消注册，将会继续尝试直到进程结构体可用。</p>\n</li>\n</ol>\n<p>这段代码实现了一个循环发送信号给指定进程的过程，如果目标进程存在，则发送信号并返回结果，如果目标进程不存在或出现错误，则会不断尝试直到发送成功或者出现无法恢复的错误。</p>\n<pre class=\" language-c\"><code class=\"language-c\"> <span class=\"token keyword\">int</span> <span class=\"token function\">group_send_sig_info</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> sig<span class=\"token punctuation\">,</span> <span class=\"token keyword\">struct</span> siginfo <span class=\"token operator\">*</span>info<span class=\"token punctuation\">,</span> <span class=\"token keyword\">struct</span> task_struct <span class=\"token operator\">*</span>p<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> ret<span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">rcu_read_lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    ret <span class=\"token operator\">=</span> <span class=\"token function\">check_kill_permission</span><span class=\"token punctuation\">(</span>sig<span class=\"token punctuation\">,</span> info<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">rcu_read_unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>ret <span class=\"token operator\">&amp;&amp;</span> sig<span class=\"token punctuation\">)</span>\n        ret <span class=\"token operator\">=</span> <span class=\"token function\">do_send_sig_info</span><span class=\"token punctuation\">(</span>sig<span class=\"token punctuation\">,</span> info<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">,</span> true<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> ret<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>这段代码执行了以下操作：</p>\n<ol>\n<li><p><code>rcu_read_lock();</code>：获取RCU（Read-Copy-Update）读取锁，确保在读取期间不会发生数据修改。</p>\n</li>\n<li><p><code>ret = check_kill_permission(sig, info, p);</code>：调用 <code>check_kill_permission</code> 函数，检查是否具有权限向进程组中的进程发送信号，并将结果保存在 <code>ret</code> 变量中。</p>\n</li>\n<li><p><code>rcu_read_unlock();</code>：释放RCU读取锁，允许其他线程继续操作。</p>\n</li>\n<li><p><code>if (!ret &amp;&amp; sig)</code>：如果没有权限问题（<code>ret</code> 为0）且信号编号不为0（表示有信号需要发送）。</p>\n<ul>\n<li><code>ret = do_send_sig_info(sig, info, p, true);</code>：调用 <code>do_send_sig_info</code> 函数，向进程组中的所有进程发送信号，将结果保存在 <code>ret</code> 中。</li>\n</ul>\n</li>\n<li><p>返回 <code>ret</code>，表示信号发送操作的结果。</p>\n</li>\n</ol>\n<p>这段代码的目标是向一个进程组中的所有进程发送信号。在执行之前，它会检查是否具有足够的权限来发送信号。然后，如果有信号需要发送，它会调用 <code>do_send_sig_info</code> 函数来实际执行信号发送操作。</p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">do_send_sig_info</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> sig<span class=\"token punctuation\">,</span> <span class=\"token keyword\">struct</span> siginfo <span class=\"token operator\">*</span>info<span class=\"token punctuation\">,</span> <span class=\"token keyword\">struct</span> task_struct <span class=\"token operator\">*</span>p<span class=\"token punctuation\">,</span>\n            bool group<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> flags<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> ret <span class=\"token operator\">=</span> <span class=\"token operator\">-</span>ESRCH<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">lock_task_sighand</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>flags<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        ret <span class=\"token operator\">=</span> <span class=\"token function\">send_signal</span><span class=\"token punctuation\">(</span>sig<span class=\"token punctuation\">,</span> info<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">,</span> group<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">unlock_task_sighand</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>flags<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> ret<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><code>do_send_sig_info</code> 函数，用于向一个特定进程发送信号，并且可以选择是否发送给整个进程组：</p>\n<ol>\n<li><p><code>int do_send_sig_info(int sig, struct siginfo *info, struct task_struct *p, bool group)</code>：这个函数用于向指定的进程发送信号，可以选择是否发送给整个进程组。它接受信号编号 <code>sig</code>、信号信息结构体 <code>info</code>、目标进程结构体 <code>p</code>，以及一个布尔值 <code>group</code> 作为参数。</p>\n</li>\n<li><p><code>unsigned long flags;</code>：定义一个无符号长整型变量，用于保存中断标志。</p>\n</li>\n<li><p><code>int ret = -ESRCH;</code>：初始化结果变量为 <code>-ESRCH</code>，表示最初状态下信号发送操作没有成功。</p>\n</li>\n<li><p><code>if (lock_task_sighand(p, &amp;flags))</code>：如果成功获取目标进程的信号处理锁。</p>\n<ul>\n<li><code>lock_task_sighand</code> 会锁定进程的信号处理数据结构，以确保在发送信号的过程中没有其他线程干扰。</li>\n</ul>\n</li>\n<li><p><code>ret = send_signal(sig, info, p, group);</code>：调用 <code>send_signal</code> 函数，实际发送信号给目标进程。根据 <code>group</code> 参数的值，可以选择是否发送给整个进程组。</p>\n</li>\n<li><p><code>unlock_task_sighand(p, &amp;flags);</code>：解锁目标进程的信号处理数据结构。</p>\n</li>\n<li><p>返回 <code>ret</code>，表示信号发送操作的结果。</p>\n</li>\n</ol>\n<p>这段代码的目标是向指定的进程发送信号，并且根据传递的参数决定是否将信号发送给整个进程组。它会尝试锁定目标进程的信号处理数据结构，然后调用 <code>send_signal</code> 函数来实际发送信号。发送完成后，它会解锁信号处理数据结构并返回信号发送的结果。</p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">send_signal</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> sig<span class=\"token punctuation\">,</span> <span class=\"token keyword\">struct</span> siginfo <span class=\"token operator\">*</span>info<span class=\"token punctuation\">,</span> <span class=\"token keyword\">struct</span> task_struct <span class=\"token operator\">*</span>t<span class=\"token punctuation\">,</span>\n            <span class=\"token keyword\">int</span> group<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> from_ancestor_ns <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token macro property\">#<span class=\"token directive keyword\">ifdef</span> CONFIG_PID_NS</span>\n    from_ancestor_ns <span class=\"token operator\">=</span> <span class=\"token function\">si_fromuser</span><span class=\"token punctuation\">(</span>info<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span>\n               <span class=\"token operator\">!</span><span class=\"token function\">task_pid_nr_ns</span><span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">,</span> <span class=\"token function\">task_active_pid_ns</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">endif</span></span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token function\">__send_signal</span><span class=\"token punctuation\">(</span>sig<span class=\"token punctuation\">,</span> info<span class=\"token punctuation\">,</span> t<span class=\"token punctuation\">,</span> group<span class=\"token punctuation\">,</span> from_ancestor_ns<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-c\"><code class=\"language-c\">\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">__send_signal</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> sig<span class=\"token punctuation\">,</span> <span class=\"token keyword\">struct</span> siginfo <span class=\"token operator\">*</span>info<span class=\"token punctuation\">,</span> <span class=\"token keyword\">struct</span> task_struct <span class=\"token operator\">*</span>t<span class=\"token punctuation\">,</span>\n            <span class=\"token keyword\">int</span> group<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> from_ancestor_ns<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">struct</span> sigpending <span class=\"token operator\">*</span>pending<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">struct</span> sigqueue <span class=\"token operator\">*</span>q<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> override_rlimit<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> ret <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">assert_spin_locked</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>t<span class=\"token operator\">-></span>sighand<span class=\"token operator\">-></span>siglock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    result <span class=\"token operator\">=</span> TRACE_SIGNAL_IGNORED<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">prepare_signal</span><span class=\"token punctuation\">(</span>sig<span class=\"token punctuation\">,</span> t<span class=\"token punctuation\">,</span>\n            from_ancestor_ns <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>info <span class=\"token operator\">==</span> SEND_SIG_FORCED<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">goto</span> ret<span class=\"token punctuation\">;</span>\n\n    pending <span class=\"token operator\">=</span> group <span class=\"token operator\">?</span> <span class=\"token operator\">&amp;</span>t<span class=\"token operator\">-></span>signal<span class=\"token operator\">-></span>shared_pending <span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span>t<span class=\"token operator\">-></span>pending<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">/*\n     * Short-circuit ignored signals and support queuing\n     * exactly one non-rt signal, so that we can get more\n     * detailed information about the cause of the signal.\n     */</span>\n    result <span class=\"token operator\">=</span> TRACE_SIGNAL_ALREADY_PENDING<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">legacy_queue</span><span class=\"token punctuation\">(</span>pending<span class=\"token punctuation\">,</span> sig<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">goto</span> ret<span class=\"token punctuation\">;</span>\n\n    result <span class=\"token operator\">=</span> TRACE_SIGNAL_DELIVERED<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">/*\n     * fast-pathed signals for kernel-internal things like SIGSTOP\n     * or SIGKILL.\n     */</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>info <span class=\"token operator\">==</span> SEND_SIG_FORCED<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">goto</span> out_set<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/*\n     * Real-time signals must be queued if sent by sigqueue, or\n     * some other real-time mechanism.  It is implementation\n     * defined whether kill() does so.  We attempt to do so, on\n     * the principle of least surprise, but since kill is not\n     * allowed to fail with EAGAIN when low on memory we just\n     * make sure at least one signal gets delivered and don't\n     * pass on the info struct.\n     */</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>sig <span class=\"token operator\">&lt;</span> SIGRTMIN<span class=\"token punctuation\">)</span>\n        override_rlimit <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token function\">is_si_special</span><span class=\"token punctuation\">(</span>info<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> info<span class=\"token operator\">-></span>si_code <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span>\n        override_rlimit <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    q <span class=\"token operator\">=</span> <span class=\"token function\">__sigqueue_alloc</span><span class=\"token punctuation\">(</span>sig<span class=\"token punctuation\">,</span> t<span class=\"token punctuation\">,</span> GFP_ATOMIC <span class=\"token operator\">|</span> __GFP_NOTRACK_FALSE_POSITIVE<span class=\"token punctuation\">,</span>\n        override_rlimit<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">list_add_tail</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>q<span class=\"token operator\">-></span>list<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>pending<span class=\"token operator\">-></span>list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">)</span> info<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">case</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">)</span> SEND_SIG_NOINFO<span class=\"token punctuation\">:</span>\n            q<span class=\"token operator\">-></span>info<span class=\"token punctuation\">.</span>si_signo <span class=\"token operator\">=</span> sig<span class=\"token punctuation\">;</span>\n            q<span class=\"token operator\">-></span>info<span class=\"token punctuation\">.</span>si_errno <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n            q<span class=\"token operator\">-></span>info<span class=\"token punctuation\">.</span>si_code <span class=\"token operator\">=</span> SI_USER<span class=\"token punctuation\">;</span>\n            q<span class=\"token operator\">-></span>info<span class=\"token punctuation\">.</span>si_pid <span class=\"token operator\">=</span> <span class=\"token function\">task_tgid_nr_ns</span><span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">,</span>\n                            <span class=\"token function\">task_active_pid_ns</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            q<span class=\"token operator\">-></span>info<span class=\"token punctuation\">.</span>si_uid <span class=\"token operator\">=</span> <span class=\"token function\">from_kuid_munged</span><span class=\"token punctuation\">(</span><span class=\"token function\">current_user_ns</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">current_uid</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">case</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">)</span> SEND_SIG_PRIV<span class=\"token punctuation\">:</span>\n            q<span class=\"token operator\">-></span>info<span class=\"token punctuation\">.</span>si_signo <span class=\"token operator\">=</span> sig<span class=\"token punctuation\">;</span>\n            q<span class=\"token operator\">-></span>info<span class=\"token punctuation\">.</span>si_errno <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n            q<span class=\"token operator\">-></span>info<span class=\"token punctuation\">.</span>si_code <span class=\"token operator\">=</span> SI_KERNEL<span class=\"token punctuation\">;</span>\n            q<span class=\"token operator\">-></span>info<span class=\"token punctuation\">.</span>si_pid <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n            q<span class=\"token operator\">-></span>info<span class=\"token punctuation\">.</span>si_uid <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">default</span><span class=\"token punctuation\">:</span>\n            <span class=\"token function\">copy_siginfo</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>q<span class=\"token operator\">-></span>info<span class=\"token punctuation\">,</span> info<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>from_ancestor_ns<span class=\"token punctuation\">)</span>\n                q<span class=\"token operator\">-></span>info<span class=\"token punctuation\">.</span>si_pid <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token function\">userns_fixup_signal_uid</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>q<span class=\"token operator\">-></span>info<span class=\"token punctuation\">,</span> t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">is_si_special</span><span class=\"token punctuation\">(</span>info<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>sig <span class=\"token operator\">>=</span> SIGRTMIN <span class=\"token operator\">&amp;&amp;</span> info<span class=\"token operator\">-></span>si_code <span class=\"token operator\">!=</span> SI_USER<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">/*\n             * Queue overflow, abort.  We may abort if the\n             * signal was rt and sent by user using something\n             * other than kill().\n             */</span>\n            result <span class=\"token operator\">=</span> TRACE_SIGNAL_OVERFLOW_FAIL<span class=\"token punctuation\">;</span>\n            ret <span class=\"token operator\">=</span> <span class=\"token operator\">-</span>EAGAIN<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">goto</span> ret<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">/*\n             * This is a silent loss of information.  We still\n             * send the signal, but the *info bits are lost.\n             */</span>\n            result <span class=\"token operator\">=</span> TRACE_SIGNAL_LOSE_INFO<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\nout_set<span class=\"token punctuation\">:</span>\n    <span class=\"token function\">signalfd_notify</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">,</span> sig<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">sigaddset</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>pending<span class=\"token operator\">-></span>signal<span class=\"token punctuation\">,</span> sig<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">complete_signal</span><span class=\"token punctuation\">(</span>sig<span class=\"token punctuation\">,</span> t<span class=\"token punctuation\">,</span> group<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nret<span class=\"token punctuation\">:</span>\n    <span class=\"token function\">trace_signal_generate</span><span class=\"token punctuation\">(</span>sig<span class=\"token punctuation\">,</span> info<span class=\"token punctuation\">,</span> t<span class=\"token punctuation\">,</span> group<span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> ret<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>这段代码实现了 <code>__send_signal</code> 函数，用于实际将信号发送给指定进程。这个函数是信号发送过程的核心部分：</p>\n<ol>\n<li><p><code>int __send_signal(int sig, struct siginfo *info, struct task_struct *t, int group, int from_ancestor_ns)</code>：这个函数用于实际将信号发送给指定进程。它接受信号编号 <code>sig</code>、信号信息结构体 <code>info</code>、目标进程结构体 <code>t</code>、发送方式 <code>group</code> 和一个整数 <code>from_ancestor_ns</code> 作为参数。</p>\n</li>\n<li><p><code>assert_spin_locked(&amp;t-&gt;sighand-&gt;siglock);</code>：确保当前进程已经获取了目标进程信号处理锁，以保证在信号发送过程中没有其他线程干扰。</p>\n</li>\n<li><p><code>result = TRACE_SIGNAL_IGNORED;</code>：初始化结果变量为 <code>TRACE_SIGNAL_IGNORED</code>，表示最初状态下信号被忽略。</p>\n</li>\n<li><p><code>if (!prepare_signal(sig, t, from_ancestor_ns || (info == SEND_SIG_FORCED)))</code>：如果无法准备发送信号。</p>\n<ul>\n<li>调用 <code>prepare_signal</code> 函数来检查是否可以发送信号。如果无法准备发送，跳转到 <code>ret</code> 处返回结果。</li>\n</ul>\n</li>\n<li><p><code>pending = group ? &amp;t-&gt;signal-&gt;shared_pending : &amp;t-&gt;pending;</code>：根据 <code>group</code> 参数决定要使用的挂起信号列表，如果 <code>group</code> 为真，使用共享挂起信号列表，否则使用目标进程的挂起信号列表。</p>\n</li>\n<li><p><code>if (legacy_queue(pending, sig))</code>：如果将信号添加到挂起信号列表中。</p>\n<ul>\n<li>调用 <code>legacy_queue</code> 函数，如果挂起信号列表中已经存在相同的信号，则表示该信号已经被挂起，跳转到 <code>ret</code> 处返回结果。</li>\n</ul>\n</li>\n<li><p><code>if (info == SEND_SIG_FORCED)</code>：如果信号信息是 <code>SEND_SIG_FORCED</code>。</p>\n<ul>\n<li>直接跳转到 <code>out_set</code> 处，表示将信号添加到挂起信号列表中。</li>\n</ul>\n</li>\n<li><p>检查信号是否为实时信号或普通信号，并设置是否覆盖资源限制的标志。</p>\n</li>\n<li><p><code>q = __sigqueue_alloc(sig, t, GFP_ATOMIC | __GFP_NOTRACK_FALSE_POSITIVE, override_rlimit);</code>：调用 <code>__sigqueue_alloc</code> 函数分配一个信号队列节点，用于存储信号信息。</p>\n</li>\n<li><p>如果成功分配了信号队列节点 <code>q</code>，则将其添加到相应的挂起信号列表中，并根据 <code>info</code> 的情况填充信号信息结构体 <code>q-&gt;info</code>。</p>\n</li>\n<li><p>如果无法分配信号队列节点，判断是否为特殊信号，如果不是则处理队列溢出，如果是实时信号则返回失败。</p>\n</li>\n<li><p>调用 <code>signalfd_notify</code> 函数，通知与目标进程关联的 <code>signalfd</code> 文件描述符。</p>\n</li>\n<li><p>调用 <code>sigaddset</code> 函数，将信号添加到挂起信号集合中。</p>\n</li>\n<li><p>调用 <code>complete_signal</code> 函数函数会调用signal_wake_up。这个函数会将线程的TIF_SIGPENDING标志设为1。这样后面就可以快速检测是否有未处理的信号了</p>\n</li>\n<li><p>返回结果 <code>ret</code>，表示信号发送的结果。</p>\n</li>\n<li><p>最后，调用 <code>trace_signal_generate</code> 函数，记录信号发送的跟踪事件，并返回结果 <code>ret</code>。</p>\n</li>\n</ol>\n<p>这段代码实现了实际的信号发送操作。它准备发送信号，判断是否需要加入挂起信号列表，处理特殊信号和实时信号，分配和填充信号信息结构体，通知 <code>signalfd</code> 文件描述符，添加信号到挂起信号集合，并最终完成信号发送的过程。</p>\n<h2 id=\"信号被线程处理\"><a href=\"#信号被线程处理\" class=\"headerlink\" title=\"信号被线程处理\"></a>信号被线程处理</h2><p><strong><em>当前进程陷入内核态，并准备返回用户态时处理信号</em></strong><br>现在，当前进程正在正常执行。刚才已经有进程发送信号，通过send_signal将信号存储在了当前进程的Pending queue当中。当前进程显然不会立刻处理这个信号。处理信号的时机，实际上是当前进程因为一些原因陷入内核态，然后返回用户态的时候。</p>\n<p>现在，假设当前进程因为下面的原因进入内核态：<br>⚫中断<br>⚫系统调用<br>⚫异常<br>执行完内核态的操作之后，返回用户态。返回用户态内核内部将会使用这个函数：do_notify_resume函数：</p>\n<pre class=\" language-c\"><code class=\"language-c\">work_pending<span class=\"token punctuation\">:</span>\n    tbnz    x1<span class=\"token punctuation\">,</span> #TIF_NEED_RESCHED<span class=\"token punctuation\">,</span> work_resched\n    <span class=\"token comment\" spellcheck=\"true\">/* TIF_SIGPENDING, TIF_NOTIFY_RESUME or TIF_FOREIGN_FPSTATE case */</span>\n    ldr    x2<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>sp<span class=\"token punctuation\">,</span> #S_PSTATE<span class=\"token punctuation\">]</span>\n    mov    x0<span class=\"token punctuation\">,</span> sp                <span class=\"token comment\" spellcheck=\"true\">// 'regs'</span>\n    tst    x2<span class=\"token punctuation\">,</span> #PSR_MODE_MASK        <span class=\"token comment\" spellcheck=\"true\">// user mode regs?</span>\n    b<span class=\"token punctuation\">.</span>ne    no_work_pending            <span class=\"token comment\" spellcheck=\"true\">// returning to kernel</span>\n    enable_irq                <span class=\"token comment\" spellcheck=\"true\">// enable interrupts for do_notify_resume()</span>\n    bl    do_notify_resume\n    b    ret_to_user\nwork_resched<span class=\"token punctuation\">:</span>\n    bl    schedule\n\n<span class=\"token comment\" spellcheck=\"true\">/*\n * \"slow\" syscall return path.\n */</span>\nret_to_user<span class=\"token punctuation\">:</span>\n    disable_irq                <span class=\"token comment\" spellcheck=\"true\">// disable interrupts</span>\n    ldr    x1<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>tsk<span class=\"token punctuation\">,</span> #TI_FLAGS<span class=\"token punctuation\">]</span>\n    and    x2<span class=\"token punctuation\">,</span> x1<span class=\"token punctuation\">,</span> #_TIF_WORK_MASK\n    cbnz    x2<span class=\"token punctuation\">,</span> work_pending\n    enable_step_tsk x1<span class=\"token punctuation\">,</span> x2\nno_work_pending<span class=\"token punctuation\">:</span>\n    kernel_exit <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> ret <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n<span class=\"token function\">ENDPROC</span><span class=\"token punctuation\">(</span>ret_to_user<span class=\"token punctuation\">)</span></code></pre>\n<pre class=\" language-c\"><code class=\"language-c\">asmlinkage <span class=\"token keyword\">void</span> <span class=\"token function\">do_notify_resume</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> pt_regs <span class=\"token operator\">*</span>regs<span class=\"token punctuation\">,</span>\n                                 <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> thread_flags<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 如果线程标志中存在 _TIF_SIGPENDING 标志</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>thread_flags <span class=\"token operator\">&amp;</span> _TIF_SIGPENDING<span class=\"token punctuation\">)</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 调用 do_signal 函数来处理挂起的信号</span>\n        <span class=\"token function\">do_signal</span><span class=\"token punctuation\">(</span>regs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 如果线程标志中存在 _TIF_NOTIFY_RESUME 标志</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>thread_flags <span class=\"token operator\">&amp;</span> _TIF_NOTIFY_RESUME<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 清除线程标志中的 TIF_NOTIFY_RESUME 标志</span>\n        <span class=\"token function\">clear_thread_flag</span><span class=\"token punctuation\">(</span>TIF_NOTIFY_RESUME<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 调用 tracehook_notify_resume 函数来处理通知并恢复执行</span>\n        <span class=\"token function\">tracehook_notify_resume</span><span class=\"token punctuation\">(</span>regs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 如果线程标志中存在 _TIF_FOREIGN_FPSTATE 标志</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>thread_flags <span class=\"token operator\">&amp;</span> _TIF_FOREIGN_FPSTATE<span class=\"token punctuation\">)</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 恢复当前状态的浮点寄存器/向量寄存器状态</span>\n        <span class=\"token function\">fpsimd_restore_current_state</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">do_signal</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> pt_regs <span class=\"token operator\">*</span>regs<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> continue_addr <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> restart_addr <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> retval <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> syscall <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span>regs<span class=\"token operator\">-></span>syscallno<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">struct</span> ksignal ksig<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/*\n     * 如果之前是从系统调用返回，检查是否需要重新启动系统调用...\n     */</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>syscall <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        continue_addr <span class=\"token operator\">=</span> regs<span class=\"token operator\">-></span>pc<span class=\"token punctuation\">;</span>\n        restart_addr <span class=\"token operator\">=</span> continue_addr <span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token function\">compat_thumb_mode</span><span class=\"token punctuation\">(</span>regs<span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">:</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        retval <span class=\"token operator\">=</span> regs<span class=\"token operator\">-></span>regs<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">/*\n         * 避免通过 ret_to_user 陷入额外的系统调用重新启动。\n         */</span>\n        regs<span class=\"token operator\">-></span>syscallno <span class=\"token operator\">=</span> <span class=\"token operator\">~</span><span class=\"token number\">0UL</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">/*\n         * 为系统调用重新启动做准备。我们在这里这样做是为了调试器能够看到已经更改的 PC。\n         */</span>\n        <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>retval<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">case</span> <span class=\"token operator\">-</span>ERESTARTNOHAND<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">case</span> <span class=\"token operator\">-</span>ERESTARTSYS<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">case</span> <span class=\"token operator\">-</span>ERESTARTNOINTR<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">case</span> <span class=\"token operator\">-</span>ERESTART_RESTARTBLOCK<span class=\"token punctuation\">:</span>\n            regs<span class=\"token operator\">-></span>regs<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> regs<span class=\"token operator\">-></span>orig_x0<span class=\"token punctuation\">;</span>\n            regs<span class=\"token operator\">-></span>pc <span class=\"token operator\">=</span> restart_addr<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/*\n     * 获取要传递的信号。在运行时使用 ptrace 时，此时调试器可能会更改我们的所有寄存器。\n     */</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">get_signal</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>ksig<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">/*\n         * 根据信号的设置，可能需要撤消重新启动系统调用的决定，但如果调试器已选择在不同的 PC 上重新启动，则跳过此步骤。\n         */</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>regs<span class=\"token operator\">-></span>pc <span class=\"token operator\">==</span> restart_addr <span class=\"token operator\">&amp;&amp;</span>\n            <span class=\"token punctuation\">(</span>retval <span class=\"token operator\">==</span> <span class=\"token operator\">-</span>ERESTARTNOHAND <span class=\"token operator\">||</span>\n             retval <span class=\"token operator\">==</span> <span class=\"token operator\">-</span>ERESTART_RESTARTBLOCK <span class=\"token operator\">||</span>\n             <span class=\"token punctuation\">(</span>retval <span class=\"token operator\">==</span> <span class=\"token operator\">-</span>ERESTARTSYS <span class=\"token operator\">&amp;&amp;</span>\n              <span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>ksig<span class=\"token punctuation\">.</span>ka<span class=\"token punctuation\">.</span>sa<span class=\"token punctuation\">.</span>sa_flags <span class=\"token operator\">&amp;</span> SA_RESTART<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            regs<span class=\"token operator\">-></span>regs<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">-</span>EINTR<span class=\"token punctuation\">;</span>\n            regs<span class=\"token operator\">-></span>pc <span class=\"token operator\">=</span> continue_addr<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token function\">handle_signal</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>ksig<span class=\"token punctuation\">,</span> regs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/*\n     * 处理重新启动不同的系统调用。与上述类似，如果调试器已选择在不同的 PC 上重新启动，则忽略重新启动。\n     */</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>syscall <span class=\"token operator\">>=</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> regs<span class=\"token operator\">-></span>pc <span class=\"token operator\">==</span> restart_addr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>retval <span class=\"token operator\">==</span> <span class=\"token operator\">-</span>ERESTART_RESTARTBLOCK<span class=\"token punctuation\">)</span>\n            <span class=\"token function\">setup_restart_syscall</span><span class=\"token punctuation\">(</span>regs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">user_rewind_single_step</span><span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">restore_saved_sigmask</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>可以看出，do_signal的核心是handle_signal</p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">handle_signal</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> ksignal <span class=\"token operator\">*</span>ksig<span class=\"token punctuation\">,</span> <span class=\"token keyword\">struct</span> pt_regs <span class=\"token operator\">*</span>regs<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">struct</span> task_struct <span class=\"token operator\">*</span>tsk <span class=\"token operator\">=</span> current<span class=\"token punctuation\">;</span>\n    sigset_t <span class=\"token operator\">*</span>oldset <span class=\"token operator\">=</span> <span class=\"token function\">sigmask_to_save</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> usig <span class=\"token operator\">=</span> ksig<span class=\"token operator\">-></span>sig<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> ret<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/*\n     * Set up the stack frame\n     */</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">is_compat_task</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ksig<span class=\"token operator\">-></span>ka<span class=\"token punctuation\">.</span>sa<span class=\"token punctuation\">.</span>sa_flags <span class=\"token operator\">&amp;</span> SA_SIGINFO<span class=\"token punctuation\">)</span>\n            ret <span class=\"token operator\">=</span> <span class=\"token function\">compat_setup_rt_frame</span><span class=\"token punctuation\">(</span>usig<span class=\"token punctuation\">,</span> ksig<span class=\"token punctuation\">,</span> oldset<span class=\"token punctuation\">,</span> regs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span>\n            ret <span class=\"token operator\">=</span> <span class=\"token function\">compat_setup_frame</span><span class=\"token punctuation\">(</span>usig<span class=\"token punctuation\">,</span> ksig<span class=\"token punctuation\">,</span> oldset<span class=\"token punctuation\">,</span> regs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        ret <span class=\"token operator\">=</span> <span class=\"token function\">setup_rt_frame</span><span class=\"token punctuation\">(</span>usig<span class=\"token punctuation\">,</span> ksig<span class=\"token punctuation\">,</span> oldset<span class=\"token punctuation\">,</span> regs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/*\n     * Check that the resulting registers are actually sane.\n     */</span>\n    ret <span class=\"token operator\">|</span><span class=\"token operator\">=</span> <span class=\"token operator\">!</span><span class=\"token function\">valid_user_regs</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>regs<span class=\"token operator\">-></span>user_regs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/*\n     * Fast forward the stepping logic so we step into the signal\n     * handler.\n     */</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>ret<span class=\"token punctuation\">)</span>\n        <span class=\"token function\">user_fastforward_single_step</span><span class=\"token punctuation\">(</span>tsk<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">signal_setup_done</span><span class=\"token punctuation\">(</span>ret<span class=\"token punctuation\">,</span> ksig<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>这段代码实现了 <code>handle_signal</code> 函数，它负责在接收到信号时设置信号处理函数的栈帧并执行一些相关的处理：</p>\n<ol>\n<li><p><code>struct task_struct *tsk = current;</code>：获取当前正在运行的任务的指针，也就是当前进程的任务结构体。</p>\n</li>\n<li><p><code>sigset_t *oldset = sigmask_to_save();</code>：获取当前进程的旧信号屏蔽集。</p>\n</li>\n<li><p><code>int usig = ksig-&gt;sig;</code>：获取要处理的信号的编号。</p>\n</li>\n<li><p><code>int ret;</code>：定义变量用于存储函数的返回值。</p>\n</li>\n<li><p>设置栈帧：</p>\n<ul>\n<li>根据当前进程是否为兼容模式任务（32位应用程序在64位内核中运行），以及信号的设置情况，选择不同的栈帧设置函数。如果信号设置了 <code>SA_SIGINFO</code> 标志，调用对应的栈帧设置函数 <code>compat_setup_rt_frame</code>，否则调用 <code>compat_setup_frame</code>。</li>\n<li>如果当前进程不是兼容模式任务，调用 <code>setup_rt_frame</code> 来设置栈帧。</li>\n</ul>\n</li>\n<li><p>检查生成的寄存器是否合理：</p>\n<ul>\n<li>检查之前设置的用户寄存器是否合理。如果栈帧设置函数返回非零，或者用户寄存器不合理，将 <code>ret</code> 的相应位设置为 1，表示出现问题。</li>\n</ul>\n</li>\n<li><p>快速前进步进逻辑：</p>\n<ul>\n<li>如果之前的操作没有问题，调用 <code>user_fastforward_single_step</code> 函数，以便能够在信号处理函数中进行单步调试。</li>\n</ul>\n</li>\n<li><p>完成信号设置：</p>\n<ul>\n<li>调用 <code>signal_setup_done</code> 函数，将栈帧设置的结果、信号信息和其他参数传递给它。这个函数会通知调度程序信号处理已经准备完成。</li>\n</ul>\n</li>\n</ol>\n<p><code>handle_signal</code> 函数负责为信号处理函数设置栈帧，并根据情况执行相关处理，以确保信号的适当处理。这涉及了栈帧的设置、寄存器的检查、单步调试逻辑的前进，最终通知调度程序信号处理准备已完成，是通过setup_rt_frame来设定的。</p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">setup_rt_frame</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> usig<span class=\"token punctuation\">,</span> <span class=\"token keyword\">struct</span> ksignal <span class=\"token operator\">*</span>ksig<span class=\"token punctuation\">,</span> sigset_t <span class=\"token operator\">*</span>set<span class=\"token punctuation\">,</span>\n                          <span class=\"token keyword\">struct</span> pt_regs <span class=\"token operator\">*</span>regs<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">struct</span> rt_sigframe __user <span class=\"token operator\">*</span>frame<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 声明一个指向用户空间的信号栈帧结构体指针</span>\n    <span class=\"token keyword\">int</span> err <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 初始化错误码变量</span>\n\n    frame <span class=\"token operator\">=</span> <span class=\"token function\">get_sigframe</span><span class=\"token punctuation\">(</span>ksig<span class=\"token punctuation\">,</span> regs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 获取适合信号处理函数的用户空间栈帧</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>frame<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 如果获取失败，返回错误码 1 表示出现问题</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 设置信号栈帧中的字段</span>\n    <span class=\"token function\">__put_user_error</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>frame<span class=\"token operator\">-></span>uc<span class=\"token punctuation\">.</span>uc_flags<span class=\"token punctuation\">,</span> err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 将值 0 存储到 uc_flags 字段</span>\n    <span class=\"token function\">__put_user_error</span><span class=\"token punctuation\">(</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>frame<span class=\"token operator\">-></span>uc<span class=\"token punctuation\">.</span>uc_link<span class=\"token punctuation\">,</span> err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 将 NULL 存储到 uc_link 字段</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 保存备用堆栈信息</span>\n    err <span class=\"token operator\">|</span><span class=\"token operator\">=</span> <span class=\"token function\">__save_altstack</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>frame<span class=\"token operator\">-></span>uc<span class=\"token punctuation\">.</span>uc_stack<span class=\"token punctuation\">,</span> regs<span class=\"token operator\">-></span>sp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    err <span class=\"token operator\">|</span><span class=\"token operator\">=</span> <span class=\"token function\">setup_sigframe</span><span class=\"token punctuation\">(</span>frame<span class=\"token punctuation\">,</span> regs<span class=\"token punctuation\">,</span> set<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 设置信号栈帧的其他字段</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>err <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">setup_return</span><span class=\"token punctuation\">(</span>regs<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>ksig<span class=\"token operator\">-></span>ka<span class=\"token punctuation\">,</span> frame<span class=\"token punctuation\">,</span> usig<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 设置返回点，用于信号处理函数返回时</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ksig<span class=\"token operator\">-></span>ka<span class=\"token punctuation\">.</span>sa<span class=\"token punctuation\">.</span>sa_flags <span class=\"token operator\">&amp;</span> SA_SIGINFO<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            err <span class=\"token operator\">|</span><span class=\"token operator\">=</span> <span class=\"token function\">copy_siginfo_to_user</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>frame<span class=\"token operator\">-></span>info<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>ksig<span class=\"token operator\">-></span>info<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 将信号信息复制到栈帧中</span>\n            regs<span class=\"token operator\">-></span>regs<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">)</span><span class=\"token operator\">&amp;</span>frame<span class=\"token operator\">-></span>info<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 设置寄存器中对应参数的值</span>\n            regs<span class=\"token operator\">-></span>regs<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">)</span><span class=\"token operator\">&amp;</span>frame<span class=\"token operator\">-></span>uc<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> err<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 返回错误码，表示函数执行是否成功</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>先看get_sigframe函数</p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">static</span> <span class=\"token keyword\">struct</span> rt_sigframe __user <span class=\"token operator\">*</span><span class=\"token function\">get_sigframe</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> ksignal <span class=\"token operator\">*</span>ksig<span class=\"token punctuation\">,</span>\n                                               <span class=\"token keyword\">struct</span> pt_regs <span class=\"token operator\">*</span>regs<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> sp<span class=\"token punctuation\">,</span> sp_top<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">struct</span> rt_sigframe __user <span class=\"token operator\">*</span>frame<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 声明一个指向用户空间信号栈帧结构体的指针</span>\n\n    sp <span class=\"token operator\">=</span> sp_top <span class=\"token operator\">=</span> <span class=\"token function\">sigsp</span><span class=\"token punctuation\">(</span>regs<span class=\"token operator\">-></span>sp<span class=\"token punctuation\">,</span> ksig<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 计算信号栈的起始地址</span>\n\n    sp <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>sp <span class=\"token operator\">-</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> rt_sigframe<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;</span> <span class=\"token operator\">~</span><span class=\"token number\">15</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 根据信号栈帧的大小和对齐要求调整栈指针</span>\n    frame <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> rt_sigframe __user <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>sp<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 将栈指针指向调整后的位置，作为信号栈帧的起始地址</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/*\n     * 检查我们是否可以实际写入信号栈帧。\n     */</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">access_ok</span><span class=\"token punctuation\">(</span>VERIFY_WRITE<span class=\"token punctuation\">,</span> frame<span class=\"token punctuation\">,</span> sp_top <span class=\"token operator\">-</span> sp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        frame <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 如果无法写入信号栈帧，将 frame 设为 NULL</span>\n\n    <span class=\"token keyword\">return</span> frame<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 返回适合信号处理函数的用户空间栈帧指针</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>注意，这里的一堆操作就是将sig值给寄存器，ip寄存器设置成信号处理函数指针。具体的堆栈以及寄存器的配置还不是太懂后续研究。<br>处理完信号函数之后，进行一系列地恢复操作即可。首先恢复寄存器到陷入内核态之前的状态，然后恢复栈。这就是完整的信号生命周期</p>\n<h2 id=\"signal函数\"><a href=\"#signal函数\" class=\"headerlink\" title=\"signal函数\"></a>signal函数</h2><p>这段代码是 Linux 内核中 <code>signal</code> 系统调用的实现，用于设置信号的处理函数。以下是对代码中每一行的解释：</p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token function\">SYSCALL_DEFINE2</span><span class=\"token punctuation\">(</span>signal<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> sig<span class=\"token punctuation\">,</span> __sighandler_t<span class=\"token punctuation\">,</span> handler<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">struct</span> k_sigaction new_sa<span class=\"token punctuation\">,</span> old_sa<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 声明新旧信号处理动作的结构体</span>\n    <span class=\"token keyword\">int</span> ret<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 存储函数返回值的变量</span>\n\n    new_sa<span class=\"token punctuation\">.</span>sa<span class=\"token punctuation\">.</span>sa_handler <span class=\"token operator\">=</span> handler<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 设置新的信号处理函数</span>\n    new_sa<span class=\"token punctuation\">.</span>sa<span class=\"token punctuation\">.</span>sa_flags <span class=\"token operator\">=</span> SA_ONESHOT <span class=\"token operator\">|</span> SA_NOMASK<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 设置信号处理标志</span>\n    <span class=\"token function\">sigemptyset</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>new_sa<span class=\"token punctuation\">.</span>sa<span class=\"token punctuation\">.</span>sa_mask<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 初始化信号屏蔽集为空集</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 调用内核函数 do_sigaction 来设置信号处理动作</span>\n    ret <span class=\"token operator\">=</span> <span class=\"token function\">do_sigaction</span><span class=\"token punctuation\">(</span>sig<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>new_sa<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>old_sa<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 如果设置信号处理动作失败，返回错误码；否则返回旧的信号处理函数指针</span>\n    <span class=\"token keyword\">return</span> ret <span class=\"token operator\">?</span> ret <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">)</span>old_sa<span class=\"token punctuation\">.</span>sa<span class=\"token punctuation\">.</span>sa_handler<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>解释每个部分：</p>\n<ul>\n<li><p><code>struct k_sigaction new_sa, old_sa;</code>: 声明用于存储新旧信号处理动作的结构体。</p>\n</li>\n<li><p><code>new_sa.sa.sa_handler = handler;</code>: 设置新的信号处理函数为传入的 <code>handler</code> 函数指针。</p>\n</li>\n<li><p><code>new_sa.sa.sa_flags = SA_ONESHOT | SA_NOMASK;</code>: 设置新的信号处理标志，其中 <code>SA_ONESHOT</code> 表示信号处理函数只会执行一次，<code>SA_NOMASK</code> 表示在信号处理函数执行期间不会阻塞其他信号。</p>\n</li>\n<li><p><code>sigemptyset(&amp;new_sa.sa.sa_mask);</code>: 初始化新的信号处理函数的屏蔽信号集为空集，即在信号处理函数执行期间不会阻塞任何信号。</p>\n</li>\n<li><p><code>ret = do_sigaction(sig, &amp;new_sa, &amp;old_sa);</code>: 调用内核函数 <code>do_sigaction</code> 来设置信号的处理动作，并将旧的信号处理动作保存在 <code>old_sa</code> 中。</p>\n</li>\n<li><p><code>return ret ? ret : (unsigned long)old_sa.sa.sa_handler;</code>: 如果设置信号处理动作失败，返回错误码；否则返回旧的信号处理函数指针。</p>\n</li>\n</ul>\n<p>这段代码实现了用户空间程序通过系统调用 <code>signal</code> 来设置指定信号的处理函数。新的信号处理动作由一个结构体表示，其中包含处理函数、处理标志等信息。然后，调用内核函数 <code>do_sigaction</code> 来将新的信号处理动作应用于进程的信号处理表，并返回旧的信号处理函数指针。</p>\n<p>这段代码是 Linux 内核中的 <code>do_sigaction</code> 函数，用于设置信号的处理动作。以下是对代码中每一行的解释：</p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">do_sigaction</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> sig<span class=\"token punctuation\">,</span> <span class=\"token keyword\">struct</span> k_sigaction <span class=\"token operator\">*</span>act<span class=\"token punctuation\">,</span> <span class=\"token keyword\">struct</span> k_sigaction <span class=\"token operator\">*</span>oact<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">struct</span> task_struct <span class=\"token operator\">*</span>p <span class=\"token operator\">=</span> current<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>t<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 获取当前进程和线程</span>\n    <span class=\"token keyword\">struct</span> k_sigaction <span class=\"token operator\">*</span>k<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 指向当前进程的信号处理表项的指针</span>\n    sigset_t mask<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 信号屏蔽集</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 检查信号编号的有效性，以及是否是仅内核处理的信号</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">valid_signal</span><span class=\"token punctuation\">(</span>sig<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> sig <span class=\"token operator\">&lt;</span> <span class=\"token number\">1</span> <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>act <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">sig_kernel_only</span><span class=\"token punctuation\">(</span>sig<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span>EINVAL<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 获取当前进程的信号处理表项</span>\n    k <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>p<span class=\"token operator\">-></span>sighand<span class=\"token operator\">-></span>action<span class=\"token punctuation\">[</span>sig<span class=\"token number\">-1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">spin_lock_irq</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>p<span class=\"token operator\">-></span>sighand<span class=\"token operator\">-></span>siglock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 获取信号处理表锁</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>oact<span class=\"token punctuation\">)</span>\n        <span class=\"token operator\">*</span>oact <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>k<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 复制当前信号处理动作到旧的信号处理动作结构体</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>act<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 设置新信号处理动作，并从新动作的屏蔽集中排除 SIGKILL 和 SIGSTOP</span>\n        <span class=\"token function\">sigdelsetmask</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>act<span class=\"token operator\">-></span>sa<span class=\"token punctuation\">.</span>sa_mask<span class=\"token punctuation\">,</span>\n                      <span class=\"token function\">sigmask</span><span class=\"token punctuation\">(</span>SIGKILL<span class=\"token punctuation\">)</span> <span class=\"token operator\">|</span> <span class=\"token function\">sigmask</span><span class=\"token punctuation\">(</span>SIGSTOP<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token operator\">*</span>k <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>act<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 复制新信号处理动作到当前信号处理表项</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">/*\n         * POSIX 3.3.1.3 规定：\n         * \"如果将挂起的信号的处理动作设置为 SIG_IGN，无论是否阻塞，都应将挂起的信号丢弃。\"\n         * \"如果将挂起的默认动作为 SIG_DFL，且默认动作是忽略信号（例如 SIGCHLD），则无论是否阻塞，都应将挂起的信号丢弃。\"\n         */</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">sig_handler_ignored</span><span class=\"token punctuation\">(</span><span class=\"token function\">sig_handler</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">,</span> sig<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> sig<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">sigemptyset</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>mask<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">sigaddset</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>mask<span class=\"token punctuation\">,</span> sig<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">flush_sigqueue_mask</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>mask<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>p<span class=\"token operator\">-></span>signal<span class=\"token operator\">-></span>shared_pending<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 清除挂起的共享信号队列中的对应信号</span>\n            <span class=\"token function\">for_each_thread</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">,</span> t<span class=\"token punctuation\">)</span>\n                <span class=\"token function\">flush_sigqueue_mask</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>mask<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>t<span class=\"token operator\">-></span>pending<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 清除每个线程的挂起信号队列中的对应信号</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">spin_unlock_irq</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>p<span class=\"token operator\">-></span>sighand<span class=\"token operator\">-></span>siglock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 释放信号处理表锁</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 返回成功</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>解释每个部分：</p>\n<ul>\n<li><p><code>struct task_struct *p = current, *t;</code>: 获取当前进程的 <code>task_struct</code> 结构体指针，并声明一个用于遍历线程的指针。</p>\n</li>\n<li><p><code>k = &amp;p-&gt;sighand-&gt;action[sig-1];</code>: 获取当前进程的信号处理表项，其中 <code>sighand</code> 是进程的信号处理句柄，<code>action</code> 是信号处理表数组。</p>\n</li>\n<li><p><code>spin_lock_irq(&amp;p-&gt;sighand-&gt;siglock);</code>: 获取当前进程信号处理表的锁，以确保多线程并发修改信号处理表时的同步。</p>\n</li>\n<li><p><code>if (oact) *oact = *k;</code>: 如果传入了旧的信号处理动作指针 <code>oact</code>，则将当前信号处理表项的内容复制到旧的动作结构体中。</p>\n</li>\n<li><p><code>if (act) { ... }</code>: 如果传入了新的信号处理动作指针 <code>act</code>，则进行以下操作：</p>\n<ul>\n<li><p><code>sigdelsetmask(&amp;act-&gt;sa.sa_mask, sigmask(SIGKILL) | sigmask(SIGSTOP));</code>: 从新的信号处理动作的屏蔽集中排除 <code>SIGKILL</code> 和 <code>SIGSTOP</code>，确保这两个信号不会被阻塞。</p>\n</li>\n<li><p><code>*k = *act;</code>: 复制新的信号处理动作到当前信号处理表项。</p>\n</li>\n<li><p>根据 POSIX 规定，如果新的信号处理动作是忽略信号或恢复默认动作，需要丢弃已挂起的对应信号。</p>\n</li>\n</ul>\n</li>\n<li><p><code>spin_unlock_irq(&amp;p-&gt;sighand-&gt;siglock);</code>: 释放当前进程信号处理表的锁。</p>\n</li>\n<li><p><code>return 0;</code>: 返回成功标志。</p>\n</li>\n</ul>\n<p>综合来看，<code>do_sigaction</code> 函数用于设置信号的处理动作，根据传入的参数进行相应的处理，包括设置新的处理动作、排除某些屏蔽信号、丢弃已挂起的信号等操作。这是 Linux 内核中信号处理机制的一部分。</p>\n<h2 id=\"内核signal-handlers结构\"><a href=\"#内核signal-handlers结构\" class=\"headerlink\" title=\"内核signal handlers结构\"></a>内核signal handlers结构</h2><pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> task_struct <span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span>\n<span class=\"token comment\" spellcheck=\"true\">/* signal handlers */</span>\n    <span class=\"token keyword\">struct</span> signal_struct <span class=\"token operator\">*</span>signal<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">struct</span> sighand_struct <span class=\"token operator\">*</span>sighand<span class=\"token punctuation\">;</span>\n\n    sigset_t blocked<span class=\"token punctuation\">,</span> real_blocked<span class=\"token punctuation\">;</span>\n    sigset_t saved_sigmask<span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">/* restored if set_restore_sigmask() was used */</span>\n    <span class=\"token keyword\">struct</span> sigpending pending<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> sas_ss_sp<span class=\"token punctuation\">;</span>\n    size_t sas_ss_size<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>notifier<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>priv<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>notifier_data<span class=\"token punctuation\">;</span>\n    sigset_t <span class=\"token operator\">*</span>notifier_mask<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">struct</span> callback_head <span class=\"token operator\">*</span>task_works<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">struct</span> audit_context <span class=\"token operator\">*</span>audit_context<span class=\"token punctuation\">;</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">ifdef</span> CONFIG_AUDITSYSCALL</span>\n    kuid_t loginuid<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> sessionid<span class=\"token punctuation\">;</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">endif</span></span>\n    <span class=\"token keyword\">struct</span> seccomp seccomp<span class=\"token punctuation\">;</span>\n    <span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<ul>\n<li><p><code>signal_struct</code> 数据结构，用于表示进程的信号相关信息。</p>\n</li>\n<li><p><code>struct sighand_struct *sighand;</code>: 指向进程的信号处理句柄（signal handler）的指针，其中包含有关进程信号处理函数的信息。</p>\n</li>\n<li><p><code>sigset_t blocked, real_blocked;</code>: 分别表示进程当前阻塞的信号集合和实际阻塞的信号集合。</p>\n</li>\n<li><p><code>sigset_t saved_sigmask;</code>: 保存在设置了 <code>set_restore_sigmask()</code> 时被恢复的信号掩码。</p>\n</li>\n<li><p><code>struct sigpending pending;</code>: 挂起信号队列，包含了已经发送但尚未处理的信号。</p>\n</li>\n<li><p><code>unsigned long sas_ss_sp;</code> 和 <code>size_t sas_ss_size;</code>: 用户态的备用信号栈（Alternate Signal Stack）的起始地址和大小。</p>\n</li>\n<li><p><code>int (*notifier)(void *priv);</code>: 用于通知回调的函数指针。</p>\n</li>\n<li><p><code>void *notifier_data;</code>: 传递给通知回调函数的私有数据。</p>\n</li>\n<li><p><code>sigset_t *notifier_mask;</code>: 指向一个信号集，用于通知回调函数决定哪些信号需要通知。</p>\n</li>\n<li><p><code>struct callback_head *task_works;</code>: 与进程关联的回调函数链表。</p>\n</li>\n<li><p><code>struct audit_context *audit_context;</code>: 用于存储与审计相关的上下文信息。</p>\n</li>\n<li><p><code>kuid_t loginuid;</code> 和 <code>unsigned int sessionid;</code>: 用于记录登录用户的用户ID和会话ID。</p>\n</li>\n<li><p><code>struct seccomp seccomp;</code>: 用于存储与 seccomp（安全计算模式）相关的信息。</p>\n</li>\n</ul>\n<p>这个数据结构存储了与进程信号相关的各种信息，包括信号处理函数、阻塞信号、挂起信号、备用信号栈、通知回调等。这些信息在 Linux 内核中用于管理和处理进程接收到的各种信号。</p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> sighand_struct <span class=\"token punctuation\">{</span>\n    atomic_t        count<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">struct</span> k_sigaction    action<span class=\"token punctuation\">[</span>_NSIG<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    spinlock_t        siglock<span class=\"token punctuation\">;</span>\n    wait_queue_head_t    signalfd_wqh<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre>\n<p>其中的action是我们最需要关注的。它是一个长度为_NSIG的数组。下标为k的元素，就代表编号为k的信号的处理函数。k_sigaction实际上就是在内核态中对于sigaction的一个包装，signal函数就是将struct k_sigaction    action[_NSIG]的相应为设置成指定的函数。</p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<h1 id=\"kill命令是如何执行的\"><a href=\"#kill命令是如何执行的\" class=\"headerlink\" title=\"kill命令是如何执行的\"></a>kill命令是如何执行的</h1><h2 id=\"kill发送信号\"><a href=\"#kill发送信号\" class=\"headerlink\" title=\"kill发送信号\"></a>kill发送信号</h2><p>文件kernel/signal.c</p>\n<pre><code class=\"c\"> /**\n *  sys_kill - send a signal to a process\n *  @pid: the PID of the process\n *  @sig: signal to be sent\n */\nSYSCALL_DEFINE2(kill, pid_t, pid, int, sig)\n{\n    struct siginfo info;\n\n    info.si_signo = sig;\n    info.si_errno = 0;\n    info.si_code = SI_USER;\n    info.si_pid = task_tgid_vnr(current);\n    info.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\n    return kill_something_info(sig, &amp;info, pid);\n}</code></pre>\n<p> 这段代码是 Linux 内核中实现 <code>kill</code> 系统调用的部分。让我们逐步分析这段代码的功能：</p>\n<ol>\n<li><p><code>SYSCALL_DEFINE2(kill, pid_t, pid, int, sig)</code>：这是一个宏，用于定义带有两个参数的系统调用 <code>kill</code>。<code>pid_t</code> 和 <code>int</code> 是参数的类型，<code>pid</code> 是要发送信号的目标进程的 ID，<code>sig</code> 是要发送的信号编号。</p>\n</li>\n<li><p><code>struct siginfo info</code>：这是一个结构体，用于保存信号的附加信息。</p>\n</li>\n<li><p><code>info.si_signo = sig</code>：将信号编号赋值给 <code>si_signo</code> 字段，表示要发送的信号的编号。</p>\n</li>\n<li><p><code>info.si_errno = 0</code>：将错误编号字段置为 0，表示没有错误。</p>\n</li>\n<li><p><code>info.si_code = SI_USER</code>：将信号代码字段设置为 <code>SI_USER</code>，表示该信号是由用户空间进程发送的。</p>\n</li>\n<li><p><code>info.si_pid = task_tgid_vnr(current)</code>：将当前进程的 TGID（线程组ID）作为发送信号的进程ID。</p>\n</li>\n<li><p><code>info.si_uid = from_kuid_munged(current_user_ns(), current_uid())</code>：将当前进程的有效用户ID转换为用户命名空间中的用户ID，并将结果赋值给发送信号的用户ID字段。</p>\n</li>\n<li><p><code>return kill_something_info(sig, &amp;info, pid)</code>：调用 <code>kill_something_info</code> 函数，将信号编号、信号信息结构体和目标进程的ID作为参数传递，并返回结果。这个函数的功能是根据给定的参数发送信号给目标进程。</p>\n</li>\n</ol>\n<p>这段代码实现了 <code>kill</code> 系统调用的功能。它接受一个目标进程ID和信号编号作为参数，然后构建一个带有信号信息的结构体，并调用相应的函数将信号发送给目标进程。这是 Linux 内核中管理进程间通信的一部分，允许一个进程向另一个进程发送信号以通知或影响其行为。</p>\n<pre><code class=\"c\">/*\n * kill_something_info() interprets pid in interesting ways just like kill(2).\n *\n * POSIX specifies that kill(-1,sig) is unspecified, but what we have\n * is probably wrong.  Should make it like BSD or SYSV.\n */\n\nstatic int kill_something_info(int sig, struct siginfo *info, pid_t pid)\n{\n    int ret;\n\n    if (pid &gt; 0) {\n        rcu_read_lock();\n        ret = kill_pid_info(sig, info, find_vpid(pid));\n        rcu_read_unlock();\n        return ret;\n    }\n\n    read_lock(&amp;tasklist_lock);\n    if (pid != -1) {\n        ret = __kill_pgrp_info(sig, info,\n                pid ? find_vpid(-pid) : task_pgrp(current));\n    } else {\n        int retval = 0, count = 0;\n        struct task_struct * p;\n\n        for_each_process(p) {\n            if (task_pid_vnr(p) &gt; 1 &amp;&amp;\n                    !same_thread_group(p, current)) {\n                int err = group_send_sig_info(sig, info, p);\n                ++count;\n                if (err != -EPERM)\n                    retval = err;\n            }\n        }\n        ret = count ? retval : -ESRCH;\n    }\n    read_unlock(&amp;tasklist_lock);\n\n    return ret;\n}</code></pre>\n<p>这段代码是 Linux 内核中用于实现 <code>kill_something_info</code> 函数的部分。这个函数用于向一个或多个进程发送信号，具体操作取决于传递的参数。让我们逐步解释这段代码的功能：</p>\n<ol>\n<li><p><code>static int kill_something_info(int sig, struct siginfo *info, pid_t pid)</code>：这是一个静态函数，用于发送信号给一个或多个进程。它接受信号编号 <code>sig</code>、信号信息结构体 <code>info</code> 和目标进程的ID <code>pid</code> 作为参数。</p>\n</li>\n<li><p><code>if (pid &gt; 0)</code>：如果目标进程ID大于0，表示要向指定PID的进程发送信号。</p>\n<ul>\n<li><p><code>rcu_read_lock()</code>：获取 RCU（Read-Copy-Update）读取锁，确保在读取期间不会发生数据修改。</p>\n</li>\n<li><p><code>ret = kill_pid_info(sig, info, find_vpid(pid))</code>：调用 <code>kill_pid_info</code> 函数，向指定的进程发送信号，并传递信号编号、信号信息和目标进程的虚拟PID（vpid）。</p>\n</li>\n<li><p><code>rcu_read_unlock()</code>：释放 RCU 读取锁。</p>\n</li>\n<li><p>返回 <code>ret</code>，表示操作的结果。</p>\n</li>\n</ul>\n</li>\n<li><p>如果 <code>pid</code> 不大于0：</p>\n<ul>\n<li><p><code>read_lock(&amp;tasklist_lock)</code>：获取进程列表读取锁，以确保在遍历进程列表期间不会发生修改。</p>\n</li>\n<li><p>如果 <code>pid</code> 不等于-1，表示要发送信号给指定的进程组：</p>\n<ul>\n<li><code>ret = __kill_pgrp_info(sig, info, pid ? find_vpid(-pid) : task_pgrp(current))</code>：调用 <code>__kill_pgrp_info</code> 函数，向指定的进程组发送信号。如果 <code>pid</code> 不为0，表示发送给指定的进程组，否则发送给当前进程组。</li>\n</ul>\n</li>\n<li><p>否则，表示要向所有非当前线程组中的进程发送信号：</p>\n<ul>\n<li><p><code>int retval = 0, count = 0;</code>：初始化变量 <code>retval</code> 和 <code>count</code>，用于跟踪操作结果和计数。</p>\n</li>\n<li><p><code>struct task_struct * p;</code>：定义一个指向进程结构体的指针。</p>\n</li>\n<li><p><code>for_each_process(p)</code>：遍历所有进程。</p>\n<ul>\n<li><p><code>if (task_pid_vnr(p) &gt; 1 &amp;&amp; !same_thread_group(p, current))</code>：检查进程的虚拟PID是否大于1（排除init进程和内核线程）以及是否属于与当前进程不同的线程组。</p>\n<ul>\n<li><p><code>group_send_sig_info(sig, info, p)</code>：调用 <code>group_send_sig_info</code> 函数，向指定进程发送信号。</p>\n</li>\n<li><p><code>++count</code>：递增计数器。</p>\n</li>\n<li><p>如果返回值不是 <code>-EPERM</code>，将 <code>err</code> 赋值给 <code>retval</code>。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><code>ret = count ? retval : -ESRCH;</code>：根据计数器判断是否有进程接收到信号，如果有则返回 <code>retval</code>，否则返回 <code>-ESRCH</code> 表示没有匹配的进程。</p>\n</li>\n</ul>\n</li>\n<li><p><code>read_unlock(&amp;tasklist_lock)</code>：释放进程列表读取锁。</p>\n</li>\n<li><p>返回 <code>ret</code>，表示操作的结果。</p>\n</li>\n</ul>\n</li>\n</ol>\n<p>参数 pid 不同取值含义：<br>⚫ 如果 pid 为正，则信号 sig 将发送到 pid 指定的进程。<br>⚫ 如果 pid 等于 0，则将 sig 发送到当前进程的进程组中的每个进程。<br>⚫ 如果 pid 等于-1，则将 sig 发送到当前进程有权发送信号的每个进程，但进程 1（init）除外。<br>⚫ 如果 pid 小于-1，则将 sig 发送到 ID 为-pid 的进程组中的每个进程。<br>进程中将信号发送给另一个进程是需要权限的，并不是可以随便给任何一个进程发送信号，超级用户<br>root 进程可以将信号发送给任何进程，但对于非超级用户（普通用户）进程来说，其基本规则是发送者进程<br>的实际用户 ID 或有效用户 ID 必须等于接收者进程的实际用户 ID 或有效用户 ID。</p>\n<h2 id=\"信号传输的途径\"><a href=\"#信号传输的途径\" class=\"headerlink\" title=\"信号传输的途径\"></a>信号传输的途径</h2><pre><code class=\"c\">int kill_pid_info(int sig, struct siginfo *info, struct pid *pid)\n{\n    int error = -ESRCH;\n    struct task_struct *p;\n\n    for (;;) {\n        rcu_read_lock();\n        p = pid_task(pid, PIDTYPE_PID);\n        if (p)\n            error = group_send_sig_info(sig, info, p);\n        rcu_read_unlock();\n        if (likely(!p || error != -ESRCH))\n            return error;\n\n        /*\n         * The task was unhashed in between, try again.  If it\n         * is dead, pid_task() will return NULL, if we race with\n         * de_thread() it will find the new leader.\n         */\n    }\n}</code></pre>\n<p>这段代码实现了 <code>kill_pid_info</code> 函数，它用于向指定的进程发送信号，并且会不断尝试直到发送成功或者出现错误。让我们逐步解释这段代码的功能：</p>\n<ol>\n<li><p><code>int kill_pid_info(int sig, struct siginfo *info, struct pid *pid)</code>：这个函数用于向指定的进程发送信号。它接受信号编号 <code>sig</code>、信号信息结构体 <code>info</code> 和指向目标进程 <code>struct pid</code> 的指针作为参数。</p>\n</li>\n<li><p><code>int error = -ESRCH;</code>：初始化错误码为 <code>-ESRCH</code>，表示最初的状态是没有找到匹配的进程。</p>\n</li>\n<li><p><code>struct task_struct *p;</code>：定义一个指向进程结构体的指针。</p>\n</li>\n<li><p><code>for (;;) {</code>：进入无限循环，直到发送成功或出现错误。</p>\n<ul>\n<li><p><code>rcu_read_lock();</code>：获取 RCU 读取锁。</p>\n</li>\n<li><p><code>p = pid_task(pid, PIDTYPE_PID);</code>：通过给定的 <code>struct pid</code> 和 <code>PIDTYPE_PID</code> 类型，获取与该PID相关联的进程的指针。</p>\n</li>\n<li><p><code>if (p)</code>：如果找到了相关的进程。</p>\n<ul>\n<li><code>error = group_send_sig_info(sig, info, p);</code>：调用 <code>group_send_sig_info</code> 函数，向指定的进程发送信号，将结果保存在 <code>error</code> 中。</li>\n</ul>\n</li>\n<li><p><code>rcu_read_unlock();</code>：释放 RCU 读取锁。</p>\n</li>\n<li><p><code>if (likely(!p || error != -ESRCH))</code>：如果找不到相关进程，或者已经成功发送了信号，跳出循环。</p>\n<ul>\n<li><code>return error;</code>：返回错误码。</li>\n</ul>\n</li>\n<li><p>如果进程不在哈希表中，很可能在 <code>pid_task</code> 调用期间被取消注册（unhashed），进程结构体可能已经不再可用。</p>\n<ul>\n<li>循环重新开始，进行新一轮的尝试。</li>\n</ul>\n</li>\n</ul>\n<p>这个无限循环会不断尝试发送信号，直到成功发送信号给目标进程或出现错误。如果进程在循环中被取消注册，将会继续尝试直到进程结构体可用。</p>\n</li>\n</ol>\n<p>这段代码实现了一个循环发送信号给指定进程的过程，如果目标进程存在，则发送信号并返回结果，如果目标进程不存在或出现错误，则会不断尝试直到发送成功或者出现无法恢复的错误。</p>\n<pre><code class=\"c\"> int group_send_sig_info(int sig, struct siginfo *info, struct task_struct *p)\n{\n    int ret;\n\n    rcu_read_lock();\n    ret = check_kill_permission(sig, info, p);\n    rcu_read_unlock();\n\n    if (!ret &amp;&amp; sig)\n        ret = do_send_sig_info(sig, info, p, true);\n\n    return ret;\n}</code></pre>\n<p>这段代码执行了以下操作：</p>\n<ol>\n<li><p><code>rcu_read_lock();</code>：获取RCU（Read-Copy-Update）读取锁，确保在读取期间不会发生数据修改。</p>\n</li>\n<li><p><code>ret = check_kill_permission(sig, info, p);</code>：调用 <code>check_kill_permission</code> 函数，检查是否具有权限向进程组中的进程发送信号，并将结果保存在 <code>ret</code> 变量中。</p>\n</li>\n<li><p><code>rcu_read_unlock();</code>：释放RCU读取锁，允许其他线程继续操作。</p>\n</li>\n<li><p><code>if (!ret &amp;&amp; sig)</code>：如果没有权限问题（<code>ret</code> 为0）且信号编号不为0（表示有信号需要发送）。</p>\n<ul>\n<li><code>ret = do_send_sig_info(sig, info, p, true);</code>：调用 <code>do_send_sig_info</code> 函数，向进程组中的所有进程发送信号，将结果保存在 <code>ret</code> 中。</li>\n</ul>\n</li>\n<li><p>返回 <code>ret</code>，表示信号发送操作的结果。</p>\n</li>\n</ol>\n<p>这段代码的目标是向一个进程组中的所有进程发送信号。在执行之前，它会检查是否具有足够的权限来发送信号。然后，如果有信号需要发送，它会调用 <code>do_send_sig_info</code> 函数来实际执行信号发送操作。</p>\n<pre><code class=\"c\">int do_send_sig_info(int sig, struct siginfo *info, struct task_struct *p,\n            bool group)\n{\n    unsigned long flags;\n    int ret = -ESRCH;\n\n    if (lock_task_sighand(p, &amp;flags)) {\n        ret = send_signal(sig, info, p, group);\n        unlock_task_sighand(p, &amp;flags);\n    }\n\n    return ret;\n}</code></pre>\n<p><code>do_send_sig_info</code> 函数，用于向一个特定进程发送信号，并且可以选择是否发送给整个进程组：</p>\n<ol>\n<li><p><code>int do_send_sig_info(int sig, struct siginfo *info, struct task_struct *p, bool group)</code>：这个函数用于向指定的进程发送信号，可以选择是否发送给整个进程组。它接受信号编号 <code>sig</code>、信号信息结构体 <code>info</code>、目标进程结构体 <code>p</code>，以及一个布尔值 <code>group</code> 作为参数。</p>\n</li>\n<li><p><code>unsigned long flags;</code>：定义一个无符号长整型变量，用于保存中断标志。</p>\n</li>\n<li><p><code>int ret = -ESRCH;</code>：初始化结果变量为 <code>-ESRCH</code>，表示最初状态下信号发送操作没有成功。</p>\n</li>\n<li><p><code>if (lock_task_sighand(p, &amp;flags))</code>：如果成功获取目标进程的信号处理锁。</p>\n<ul>\n<li><code>lock_task_sighand</code> 会锁定进程的信号处理数据结构，以确保在发送信号的过程中没有其他线程干扰。</li>\n</ul>\n</li>\n<li><p><code>ret = send_signal(sig, info, p, group);</code>：调用 <code>send_signal</code> 函数，实际发送信号给目标进程。根据 <code>group</code> 参数的值，可以选择是否发送给整个进程组。</p>\n</li>\n<li><p><code>unlock_task_sighand(p, &amp;flags);</code>：解锁目标进程的信号处理数据结构。</p>\n</li>\n<li><p>返回 <code>ret</code>，表示信号发送操作的结果。</p>\n</li>\n</ol>\n<p>这段代码的目标是向指定的进程发送信号，并且根据传递的参数决定是否将信号发送给整个进程组。它会尝试锁定目标进程的信号处理数据结构，然后调用 <code>send_signal</code> 函数来实际发送信号。发送完成后，它会解锁信号处理数据结构并返回信号发送的结果。</p>\n<pre><code class=\"c\">static int send_signal(int sig, struct siginfo *info, struct task_struct *t,\n            int group)\n{\n    int from_ancestor_ns = 0;\n\n#ifdef CONFIG_PID_NS\n    from_ancestor_ns = si_fromuser(info) &amp;&amp;\n               !task_pid_nr_ns(current, task_active_pid_ns(t));\n#endif\n\n    return __send_signal(sig, info, t, group, from_ancestor_ns);\n}</code></pre>\n<pre><code class=\"c\">\nstatic int __send_signal(int sig, struct siginfo *info, struct task_struct *t,\n            int group, int from_ancestor_ns)\n{\n    struct sigpending *pending;\n    struct sigqueue *q;\n    int override_rlimit;\n    int ret = 0, result;\n\n    assert_spin_locked(&amp;t-&gt;sighand-&gt;siglock);\n\n    result = TRACE_SIGNAL_IGNORED;\n    if (!prepare_signal(sig, t,\n            from_ancestor_ns || (info == SEND_SIG_FORCED)))\n        goto ret;\n\n    pending = group ? &amp;t-&gt;signal-&gt;shared_pending : &amp;t-&gt;pending;\n    /*\n     * Short-circuit ignored signals and support queuing\n     * exactly one non-rt signal, so that we can get more\n     * detailed information about the cause of the signal.\n     */\n    result = TRACE_SIGNAL_ALREADY_PENDING;\n    if (legacy_queue(pending, sig))\n        goto ret;\n\n    result = TRACE_SIGNAL_DELIVERED;\n    /*\n     * fast-pathed signals for kernel-internal things like SIGSTOP\n     * or SIGKILL.\n     */\n    if (info == SEND_SIG_FORCED)\n        goto out_set;\n\n    /*\n     * Real-time signals must be queued if sent by sigqueue, or\n     * some other real-time mechanism.  It is implementation\n     * defined whether kill() does so.  We attempt to do so, on\n     * the principle of least surprise, but since kill is not\n     * allowed to fail with EAGAIN when low on memory we just\n     * make sure at least one signal gets delivered and don&#39;t\n     * pass on the info struct.\n     */\n    if (sig &lt; SIGRTMIN)\n        override_rlimit = (is_si_special(info) || info-&gt;si_code &gt;= 0);\n    else\n        override_rlimit = 0;\n\n    q = __sigqueue_alloc(sig, t, GFP_ATOMIC | __GFP_NOTRACK_FALSE_POSITIVE,\n        override_rlimit);\n    if (q) {\n        list_add_tail(&amp;q-&gt;list, &amp;pending-&gt;list);\n        switch ((unsigned long) info) {\n        case (unsigned long) SEND_SIG_NOINFO:\n            q-&gt;info.si_signo = sig;\n            q-&gt;info.si_errno = 0;\n            q-&gt;info.si_code = SI_USER;\n            q-&gt;info.si_pid = task_tgid_nr_ns(current,\n                            task_active_pid_ns(t));\n            q-&gt;info.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n            break;\n        case (unsigned long) SEND_SIG_PRIV:\n            q-&gt;info.si_signo = sig;\n            q-&gt;info.si_errno = 0;\n            q-&gt;info.si_code = SI_KERNEL;\n            q-&gt;info.si_pid = 0;\n            q-&gt;info.si_uid = 0;\n            break;\n        default:\n            copy_siginfo(&amp;q-&gt;info, info);\n            if (from_ancestor_ns)\n                q-&gt;info.si_pid = 0;\n            break;\n        }\n\n        userns_fixup_signal_uid(&amp;q-&gt;info, t);\n\n    } else if (!is_si_special(info)) {\n        if (sig &gt;= SIGRTMIN &amp;&amp; info-&gt;si_code != SI_USER) {\n            /*\n             * Queue overflow, abort.  We may abort if the\n             * signal was rt and sent by user using something\n             * other than kill().\n             */\n            result = TRACE_SIGNAL_OVERFLOW_FAIL;\n            ret = -EAGAIN;\n            goto ret;\n        } else {\n            /*\n             * This is a silent loss of information.  We still\n             * send the signal, but the *info bits are lost.\n             */\n            result = TRACE_SIGNAL_LOSE_INFO;\n        }\n    }\n\nout_set:\n    signalfd_notify(t, sig);\n    sigaddset(&amp;pending-&gt;signal, sig);\n    complete_signal(sig, t, group);\nret:\n    trace_signal_generate(sig, info, t, group, result);\n    return ret;\n}</code></pre>\n<p>这段代码实现了 <code>__send_signal</code> 函数，用于实际将信号发送给指定进程。这个函数是信号发送过程的核心部分：</p>\n<ol>\n<li><p><code>int __send_signal(int sig, struct siginfo *info, struct task_struct *t, int group, int from_ancestor_ns)</code>：这个函数用于实际将信号发送给指定进程。它接受信号编号 <code>sig</code>、信号信息结构体 <code>info</code>、目标进程结构体 <code>t</code>、发送方式 <code>group</code> 和一个整数 <code>from_ancestor_ns</code> 作为参数。</p>\n</li>\n<li><p><code>assert_spin_locked(&amp;t-&gt;sighand-&gt;siglock);</code>：确保当前进程已经获取了目标进程信号处理锁，以保证在信号发送过程中没有其他线程干扰。</p>\n</li>\n<li><p><code>result = TRACE_SIGNAL_IGNORED;</code>：初始化结果变量为 <code>TRACE_SIGNAL_IGNORED</code>，表示最初状态下信号被忽略。</p>\n</li>\n<li><p><code>if (!prepare_signal(sig, t, from_ancestor_ns || (info == SEND_SIG_FORCED)))</code>：如果无法准备发送信号。</p>\n<ul>\n<li>调用 <code>prepare_signal</code> 函数来检查是否可以发送信号。如果无法准备发送，跳转到 <code>ret</code> 处返回结果。</li>\n</ul>\n</li>\n<li><p><code>pending = group ? &amp;t-&gt;signal-&gt;shared_pending : &amp;t-&gt;pending;</code>：根据 <code>group</code> 参数决定要使用的挂起信号列表，如果 <code>group</code> 为真，使用共享挂起信号列表，否则使用目标进程的挂起信号列表。</p>\n</li>\n<li><p><code>if (legacy_queue(pending, sig))</code>：如果将信号添加到挂起信号列表中。</p>\n<ul>\n<li>调用 <code>legacy_queue</code> 函数，如果挂起信号列表中已经存在相同的信号，则表示该信号已经被挂起，跳转到 <code>ret</code> 处返回结果。</li>\n</ul>\n</li>\n<li><p><code>if (info == SEND_SIG_FORCED)</code>：如果信号信息是 <code>SEND_SIG_FORCED</code>。</p>\n<ul>\n<li>直接跳转到 <code>out_set</code> 处，表示将信号添加到挂起信号列表中。</li>\n</ul>\n</li>\n<li><p>检查信号是否为实时信号或普通信号，并设置是否覆盖资源限制的标志。</p>\n</li>\n<li><p><code>q = __sigqueue_alloc(sig, t, GFP_ATOMIC | __GFP_NOTRACK_FALSE_POSITIVE, override_rlimit);</code>：调用 <code>__sigqueue_alloc</code> 函数分配一个信号队列节点，用于存储信号信息。</p>\n</li>\n<li><p>如果成功分配了信号队列节点 <code>q</code>，则将其添加到相应的挂起信号列表中，并根据 <code>info</code> 的情况填充信号信息结构体 <code>q-&gt;info</code>。</p>\n</li>\n<li><p>如果无法分配信号队列节点，判断是否为特殊信号，如果不是则处理队列溢出，如果是实时信号则返回失败。</p>\n</li>\n<li><p>调用 <code>signalfd_notify</code> 函数，通知与目标进程关联的 <code>signalfd</code> 文件描述符。</p>\n</li>\n<li><p>调用 <code>sigaddset</code> 函数，将信号添加到挂起信号集合中。</p>\n</li>\n<li><p>调用 <code>complete_signal</code> 函数函数会调用signal_wake_up。这个函数会将线程的TIF_SIGPENDING标志设为1。这样后面就可以快速检测是否有未处理的信号了</p>\n</li>\n<li><p>返回结果 <code>ret</code>，表示信号发送的结果。</p>\n</li>\n<li><p>最后，调用 <code>trace_signal_generate</code> 函数，记录信号发送的跟踪事件，并返回结果 <code>ret</code>。</p>\n</li>\n</ol>\n<p>这段代码实现了实际的信号发送操作。它准备发送信号，判断是否需要加入挂起信号列表，处理特殊信号和实时信号，分配和填充信号信息结构体，通知 <code>signalfd</code> 文件描述符，添加信号到挂起信号集合，并最终完成信号发送的过程。</p>\n<h2 id=\"信号被线程处理\"><a href=\"#信号被线程处理\" class=\"headerlink\" title=\"信号被线程处理\"></a>信号被线程处理</h2><p><strong><em>当前进程陷入内核态，并准备返回用户态时处理信号</em></strong><br>现在，当前进程正在正常执行。刚才已经有进程发送信号，通过send_signal将信号存储在了当前进程的Pending queue当中。当前进程显然不会立刻处理这个信号。处理信号的时机，实际上是当前进程因为一些原因陷入内核态，然后返回用户态的时候。</p>\n<p>现在，假设当前进程因为下面的原因进入内核态：<br>⚫中断<br>⚫系统调用<br>⚫异常<br>执行完内核态的操作之后，返回用户态。返回用户态内核内部将会使用这个函数：do_notify_resume函数：</p>\n<pre><code class=\"c\">work_pending:\n    tbnz    x1, #TIF_NEED_RESCHED, work_resched\n    /* TIF_SIGPENDING, TIF_NOTIFY_RESUME or TIF_FOREIGN_FPSTATE case */\n    ldr    x2, [sp, #S_PSTATE]\n    mov    x0, sp                // &#39;regs&#39;\n    tst    x2, #PSR_MODE_MASK        // user mode regs?\n    b.ne    no_work_pending            // returning to kernel\n    enable_irq                // enable interrupts for do_notify_resume()\n    bl    do_notify_resume\n    b    ret_to_user\nwork_resched:\n    bl    schedule\n\n/*\n * &quot;slow&quot; syscall return path.\n */\nret_to_user:\n    disable_irq                // disable interrupts\n    ldr    x1, [tsk, #TI_FLAGS]\n    and    x2, x1, #_TIF_WORK_MASK\n    cbnz    x2, work_pending\n    enable_step_tsk x1, x2\nno_work_pending:\n    kernel_exit 0, ret = 0\nENDPROC(ret_to_user)</code></pre>\n<pre><code class=\"c\">asmlinkage void do_notify_resume(struct pt_regs *regs,\n                                 unsigned int thread_flags)\n{\n    // 如果线程标志中存在 _TIF_SIGPENDING 标志\n    if (thread_flags &amp; _TIF_SIGPENDING)\n        // 调用 do_signal 函数来处理挂起的信号\n        do_signal(regs);\n\n    // 如果线程标志中存在 _TIF_NOTIFY_RESUME 标志\n    if (thread_flags &amp; _TIF_NOTIFY_RESUME) {\n        // 清除线程标志中的 TIF_NOTIFY_RESUME 标志\n        clear_thread_flag(TIF_NOTIFY_RESUME);\n        // 调用 tracehook_notify_resume 函数来处理通知并恢复执行\n        tracehook_notify_resume(regs);\n    }\n\n    // 如果线程标志中存在 _TIF_FOREIGN_FPSTATE 标志\n    if (thread_flags &amp; _TIF_FOREIGN_FPSTATE)\n        // 恢复当前状态的浮点寄存器/向量寄存器状态\n        fpsimd_restore_current_state();\n}</code></pre>\n<pre><code class=\"c\">static void do_signal(struct pt_regs *regs)\n{\n    unsigned long continue_addr = 0, restart_addr = 0;\n    int retval = 0;\n    int syscall = (int)regs-&gt;syscallno;\n    struct ksignal ksig;\n\n    /*\n     * 如果之前是从系统调用返回，检查是否需要重新启动系统调用...\n     */\n    if (syscall &gt;= 0) {\n        continue_addr = regs-&gt;pc;\n        restart_addr = continue_addr - (compat_thumb_mode(regs) ? 2 : 4);\n        retval = regs-&gt;regs[0];\n\n        /*\n         * 避免通过 ret_to_user 陷入额外的系统调用重新启动。\n         */\n        regs-&gt;syscallno = ~0UL;\n\n        /*\n         * 为系统调用重新启动做准备。我们在这里这样做是为了调试器能够看到已经更改的 PC。\n         */\n        switch (retval) {\n        case -ERESTARTNOHAND:\n        case -ERESTARTSYS:\n        case -ERESTARTNOINTR:\n        case -ERESTART_RESTARTBLOCK:\n            regs-&gt;regs[0] = regs-&gt;orig_x0;\n            regs-&gt;pc = restart_addr;\n            break;\n        }\n    }\n\n    /*\n     * 获取要传递的信号。在运行时使用 ptrace 时，此时调试器可能会更改我们的所有寄存器。\n     */\n    if (get_signal(&amp;ksig)) {\n        /*\n         * 根据信号的设置，可能需要撤消重新启动系统调用的决定，但如果调试器已选择在不同的 PC 上重新启动，则跳过此步骤。\n         */\n        if (regs-&gt;pc == restart_addr &amp;&amp;\n            (retval == -ERESTARTNOHAND ||\n             retval == -ERESTART_RESTARTBLOCK ||\n             (retval == -ERESTARTSYS &amp;&amp;\n              !(ksig.ka.sa.sa_flags &amp; SA_RESTART)))) {\n            regs-&gt;regs[0] = -EINTR;\n            regs-&gt;pc = continue_addr;\n        }\n\n        handle_signal(&amp;ksig, regs);\n        return;\n    }\n\n    /*\n     * 处理重新启动不同的系统调用。与上述类似，如果调试器已选择在不同的 PC 上重新启动，则忽略重新启动。\n     */\n    if (syscall &gt;= 0 &amp;&amp; regs-&gt;pc == restart_addr) {\n        if (retval == -ERESTART_RESTARTBLOCK)\n            setup_restart_syscall(regs);\n        user_rewind_single_step(current);\n    }\n\n    restore_saved_sigmask();\n}</code></pre>\n<p>可以看出，do_signal的核心是handle_signal</p>\n<pre><code class=\"c\">static void handle_signal(struct ksignal *ksig, struct pt_regs *regs)\n{\n    struct task_struct *tsk = current;\n    sigset_t *oldset = sigmask_to_save();\n    int usig = ksig-&gt;sig;\n    int ret;\n\n    /*\n     * Set up the stack frame\n     */\n    if (is_compat_task()) {\n        if (ksig-&gt;ka.sa.sa_flags &amp; SA_SIGINFO)\n            ret = compat_setup_rt_frame(usig, ksig, oldset, regs);\n        else\n            ret = compat_setup_frame(usig, ksig, oldset, regs);\n    } else {\n        ret = setup_rt_frame(usig, ksig, oldset, regs);\n    }\n\n    /*\n     * Check that the resulting registers are actually sane.\n     */\n    ret |= !valid_user_regs(&amp;regs-&gt;user_regs);\n\n    /*\n     * Fast forward the stepping logic so we step into the signal\n     * handler.\n     */\n    if (!ret)\n        user_fastforward_single_step(tsk);\n\n    signal_setup_done(ret, ksig, 0);\n}</code></pre>\n<p>这段代码实现了 <code>handle_signal</code> 函数，它负责在接收到信号时设置信号处理函数的栈帧并执行一些相关的处理：</p>\n<ol>\n<li><p><code>struct task_struct *tsk = current;</code>：获取当前正在运行的任务的指针，也就是当前进程的任务结构体。</p>\n</li>\n<li><p><code>sigset_t *oldset = sigmask_to_save();</code>：获取当前进程的旧信号屏蔽集。</p>\n</li>\n<li><p><code>int usig = ksig-&gt;sig;</code>：获取要处理的信号的编号。</p>\n</li>\n<li><p><code>int ret;</code>：定义变量用于存储函数的返回值。</p>\n</li>\n<li><p>设置栈帧：</p>\n<ul>\n<li>根据当前进程是否为兼容模式任务（32位应用程序在64位内核中运行），以及信号的设置情况，选择不同的栈帧设置函数。如果信号设置了 <code>SA_SIGINFO</code> 标志，调用对应的栈帧设置函数 <code>compat_setup_rt_frame</code>，否则调用 <code>compat_setup_frame</code>。</li>\n<li>如果当前进程不是兼容模式任务，调用 <code>setup_rt_frame</code> 来设置栈帧。</li>\n</ul>\n</li>\n<li><p>检查生成的寄存器是否合理：</p>\n<ul>\n<li>检查之前设置的用户寄存器是否合理。如果栈帧设置函数返回非零，或者用户寄存器不合理，将 <code>ret</code> 的相应位设置为 1，表示出现问题。</li>\n</ul>\n</li>\n<li><p>快速前进步进逻辑：</p>\n<ul>\n<li>如果之前的操作没有问题，调用 <code>user_fastforward_single_step</code> 函数，以便能够在信号处理函数中进行单步调试。</li>\n</ul>\n</li>\n<li><p>完成信号设置：</p>\n<ul>\n<li>调用 <code>signal_setup_done</code> 函数，将栈帧设置的结果、信号信息和其他参数传递给它。这个函数会通知调度程序信号处理已经准备完成。</li>\n</ul>\n</li>\n</ol>\n<p><code>handle_signal</code> 函数负责为信号处理函数设置栈帧，并根据情况执行相关处理，以确保信号的适当处理。这涉及了栈帧的设置、寄存器的检查、单步调试逻辑的前进，最终通知调度程序信号处理准备已完成，是通过setup_rt_frame来设定的。</p>\n<pre><code class=\"c\">static int setup_rt_frame(int usig, struct ksignal *ksig, sigset_t *set,\n                          struct pt_regs *regs)\n{\n    struct rt_sigframe __user *frame; // 声明一个指向用户空间的信号栈帧结构体指针\n    int err = 0; // 初始化错误码变量\n\n    frame = get_sigframe(ksig, regs); // 获取适合信号处理函数的用户空间栈帧\n    if (!frame)\n        return 1; // 如果获取失败，返回错误码 1 表示出现问题\n\n    // 设置信号栈帧中的字段\n    __put_user_error(0, &amp;frame-&gt;uc.uc_flags, err); // 将值 0 存储到 uc_flags 字段\n    __put_user_error(NULL, &amp;frame-&gt;uc.uc_link, err); // 将 NULL 存储到 uc_link 字段\n\n    // 保存备用堆栈信息\n    err |= __save_altstack(&amp;frame-&gt;uc.uc_stack, regs-&gt;sp);\n\n    err |= setup_sigframe(frame, regs, set); // 设置信号栈帧的其他字段\n    if (err == 0) {\n        setup_return(regs, &amp;ksig-&gt;ka, frame, usig); // 设置返回点，用于信号处理函数返回时\n        if (ksig-&gt;ka.sa.sa_flags &amp; SA_SIGINFO) {\n            err |= copy_siginfo_to_user(&amp;frame-&gt;info, &amp;ksig-&gt;info); // 将信号信息复制到栈帧中\n            regs-&gt;regs[1] = (unsigned long)&amp;frame-&gt;info; // 设置寄存器中对应参数的值\n            regs-&gt;regs[2] = (unsigned long)&amp;frame-&gt;uc;\n        }\n    }\n\n    return err; // 返回错误码，表示函数执行是否成功\n}</code></pre>\n<p>先看get_sigframe函数</p>\n<pre><code class=\"c\">static struct rt_sigframe __user *get_sigframe(struct ksignal *ksig,\n                                               struct pt_regs *regs)\n{\n    unsigned long sp, sp_top;\n    struct rt_sigframe __user *frame; // 声明一个指向用户空间信号栈帧结构体的指针\n\n    sp = sp_top = sigsp(regs-&gt;sp, ksig); // 计算信号栈的起始地址\n\n    sp = (sp - sizeof(struct rt_sigframe)) &amp; ~15; // 根据信号栈帧的大小和对齐要求调整栈指针\n    frame = (struct rt_sigframe __user *)sp; // 将栈指针指向调整后的位置，作为信号栈帧的起始地址\n\n    /*\n     * 检查我们是否可以实际写入信号栈帧。\n     */\n    if (!access_ok(VERIFY_WRITE, frame, sp_top - sp))\n        frame = NULL; // 如果无法写入信号栈帧，将 frame 设为 NULL\n\n    return frame; // 返回适合信号处理函数的用户空间栈帧指针\n}</code></pre>\n<p>注意，这里的一堆操作就是将sig值给寄存器，ip寄存器设置成信号处理函数指针。具体的堆栈以及寄存器的配置还不是太懂后续研究。<br>处理完信号函数之后，进行一系列地恢复操作即可。首先恢复寄存器到陷入内核态之前的状态，然后恢复栈。这就是完整的信号生命周期</p>\n<h2 id=\"signal函数\"><a href=\"#signal函数\" class=\"headerlink\" title=\"signal函数\"></a>signal函数</h2><p>这段代码是 Linux 内核中 <code>signal</code> 系统调用的实现，用于设置信号的处理函数。以下是对代码中每一行的解释：</p>\n<pre><code class=\"c\">SYSCALL_DEFINE2(signal, int, sig, __sighandler_t, handler)\n{\n    struct k_sigaction new_sa, old_sa; // 声明新旧信号处理动作的结构体\n    int ret; // 存储函数返回值的变量\n\n    new_sa.sa.sa_handler = handler; // 设置新的信号处理函数\n    new_sa.sa.sa_flags = SA_ONESHOT | SA_NOMASK; // 设置信号处理标志\n    sigemptyset(&amp;new_sa.sa.sa_mask); // 初始化信号屏蔽集为空集\n\n    // 调用内核函数 do_sigaction 来设置信号处理动作\n    ret = do_sigaction(sig, &amp;new_sa, &amp;old_sa);\n\n    // 如果设置信号处理动作失败，返回错误码；否则返回旧的信号处理函数指针\n    return ret ? ret : (unsigned long)old_sa.sa.sa_handler;\n}</code></pre>\n<p>解释每个部分：</p>\n<ul>\n<li><p><code>struct k_sigaction new_sa, old_sa;</code>: 声明用于存储新旧信号处理动作的结构体。</p>\n</li>\n<li><p><code>new_sa.sa.sa_handler = handler;</code>: 设置新的信号处理函数为传入的 <code>handler</code> 函数指针。</p>\n</li>\n<li><p><code>new_sa.sa.sa_flags = SA_ONESHOT | SA_NOMASK;</code>: 设置新的信号处理标志，其中 <code>SA_ONESHOT</code> 表示信号处理函数只会执行一次，<code>SA_NOMASK</code> 表示在信号处理函数执行期间不会阻塞其他信号。</p>\n</li>\n<li><p><code>sigemptyset(&amp;new_sa.sa.sa_mask);</code>: 初始化新的信号处理函数的屏蔽信号集为空集，即在信号处理函数执行期间不会阻塞任何信号。</p>\n</li>\n<li><p><code>ret = do_sigaction(sig, &amp;new_sa, &amp;old_sa);</code>: 调用内核函数 <code>do_sigaction</code> 来设置信号的处理动作，并将旧的信号处理动作保存在 <code>old_sa</code> 中。</p>\n</li>\n<li><p><code>return ret ? ret : (unsigned long)old_sa.sa.sa_handler;</code>: 如果设置信号处理动作失败，返回错误码；否则返回旧的信号处理函数指针。</p>\n</li>\n</ul>\n<p>这段代码实现了用户空间程序通过系统调用 <code>signal</code> 来设置指定信号的处理函数。新的信号处理动作由一个结构体表示，其中包含处理函数、处理标志等信息。然后，调用内核函数 <code>do_sigaction</code> 来将新的信号处理动作应用于进程的信号处理表，并返回旧的信号处理函数指针。</p>\n<p>这段代码是 Linux 内核中的 <code>do_sigaction</code> 函数，用于设置信号的处理动作。以下是对代码中每一行的解释：</p>\n<pre><code class=\"c\">int do_sigaction(int sig, struct k_sigaction *act, struct k_sigaction *oact)\n{\n    struct task_struct *p = current, *t; // 获取当前进程和线程\n    struct k_sigaction *k; // 指向当前进程的信号处理表项的指针\n    sigset_t mask; // 信号屏蔽集\n\n    // 检查信号编号的有效性，以及是否是仅内核处理的信号\n    if (!valid_signal(sig) || sig &lt; 1 || (act &amp;&amp; sig_kernel_only(sig)))\n        return -EINVAL;\n\n    // 获取当前进程的信号处理表项\n    k = &amp;p-&gt;sighand-&gt;action[sig-1];\n\n    spin_lock_irq(&amp;p-&gt;sighand-&gt;siglock); // 获取信号处理表锁\n    if (oact)\n        *oact = *k; // 复制当前信号处理动作到旧的信号处理动作结构体\n\n    if (act) {\n        // 设置新信号处理动作，并从新动作的屏蔽集中排除 SIGKILL 和 SIGSTOP\n        sigdelsetmask(&amp;act-&gt;sa.sa_mask,\n                      sigmask(SIGKILL) | sigmask(SIGSTOP));\n        *k = *act; // 复制新信号处理动作到当前信号处理表项\n\n        /*\n         * POSIX 3.3.1.3 规定：\n         * &quot;如果将挂起的信号的处理动作设置为 SIG_IGN，无论是否阻塞，都应将挂起的信号丢弃。&quot;\n         * &quot;如果将挂起的默认动作为 SIG_DFL，且默认动作是忽略信号（例如 SIGCHLD），则无论是否阻塞，都应将挂起的信号丢弃。&quot;\n         */\n        if (sig_handler_ignored(sig_handler(p, sig), sig)) {\n            sigemptyset(&amp;mask);\n            sigaddset(&amp;mask, sig);\n            flush_sigqueue_mask(&amp;mask, &amp;p-&gt;signal-&gt;shared_pending); // 清除挂起的共享信号队列中的对应信号\n            for_each_thread(p, t)\n                flush_sigqueue_mask(&amp;mask, &amp;t-&gt;pending); // 清除每个线程的挂起信号队列中的对应信号\n        }\n    }\n\n    spin_unlock_irq(&amp;p-&gt;sighand-&gt;siglock); // 释放信号处理表锁\n    return 0; // 返回成功\n}</code></pre>\n<p>解释每个部分：</p>\n<ul>\n<li><p><code>struct task_struct *p = current, *t;</code>: 获取当前进程的 <code>task_struct</code> 结构体指针，并声明一个用于遍历线程的指针。</p>\n</li>\n<li><p><code>k = &amp;p-&gt;sighand-&gt;action[sig-1];</code>: 获取当前进程的信号处理表项，其中 <code>sighand</code> 是进程的信号处理句柄，<code>action</code> 是信号处理表数组。</p>\n</li>\n<li><p><code>spin_lock_irq(&amp;p-&gt;sighand-&gt;siglock);</code>: 获取当前进程信号处理表的锁，以确保多线程并发修改信号处理表时的同步。</p>\n</li>\n<li><p><code>if (oact) *oact = *k;</code>: 如果传入了旧的信号处理动作指针 <code>oact</code>，则将当前信号处理表项的内容复制到旧的动作结构体中。</p>\n</li>\n<li><p><code>if (act) { ... }</code>: 如果传入了新的信号处理动作指针 <code>act</code>，则进行以下操作：</p>\n<ul>\n<li><p><code>sigdelsetmask(&amp;act-&gt;sa.sa_mask, sigmask(SIGKILL) | sigmask(SIGSTOP));</code>: 从新的信号处理动作的屏蔽集中排除 <code>SIGKILL</code> 和 <code>SIGSTOP</code>，确保这两个信号不会被阻塞。</p>\n</li>\n<li><p><code>*k = *act;</code>: 复制新的信号处理动作到当前信号处理表项。</p>\n</li>\n<li><p>根据 POSIX 规定，如果新的信号处理动作是忽略信号或恢复默认动作，需要丢弃已挂起的对应信号。</p>\n</li>\n</ul>\n</li>\n<li><p><code>spin_unlock_irq(&amp;p-&gt;sighand-&gt;siglock);</code>: 释放当前进程信号处理表的锁。</p>\n</li>\n<li><p><code>return 0;</code>: 返回成功标志。</p>\n</li>\n</ul>\n<p>综合来看，<code>do_sigaction</code> 函数用于设置信号的处理动作，根据传入的参数进行相应的处理，包括设置新的处理动作、排除某些屏蔽信号、丢弃已挂起的信号等操作。这是 Linux 内核中信号处理机制的一部分。</p>\n<h2 id=\"内核signal-handlers结构\"><a href=\"#内核signal-handlers结构\" class=\"headerlink\" title=\"内核signal handlers结构\"></a>内核signal handlers结构</h2><pre><code class=\"c\">struct task_struct {\n    *****************\n/* signal handlers */\n    struct signal_struct *signal;\n    struct sighand_struct *sighand;\n\n    sigset_t blocked, real_blocked;\n    sigset_t saved_sigmask;    /* restored if set_restore_sigmask() was used */\n    struct sigpending pending;\n\n    unsigned long sas_ss_sp;\n    size_t sas_ss_size;\n    int (*notifier)(void *priv);\n    void *notifier_data;\n    sigset_t *notifier_mask;\n    struct callback_head *task_works;\n\n    struct audit_context *audit_context;\n#ifdef CONFIG_AUDITSYSCALL\n    kuid_t loginuid;\n    unsigned int sessionid;\n#endif\n    struct seccomp seccomp;\n    ****************\n}</code></pre>\n<ul>\n<li><p><code>signal_struct</code> 数据结构，用于表示进程的信号相关信息。</p>\n</li>\n<li><p><code>struct sighand_struct *sighand;</code>: 指向进程的信号处理句柄（signal handler）的指针，其中包含有关进程信号处理函数的信息。</p>\n</li>\n<li><p><code>sigset_t blocked, real_blocked;</code>: 分别表示进程当前阻塞的信号集合和实际阻塞的信号集合。</p>\n</li>\n<li><p><code>sigset_t saved_sigmask;</code>: 保存在设置了 <code>set_restore_sigmask()</code> 时被恢复的信号掩码。</p>\n</li>\n<li><p><code>struct sigpending pending;</code>: 挂起信号队列，包含了已经发送但尚未处理的信号。</p>\n</li>\n<li><p><code>unsigned long sas_ss_sp;</code> 和 <code>size_t sas_ss_size;</code>: 用户态的备用信号栈（Alternate Signal Stack）的起始地址和大小。</p>\n</li>\n<li><p><code>int (*notifier)(void *priv);</code>: 用于通知回调的函数指针。</p>\n</li>\n<li><p><code>void *notifier_data;</code>: 传递给通知回调函数的私有数据。</p>\n</li>\n<li><p><code>sigset_t *notifier_mask;</code>: 指向一个信号集，用于通知回调函数决定哪些信号需要通知。</p>\n</li>\n<li><p><code>struct callback_head *task_works;</code>: 与进程关联的回调函数链表。</p>\n</li>\n<li><p><code>struct audit_context *audit_context;</code>: 用于存储与审计相关的上下文信息。</p>\n</li>\n<li><p><code>kuid_t loginuid;</code> 和 <code>unsigned int sessionid;</code>: 用于记录登录用户的用户ID和会话ID。</p>\n</li>\n<li><p><code>struct seccomp seccomp;</code>: 用于存储与 seccomp（安全计算模式）相关的信息。</p>\n</li>\n</ul>\n<p>这个数据结构存储了与进程信号相关的各种信息，包括信号处理函数、阻塞信号、挂起信号、备用信号栈、通知回调等。这些信息在 Linux 内核中用于管理和处理进程接收到的各种信号。</p>\n<pre><code class=\"c\">struct sighand_struct {\n    atomic_t        count;\n    struct k_sigaction    action[_NSIG];\n    spinlock_t        siglock;\n    wait_queue_head_t    signalfd_wqh;\n};</code></pre>\n<p>其中的action是我们最需要关注的。它是一个长度为_NSIG的数组。下标为k的元素，就代表编号为k的信号的处理函数。k_sigaction实际上就是在内核态中对于sigaction的一个包装，signal函数就是将struct k_sigaction    action[_NSIG]的相应为设置成指定的函数。</p>\n"},{"title":"嵌入式软件框架方案","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-07-15T13:54:34.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"\n| 文件类型               | 研发过程文档   | 机密等级 | 机密     |\n|------------------------|----------------|----------|----------|\n| 文件编号               |                | 版本     | V1.0     |\n| 撰 写 人               |                | 日期     |          |\n| 审 核 人               |                | 日期     |          |\n| 批 准 人               |                | 日期     |          |\n| 项目名称               | XXX开发        |          |          |\n| **嵌入式软件框架设计** |                |          |          |\n| **相 关 文 档**        |                |          |          |\n| 文件编号               | 文件名称       | 版本     |          |\n|                        | 产品需求       |          |          |\n|                        | 用户需求       |          |          |\n|                        | 嵌入式软件需求 |          |          |\n|                        |                |          |          |\n|                        |                |          |          |\n|                        |                |          |          |\n|                        |                |          |          |\n|                        |                |          |          |\n| **修 订 记 录**        |                |          |          |\n| 版本                   | 修订内容       | 修订人   | 修订日期 |\n| V1.0                   | 创建           |          |          |\n|                        |                |          |          |\n|                        |                |          |          |\n|                        |                |          |          |\n|                        |                |          |          |\n|                        |                |          |          |\n|                        |                |          |          |\n\n**目 录**\n\n[0 版本记录](#_Toc57747469)\n\n[1 引言](#引言)\n\n[1.1 目的](#_Toc57747471)\n\n[1.2 背景](#_Toc57747472)\n\n[1.3 项目概述](#_Toc57747473)\n\n[1.4 术语与缩略语](#_Toc57747474)\n\n[1.5 引用文件](#_Toc57747475)\n\n[2 架构目标与设计约束](#_Toc57747476)\n\n[2.1 目标产品/目标产品系列](#_Toc57747477)\n\n[2.2 功能需求](#_Toc57747478)\n\n[2.3 上下文图](#上下文图)\n\n[2.4 质量需求](#_Toc57747480)\n\n[2.5 来自技术路线的约束：开发与运行环境限制](#来自技术路线的约束开发与运行环境限制)\n\n[2.6 来自硬件设计的约束：嵌入式硬件变化分析](#_Toc57747482)\n\n[2.7 来自上游方案的约束：整机配置变化分析](#来自上游方案的约束整机配置变化分析)\n\n[2.8 来自上游方案的约束：方案部署变化分析](#_Toc57747484)\n\n[3 架构思想](#_Toc57747485)\n\n[3.1 思想一：避免瓶颈、提高性能 【强制，嵌入式软件必须】](#_Toc57747486)\n\n[3.2 思想二：XXXXX](#思想二模块设计)\n\n[3.3 思想三：XXXXX](#思想三子系统设计)\n\n[4 架构设计](#_Toc57747489)\n\n[4.1 逻辑视图](#_Toc57747490)\n\n[4.2 产品/平台分工开发视图](#产品平台分工开发视图)\n\n[4.3 运行视图](#运行视图)\n\n[4.4 物理视图](#物理视图)\n\n[5 接口设计](#接口设计)\n\n[5.1 对外接口总览](#_Toc57747495)\n\n[5.2 各模块间接口总览](#各模块间接口总览)\n\n[5.3 平台和设备间接口总览](#_Toc57747497)\n\n[5.4 接口列表](#接口列表)\n\n[5.5 XXXXX接口设计](#xxxxx接口设计)\n\n[5.6 XXXXX接口设计](#xxxxx接口设计-1)\n\n[6 关键功能的设计原理](#_Toc57747501)\n\n[6.1 XXXXX功能设计](#xxxxx功能设计)\n\n[6.2 XXXXX功能设计](#xxxxx功能设计-1)\n\n[7 关键质量的设计原理](#_Toc57747504)\n\n[7.1 XXXX设计](#_Toc57747505)\n\n[7.2 XXXX设计](#xxxx设计-1)\n\n[7.3 XXXX设计](#xxxx设计-2)\n\n[8 对CBB管理的影响](#_Toc57747508)\n\n[8.1 本设计重用的CBB](#_Toc57747509)\n\n[8.2 本设计贡献的新CBB](#_Toc57747510)\n\n[8.3 本设计对现有CBB的升级需求](#_Toc57747511)\n\n# 引言\n\n## 目的\n\n*简要说明本文档的编写目的、用途和适用范围。*\n\n*【注意项】本节写“文档目的”，并非“项目目的”。*\n\n*【示例】*\n\n*本架构设计说明书编写的目的是……。本说明书的预期读者为系统设计人员、软件开发人员、软件测试人员和项目评审人员。*\n\n## 背景\n\n*简要说明产业背景、企业立项本项目的背景。*\n\n## 项目概述\n\n*简要说明项目内容、特点。*\n\n*【注意项】本节十分简洁，待到后续“2.1 目标产品/目标产品系列”适当展开。*\n\n## 术语与缩略语\n\n*本节集中说明和解释文档涉及的行业词汇、专业术语、首字母缩略语，提高文档可读性。*\n\n*【注意项】本节不可不写。*\n\n| **词汇** | **解释** |\n|----------|----------|\n|          |          |\n|          |          |\n|          |          |\n\n## 引用文件\n\n*应列出本文档引用的所有文档的编号、标题、修订版本和日期，方便读者查阅参考。*\n\n*【注意项】文档编号为□□公司为文档赋予的唯一正规编号。文档编号、文档版本号，均必写。*\n\n| **文档编号** | **文档名称** | **版本号** | **文档日期** |\n|--------------|--------------|------------|--------------|\n|              |              |            |              |\n|              |              |            |              |\n|              |              |            |              |\n|              |              |            |              |\n\n# 架构目标与设计约束\n\n*对于XX厂商，影响嵌入式软件架构设计大方向的不仅有功能需求、更有接口需求、运行开销约束、配置形态需求等。*\n\n*此节对后续架构设计的具体展开，具有重大指导、和方向性影响。*\n\n## 目标产品/目标产品系列\n\n*设备软件的研发有何特点？*\n\n*架构设计期能不能更有作为？*\n\n*多个相似产品的架构设计能否重用？*\n\n*设备软件有明显的“产品系列”特点，企业更是希望提高软件通用性与设计复用性，从而降成本。因此，本节应明确认真地说明：*\n\n*A）本架构设计文档是针对具体的一个产品、还是由多个产品组成的产品系列。*\n\n*B）如果针对产品系列，应对比其中各产品的关键能力、关键指标的不同。使读者有大局观。*\n\n*【注意项】面向产品系列而设计的架构，文档后续注意通用性设计、适应性设计的描述。*\n\n*概述目标产品，可以表格方式说明*\n\n| **架构设计针对的目标产品** | **产品说明** |\n|----------------------------|--------------|\n| Xx产品                     |              |\n| Yy产品                     |              |\n| Zz产品                     |              |\n\n*对比产品不同，可以《产品系列对比表》形式说明*\n\n*![](media/e852708ffd1c78efd87949efa7b31592.png)*\n\n## 功能需求\n\n### 功能树/功能列表\n\n*本节以功能树、功能表格等方式描述功能范围。*\n\n*注意1：无需展开描述。*\n\n*注意2：全面涵盖待研发的嵌入式设备软件的功能范围。*\n\n*【示例】功能树*\n\n![](media/dc4e3ddfdab5a0456af40df7d0a9238b.png)\n\n### 产品系列功能对比表\n\n*针对 “目标产品系列”的架构文档，请提供产品系列功能对比表。*\n\n*【注意项】针对“单个目标产品”的文档，请写“本节无内容”。*\n\n*【示例】产品系列功能特性对比表*\n\n*![](media/2dd308b3411c41658cce041f8c230853.png)*\n\n### * *关键功能识别与问题单分析\n\n*【背景1】关键需求决定架构。当设计需要权衡时，照顾的是关键需求。方法！*\n\n*【背景2】企业的问题单数据库，记录了同类系统暴露过的重大问题。风险！*\n\n*本节督促架构师去分析历史问题、提高设计针对性、避免问题重演：*\n\n*A）列出关键功能。文档后续的“6关键功能的设计原理”一节，应分别展开每个功能的设计。*\n\n*B）列出对问题单的单号、描述、风险点分析。设计时解决之。*\n\n*推荐描述形式*\n\n| **关键功能** | **问题单分析** |              |              |\n|--------------|----------------|--------------|--------------|\n|              | **单号**       | **历史问题** | **设计风险** |\n|              | \\#n            |              |              |\n|              | \\#m            |              |              |\n|              | \\#n            |              |              |\n|              | \\#m            |              |              |\n|              | \\#n            |              |              |\n|              | \\#m            |              |              |\n|              | \\#n            |              |              |\n|              | \\#m            |              |              |\n\n## 上下文图\n\n*本节以顶层数据流图的形式，描述XX软件的上下文，即与外部哪些其他控制器、硬件单元、软件系统等有接口。*\n\n*【示例】*\n\n## 质量需求\n\n*本节内容：*\n\n1.  *TODO XX公司应制定《嵌入式软件质量属性标准》，本节包含哪些小节应当与之一一对应。类似XX公司的系统工程化设计要求的“五可”：可靠性、可测试性、可生产性、可安装性，可服务性。*\n2.  *本节应覆盖来自高层需求文档的全部“质量指标”。*\n3.  *本节求全，不求细。不写场景，不写因素分解。*\n\n*制定《嵌入式软件质量属性标准》的参考一：某质量分类标准*\n\n| *运行期质量属性*                                                                                                                                                                                       | *开发期质量属性*                                                                                                                                                         |\n|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| *性能（Performance）* *安全性（Security）* *易用性（Usability）* *持续可用性（Availability）* *可伸缩性（Scalability）* *互操作性（Interoperability）* *可靠性（Reliability）* *鲁棒性（Robustness）*  | *易理解性（Understandability）* *可扩展性（Extensibility）* *可重用性（Reusability）* *可测试性（Testability）* *可维护性（Maintainability）* *可移植性（Portability）*  |\n\n*制定《嵌入式软件质量属性标准》的参考二：性能五项*\n\n*![](media/6aadad4da134377249d84bab5dbdfa8d.png)*\n\n### XXXX\n\n*该项质量的文字简述。不展开。*\n\n### XXXX\n\n*该项质量的文字简述。不展开。*\n\n## 来自技术路线的约束：开发与运行环境限制\n\n*公司的技术路线与技术战略中，包含了软件研发类技术选型的考虑，具体产品的架构师往往没有权力任意改变技术选型。本节内容：*\n\n1.  *简述技术选型约束*\n2.  *分析技术选型对关键资源的开销*\n\n### 开发环境约定\n\n*简单列举嵌入式软件研发的公司约定：开发语言、编译环境、本公司开发平台等。*\n\n### 运行环境约定\n\n*简单列举嵌入式软件研发的公司约定：硬件要求、操作系统、关系数据、实时数据库等。*\n\n### 选型的资源开销分析：CPU资源\n\n*资源紧、效率关键是嵌入式开发的特点。本节分析上述技术选型带来的CPU资源开销：*\n\n-   *CPU占用率、*\n-   *最大最小值、*\n-   *可能的架构风险。*\n\n### 选型的资源开销分析：内存资源\n\n*资源紧、效率关键是嵌入式开发的特点。本节分析上述技术选型带来的内存资源开销：*\n\n-   *内存占用率、*\n-   *最大最小值、*\n-   *可能的架构风险。*\n\n### 选型的资源开销分析：Flash资源\n\n*资源紧、效率关键是嵌入式开发的特点。本节分析上述技术选型带来的存储空间资源开销：*\n\n-   *存储空间占用率、*\n-   *最大最小值、*\n-   *可能的架构风险。*\n\n*【例如】例如Log组件高频度存储日志会消耗极多存储空间。架构师应尽早考虑如下影响：*\n\n-   *对于软件包大小的限制*\n-   *其他软件包大小的规划*\n-   *LOG存储策略、存储频度的考虑*\n\n## 来自硬件设计的约束：嵌入式硬件变化分析\n\n*本节通过多个硬件结构框图，列出所有（即穷举）可能的嵌入式硬件结构。这对后续架构的驱动层设计有直接影响。*\n\n*【FAQ】如果硬件设计还未完成，我要如何穷举所有可能的嵌入式硬件结构？*\n\n*【答】架构设计开始较早，这决定了架构师和程序员的一个极大不同，即软件架构师“时刻保持和硬件设计师的直接沟通”、“不应等待正式的《硬件设计文档》发布后才开始设计”。这一点，和程序员“在正式《需求规格》发布后才编程”有极大不同。*\n\n*【示例1】*\n\n*![](media/32643a6fbe010dcc95af301416619164.png)*\n\n## 来自上游方案的约束：整机配置变化分析\n\n*整机配置，指一台整机设备内如下不同：*\n\n-   *背板总线类型*\n-   *主控板类型*\n-   *主控板是否有主备、是否有群集*\n-   *非主控板的数量*\n-   *非主控板的种类*\n\n*本节通过多个图，列出所有（即穷举）可能的整机配置。*\n\n*【示例】*\n\n*![](media/22c7469876239933b38a12a32e9c6f16.png)*\n\n# 架构思想\n\n*作为架构师，你在本节，应当重点突出地说明有价值、有独特性的2\\~3条设计思想。*\n\n-   *例如，嵌入式软件可用的CPU、内存等资源有限，你的规划思想规划原则是什么*\n-   *例如，你如何运用状态机处理核心硬件的复杂状态组合*\n-   *……*\n\n## 思想一：避免瓶颈、提高性能 【强制，嵌入式软件必须】\n\n*分析关键资源约束，并在此给出相应的设计准则：*\n\n-   *例如，如果CPU是瓶颈，应约定“最大线程数限制”等设计原则并具体说明*\n-   *例如，如果内存是瓶颈，应约定“限制Cache滥用”等设计原则并具体说明*\n-   *例如，如果Flash紧缺，应约定“限制Log存储频率”等设计原则并具体说明*\n\n## 思想二：模块设计\n\n*只需重点突出地说明有价值、有独特性的2\\~3条设计思想。*\n\n## 思想三：子系统设计\n\n*只需重点突出地说明有价值、有独特性的2\\~3条设计思想。*\n\n# 架构设计\n\n## 逻辑视图\n\n### 功能子系统划分\n\n*纵切：功能子系统*\n\n*列出或画出包含的功能子系统，并说明。*\n\n### 系统分层架构\n\n*横切：逻辑层*\n\n*此处描述分层架构，有时采用“*系统分层架构**+**每层所用技术*”的形式将重要技术选型也描述进来。*\n\n*【示例】*\n\n## 产品/平台分工开发视图\n\n**【开发视图 vs. 产品/平台分工开发视图】**\n\n*开发视图，5视图之一，是单一视图——产品开发单元的切分，没有涉及平台扩充。*\n\n*产品/平台分工开发视图，是混合视图——产品要开发，同时平台要生长扩充。*\n\n**【本节内容】**\n\n*首先，要说清功能需求映射到产品组件、还是平台组件。*\n\n*其次，要说明平台总共要增加哪些组件、增强哪些组件。*\n\n*最后，才是详细说明产品组件有哪些、又分别对应哪些代码工程。*\n\n### 需求映射 与 产品/平台组件识别\n\n*此前需求分析做过的工作，架构师不再重复。本节也不写。*\n\n1.  *分析本嵌入式设备上实现的业务场景*\n2.  *分解出多项功能需求*\n\n*本节，架构师需要做：*\n\n1.  *将功能需求映射到对应的嵌入式软件的具体组件，并区分它是产品组件还是平台组件。以表格形式呈现。*\n\n*推荐形式：功能与参与功能实现的组件的映射矩阵*\n\n*![](media/780552b6b4ceacfe274a8c687b74a569.png)*\n\n### 平台架构 与 新增/增强组件的位置 【平台侧】\n\n*画出平台架构图，平台尽量黑盒化，不变的组件尽量少体现，重点体现平台侧还要加强的组件，特别标出新增/增强组件的位置。*\n\n### 产品组件 与 各组件说明 【产品侧】\n\n*可采用多种方式：列表格、画UML组件图并辅以文字说明。*\n\n*【示例】*\n\n| *序号* | *模块名称*    | *子模块名称*       | *功能说明*                                                             |\n|--------|---------------|--------------------|------------------------------------------------------------------------|\n| *1*    |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n| *2*    | *MCU机电模块* | *机电通信模块*     | *实现NMU机电模块与K10主机的通信。*                                     |\n|        |               | *电子标签接口模块* | *实现背板EEPROM的电子信息写入和读出。*                                 |\n|        |               | *风扇接口模块*     | *通过风扇控制寄存器的访问接口。*                                       |\n|        |               | *风扇控制模块*     | *提供对风扇单元转速的控制接口，风扇单元的工作状态和告警信息读取接口。* |\n|        |               | *机电应用模块*     | *实现机电信息的收集处理和上报，接收、响应NMU指令。*                    |\n|        |               | *机电软件下载模块* | *建立与K10主机机电软件下载会话，实现机电软件模块切割分片传送。*        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n| *3*    |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n\n### 产品组件对应的代码工程 与 开发技术 【产品侧】\n\n*说明嵌入式软件（产品侧）包含的多个开发工程（Project）或Makefile。*\n\n*细致地说明，每个组件开发所需的三方库、框架。*\n\n*【示例】*\n\n## 运行视图\n\n### 嵌入式软件：运行架构总览\n\n*说明嵌入式软件运行态下，有哪些进程、线程、以及对应组件的功能简述。*\n\n*【示例】*\n\n| **进程** | **线程** | **组件** | **组件功能** |\n|----------|----------|----------|--------------|\n|          |          |          |              |\n|          |          |          |              |\n|          |          |          |              |\n|          |          |          |              |\n|          |          |          |              |\n|          |          |          |              |\n|          |          |          |              |\n|          |          |          |              |\n|          |          |          |              |\n\n### 嵌入式软件中的组件：能否创建线程的准则\n\n*说明嵌入式软件产品侧线程创建的准则：*\n\n-   *哪些情况可以创建线程*\n-   *哪些情况杜绝滥启线程★★★*\n\n*后续组件详细设计师必须严格遵守，杜绝线程泛滥拉低性能和易理解性。*\n\n## 物理视图\n\n### 运行环境\n\n*细致地说明，嵌入式的硬件配置。*\n\n*细致地说明操作系统、各种系统软件、中间件的种类和版本。*\n\n*【示例】*\n\n| *硬件环境* *主CPU扣板为P2041，底板核心交换芯片为Qumran的硬件板卡。* *硬件配置* *CPU型号: p2041* *CPU主频：1.5GHz* *CPU核数：4\\*e500mc核* *CPU位宽：32位* *内存：4096 MB* *操作系统* *Linux localhost 2.6.34.15-grsec-WR4.3.0.0_cgl \\#1 SMP PREEMPT Fri Nov 4 16:51:14 CST 2016 ppc ppc ppc GNU/Linux* |\n|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n\n### 发布包目录结构及目标路径定义\n\n*本节应描述：*\n\n*A）发布包的详细目录结构约定。*\n\n*B）发布包应该mount到的目标路径*\n\n*【示例】*\n\n*。。。。。。*\n\n### * *组件部署结构\n\n*嵌入式软件往往由许多组件组成，本节重点说明组件之间的上下游关系。*\n\n*【示例】*\n\n# 接口设计\n\n## 对外接口总览\n\n画图，概览本嵌入式软件的对外接口的位置。\n\n## 各模块间接口总览\n\n画图，概览嵌入式软件内部的做个组件之间接口的位置。\n\n## 平台和设备间接口总览\n\n画图，概览平台与设备间接口的位置。\n\n## 接口列表\n\n列出接口名称和功能，对外和内部分别罗列。\n\n## XXXXX接口设计\n\n接口=交互过程+技术选择+格式定义。交互过程用序列图刻画\n\n*【示例1】函数接口的格式定义*\n\n| **名称**                                                                                                                                                                                                                                                             | dhcm回调函数                                      |          |\n|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------|----------|\n| **用途**                                                                                                                                                                                                                                                             | **DHCM组件提供给DDA的回调接口**                   |          |\n| **声明**                                                                                                                                                                                                                                                             |                                                   |          |\n| typedef struct tag_dhcm_callback {  INT32 (\\*dcoi_board_init)(DCOI_BOARD_INIT_INFO \\*init_info);  UINT32 (\\*dcoi_get_support_card_flag)();  UINT32 (\\*dcoi_cmi_ready_cb)();  VOID (\\*dcoi_dhcs_ready)(DHCS_CARD_COMP_INFO_MSG_EN \\*card_comp_info);  }DHCM_CALLBACK; |                                                   |          |\n| **字段**                                                                                                                                                                                                                                                             | **含义**                                          | **说明** |\n| dcoi_board_init                                                                                                                                                                                                                                                      | 嵌入式初始化的调用，包含硬件初始化和软件初始化。  |          |\n| dcoi_get_support_card_flag                                                                                                                                                                                                                                           | 返回嵌入式是否支持子卡的信息                      |          |\n| dcoi_cmi_ready_cb                                                                                                                                                                                                                                                    | 判断组件cmi是否有值                               |          |\n| dcoi_dhcs_ready                                                                                                                                                                                                                                                      | 获取嵌入式建模信息，包含框/槽/子卡/板类型等信息。 |          |\n\n*【示例2】协议接口的格式定义*\n\n![](media/60a0b6815e87242adbc049d64b96e01b.png)\n\n## XXXXX接口设计\n\n接口=交互过程+技术选择+格式定义。交互过程用序列图刻画\n\n# 关键功能的设计原理\n\n*本节内容：*\n\n-   *典型功能的设计*\n-   *“2.2.3关键功能识别与问题单分析”节中每个关键功能的设计*\n\n## XXXXX功能设计\n\n*用“*协作图+文字说明*”的方式说明每个关键功能的设计原理。图可以是下列方式之一：*\n\n-   *序列图*\n-   *协作图*\n-   *涉及多进程多线程的，图中应刻画出“进程/线程”*\n-   *设计跨机器分布式的，图中应刻画出“机器/控制板”*\n-   *协作逻辑复杂的，图中标号，再针对每个标号进行文字说明*\n\n## XXXXX功能设计\n\n# 关键质量的设计原理\n\n## XXXX设计\n\n### 影响质量的因素分解表/质量因素树\n\n*本节的核心是运用分解思维、系统化思维，梳理影响质量的因素。可采用表格、树等形式。*\n\n### 目标-场景-决策表\n\n*本节的核心是运用场景思维、具体化思维，分析质量因素对系统的具体影响，并给出设计对策。*\n\n*【注意项】推荐使用目标-场景-决策表，表中场景按“质量场景规约”格式编写*\n\n*![](media/c7546c50623e8a8aa6ab33ead8fac6cb.png)*\n\n### 设计原理图\n\n【示例】![](media/e7176066eab77c0cf6e147aed0046ea7.png)\n\n## XXXX设计\n\n### 影响质量的因素分解表/质量因素树\n\n### 目标-场景-决策表\n\n### 设计原理图\n\n## XXXX设计\n\n### 影响质量的因素分解表/质量因素树\n\n### 目标-场景-决策表\n\n### 设计原理图\n\n# \n","source":"_posts/2023/07/嵌入式软件框架方案.md","raw":"---\ntitle: 嵌入式软件框架方案\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-07-15 21:54:34\npassword:\nsummary:\ntags:\n- Embedded system\ncategories:\n- Embedded system\nkeywords:\ndescription:\n---\n\n| 文件类型               | 研发过程文档   | 机密等级 | 机密     |\n|------------------------|----------------|----------|----------|\n| 文件编号               |                | 版本     | V1.0     |\n| 撰 写 人               |                | 日期     |          |\n| 审 核 人               |                | 日期     |          |\n| 批 准 人               |                | 日期     |          |\n| 项目名称               | XXX开发        |          |          |\n| **嵌入式软件框架设计** |                |          |          |\n| **相 关 文 档**        |                |          |          |\n| 文件编号               | 文件名称       | 版本     |          |\n|                        | 产品需求       |          |          |\n|                        | 用户需求       |          |          |\n|                        | 嵌入式软件需求 |          |          |\n|                        |                |          |          |\n|                        |                |          |          |\n|                        |                |          |          |\n|                        |                |          |          |\n|                        |                |          |          |\n| **修 订 记 录**        |                |          |          |\n| 版本                   | 修订内容       | 修订人   | 修订日期 |\n| V1.0                   | 创建           |          |          |\n|                        |                |          |          |\n|                        |                |          |          |\n|                        |                |          |          |\n|                        |                |          |          |\n|                        |                |          |          |\n|                        |                |          |          |\n\n**目 录**\n\n[0 版本记录](#_Toc57747469)\n\n[1 引言](#引言)\n\n[1.1 目的](#_Toc57747471)\n\n[1.2 背景](#_Toc57747472)\n\n[1.3 项目概述](#_Toc57747473)\n\n[1.4 术语与缩略语](#_Toc57747474)\n\n[1.5 引用文件](#_Toc57747475)\n\n[2 架构目标与设计约束](#_Toc57747476)\n\n[2.1 目标产品/目标产品系列](#_Toc57747477)\n\n[2.2 功能需求](#_Toc57747478)\n\n[2.3 上下文图](#上下文图)\n\n[2.4 质量需求](#_Toc57747480)\n\n[2.5 来自技术路线的约束：开发与运行环境限制](#来自技术路线的约束开发与运行环境限制)\n\n[2.6 来自硬件设计的约束：嵌入式硬件变化分析](#_Toc57747482)\n\n[2.7 来自上游方案的约束：整机配置变化分析](#来自上游方案的约束整机配置变化分析)\n\n[2.8 来自上游方案的约束：方案部署变化分析](#_Toc57747484)\n\n[3 架构思想](#_Toc57747485)\n\n[3.1 思想一：避免瓶颈、提高性能 【强制，嵌入式软件必须】](#_Toc57747486)\n\n[3.2 思想二：XXXXX](#思想二模块设计)\n\n[3.3 思想三：XXXXX](#思想三子系统设计)\n\n[4 架构设计](#_Toc57747489)\n\n[4.1 逻辑视图](#_Toc57747490)\n\n[4.2 产品/平台分工开发视图](#产品平台分工开发视图)\n\n[4.3 运行视图](#运行视图)\n\n[4.4 物理视图](#物理视图)\n\n[5 接口设计](#接口设计)\n\n[5.1 对外接口总览](#_Toc57747495)\n\n[5.2 各模块间接口总览](#各模块间接口总览)\n\n[5.3 平台和设备间接口总览](#_Toc57747497)\n\n[5.4 接口列表](#接口列表)\n\n[5.5 XXXXX接口设计](#xxxxx接口设计)\n\n[5.6 XXXXX接口设计](#xxxxx接口设计-1)\n\n[6 关键功能的设计原理](#_Toc57747501)\n\n[6.1 XXXXX功能设计](#xxxxx功能设计)\n\n[6.2 XXXXX功能设计](#xxxxx功能设计-1)\n\n[7 关键质量的设计原理](#_Toc57747504)\n\n[7.1 XXXX设计](#_Toc57747505)\n\n[7.2 XXXX设计](#xxxx设计-1)\n\n[7.3 XXXX设计](#xxxx设计-2)\n\n[8 对CBB管理的影响](#_Toc57747508)\n\n[8.1 本设计重用的CBB](#_Toc57747509)\n\n[8.2 本设计贡献的新CBB](#_Toc57747510)\n\n[8.3 本设计对现有CBB的升级需求](#_Toc57747511)\n\n# 引言\n\n## 目的\n\n*简要说明本文档的编写目的、用途和适用范围。*\n\n*【注意项】本节写“文档目的”，并非“项目目的”。*\n\n*【示例】*\n\n*本架构设计说明书编写的目的是……。本说明书的预期读者为系统设计人员、软件开发人员、软件测试人员和项目评审人员。*\n\n## 背景\n\n*简要说明产业背景、企业立项本项目的背景。*\n\n## 项目概述\n\n*简要说明项目内容、特点。*\n\n*【注意项】本节十分简洁，待到后续“2.1 目标产品/目标产品系列”适当展开。*\n\n## 术语与缩略语\n\n*本节集中说明和解释文档涉及的行业词汇、专业术语、首字母缩略语，提高文档可读性。*\n\n*【注意项】本节不可不写。*\n\n| **词汇** | **解释** |\n|----------|----------|\n|          |          |\n|          |          |\n|          |          |\n\n## 引用文件\n\n*应列出本文档引用的所有文档的编号、标题、修订版本和日期，方便读者查阅参考。*\n\n*【注意项】文档编号为□□公司为文档赋予的唯一正规编号。文档编号、文档版本号，均必写。*\n\n| **文档编号** | **文档名称** | **版本号** | **文档日期** |\n|--------------|--------------|------------|--------------|\n|              |              |            |              |\n|              |              |            |              |\n|              |              |            |              |\n|              |              |            |              |\n\n# 架构目标与设计约束\n\n*对于XX厂商，影响嵌入式软件架构设计大方向的不仅有功能需求、更有接口需求、运行开销约束、配置形态需求等。*\n\n*此节对后续架构设计的具体展开，具有重大指导、和方向性影响。*\n\n## 目标产品/目标产品系列\n\n*设备软件的研发有何特点？*\n\n*架构设计期能不能更有作为？*\n\n*多个相似产品的架构设计能否重用？*\n\n*设备软件有明显的“产品系列”特点，企业更是希望提高软件通用性与设计复用性，从而降成本。因此，本节应明确认真地说明：*\n\n*A）本架构设计文档是针对具体的一个产品、还是由多个产品组成的产品系列。*\n\n*B）如果针对产品系列，应对比其中各产品的关键能力、关键指标的不同。使读者有大局观。*\n\n*【注意项】面向产品系列而设计的架构，文档后续注意通用性设计、适应性设计的描述。*\n\n*概述目标产品，可以表格方式说明*\n\n| **架构设计针对的目标产品** | **产品说明** |\n|----------------------------|--------------|\n| Xx产品                     |              |\n| Yy产品                     |              |\n| Zz产品                     |              |\n\n*对比产品不同，可以《产品系列对比表》形式说明*\n\n*![](media/e852708ffd1c78efd87949efa7b31592.png)*\n\n## 功能需求\n\n### 功能树/功能列表\n\n*本节以功能树、功能表格等方式描述功能范围。*\n\n*注意1：无需展开描述。*\n\n*注意2：全面涵盖待研发的嵌入式设备软件的功能范围。*\n\n*【示例】功能树*\n\n![](media/dc4e3ddfdab5a0456af40df7d0a9238b.png)\n\n### 产品系列功能对比表\n\n*针对 “目标产品系列”的架构文档，请提供产品系列功能对比表。*\n\n*【注意项】针对“单个目标产品”的文档，请写“本节无内容”。*\n\n*【示例】产品系列功能特性对比表*\n\n*![](media/2dd308b3411c41658cce041f8c230853.png)*\n\n### * *关键功能识别与问题单分析\n\n*【背景1】关键需求决定架构。当设计需要权衡时，照顾的是关键需求。方法！*\n\n*【背景2】企业的问题单数据库，记录了同类系统暴露过的重大问题。风险！*\n\n*本节督促架构师去分析历史问题、提高设计针对性、避免问题重演：*\n\n*A）列出关键功能。文档后续的“6关键功能的设计原理”一节，应分别展开每个功能的设计。*\n\n*B）列出对问题单的单号、描述、风险点分析。设计时解决之。*\n\n*推荐描述形式*\n\n| **关键功能** | **问题单分析** |              |              |\n|--------------|----------------|--------------|--------------|\n|              | **单号**       | **历史问题** | **设计风险** |\n|              | \\#n            |              |              |\n|              | \\#m            |              |              |\n|              | \\#n            |              |              |\n|              | \\#m            |              |              |\n|              | \\#n            |              |              |\n|              | \\#m            |              |              |\n|              | \\#n            |              |              |\n|              | \\#m            |              |              |\n\n## 上下文图\n\n*本节以顶层数据流图的形式，描述XX软件的上下文，即与外部哪些其他控制器、硬件单元、软件系统等有接口。*\n\n*【示例】*\n\n## 质量需求\n\n*本节内容：*\n\n1.  *TODO XX公司应制定《嵌入式软件质量属性标准》，本节包含哪些小节应当与之一一对应。类似XX公司的系统工程化设计要求的“五可”：可靠性、可测试性、可生产性、可安装性，可服务性。*\n2.  *本节应覆盖来自高层需求文档的全部“质量指标”。*\n3.  *本节求全，不求细。不写场景，不写因素分解。*\n\n*制定《嵌入式软件质量属性标准》的参考一：某质量分类标准*\n\n| *运行期质量属性*                                                                                                                                                                                       | *开发期质量属性*                                                                                                                                                         |\n|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| *性能（Performance）* *安全性（Security）* *易用性（Usability）* *持续可用性（Availability）* *可伸缩性（Scalability）* *互操作性（Interoperability）* *可靠性（Reliability）* *鲁棒性（Robustness）*  | *易理解性（Understandability）* *可扩展性（Extensibility）* *可重用性（Reusability）* *可测试性（Testability）* *可维护性（Maintainability）* *可移植性（Portability）*  |\n\n*制定《嵌入式软件质量属性标准》的参考二：性能五项*\n\n*![](media/6aadad4da134377249d84bab5dbdfa8d.png)*\n\n### XXXX\n\n*该项质量的文字简述。不展开。*\n\n### XXXX\n\n*该项质量的文字简述。不展开。*\n\n## 来自技术路线的约束：开发与运行环境限制\n\n*公司的技术路线与技术战略中，包含了软件研发类技术选型的考虑，具体产品的架构师往往没有权力任意改变技术选型。本节内容：*\n\n1.  *简述技术选型约束*\n2.  *分析技术选型对关键资源的开销*\n\n### 开发环境约定\n\n*简单列举嵌入式软件研发的公司约定：开发语言、编译环境、本公司开发平台等。*\n\n### 运行环境约定\n\n*简单列举嵌入式软件研发的公司约定：硬件要求、操作系统、关系数据、实时数据库等。*\n\n### 选型的资源开销分析：CPU资源\n\n*资源紧、效率关键是嵌入式开发的特点。本节分析上述技术选型带来的CPU资源开销：*\n\n-   *CPU占用率、*\n-   *最大最小值、*\n-   *可能的架构风险。*\n\n### 选型的资源开销分析：内存资源\n\n*资源紧、效率关键是嵌入式开发的特点。本节分析上述技术选型带来的内存资源开销：*\n\n-   *内存占用率、*\n-   *最大最小值、*\n-   *可能的架构风险。*\n\n### 选型的资源开销分析：Flash资源\n\n*资源紧、效率关键是嵌入式开发的特点。本节分析上述技术选型带来的存储空间资源开销：*\n\n-   *存储空间占用率、*\n-   *最大最小值、*\n-   *可能的架构风险。*\n\n*【例如】例如Log组件高频度存储日志会消耗极多存储空间。架构师应尽早考虑如下影响：*\n\n-   *对于软件包大小的限制*\n-   *其他软件包大小的规划*\n-   *LOG存储策略、存储频度的考虑*\n\n## 来自硬件设计的约束：嵌入式硬件变化分析\n\n*本节通过多个硬件结构框图，列出所有（即穷举）可能的嵌入式硬件结构。这对后续架构的驱动层设计有直接影响。*\n\n*【FAQ】如果硬件设计还未完成，我要如何穷举所有可能的嵌入式硬件结构？*\n\n*【答】架构设计开始较早，这决定了架构师和程序员的一个极大不同，即软件架构师“时刻保持和硬件设计师的直接沟通”、“不应等待正式的《硬件设计文档》发布后才开始设计”。这一点，和程序员“在正式《需求规格》发布后才编程”有极大不同。*\n\n*【示例1】*\n\n*![](media/32643a6fbe010dcc95af301416619164.png)*\n\n## 来自上游方案的约束：整机配置变化分析\n\n*整机配置，指一台整机设备内如下不同：*\n\n-   *背板总线类型*\n-   *主控板类型*\n-   *主控板是否有主备、是否有群集*\n-   *非主控板的数量*\n-   *非主控板的种类*\n\n*本节通过多个图，列出所有（即穷举）可能的整机配置。*\n\n*【示例】*\n\n*![](media/22c7469876239933b38a12a32e9c6f16.png)*\n\n# 架构思想\n\n*作为架构师，你在本节，应当重点突出地说明有价值、有独特性的2\\~3条设计思想。*\n\n-   *例如，嵌入式软件可用的CPU、内存等资源有限，你的规划思想规划原则是什么*\n-   *例如，你如何运用状态机处理核心硬件的复杂状态组合*\n-   *……*\n\n## 思想一：避免瓶颈、提高性能 【强制，嵌入式软件必须】\n\n*分析关键资源约束，并在此给出相应的设计准则：*\n\n-   *例如，如果CPU是瓶颈，应约定“最大线程数限制”等设计原则并具体说明*\n-   *例如，如果内存是瓶颈，应约定“限制Cache滥用”等设计原则并具体说明*\n-   *例如，如果Flash紧缺，应约定“限制Log存储频率”等设计原则并具体说明*\n\n## 思想二：模块设计\n\n*只需重点突出地说明有价值、有独特性的2\\~3条设计思想。*\n\n## 思想三：子系统设计\n\n*只需重点突出地说明有价值、有独特性的2\\~3条设计思想。*\n\n# 架构设计\n\n## 逻辑视图\n\n### 功能子系统划分\n\n*纵切：功能子系统*\n\n*列出或画出包含的功能子系统，并说明。*\n\n### 系统分层架构\n\n*横切：逻辑层*\n\n*此处描述分层架构，有时采用“*系统分层架构**+**每层所用技术*”的形式将重要技术选型也描述进来。*\n\n*【示例】*\n\n## 产品/平台分工开发视图\n\n**【开发视图 vs. 产品/平台分工开发视图】**\n\n*开发视图，5视图之一，是单一视图——产品开发单元的切分，没有涉及平台扩充。*\n\n*产品/平台分工开发视图，是混合视图——产品要开发，同时平台要生长扩充。*\n\n**【本节内容】**\n\n*首先，要说清功能需求映射到产品组件、还是平台组件。*\n\n*其次，要说明平台总共要增加哪些组件、增强哪些组件。*\n\n*最后，才是详细说明产品组件有哪些、又分别对应哪些代码工程。*\n\n### 需求映射 与 产品/平台组件识别\n\n*此前需求分析做过的工作，架构师不再重复。本节也不写。*\n\n1.  *分析本嵌入式设备上实现的业务场景*\n2.  *分解出多项功能需求*\n\n*本节，架构师需要做：*\n\n1.  *将功能需求映射到对应的嵌入式软件的具体组件，并区分它是产品组件还是平台组件。以表格形式呈现。*\n\n*推荐形式：功能与参与功能实现的组件的映射矩阵*\n\n*![](media/780552b6b4ceacfe274a8c687b74a569.png)*\n\n### 平台架构 与 新增/增强组件的位置 【平台侧】\n\n*画出平台架构图，平台尽量黑盒化，不变的组件尽量少体现，重点体现平台侧还要加强的组件，特别标出新增/增强组件的位置。*\n\n### 产品组件 与 各组件说明 【产品侧】\n\n*可采用多种方式：列表格、画UML组件图并辅以文字说明。*\n\n*【示例】*\n\n| *序号* | *模块名称*    | *子模块名称*       | *功能说明*                                                             |\n|--------|---------------|--------------------|------------------------------------------------------------------------|\n| *1*    |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n| *2*    | *MCU机电模块* | *机电通信模块*     | *实现NMU机电模块与K10主机的通信。*                                     |\n|        |               | *电子标签接口模块* | *实现背板EEPROM的电子信息写入和读出。*                                 |\n|        |               | *风扇接口模块*     | *通过风扇控制寄存器的访问接口。*                                       |\n|        |               | *风扇控制模块*     | *提供对风扇单元转速的控制接口，风扇单元的工作状态和告警信息读取接口。* |\n|        |               | *机电应用模块*     | *实现机电信息的收集处理和上报，接收、响应NMU指令。*                    |\n|        |               | *机电软件下载模块* | *建立与K10主机机电软件下载会话，实现机电软件模块切割分片传送。*        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n| *3*    |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n|        |               |                    |                                                                        |\n\n### 产品组件对应的代码工程 与 开发技术 【产品侧】\n\n*说明嵌入式软件（产品侧）包含的多个开发工程（Project）或Makefile。*\n\n*细致地说明，每个组件开发所需的三方库、框架。*\n\n*【示例】*\n\n## 运行视图\n\n### 嵌入式软件：运行架构总览\n\n*说明嵌入式软件运行态下，有哪些进程、线程、以及对应组件的功能简述。*\n\n*【示例】*\n\n| **进程** | **线程** | **组件** | **组件功能** |\n|----------|----------|----------|--------------|\n|          |          |          |              |\n|          |          |          |              |\n|          |          |          |              |\n|          |          |          |              |\n|          |          |          |              |\n|          |          |          |              |\n|          |          |          |              |\n|          |          |          |              |\n|          |          |          |              |\n\n### 嵌入式软件中的组件：能否创建线程的准则\n\n*说明嵌入式软件产品侧线程创建的准则：*\n\n-   *哪些情况可以创建线程*\n-   *哪些情况杜绝滥启线程★★★*\n\n*后续组件详细设计师必须严格遵守，杜绝线程泛滥拉低性能和易理解性。*\n\n## 物理视图\n\n### 运行环境\n\n*细致地说明，嵌入式的硬件配置。*\n\n*细致地说明操作系统、各种系统软件、中间件的种类和版本。*\n\n*【示例】*\n\n| *硬件环境* *主CPU扣板为P2041，底板核心交换芯片为Qumran的硬件板卡。* *硬件配置* *CPU型号: p2041* *CPU主频：1.5GHz* *CPU核数：4\\*e500mc核* *CPU位宽：32位* *内存：4096 MB* *操作系统* *Linux localhost 2.6.34.15-grsec-WR4.3.0.0_cgl \\#1 SMP PREEMPT Fri Nov 4 16:51:14 CST 2016 ppc ppc ppc GNU/Linux* |\n|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n\n### 发布包目录结构及目标路径定义\n\n*本节应描述：*\n\n*A）发布包的详细目录结构约定。*\n\n*B）发布包应该mount到的目标路径*\n\n*【示例】*\n\n*。。。。。。*\n\n### * *组件部署结构\n\n*嵌入式软件往往由许多组件组成，本节重点说明组件之间的上下游关系。*\n\n*【示例】*\n\n# 接口设计\n\n## 对外接口总览\n\n画图，概览本嵌入式软件的对外接口的位置。\n\n## 各模块间接口总览\n\n画图，概览嵌入式软件内部的做个组件之间接口的位置。\n\n## 平台和设备间接口总览\n\n画图，概览平台与设备间接口的位置。\n\n## 接口列表\n\n列出接口名称和功能，对外和内部分别罗列。\n\n## XXXXX接口设计\n\n接口=交互过程+技术选择+格式定义。交互过程用序列图刻画\n\n*【示例1】函数接口的格式定义*\n\n| **名称**                                                                                                                                                                                                                                                             | dhcm回调函数                                      |          |\n|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------|----------|\n| **用途**                                                                                                                                                                                                                                                             | **DHCM组件提供给DDA的回调接口**                   |          |\n| **声明**                                                                                                                                                                                                                                                             |                                                   |          |\n| typedef struct tag_dhcm_callback {  INT32 (\\*dcoi_board_init)(DCOI_BOARD_INIT_INFO \\*init_info);  UINT32 (\\*dcoi_get_support_card_flag)();  UINT32 (\\*dcoi_cmi_ready_cb)();  VOID (\\*dcoi_dhcs_ready)(DHCS_CARD_COMP_INFO_MSG_EN \\*card_comp_info);  }DHCM_CALLBACK; |                                                   |          |\n| **字段**                                                                                                                                                                                                                                                             | **含义**                                          | **说明** |\n| dcoi_board_init                                                                                                                                                                                                                                                      | 嵌入式初始化的调用，包含硬件初始化和软件初始化。  |          |\n| dcoi_get_support_card_flag                                                                                                                                                                                                                                           | 返回嵌入式是否支持子卡的信息                      |          |\n| dcoi_cmi_ready_cb                                                                                                                                                                                                                                                    | 判断组件cmi是否有值                               |          |\n| dcoi_dhcs_ready                                                                                                                                                                                                                                                      | 获取嵌入式建模信息，包含框/槽/子卡/板类型等信息。 |          |\n\n*【示例2】协议接口的格式定义*\n\n![](media/60a0b6815e87242adbc049d64b96e01b.png)\n\n## XXXXX接口设计\n\n接口=交互过程+技术选择+格式定义。交互过程用序列图刻画\n\n# 关键功能的设计原理\n\n*本节内容：*\n\n-   *典型功能的设计*\n-   *“2.2.3关键功能识别与问题单分析”节中每个关键功能的设计*\n\n## XXXXX功能设计\n\n*用“*协作图+文字说明*”的方式说明每个关键功能的设计原理。图可以是下列方式之一：*\n\n-   *序列图*\n-   *协作图*\n-   *涉及多进程多线程的，图中应刻画出“进程/线程”*\n-   *设计跨机器分布式的，图中应刻画出“机器/控制板”*\n-   *协作逻辑复杂的，图中标号，再针对每个标号进行文字说明*\n\n## XXXXX功能设计\n\n# 关键质量的设计原理\n\n## XXXX设计\n\n### 影响质量的因素分解表/质量因素树\n\n*本节的核心是运用分解思维、系统化思维，梳理影响质量的因素。可采用表格、树等形式。*\n\n### 目标-场景-决策表\n\n*本节的核心是运用场景思维、具体化思维，分析质量因素对系统的具体影响，并给出设计对策。*\n\n*【注意项】推荐使用目标-场景-决策表，表中场景按“质量场景规约”格式编写*\n\n*![](media/c7546c50623e8a8aa6ab33ead8fac6cb.png)*\n\n### 设计原理图\n\n【示例】![](media/e7176066eab77c0cf6e147aed0046ea7.png)\n\n## XXXX设计\n\n### 影响质量的因素分解表/质量因素树\n\n### 目标-场景-决策表\n\n### 设计原理图\n\n## XXXX设计\n\n### 影响质量的因素分解表/质量因素树\n\n### 目标-场景-决策表\n\n### 设计原理图\n\n# \n","slug":"嵌入式软件框架方案","published":1,"updated":"2024-01-05T08:12:19.791Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clru1g21o0022s4fugc4vhpx2","content":"<table>\n<thead>\n<tr>\n<th>文件类型</th>\n<th>研发过程文档</th>\n<th>机密等级</th>\n<th>机密</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>文件编号</td>\n<td></td>\n<td>版本</td>\n<td>V1.0</td>\n</tr>\n<tr>\n<td>撰 写 人</td>\n<td></td>\n<td>日期</td>\n<td></td>\n</tr>\n<tr>\n<td>审 核 人</td>\n<td></td>\n<td>日期</td>\n<td></td>\n</tr>\n<tr>\n<td>批 准 人</td>\n<td></td>\n<td>日期</td>\n<td></td>\n</tr>\n<tr>\n<td>项目名称</td>\n<td>XXX开发</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>嵌入式软件框架设计</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>相 关 文 档</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>文件编号</td>\n<td>文件名称</td>\n<td>版本</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>产品需求</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>用户需求</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>嵌入式软件需求</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>修 订 记 录</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>版本</td>\n<td>修订内容</td>\n<td>修订人</td>\n<td>修订日期</td>\n</tr>\n<tr>\n<td>V1.0</td>\n<td>创建</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p><strong>目 录</strong></p>\n<p><a href=\"#_Toc57747469\">0 版本记录</a></p>\n<p><a href=\"#引言\">1 引言</a></p>\n<p><a href=\"#_Toc57747471\">1.1 目的</a></p>\n<p><a href=\"#_Toc57747472\">1.2 背景</a></p>\n<p><a href=\"#_Toc57747473\">1.3 项目概述</a></p>\n<p><a href=\"#_Toc57747474\">1.4 术语与缩略语</a></p>\n<p><a href=\"#_Toc57747475\">1.5 引用文件</a></p>\n<p><a href=\"#_Toc57747476\">2 架构目标与设计约束</a></p>\n<p><a href=\"#_Toc57747477\">2.1 目标产品/目标产品系列</a></p>\n<p><a href=\"#_Toc57747478\">2.2 功能需求</a></p>\n<p><a href=\"#上下文图\">2.3 上下文图</a></p>\n<p><a href=\"#_Toc57747480\">2.4 质量需求</a></p>\n<p><a href=\"#来自技术路线的约束开发与运行环境限制\">2.5 来自技术路线的约束：开发与运行环境限制</a></p>\n<p><a href=\"#_Toc57747482\">2.6 来自硬件设计的约束：嵌入式硬件变化分析</a></p>\n<p><a href=\"#来自上游方案的约束整机配置变化分析\">2.7 来自上游方案的约束：整机配置变化分析</a></p>\n<p><a href=\"#_Toc57747484\">2.8 来自上游方案的约束：方案部署变化分析</a></p>\n<p><a href=\"#_Toc57747485\">3 架构思想</a></p>\n<p><a href=\"#_Toc57747486\">3.1 思想一：避免瓶颈、提高性能 【强制，嵌入式软件必须】</a></p>\n<p><a href=\"#思想二模块设计\">3.2 思想二：XXXXX</a></p>\n<p><a href=\"#思想三子系统设计\">3.3 思想三：XXXXX</a></p>\n<p><a href=\"#_Toc57747489\">4 架构设计</a></p>\n<p><a href=\"#_Toc57747490\">4.1 逻辑视图</a></p>\n<p><a href=\"#产品平台分工开发视图\">4.2 产品/平台分工开发视图</a></p>\n<p><a href=\"#运行视图\">4.3 运行视图</a></p>\n<p><a href=\"#物理视图\">4.4 物理视图</a></p>\n<p><a href=\"#接口设计\">5 接口设计</a></p>\n<p><a href=\"#_Toc57747495\">5.1 对外接口总览</a></p>\n<p><a href=\"#各模块间接口总览\">5.2 各模块间接口总览</a></p>\n<p><a href=\"#_Toc57747497\">5.3 平台和设备间接口总览</a></p>\n<p><a href=\"#接口列表\">5.4 接口列表</a></p>\n<p><a href=\"#xxxxx接口设计\">5.5 XXXXX接口设计</a></p>\n<p><a href=\"#xxxxx接口设计-1\">5.6 XXXXX接口设计</a></p>\n<p><a href=\"#_Toc57747501\">6 关键功能的设计原理</a></p>\n<p><a href=\"#xxxxx功能设计\">6.1 XXXXX功能设计</a></p>\n<p><a href=\"#xxxxx功能设计-1\">6.2 XXXXX功能设计</a></p>\n<p><a href=\"#_Toc57747504\">7 关键质量的设计原理</a></p>\n<p><a href=\"#_Toc57747505\">7.1 XXXX设计</a></p>\n<p><a href=\"#xxxx设计-1\">7.2 XXXX设计</a></p>\n<p><a href=\"#xxxx设计-2\">7.3 XXXX设计</a></p>\n<p><a href=\"#_Toc57747508\">8 对CBB管理的影响</a></p>\n<p><a href=\"#_Toc57747509\">8.1 本设计重用的CBB</a></p>\n<p><a href=\"#_Toc57747510\">8.2 本设计贡献的新CBB</a></p>\n<p><a href=\"#_Toc57747511\">8.3 本设计对现有CBB的升级需求</a></p>\n<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><h2 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h2><p><em>简要说明本文档的编写目的、用途和适用范围。</em></p>\n<p><em>【注意项】本节写“文档目的”，并非“项目目的”。</em></p>\n<p><em>【示例】</em></p>\n<p><em>本架构设计说明书编写的目的是……。本说明书的预期读者为系统设计人员、软件开发人员、软件测试人员和项目评审人员。</em></p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p><em>简要说明产业背景、企业立项本项目的背景。</em></p>\n<h2 id=\"项目概述\"><a href=\"#项目概述\" class=\"headerlink\" title=\"项目概述\"></a>项目概述</h2><p><em>简要说明项目内容、特点。</em></p>\n<p><em>【注意项】本节十分简洁，待到后续“2.1 目标产品/目标产品系列”适当展开。</em></p>\n<h2 id=\"术语与缩略语\"><a href=\"#术语与缩略语\" class=\"headerlink\" title=\"术语与缩略语\"></a>术语与缩略语</h2><p><em>本节集中说明和解释文档涉及的行业词汇、专业术语、首字母缩略语，提高文档可读性。</em></p>\n<p><em>【注意项】本节不可不写。</em></p>\n<table>\n<thead>\n<tr>\n<th><strong>词汇</strong></th>\n<th><strong>解释</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"引用文件\"><a href=\"#引用文件\" class=\"headerlink\" title=\"引用文件\"></a>引用文件</h2><p><em>应列出本文档引用的所有文档的编号、标题、修订版本和日期，方便读者查阅参考。</em></p>\n<p><em>【注意项】文档编号为□□公司为文档赋予的唯一正规编号。文档编号、文档版本号，均必写。</em></p>\n<table>\n<thead>\n<tr>\n<th><strong>文档编号</strong></th>\n<th><strong>文档名称</strong></th>\n<th><strong>版本号</strong></th>\n<th><strong>文档日期</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"架构目标与设计约束\"><a href=\"#架构目标与设计约束\" class=\"headerlink\" title=\"架构目标与设计约束\"></a>架构目标与设计约束</h1><p><em>对于XX厂商，影响嵌入式软件架构设计大方向的不仅有功能需求、更有接口需求、运行开销约束、配置形态需求等。</em></p>\n<p><em>此节对后续架构设计的具体展开，具有重大指导、和方向性影响。</em></p>\n<h2 id=\"目标产品-目标产品系列\"><a href=\"#目标产品-目标产品系列\" class=\"headerlink\" title=\"目标产品/目标产品系列\"></a>目标产品/目标产品系列</h2><p><em>设备软件的研发有何特点？</em></p>\n<p><em>架构设计期能不能更有作为？</em></p>\n<p><em>多个相似产品的架构设计能否重用？</em></p>\n<p><em>设备软件有明显的“产品系列”特点，企业更是希望提高软件通用性与设计复用性，从而降成本。因此，本节应明确认真地说明：</em></p>\n<p><em>A）本架构设计文档是针对具体的一个产品、还是由多个产品组成的产品系列。</em></p>\n<p><em>B）如果针对产品系列，应对比其中各产品的关键能力、关键指标的不同。使读者有大局观。</em></p>\n<p><em>【注意项】面向产品系列而设计的架构，文档后续注意通用性设计、适应性设计的描述。</em></p>\n<p><em>概述目标产品，可以表格方式说明</em></p>\n<table>\n<thead>\n<tr>\n<th><strong>架构设计针对的目标产品</strong></th>\n<th><strong>产品说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Xx产品</td>\n<td></td>\n</tr>\n<tr>\n<td>Yy产品</td>\n<td></td>\n</tr>\n<tr>\n<td>Zz产品</td>\n<td></td>\n</tr>\n</tbody></table>\n<p><em>对比产品不同，可以《产品系列对比表》形式说明</em></p>\n<p><em><img src=\"/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/e852708ffd1c78efd87949efa7b31592.png\" alt></em></p>\n<h2 id=\"功能需求\"><a href=\"#功能需求\" class=\"headerlink\" title=\"功能需求\"></a>功能需求</h2><h3 id=\"功能树-功能列表\"><a href=\"#功能树-功能列表\" class=\"headerlink\" title=\"功能树/功能列表\"></a>功能树/功能列表</h3><p><em>本节以功能树、功能表格等方式描述功能范围。</em></p>\n<p><em>注意1：无需展开描述。</em></p>\n<p><em>注意2：全面涵盖待研发的嵌入式设备软件的功能范围。</em></p>\n<p><em>【示例】功能树</em></p>\n<p><img src=\"/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/dc4e3ddfdab5a0456af40df7d0a9238b.png\" alt></p>\n<h3 id=\"产品系列功能对比表\"><a href=\"#产品系列功能对比表\" class=\"headerlink\" title=\"产品系列功能对比表\"></a>产品系列功能对比表</h3><p><em>针对 “目标产品系列”的架构文档，请提供产品系列功能对比表。</em></p>\n<p><em>【注意项】针对“单个目标产品”的文档，请写“本节无内容”。</em></p>\n<p><em>【示例】产品系列功能特性对比表</em></p>\n<p><em><img src=\"/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/2dd308b3411c41658cce041f8c230853.png\" alt></em></p>\n<h3 id=\"关键功能识别与问题单分析\"><a href=\"#关键功能识别与问题单分析\" class=\"headerlink\" title=\"* *关键功能识别与问题单分析\"></a>* *关键功能识别与问题单分析</h3><p><em>【背景1】关键需求决定架构。当设计需要权衡时，照顾的是关键需求。方法！</em></p>\n<p><em>【背景2】企业的问题单数据库，记录了同类系统暴露过的重大问题。风险！</em></p>\n<p><em>本节督促架构师去分析历史问题、提高设计针对性、避免问题重演：</em></p>\n<p><em>A）列出关键功能。文档后续的“6关键功能的设计原理”一节，应分别展开每个功能的设计。</em></p>\n<p><em>B）列出对问题单的单号、描述、风险点分析。设计时解决之。</em></p>\n<p><em>推荐描述形式</em></p>\n<table>\n<thead>\n<tr>\n<th><strong>关键功能</strong></th>\n<th><strong>问题单分析</strong></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td><strong>单号</strong></td>\n<td><strong>历史问题</strong></td>\n<td><strong>设计风险</strong></td>\n</tr>\n<tr>\n<td></td>\n<td>#n</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>#m</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>#n</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>#m</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>#n</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>#m</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>#n</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>#m</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"上下文图\"><a href=\"#上下文图\" class=\"headerlink\" title=\"上下文图\"></a>上下文图</h2><p><em>本节以顶层数据流图的形式，描述XX软件的上下文，即与外部哪些其他控制器、硬件单元、软件系统等有接口。</em></p>\n<p><em>【示例】</em></p>\n<h2 id=\"质量需求\"><a href=\"#质量需求\" class=\"headerlink\" title=\"质量需求\"></a>质量需求</h2><p><em>本节内容：</em></p>\n<ol>\n<li><em>TODO XX公司应制定《嵌入式软件质量属性标准》，本节包含哪些小节应当与之一一对应。类似XX公司的系统工程化设计要求的“五可”：可靠性、可测试性、可生产性、可安装性，可服务性。</em></li>\n<li><em>本节应覆盖来自高层需求文档的全部“质量指标”。</em></li>\n<li><em>本节求全，不求细。不写场景，不写因素分解。</em></li>\n</ol>\n<p><em>制定《嵌入式软件质量属性标准》的参考一：某质量分类标准</em></p>\n<table>\n<thead>\n<tr>\n<th><em>运行期质量属性</em></th>\n<th><em>开发期质量属性</em></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><em>性能（Performance）</em> <em>安全性（Security）</em> <em>易用性（Usability）</em> <em>持续可用性（Availability）</em> <em>可伸缩性（Scalability）</em> <em>互操作性（Interoperability）</em> <em>可靠性（Reliability）</em> <em>鲁棒性（Robustness）</em></td>\n<td><em>易理解性（Understandability）</em> <em>可扩展性（Extensibility）</em> <em>可重用性（Reusability）</em> <em>可测试性（Testability）</em> <em>可维护性（Maintainability）</em> <em>可移植性（Portability）</em></td>\n</tr>\n</tbody></table>\n<p><em>制定《嵌入式软件质量属性标准》的参考二：性能五项</em></p>\n<p><em><img src=\"/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/6aadad4da134377249d84bab5dbdfa8d.png\" alt></em></p>\n<h3 id=\"XXXX\"><a href=\"#XXXX\" class=\"headerlink\" title=\"XXXX\"></a>XXXX</h3><p><em>该项质量的文字简述。不展开。</em></p>\n<h3 id=\"XXXX-1\"><a href=\"#XXXX-1\" class=\"headerlink\" title=\"XXXX\"></a>XXXX</h3><p><em>该项质量的文字简述。不展开。</em></p>\n<h2 id=\"来自技术路线的约束：开发与运行环境限制\"><a href=\"#来自技术路线的约束：开发与运行环境限制\" class=\"headerlink\" title=\"来自技术路线的约束：开发与运行环境限制\"></a>来自技术路线的约束：开发与运行环境限制</h2><p><em>公司的技术路线与技术战略中，包含了软件研发类技术选型的考虑，具体产品的架构师往往没有权力任意改变技术选型。本节内容：</em></p>\n<ol>\n<li><em>简述技术选型约束</em></li>\n<li><em>分析技术选型对关键资源的开销</em></li>\n</ol>\n<h3 id=\"开发环境约定\"><a href=\"#开发环境约定\" class=\"headerlink\" title=\"开发环境约定\"></a>开发环境约定</h3><p><em>简单列举嵌入式软件研发的公司约定：开发语言、编译环境、本公司开发平台等。</em></p>\n<h3 id=\"运行环境约定\"><a href=\"#运行环境约定\" class=\"headerlink\" title=\"运行环境约定\"></a>运行环境约定</h3><p><em>简单列举嵌入式软件研发的公司约定：硬件要求、操作系统、关系数据、实时数据库等。</em></p>\n<h3 id=\"选型的资源开销分析：CPU资源\"><a href=\"#选型的资源开销分析：CPU资源\" class=\"headerlink\" title=\"选型的资源开销分析：CPU资源\"></a>选型的资源开销分析：CPU资源</h3><p><em>资源紧、效率关键是嵌入式开发的特点。本节分析上述技术选型带来的CPU资源开销：</em></p>\n<ul>\n<li><em>CPU占用率、</em></li>\n<li><em>最大最小值、</em></li>\n<li><em>可能的架构风险。</em></li>\n</ul>\n<h3 id=\"选型的资源开销分析：内存资源\"><a href=\"#选型的资源开销分析：内存资源\" class=\"headerlink\" title=\"选型的资源开销分析：内存资源\"></a>选型的资源开销分析：内存资源</h3><p><em>资源紧、效率关键是嵌入式开发的特点。本节分析上述技术选型带来的内存资源开销：</em></p>\n<ul>\n<li><em>内存占用率、</em></li>\n<li><em>最大最小值、</em></li>\n<li><em>可能的架构风险。</em></li>\n</ul>\n<h3 id=\"选型的资源开销分析：Flash资源\"><a href=\"#选型的资源开销分析：Flash资源\" class=\"headerlink\" title=\"选型的资源开销分析：Flash资源\"></a>选型的资源开销分析：Flash资源</h3><p><em>资源紧、效率关键是嵌入式开发的特点。本节分析上述技术选型带来的存储空间资源开销：</em></p>\n<ul>\n<li><em>存储空间占用率、</em></li>\n<li><em>最大最小值、</em></li>\n<li><em>可能的架构风险。</em></li>\n</ul>\n<p><em>【例如】例如Log组件高频度存储日志会消耗极多存储空间。架构师应尽早考虑如下影响：</em></p>\n<ul>\n<li><em>对于软件包大小的限制</em></li>\n<li><em>其他软件包大小的规划</em></li>\n<li><em>LOG存储策略、存储频度的考虑</em></li>\n</ul>\n<h2 id=\"来自硬件设计的约束：嵌入式硬件变化分析\"><a href=\"#来自硬件设计的约束：嵌入式硬件变化分析\" class=\"headerlink\" title=\"来自硬件设计的约束：嵌入式硬件变化分析\"></a>来自硬件设计的约束：嵌入式硬件变化分析</h2><p><em>本节通过多个硬件结构框图，列出所有（即穷举）可能的嵌入式硬件结构。这对后续架构的驱动层设计有直接影响。</em></p>\n<p><em>【FAQ】如果硬件设计还未完成，我要如何穷举所有可能的嵌入式硬件结构？</em></p>\n<p><em>【答】架构设计开始较早，这决定了架构师和程序员的一个极大不同，即软件架构师“时刻保持和硬件设计师的直接沟通”、“不应等待正式的《硬件设计文档》发布后才开始设计”。这一点，和程序员“在正式《需求规格》发布后才编程”有极大不同。</em></p>\n<p><em>【示例1】</em></p>\n<p><em><img src=\"/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/32643a6fbe010dcc95af301416619164.png\" alt></em></p>\n<h2 id=\"来自上游方案的约束：整机配置变化分析\"><a href=\"#来自上游方案的约束：整机配置变化分析\" class=\"headerlink\" title=\"来自上游方案的约束：整机配置变化分析\"></a>来自上游方案的约束：整机配置变化分析</h2><p><em>整机配置，指一台整机设备内如下不同：</em></p>\n<ul>\n<li><em>背板总线类型</em></li>\n<li><em>主控板类型</em></li>\n<li><em>主控板是否有主备、是否有群集</em></li>\n<li><em>非主控板的数量</em></li>\n<li><em>非主控板的种类</em></li>\n</ul>\n<p><em>本节通过多个图，列出所有（即穷举）可能的整机配置。</em></p>\n<p><em>【示例】</em></p>\n<p><em><img src=\"/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/22c7469876239933b38a12a32e9c6f16.png\" alt></em></p>\n<h1 id=\"架构思想\"><a href=\"#架构思想\" class=\"headerlink\" title=\"架构思想\"></a>架构思想</h1><p><em>作为架构师，你在本节，应当重点突出地说明有价值、有独特性的2~3条设计思想。</em></p>\n<ul>\n<li><em>例如，嵌入式软件可用的CPU、内存等资源有限，你的规划思想规划原则是什么</em></li>\n<li><em>例如，你如何运用状态机处理核心硬件的复杂状态组合</em></li>\n<li><em>……</em></li>\n</ul>\n<h2 id=\"思想一：避免瓶颈、提高性能-【强制，嵌入式软件必须】\"><a href=\"#思想一：避免瓶颈、提高性能-【强制，嵌入式软件必须】\" class=\"headerlink\" title=\"思想一：避免瓶颈、提高性能 【强制，嵌入式软件必须】\"></a>思想一：避免瓶颈、提高性能 【强制，嵌入式软件必须】</h2><p><em>分析关键资源约束，并在此给出相应的设计准则：</em></p>\n<ul>\n<li><em>例如，如果CPU是瓶颈，应约定“最大线程数限制”等设计原则并具体说明</em></li>\n<li><em>例如，如果内存是瓶颈，应约定“限制Cache滥用”等设计原则并具体说明</em></li>\n<li><em>例如，如果Flash紧缺，应约定“限制Log存储频率”等设计原则并具体说明</em></li>\n</ul>\n<h2 id=\"思想二：模块设计\"><a href=\"#思想二：模块设计\" class=\"headerlink\" title=\"思想二：模块设计\"></a>思想二：模块设计</h2><p><em>只需重点突出地说明有价值、有独特性的2~3条设计思想。</em></p>\n<h2 id=\"思想三：子系统设计\"><a href=\"#思想三：子系统设计\" class=\"headerlink\" title=\"思想三：子系统设计\"></a>思想三：子系统设计</h2><p><em>只需重点突出地说明有价值、有独特性的2~3条设计思想。</em></p>\n<h1 id=\"架构设计\"><a href=\"#架构设计\" class=\"headerlink\" title=\"架构设计\"></a>架构设计</h1><h2 id=\"逻辑视图\"><a href=\"#逻辑视图\" class=\"headerlink\" title=\"逻辑视图\"></a>逻辑视图</h2><h3 id=\"功能子系统划分\"><a href=\"#功能子系统划分\" class=\"headerlink\" title=\"功能子系统划分\"></a>功能子系统划分</h3><p><em>纵切：功能子系统</em></p>\n<p><em>列出或画出包含的功能子系统，并说明。</em></p>\n<h3 id=\"系统分层架构\"><a href=\"#系统分层架构\" class=\"headerlink\" title=\"系统分层架构\"></a>系统分层架构</h3><p><em>横切：逻辑层</em></p>\n<p><em>此处描述分层架构，有时采用“<em>系统分层架构*</em>+*<em>每层所用技术</em>”的形式将重要技术选型也描述进来。</em></p>\n<p><em>【示例】</em></p>\n<h2 id=\"产品-平台分工开发视图\"><a href=\"#产品-平台分工开发视图\" class=\"headerlink\" title=\"产品/平台分工开发视图\"></a>产品/平台分工开发视图</h2><p><strong>【开发视图 vs. 产品/平台分工开发视图】</strong></p>\n<p><em>开发视图，5视图之一，是单一视图——产品开发单元的切分，没有涉及平台扩充。</em></p>\n<p><em>产品/平台分工开发视图，是混合视图——产品要开发，同时平台要生长扩充。</em></p>\n<p><strong>【本节内容】</strong></p>\n<p><em>首先，要说清功能需求映射到产品组件、还是平台组件。</em></p>\n<p><em>其次，要说明平台总共要增加哪些组件、增强哪些组件。</em></p>\n<p><em>最后，才是详细说明产品组件有哪些、又分别对应哪些代码工程。</em></p>\n<h3 id=\"需求映射-与-产品-平台组件识别\"><a href=\"#需求映射-与-产品-平台组件识别\" class=\"headerlink\" title=\"需求映射 与 产品/平台组件识别\"></a>需求映射 与 产品/平台组件识别</h3><p><em>此前需求分析做过的工作，架构师不再重复。本节也不写。</em></p>\n<ol>\n<li><em>分析本嵌入式设备上实现的业务场景</em></li>\n<li><em>分解出多项功能需求</em></li>\n</ol>\n<p><em>本节，架构师需要做：</em></p>\n<ol>\n<li><em>将功能需求映射到对应的嵌入式软件的具体组件，并区分它是产品组件还是平台组件。以表格形式呈现。</em></li>\n</ol>\n<p><em>推荐形式：功能与参与功能实现的组件的映射矩阵</em></p>\n<p><em><img src=\"/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/780552b6b4ceacfe274a8c687b74a569.png\" alt></em></p>\n<h3 id=\"平台架构-与-新增-增强组件的位置-【平台侧】\"><a href=\"#平台架构-与-新增-增强组件的位置-【平台侧】\" class=\"headerlink\" title=\"平台架构 与 新增/增强组件的位置 【平台侧】\"></a>平台架构 与 新增/增强组件的位置 【平台侧】</h3><p><em>画出平台架构图，平台尽量黑盒化，不变的组件尽量少体现，重点体现平台侧还要加强的组件，特别标出新增/增强组件的位置。</em></p>\n<h3 id=\"产品组件-与-各组件说明-【产品侧】\"><a href=\"#产品组件-与-各组件说明-【产品侧】\" class=\"headerlink\" title=\"产品组件 与 各组件说明 【产品侧】\"></a>产品组件 与 各组件说明 【产品侧】</h3><p><em>可采用多种方式：列表格、画UML组件图并辅以文字说明。</em></p>\n<p><em>【示例】</em></p>\n<table>\n<thead>\n<tr>\n<th><em>序号</em></th>\n<th><em>模块名称</em></th>\n<th><em>子模块名称</em></th>\n<th><em>功能说明</em></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><em>1</em></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><em>2</em></td>\n<td><em>MCU机电模块</em></td>\n<td><em>机电通信模块</em></td>\n<td><em>实现NMU机电模块与K10主机的通信。</em></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><em>电子标签接口模块</em></td>\n<td><em>实现背板EEPROM的电子信息写入和读出。</em></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><em>风扇接口模块</em></td>\n<td><em>通过风扇控制寄存器的访问接口。</em></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><em>风扇控制模块</em></td>\n<td><em>提供对风扇单元转速的控制接口，风扇单元的工作状态和告警信息读取接口。</em></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><em>机电应用模块</em></td>\n<td><em>实现机电信息的收集处理和上报，接收、响应NMU指令。</em></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><em>机电软件下载模块</em></td>\n<td><em>建立与K10主机机电软件下载会话，实现机电软件模块切割分片传送。</em></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><em>3</em></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"产品组件对应的代码工程-与-开发技术-【产品侧】\"><a href=\"#产品组件对应的代码工程-与-开发技术-【产品侧】\" class=\"headerlink\" title=\"产品组件对应的代码工程 与 开发技术 【产品侧】\"></a>产品组件对应的代码工程 与 开发技术 【产品侧】</h3><p><em>说明嵌入式软件（产品侧）包含的多个开发工程（Project）或Makefile。</em></p>\n<p><em>细致地说明，每个组件开发所需的三方库、框架。</em></p>\n<p><em>【示例】</em></p>\n<h2 id=\"运行视图\"><a href=\"#运行视图\" class=\"headerlink\" title=\"运行视图\"></a>运行视图</h2><h3 id=\"嵌入式软件：运行架构总览\"><a href=\"#嵌入式软件：运行架构总览\" class=\"headerlink\" title=\"嵌入式软件：运行架构总览\"></a>嵌入式软件：运行架构总览</h3><p><em>说明嵌入式软件运行态下，有哪些进程、线程、以及对应组件的功能简述。</em></p>\n<p><em>【示例】</em></p>\n<table>\n<thead>\n<tr>\n<th><strong>进程</strong></th>\n<th><strong>线程</strong></th>\n<th><strong>组件</strong></th>\n<th><strong>组件功能</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"嵌入式软件中的组件：能否创建线程的准则\"><a href=\"#嵌入式软件中的组件：能否创建线程的准则\" class=\"headerlink\" title=\"嵌入式软件中的组件：能否创建线程的准则\"></a>嵌入式软件中的组件：能否创建线程的准则</h3><p><em>说明嵌入式软件产品侧线程创建的准则：</em></p>\n<ul>\n<li><em>哪些情况可以创建线程</em></li>\n<li><em>哪些情况杜绝滥启线程★★★</em></li>\n</ul>\n<p><em>后续组件详细设计师必须严格遵守，杜绝线程泛滥拉低性能和易理解性。</em></p>\n<h2 id=\"物理视图\"><a href=\"#物理视图\" class=\"headerlink\" title=\"物理视图\"></a>物理视图</h2><h3 id=\"运行环境\"><a href=\"#运行环境\" class=\"headerlink\" title=\"运行环境\"></a>运行环境</h3><p><em>细致地说明，嵌入式的硬件配置。</em></p>\n<p><em>细致地说明操作系统、各种系统软件、中间件的种类和版本。</em></p>\n<p><em>【示例】</em></p>\n<table>\n<thead>\n<tr>\n<th><em>硬件环境</em> <em>主CPU扣板为P2041，底板核心交换芯片为Qumran的硬件板卡。</em> <em>硬件配置</em> <em>CPU型号: p2041</em> <em>CPU主频：1.5GHz</em> <em>CPU核数：4*e500mc核</em> <em>CPU位宽：32位</em> <em>内存：4096 MB</em> <em>操作系统</em> <em>Linux localhost 2.6.34.15-grsec-WR4.3.0.0_cgl #1 SMP PREEMPT Fri Nov 4 16:51:14 CST 2016 ppc ppc ppc GNU/Linux</em></th>\n</tr>\n</thead>\n</table>\n<h3 id=\"发布包目录结构及目标路径定义\"><a href=\"#发布包目录结构及目标路径定义\" class=\"headerlink\" title=\"发布包目录结构及目标路径定义\"></a>发布包目录结构及目标路径定义</h3><p><em>本节应描述：</em></p>\n<p><em>A）发布包的详细目录结构约定。</em></p>\n<p><em>B）发布包应该mount到的目标路径</em></p>\n<p><em>【示例】</em></p>\n<p><em>。。。。。。</em></p>\n<h3 id=\"组件部署结构\"><a href=\"#组件部署结构\" class=\"headerlink\" title=\"* *组件部署结构\"></a>* *组件部署结构</h3><p><em>嵌入式软件往往由许多组件组成，本节重点说明组件之间的上下游关系。</em></p>\n<p><em>【示例】</em></p>\n<h1 id=\"接口设计\"><a href=\"#接口设计\" class=\"headerlink\" title=\"接口设计\"></a>接口设计</h1><h2 id=\"对外接口总览\"><a href=\"#对外接口总览\" class=\"headerlink\" title=\"对外接口总览\"></a>对外接口总览</h2><p>画图，概览本嵌入式软件的对外接口的位置。</p>\n<h2 id=\"各模块间接口总览\"><a href=\"#各模块间接口总览\" class=\"headerlink\" title=\"各模块间接口总览\"></a>各模块间接口总览</h2><p>画图，概览嵌入式软件内部的做个组件之间接口的位置。</p>\n<h2 id=\"平台和设备间接口总览\"><a href=\"#平台和设备间接口总览\" class=\"headerlink\" title=\"平台和设备间接口总览\"></a>平台和设备间接口总览</h2><p>画图，概览平台与设备间接口的位置。</p>\n<h2 id=\"接口列表\"><a href=\"#接口列表\" class=\"headerlink\" title=\"接口列表\"></a>接口列表</h2><p>列出接口名称和功能，对外和内部分别罗列。</p>\n<h2 id=\"XXXXX接口设计\"><a href=\"#XXXXX接口设计\" class=\"headerlink\" title=\"XXXXX接口设计\"></a>XXXXX接口设计</h2><p>接口=交互过程+技术选择+格式定义。交互过程用序列图刻画</p>\n<p><em>【示例1】函数接口的格式定义</em></p>\n<table>\n<thead>\n<tr>\n<th><strong>名称</strong></th>\n<th>dhcm回调函数</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>用途</strong></td>\n<td><strong>DHCM组件提供给DDA的回调接口</strong></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>声明</strong></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>typedef struct tag_dhcm_callback {  INT32 (*dcoi_board_init)(DCOI_BOARD_INIT_INFO *init_info);  UINT32 (*dcoi_get_support_card_flag)();  UINT32 (*dcoi_cmi_ready_cb)();  VOID (*dcoi_dhcs_ready)(DHCS_CARD_COMP_INFO_MSG_EN *card_comp_info);  }DHCM_CALLBACK;</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>字段</strong></td>\n<td><strong>含义</strong></td>\n<td><strong>说明</strong></td>\n</tr>\n<tr>\n<td>dcoi_board_init</td>\n<td>嵌入式初始化的调用，包含硬件初始化和软件初始化。</td>\n<td></td>\n</tr>\n<tr>\n<td>dcoi_get_support_card_flag</td>\n<td>返回嵌入式是否支持子卡的信息</td>\n<td></td>\n</tr>\n<tr>\n<td>dcoi_cmi_ready_cb</td>\n<td>判断组件cmi是否有值</td>\n<td></td>\n</tr>\n<tr>\n<td>dcoi_dhcs_ready</td>\n<td>获取嵌入式建模信息，包含框/槽/子卡/板类型等信息。</td>\n<td></td>\n</tr>\n</tbody></table>\n<p><em>【示例2】协议接口的格式定义</em></p>\n<p><img src=\"/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/60a0b6815e87242adbc049d64b96e01b.png\" alt></p>\n<h2 id=\"XXXXX接口设计-1\"><a href=\"#XXXXX接口设计-1\" class=\"headerlink\" title=\"XXXXX接口设计\"></a>XXXXX接口设计</h2><p>接口=交互过程+技术选择+格式定义。交互过程用序列图刻画</p>\n<h1 id=\"关键功能的设计原理\"><a href=\"#关键功能的设计原理\" class=\"headerlink\" title=\"关键功能的设计原理\"></a>关键功能的设计原理</h1><p><em>本节内容：</em></p>\n<ul>\n<li><em>典型功能的设计</em></li>\n<li><em>“2.2.3关键功能识别与问题单分析”节中每个关键功能的设计</em></li>\n</ul>\n<h2 id=\"XXXXX功能设计\"><a href=\"#XXXXX功能设计\" class=\"headerlink\" title=\"XXXXX功能设计\"></a>XXXXX功能设计</h2><p><em>用“<em>协作图+文字说明</em>”的方式说明每个关键功能的设计原理。图可以是下列方式之一：</em></p>\n<ul>\n<li><em>序列图</em></li>\n<li><em>协作图</em></li>\n<li><em>涉及多进程多线程的，图中应刻画出“进程/线程”</em></li>\n<li><em>设计跨机器分布式的，图中应刻画出“机器/控制板”</em></li>\n<li><em>协作逻辑复杂的，图中标号，再针对每个标号进行文字说明</em></li>\n</ul>\n<h2 id=\"XXXXX功能设计-1\"><a href=\"#XXXXX功能设计-1\" class=\"headerlink\" title=\"XXXXX功能设计\"></a>XXXXX功能设计</h2><h1 id=\"关键质量的设计原理\"><a href=\"#关键质量的设计原理\" class=\"headerlink\" title=\"关键质量的设计原理\"></a>关键质量的设计原理</h1><h2 id=\"XXXX设计\"><a href=\"#XXXX设计\" class=\"headerlink\" title=\"XXXX设计\"></a>XXXX设计</h2><h3 id=\"影响质量的因素分解表-质量因素树\"><a href=\"#影响质量的因素分解表-质量因素树\" class=\"headerlink\" title=\"影响质量的因素分解表/质量因素树\"></a>影响质量的因素分解表/质量因素树</h3><p><em>本节的核心是运用分解思维、系统化思维，梳理影响质量的因素。可采用表格、树等形式。</em></p>\n<h3 id=\"目标-场景-决策表\"><a href=\"#目标-场景-决策表\" class=\"headerlink\" title=\"目标-场景-决策表\"></a>目标-场景-决策表</h3><p><em>本节的核心是运用场景思维、具体化思维，分析质量因素对系统的具体影响，并给出设计对策。</em></p>\n<p><em>【注意项】推荐使用目标-场景-决策表，表中场景按“质量场景规约”格式编写</em></p>\n<p><em><img src=\"/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/c7546c50623e8a8aa6ab33ead8fac6cb.png\" alt></em></p>\n<h3 id=\"设计原理图\"><a href=\"#设计原理图\" class=\"headerlink\" title=\"设计原理图\"></a>设计原理图</h3><p>【示例】<img src=\"/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/e7176066eab77c0cf6e147aed0046ea7.png\" alt></p>\n<h2 id=\"XXXX设计-1\"><a href=\"#XXXX设计-1\" class=\"headerlink\" title=\"XXXX设计\"></a>XXXX设计</h2><h3 id=\"影响质量的因素分解表-质量因素树-1\"><a href=\"#影响质量的因素分解表-质量因素树-1\" class=\"headerlink\" title=\"影响质量的因素分解表/质量因素树\"></a>影响质量的因素分解表/质量因素树</h3><h3 id=\"目标-场景-决策表-1\"><a href=\"#目标-场景-决策表-1\" class=\"headerlink\" title=\"目标-场景-决策表\"></a>目标-场景-决策表</h3><h3 id=\"设计原理图-1\"><a href=\"#设计原理图-1\" class=\"headerlink\" title=\"设计原理图\"></a>设计原理图</h3><h2 id=\"XXXX设计-2\"><a href=\"#XXXX设计-2\" class=\"headerlink\" title=\"XXXX设计\"></a>XXXX设计</h2><h3 id=\"影响质量的因素分解表-质量因素树-2\"><a href=\"#影响质量的因素分解表-质量因素树-2\" class=\"headerlink\" title=\"影响质量的因素分解表/质量因素树\"></a>影响质量的因素分解表/质量因素树</h3><h3 id=\"目标-场景-决策表-2\"><a href=\"#目标-场景-决策表-2\" class=\"headerlink\" title=\"目标-场景-决策表\"></a>目标-场景-决策表</h3><h3 id=\"设计原理图-2\"><a href=\"#设计原理图-2\" class=\"headerlink\" title=\"设计原理图\"></a>设计原理图</h3><p># </p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<table>\n<thead>\n<tr>\n<th>文件类型</th>\n<th>研发过程文档</th>\n<th>机密等级</th>\n<th>机密</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>文件编号</td>\n<td></td>\n<td>版本</td>\n<td>V1.0</td>\n</tr>\n<tr>\n<td>撰 写 人</td>\n<td></td>\n<td>日期</td>\n<td></td>\n</tr>\n<tr>\n<td>审 核 人</td>\n<td></td>\n<td>日期</td>\n<td></td>\n</tr>\n<tr>\n<td>批 准 人</td>\n<td></td>\n<td>日期</td>\n<td></td>\n</tr>\n<tr>\n<td>项目名称</td>\n<td>XXX开发</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>嵌入式软件框架设计</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>相 关 文 档</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>文件编号</td>\n<td>文件名称</td>\n<td>版本</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>产品需求</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>用户需求</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>嵌入式软件需求</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>修 订 记 录</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>版本</td>\n<td>修订内容</td>\n<td>修订人</td>\n<td>修订日期</td>\n</tr>\n<tr>\n<td>V1.0</td>\n<td>创建</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p><strong>目 录</strong></p>\n<p><a href=\"#_Toc57747469\">0 版本记录</a></p>\n<p><a href=\"#引言\">1 引言</a></p>\n<p><a href=\"#_Toc57747471\">1.1 目的</a></p>\n<p><a href=\"#_Toc57747472\">1.2 背景</a></p>\n<p><a href=\"#_Toc57747473\">1.3 项目概述</a></p>\n<p><a href=\"#_Toc57747474\">1.4 术语与缩略语</a></p>\n<p><a href=\"#_Toc57747475\">1.5 引用文件</a></p>\n<p><a href=\"#_Toc57747476\">2 架构目标与设计约束</a></p>\n<p><a href=\"#_Toc57747477\">2.1 目标产品/目标产品系列</a></p>\n<p><a href=\"#_Toc57747478\">2.2 功能需求</a></p>\n<p><a href=\"#上下文图\">2.3 上下文图</a></p>\n<p><a href=\"#_Toc57747480\">2.4 质量需求</a></p>\n<p><a href=\"#来自技术路线的约束开发与运行环境限制\">2.5 来自技术路线的约束：开发与运行环境限制</a></p>\n<p><a href=\"#_Toc57747482\">2.6 来自硬件设计的约束：嵌入式硬件变化分析</a></p>\n<p><a href=\"#来自上游方案的约束整机配置变化分析\">2.7 来自上游方案的约束：整机配置变化分析</a></p>\n<p><a href=\"#_Toc57747484\">2.8 来自上游方案的约束：方案部署变化分析</a></p>\n<p><a href=\"#_Toc57747485\">3 架构思想</a></p>\n<p><a href=\"#_Toc57747486\">3.1 思想一：避免瓶颈、提高性能 【强制，嵌入式软件必须】</a></p>\n<p><a href=\"#思想二模块设计\">3.2 思想二：XXXXX</a></p>\n<p><a href=\"#思想三子系统设计\">3.3 思想三：XXXXX</a></p>\n<p><a href=\"#_Toc57747489\">4 架构设计</a></p>\n<p><a href=\"#_Toc57747490\">4.1 逻辑视图</a></p>\n<p><a href=\"#产品平台分工开发视图\">4.2 产品/平台分工开发视图</a></p>\n<p><a href=\"#运行视图\">4.3 运行视图</a></p>\n<p><a href=\"#物理视图\">4.4 物理视图</a></p>\n<p><a href=\"#接口设计\">5 接口设计</a></p>\n<p><a href=\"#_Toc57747495\">5.1 对外接口总览</a></p>\n<p><a href=\"#各模块间接口总览\">5.2 各模块间接口总览</a></p>\n<p><a href=\"#_Toc57747497\">5.3 平台和设备间接口总览</a></p>\n<p><a href=\"#接口列表\">5.4 接口列表</a></p>\n<p><a href=\"#xxxxx接口设计\">5.5 XXXXX接口设计</a></p>\n<p><a href=\"#xxxxx接口设计-1\">5.6 XXXXX接口设计</a></p>\n<p><a href=\"#_Toc57747501\">6 关键功能的设计原理</a></p>\n<p><a href=\"#xxxxx功能设计\">6.1 XXXXX功能设计</a></p>\n<p><a href=\"#xxxxx功能设计-1\">6.2 XXXXX功能设计</a></p>\n<p><a href=\"#_Toc57747504\">7 关键质量的设计原理</a></p>\n<p><a href=\"#_Toc57747505\">7.1 XXXX设计</a></p>\n<p><a href=\"#xxxx设计-1\">7.2 XXXX设计</a></p>\n<p><a href=\"#xxxx设计-2\">7.3 XXXX设计</a></p>\n<p><a href=\"#_Toc57747508\">8 对CBB管理的影响</a></p>\n<p><a href=\"#_Toc57747509\">8.1 本设计重用的CBB</a></p>\n<p><a href=\"#_Toc57747510\">8.2 本设计贡献的新CBB</a></p>\n<p><a href=\"#_Toc57747511\">8.3 本设计对现有CBB的升级需求</a></p>\n<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><h2 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h2><p><em>简要说明本文档的编写目的、用途和适用范围。</em></p>\n<p><em>【注意项】本节写“文档目的”，并非“项目目的”。</em></p>\n<p><em>【示例】</em></p>\n<p><em>本架构设计说明书编写的目的是……。本说明书的预期读者为系统设计人员、软件开发人员、软件测试人员和项目评审人员。</em></p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p><em>简要说明产业背景、企业立项本项目的背景。</em></p>\n<h2 id=\"项目概述\"><a href=\"#项目概述\" class=\"headerlink\" title=\"项目概述\"></a>项目概述</h2><p><em>简要说明项目内容、特点。</em></p>\n<p><em>【注意项】本节十分简洁，待到后续“2.1 目标产品/目标产品系列”适当展开。</em></p>\n<h2 id=\"术语与缩略语\"><a href=\"#术语与缩略语\" class=\"headerlink\" title=\"术语与缩略语\"></a>术语与缩略语</h2><p><em>本节集中说明和解释文档涉及的行业词汇、专业术语、首字母缩略语，提高文档可读性。</em></p>\n<p><em>【注意项】本节不可不写。</em></p>\n<table>\n<thead>\n<tr>\n<th><strong>词汇</strong></th>\n<th><strong>解释</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"引用文件\"><a href=\"#引用文件\" class=\"headerlink\" title=\"引用文件\"></a>引用文件</h2><p><em>应列出本文档引用的所有文档的编号、标题、修订版本和日期，方便读者查阅参考。</em></p>\n<p><em>【注意项】文档编号为□□公司为文档赋予的唯一正规编号。文档编号、文档版本号，均必写。</em></p>\n<table>\n<thead>\n<tr>\n<th><strong>文档编号</strong></th>\n<th><strong>文档名称</strong></th>\n<th><strong>版本号</strong></th>\n<th><strong>文档日期</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"架构目标与设计约束\"><a href=\"#架构目标与设计约束\" class=\"headerlink\" title=\"架构目标与设计约束\"></a>架构目标与设计约束</h1><p><em>对于XX厂商，影响嵌入式软件架构设计大方向的不仅有功能需求、更有接口需求、运行开销约束、配置形态需求等。</em></p>\n<p><em>此节对后续架构设计的具体展开，具有重大指导、和方向性影响。</em></p>\n<h2 id=\"目标产品-目标产品系列\"><a href=\"#目标产品-目标产品系列\" class=\"headerlink\" title=\"目标产品/目标产品系列\"></a>目标产品/目标产品系列</h2><p><em>设备软件的研发有何特点？</em></p>\n<p><em>架构设计期能不能更有作为？</em></p>\n<p><em>多个相似产品的架构设计能否重用？</em></p>\n<p><em>设备软件有明显的“产品系列”特点，企业更是希望提高软件通用性与设计复用性，从而降成本。因此，本节应明确认真地说明：</em></p>\n<p><em>A）本架构设计文档是针对具体的一个产品、还是由多个产品组成的产品系列。</em></p>\n<p><em>B）如果针对产品系列，应对比其中各产品的关键能力、关键指标的不同。使读者有大局观。</em></p>\n<p><em>【注意项】面向产品系列而设计的架构，文档后续注意通用性设计、适应性设计的描述。</em></p>\n<p><em>概述目标产品，可以表格方式说明</em></p>\n<table>\n<thead>\n<tr>\n<th><strong>架构设计针对的目标产品</strong></th>\n<th><strong>产品说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Xx产品</td>\n<td></td>\n</tr>\n<tr>\n<td>Yy产品</td>\n<td></td>\n</tr>\n<tr>\n<td>Zz产品</td>\n<td></td>\n</tr>\n</tbody></table>\n<p><em>对比产品不同，可以《产品系列对比表》形式说明</em></p>\n<p><em><img src=\"/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/e852708ffd1c78efd87949efa7b31592.png\" alt></em></p>\n<h2 id=\"功能需求\"><a href=\"#功能需求\" class=\"headerlink\" title=\"功能需求\"></a>功能需求</h2><h3 id=\"功能树-功能列表\"><a href=\"#功能树-功能列表\" class=\"headerlink\" title=\"功能树/功能列表\"></a>功能树/功能列表</h3><p><em>本节以功能树、功能表格等方式描述功能范围。</em></p>\n<p><em>注意1：无需展开描述。</em></p>\n<p><em>注意2：全面涵盖待研发的嵌入式设备软件的功能范围。</em></p>\n<p><em>【示例】功能树</em></p>\n<p><img src=\"/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/dc4e3ddfdab5a0456af40df7d0a9238b.png\" alt></p>\n<h3 id=\"产品系列功能对比表\"><a href=\"#产品系列功能对比表\" class=\"headerlink\" title=\"产品系列功能对比表\"></a>产品系列功能对比表</h3><p><em>针对 “目标产品系列”的架构文档，请提供产品系列功能对比表。</em></p>\n<p><em>【注意项】针对“单个目标产品”的文档，请写“本节无内容”。</em></p>\n<p><em>【示例】产品系列功能特性对比表</em></p>\n<p><em><img src=\"/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/2dd308b3411c41658cce041f8c230853.png\" alt></em></p>\n<h3 id=\"关键功能识别与问题单分析\"><a href=\"#关键功能识别与问题单分析\" class=\"headerlink\" title=\"* *关键功能识别与问题单分析\"></a>* *关键功能识别与问题单分析</h3><p><em>【背景1】关键需求决定架构。当设计需要权衡时，照顾的是关键需求。方法！</em></p>\n<p><em>【背景2】企业的问题单数据库，记录了同类系统暴露过的重大问题。风险！</em></p>\n<p><em>本节督促架构师去分析历史问题、提高设计针对性、避免问题重演：</em></p>\n<p><em>A）列出关键功能。文档后续的“6关键功能的设计原理”一节，应分别展开每个功能的设计。</em></p>\n<p><em>B）列出对问题单的单号、描述、风险点分析。设计时解决之。</em></p>\n<p><em>推荐描述形式</em></p>\n<table>\n<thead>\n<tr>\n<th><strong>关键功能</strong></th>\n<th><strong>问题单分析</strong></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td><strong>单号</strong></td>\n<td><strong>历史问题</strong></td>\n<td><strong>设计风险</strong></td>\n</tr>\n<tr>\n<td></td>\n<td>#n</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>#m</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>#n</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>#m</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>#n</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>#m</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>#n</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>#m</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"上下文图\"><a href=\"#上下文图\" class=\"headerlink\" title=\"上下文图\"></a>上下文图</h2><p><em>本节以顶层数据流图的形式，描述XX软件的上下文，即与外部哪些其他控制器、硬件单元、软件系统等有接口。</em></p>\n<p><em>【示例】</em></p>\n<h2 id=\"质量需求\"><a href=\"#质量需求\" class=\"headerlink\" title=\"质量需求\"></a>质量需求</h2><p><em>本节内容：</em></p>\n<ol>\n<li><em>TODO XX公司应制定《嵌入式软件质量属性标准》，本节包含哪些小节应当与之一一对应。类似XX公司的系统工程化设计要求的“五可”：可靠性、可测试性、可生产性、可安装性，可服务性。</em></li>\n<li><em>本节应覆盖来自高层需求文档的全部“质量指标”。</em></li>\n<li><em>本节求全，不求细。不写场景，不写因素分解。</em></li>\n</ol>\n<p><em>制定《嵌入式软件质量属性标准》的参考一：某质量分类标准</em></p>\n<table>\n<thead>\n<tr>\n<th><em>运行期质量属性</em></th>\n<th><em>开发期质量属性</em></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><em>性能（Performance）</em> <em>安全性（Security）</em> <em>易用性（Usability）</em> <em>持续可用性（Availability）</em> <em>可伸缩性（Scalability）</em> <em>互操作性（Interoperability）</em> <em>可靠性（Reliability）</em> <em>鲁棒性（Robustness）</em></td>\n<td><em>易理解性（Understandability）</em> <em>可扩展性（Extensibility）</em> <em>可重用性（Reusability）</em> <em>可测试性（Testability）</em> <em>可维护性（Maintainability）</em> <em>可移植性（Portability）</em></td>\n</tr>\n</tbody></table>\n<p><em>制定《嵌入式软件质量属性标准》的参考二：性能五项</em></p>\n<p><em><img src=\"/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/6aadad4da134377249d84bab5dbdfa8d.png\" alt></em></p>\n<h3 id=\"XXXX\"><a href=\"#XXXX\" class=\"headerlink\" title=\"XXXX\"></a>XXXX</h3><p><em>该项质量的文字简述。不展开。</em></p>\n<h3 id=\"XXXX-1\"><a href=\"#XXXX-1\" class=\"headerlink\" title=\"XXXX\"></a>XXXX</h3><p><em>该项质量的文字简述。不展开。</em></p>\n<h2 id=\"来自技术路线的约束：开发与运行环境限制\"><a href=\"#来自技术路线的约束：开发与运行环境限制\" class=\"headerlink\" title=\"来自技术路线的约束：开发与运行环境限制\"></a>来自技术路线的约束：开发与运行环境限制</h2><p><em>公司的技术路线与技术战略中，包含了软件研发类技术选型的考虑，具体产品的架构师往往没有权力任意改变技术选型。本节内容：</em></p>\n<ol>\n<li><em>简述技术选型约束</em></li>\n<li><em>分析技术选型对关键资源的开销</em></li>\n</ol>\n<h3 id=\"开发环境约定\"><a href=\"#开发环境约定\" class=\"headerlink\" title=\"开发环境约定\"></a>开发环境约定</h3><p><em>简单列举嵌入式软件研发的公司约定：开发语言、编译环境、本公司开发平台等。</em></p>\n<h3 id=\"运行环境约定\"><a href=\"#运行环境约定\" class=\"headerlink\" title=\"运行环境约定\"></a>运行环境约定</h3><p><em>简单列举嵌入式软件研发的公司约定：硬件要求、操作系统、关系数据、实时数据库等。</em></p>\n<h3 id=\"选型的资源开销分析：CPU资源\"><a href=\"#选型的资源开销分析：CPU资源\" class=\"headerlink\" title=\"选型的资源开销分析：CPU资源\"></a>选型的资源开销分析：CPU资源</h3><p><em>资源紧、效率关键是嵌入式开发的特点。本节分析上述技术选型带来的CPU资源开销：</em></p>\n<ul>\n<li><em>CPU占用率、</em></li>\n<li><em>最大最小值、</em></li>\n<li><em>可能的架构风险。</em></li>\n</ul>\n<h3 id=\"选型的资源开销分析：内存资源\"><a href=\"#选型的资源开销分析：内存资源\" class=\"headerlink\" title=\"选型的资源开销分析：内存资源\"></a>选型的资源开销分析：内存资源</h3><p><em>资源紧、效率关键是嵌入式开发的特点。本节分析上述技术选型带来的内存资源开销：</em></p>\n<ul>\n<li><em>内存占用率、</em></li>\n<li><em>最大最小值、</em></li>\n<li><em>可能的架构风险。</em></li>\n</ul>\n<h3 id=\"选型的资源开销分析：Flash资源\"><a href=\"#选型的资源开销分析：Flash资源\" class=\"headerlink\" title=\"选型的资源开销分析：Flash资源\"></a>选型的资源开销分析：Flash资源</h3><p><em>资源紧、效率关键是嵌入式开发的特点。本节分析上述技术选型带来的存储空间资源开销：</em></p>\n<ul>\n<li><em>存储空间占用率、</em></li>\n<li><em>最大最小值、</em></li>\n<li><em>可能的架构风险。</em></li>\n</ul>\n<p><em>【例如】例如Log组件高频度存储日志会消耗极多存储空间。架构师应尽早考虑如下影响：</em></p>\n<ul>\n<li><em>对于软件包大小的限制</em></li>\n<li><em>其他软件包大小的规划</em></li>\n<li><em>LOG存储策略、存储频度的考虑</em></li>\n</ul>\n<h2 id=\"来自硬件设计的约束：嵌入式硬件变化分析\"><a href=\"#来自硬件设计的约束：嵌入式硬件变化分析\" class=\"headerlink\" title=\"来自硬件设计的约束：嵌入式硬件变化分析\"></a>来自硬件设计的约束：嵌入式硬件变化分析</h2><p><em>本节通过多个硬件结构框图，列出所有（即穷举）可能的嵌入式硬件结构。这对后续架构的驱动层设计有直接影响。</em></p>\n<p><em>【FAQ】如果硬件设计还未完成，我要如何穷举所有可能的嵌入式硬件结构？</em></p>\n<p><em>【答】架构设计开始较早，这决定了架构师和程序员的一个极大不同，即软件架构师“时刻保持和硬件设计师的直接沟通”、“不应等待正式的《硬件设计文档》发布后才开始设计”。这一点，和程序员“在正式《需求规格》发布后才编程”有极大不同。</em></p>\n<p><em>【示例1】</em></p>\n<p><em><img src=\"/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/32643a6fbe010dcc95af301416619164.png\" alt></em></p>\n<h2 id=\"来自上游方案的约束：整机配置变化分析\"><a href=\"#来自上游方案的约束：整机配置变化分析\" class=\"headerlink\" title=\"来自上游方案的约束：整机配置变化分析\"></a>来自上游方案的约束：整机配置变化分析</h2><p><em>整机配置，指一台整机设备内如下不同：</em></p>\n<ul>\n<li><em>背板总线类型</em></li>\n<li><em>主控板类型</em></li>\n<li><em>主控板是否有主备、是否有群集</em></li>\n<li><em>非主控板的数量</em></li>\n<li><em>非主控板的种类</em></li>\n</ul>\n<p><em>本节通过多个图，列出所有（即穷举）可能的整机配置。</em></p>\n<p><em>【示例】</em></p>\n<p><em><img src=\"/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/22c7469876239933b38a12a32e9c6f16.png\" alt></em></p>\n<h1 id=\"架构思想\"><a href=\"#架构思想\" class=\"headerlink\" title=\"架构思想\"></a>架构思想</h1><p><em>作为架构师，你在本节，应当重点突出地说明有价值、有独特性的2~3条设计思想。</em></p>\n<ul>\n<li><em>例如，嵌入式软件可用的CPU、内存等资源有限，你的规划思想规划原则是什么</em></li>\n<li><em>例如，你如何运用状态机处理核心硬件的复杂状态组合</em></li>\n<li><em>……</em></li>\n</ul>\n<h2 id=\"思想一：避免瓶颈、提高性能-【强制，嵌入式软件必须】\"><a href=\"#思想一：避免瓶颈、提高性能-【强制，嵌入式软件必须】\" class=\"headerlink\" title=\"思想一：避免瓶颈、提高性能 【强制，嵌入式软件必须】\"></a>思想一：避免瓶颈、提高性能 【强制，嵌入式软件必须】</h2><p><em>分析关键资源约束，并在此给出相应的设计准则：</em></p>\n<ul>\n<li><em>例如，如果CPU是瓶颈，应约定“最大线程数限制”等设计原则并具体说明</em></li>\n<li><em>例如，如果内存是瓶颈，应约定“限制Cache滥用”等设计原则并具体说明</em></li>\n<li><em>例如，如果Flash紧缺，应约定“限制Log存储频率”等设计原则并具体说明</em></li>\n</ul>\n<h2 id=\"思想二：模块设计\"><a href=\"#思想二：模块设计\" class=\"headerlink\" title=\"思想二：模块设计\"></a>思想二：模块设计</h2><p><em>只需重点突出地说明有价值、有独特性的2~3条设计思想。</em></p>\n<h2 id=\"思想三：子系统设计\"><a href=\"#思想三：子系统设计\" class=\"headerlink\" title=\"思想三：子系统设计\"></a>思想三：子系统设计</h2><p><em>只需重点突出地说明有价值、有独特性的2~3条设计思想。</em></p>\n<h1 id=\"架构设计\"><a href=\"#架构设计\" class=\"headerlink\" title=\"架构设计\"></a>架构设计</h1><h2 id=\"逻辑视图\"><a href=\"#逻辑视图\" class=\"headerlink\" title=\"逻辑视图\"></a>逻辑视图</h2><h3 id=\"功能子系统划分\"><a href=\"#功能子系统划分\" class=\"headerlink\" title=\"功能子系统划分\"></a>功能子系统划分</h3><p><em>纵切：功能子系统</em></p>\n<p><em>列出或画出包含的功能子系统，并说明。</em></p>\n<h3 id=\"系统分层架构\"><a href=\"#系统分层架构\" class=\"headerlink\" title=\"系统分层架构\"></a>系统分层架构</h3><p><em>横切：逻辑层</em></p>\n<p><em>此处描述分层架构，有时采用“<em>系统分层架构*</em>+*<em>每层所用技术</em>”的形式将重要技术选型也描述进来。</em></p>\n<p><em>【示例】</em></p>\n<h2 id=\"产品-平台分工开发视图\"><a href=\"#产品-平台分工开发视图\" class=\"headerlink\" title=\"产品/平台分工开发视图\"></a>产品/平台分工开发视图</h2><p><strong>【开发视图 vs. 产品/平台分工开发视图】</strong></p>\n<p><em>开发视图，5视图之一，是单一视图——产品开发单元的切分，没有涉及平台扩充。</em></p>\n<p><em>产品/平台分工开发视图，是混合视图——产品要开发，同时平台要生长扩充。</em></p>\n<p><strong>【本节内容】</strong></p>\n<p><em>首先，要说清功能需求映射到产品组件、还是平台组件。</em></p>\n<p><em>其次，要说明平台总共要增加哪些组件、增强哪些组件。</em></p>\n<p><em>最后，才是详细说明产品组件有哪些、又分别对应哪些代码工程。</em></p>\n<h3 id=\"需求映射-与-产品-平台组件识别\"><a href=\"#需求映射-与-产品-平台组件识别\" class=\"headerlink\" title=\"需求映射 与 产品/平台组件识别\"></a>需求映射 与 产品/平台组件识别</h3><p><em>此前需求分析做过的工作，架构师不再重复。本节也不写。</em></p>\n<ol>\n<li><em>分析本嵌入式设备上实现的业务场景</em></li>\n<li><em>分解出多项功能需求</em></li>\n</ol>\n<p><em>本节，架构师需要做：</em></p>\n<ol>\n<li><em>将功能需求映射到对应的嵌入式软件的具体组件，并区分它是产品组件还是平台组件。以表格形式呈现。</em></li>\n</ol>\n<p><em>推荐形式：功能与参与功能实现的组件的映射矩阵</em></p>\n<p><em><img src=\"/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/780552b6b4ceacfe274a8c687b74a569.png\" alt></em></p>\n<h3 id=\"平台架构-与-新增-增强组件的位置-【平台侧】\"><a href=\"#平台架构-与-新增-增强组件的位置-【平台侧】\" class=\"headerlink\" title=\"平台架构 与 新增/增强组件的位置 【平台侧】\"></a>平台架构 与 新增/增强组件的位置 【平台侧】</h3><p><em>画出平台架构图，平台尽量黑盒化，不变的组件尽量少体现，重点体现平台侧还要加强的组件，特别标出新增/增强组件的位置。</em></p>\n<h3 id=\"产品组件-与-各组件说明-【产品侧】\"><a href=\"#产品组件-与-各组件说明-【产品侧】\" class=\"headerlink\" title=\"产品组件 与 各组件说明 【产品侧】\"></a>产品组件 与 各组件说明 【产品侧】</h3><p><em>可采用多种方式：列表格、画UML组件图并辅以文字说明。</em></p>\n<p><em>【示例】</em></p>\n<table>\n<thead>\n<tr>\n<th><em>序号</em></th>\n<th><em>模块名称</em></th>\n<th><em>子模块名称</em></th>\n<th><em>功能说明</em></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><em>1</em></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><em>2</em></td>\n<td><em>MCU机电模块</em></td>\n<td><em>机电通信模块</em></td>\n<td><em>实现NMU机电模块与K10主机的通信。</em></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><em>电子标签接口模块</em></td>\n<td><em>实现背板EEPROM的电子信息写入和读出。</em></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><em>风扇接口模块</em></td>\n<td><em>通过风扇控制寄存器的访问接口。</em></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><em>风扇控制模块</em></td>\n<td><em>提供对风扇单元转速的控制接口，风扇单元的工作状态和告警信息读取接口。</em></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><em>机电应用模块</em></td>\n<td><em>实现机电信息的收集处理和上报，接收、响应NMU指令。</em></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><em>机电软件下载模块</em></td>\n<td><em>建立与K10主机机电软件下载会话，实现机电软件模块切割分片传送。</em></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><em>3</em></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"产品组件对应的代码工程-与-开发技术-【产品侧】\"><a href=\"#产品组件对应的代码工程-与-开发技术-【产品侧】\" class=\"headerlink\" title=\"产品组件对应的代码工程 与 开发技术 【产品侧】\"></a>产品组件对应的代码工程 与 开发技术 【产品侧】</h3><p><em>说明嵌入式软件（产品侧）包含的多个开发工程（Project）或Makefile。</em></p>\n<p><em>细致地说明，每个组件开发所需的三方库、框架。</em></p>\n<p><em>【示例】</em></p>\n<h2 id=\"运行视图\"><a href=\"#运行视图\" class=\"headerlink\" title=\"运行视图\"></a>运行视图</h2><h3 id=\"嵌入式软件：运行架构总览\"><a href=\"#嵌入式软件：运行架构总览\" class=\"headerlink\" title=\"嵌入式软件：运行架构总览\"></a>嵌入式软件：运行架构总览</h3><p><em>说明嵌入式软件运行态下，有哪些进程、线程、以及对应组件的功能简述。</em></p>\n<p><em>【示例】</em></p>\n<table>\n<thead>\n<tr>\n<th><strong>进程</strong></th>\n<th><strong>线程</strong></th>\n<th><strong>组件</strong></th>\n<th><strong>组件功能</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"嵌入式软件中的组件：能否创建线程的准则\"><a href=\"#嵌入式软件中的组件：能否创建线程的准则\" class=\"headerlink\" title=\"嵌入式软件中的组件：能否创建线程的准则\"></a>嵌入式软件中的组件：能否创建线程的准则</h3><p><em>说明嵌入式软件产品侧线程创建的准则：</em></p>\n<ul>\n<li><em>哪些情况可以创建线程</em></li>\n<li><em>哪些情况杜绝滥启线程★★★</em></li>\n</ul>\n<p><em>后续组件详细设计师必须严格遵守，杜绝线程泛滥拉低性能和易理解性。</em></p>\n<h2 id=\"物理视图\"><a href=\"#物理视图\" class=\"headerlink\" title=\"物理视图\"></a>物理视图</h2><h3 id=\"运行环境\"><a href=\"#运行环境\" class=\"headerlink\" title=\"运行环境\"></a>运行环境</h3><p><em>细致地说明，嵌入式的硬件配置。</em></p>\n<p><em>细致地说明操作系统、各种系统软件、中间件的种类和版本。</em></p>\n<p><em>【示例】</em></p>\n<table>\n<thead>\n<tr>\n<th><em>硬件环境</em> <em>主CPU扣板为P2041，底板核心交换芯片为Qumran的硬件板卡。</em> <em>硬件配置</em> <em>CPU型号: p2041</em> <em>CPU主频：1.5GHz</em> <em>CPU核数：4*e500mc核</em> <em>CPU位宽：32位</em> <em>内存：4096 MB</em> <em>操作系统</em> <em>Linux localhost 2.6.34.15-grsec-WR4.3.0.0_cgl #1 SMP PREEMPT Fri Nov 4 16:51:14 CST 2016 ppc ppc ppc GNU/Linux</em></th>\n</tr>\n</thead>\n</table>\n<h3 id=\"发布包目录结构及目标路径定义\"><a href=\"#发布包目录结构及目标路径定义\" class=\"headerlink\" title=\"发布包目录结构及目标路径定义\"></a>发布包目录结构及目标路径定义</h3><p><em>本节应描述：</em></p>\n<p><em>A）发布包的详细目录结构约定。</em></p>\n<p><em>B）发布包应该mount到的目标路径</em></p>\n<p><em>【示例】</em></p>\n<p><em>。。。。。。</em></p>\n<h3 id=\"组件部署结构\"><a href=\"#组件部署结构\" class=\"headerlink\" title=\"* *组件部署结构\"></a>* *组件部署结构</h3><p><em>嵌入式软件往往由许多组件组成，本节重点说明组件之间的上下游关系。</em></p>\n<p><em>【示例】</em></p>\n<h1 id=\"接口设计\"><a href=\"#接口设计\" class=\"headerlink\" title=\"接口设计\"></a>接口设计</h1><h2 id=\"对外接口总览\"><a href=\"#对外接口总览\" class=\"headerlink\" title=\"对外接口总览\"></a>对外接口总览</h2><p>画图，概览本嵌入式软件的对外接口的位置。</p>\n<h2 id=\"各模块间接口总览\"><a href=\"#各模块间接口总览\" class=\"headerlink\" title=\"各模块间接口总览\"></a>各模块间接口总览</h2><p>画图，概览嵌入式软件内部的做个组件之间接口的位置。</p>\n<h2 id=\"平台和设备间接口总览\"><a href=\"#平台和设备间接口总览\" class=\"headerlink\" title=\"平台和设备间接口总览\"></a>平台和设备间接口总览</h2><p>画图，概览平台与设备间接口的位置。</p>\n<h2 id=\"接口列表\"><a href=\"#接口列表\" class=\"headerlink\" title=\"接口列表\"></a>接口列表</h2><p>列出接口名称和功能，对外和内部分别罗列。</p>\n<h2 id=\"XXXXX接口设计\"><a href=\"#XXXXX接口设计\" class=\"headerlink\" title=\"XXXXX接口设计\"></a>XXXXX接口设计</h2><p>接口=交互过程+技术选择+格式定义。交互过程用序列图刻画</p>\n<p><em>【示例1】函数接口的格式定义</em></p>\n<table>\n<thead>\n<tr>\n<th><strong>名称</strong></th>\n<th>dhcm回调函数</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>用途</strong></td>\n<td><strong>DHCM组件提供给DDA的回调接口</strong></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>声明</strong></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>typedef struct tag_dhcm_callback {  INT32 (*dcoi_board_init)(DCOI_BOARD_INIT_INFO *init_info);  UINT32 (*dcoi_get_support_card_flag)();  UINT32 (*dcoi_cmi_ready_cb)();  VOID (*dcoi_dhcs_ready)(DHCS_CARD_COMP_INFO_MSG_EN *card_comp_info);  }DHCM_CALLBACK;</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>字段</strong></td>\n<td><strong>含义</strong></td>\n<td><strong>说明</strong></td>\n</tr>\n<tr>\n<td>dcoi_board_init</td>\n<td>嵌入式初始化的调用，包含硬件初始化和软件初始化。</td>\n<td></td>\n</tr>\n<tr>\n<td>dcoi_get_support_card_flag</td>\n<td>返回嵌入式是否支持子卡的信息</td>\n<td></td>\n</tr>\n<tr>\n<td>dcoi_cmi_ready_cb</td>\n<td>判断组件cmi是否有值</td>\n<td></td>\n</tr>\n<tr>\n<td>dcoi_dhcs_ready</td>\n<td>获取嵌入式建模信息，包含框/槽/子卡/板类型等信息。</td>\n<td></td>\n</tr>\n</tbody></table>\n<p><em>【示例2】协议接口的格式定义</em></p>\n<p><img src=\"/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/60a0b6815e87242adbc049d64b96e01b.png\" alt></p>\n<h2 id=\"XXXXX接口设计-1\"><a href=\"#XXXXX接口设计-1\" class=\"headerlink\" title=\"XXXXX接口设计\"></a>XXXXX接口设计</h2><p>接口=交互过程+技术选择+格式定义。交互过程用序列图刻画</p>\n<h1 id=\"关键功能的设计原理\"><a href=\"#关键功能的设计原理\" class=\"headerlink\" title=\"关键功能的设计原理\"></a>关键功能的设计原理</h1><p><em>本节内容：</em></p>\n<ul>\n<li><em>典型功能的设计</em></li>\n<li><em>“2.2.3关键功能识别与问题单分析”节中每个关键功能的设计</em></li>\n</ul>\n<h2 id=\"XXXXX功能设计\"><a href=\"#XXXXX功能设计\" class=\"headerlink\" title=\"XXXXX功能设计\"></a>XXXXX功能设计</h2><p><em>用“<em>协作图+文字说明</em>”的方式说明每个关键功能的设计原理。图可以是下列方式之一：</em></p>\n<ul>\n<li><em>序列图</em></li>\n<li><em>协作图</em></li>\n<li><em>涉及多进程多线程的，图中应刻画出“进程/线程”</em></li>\n<li><em>设计跨机器分布式的，图中应刻画出“机器/控制板”</em></li>\n<li><em>协作逻辑复杂的，图中标号，再针对每个标号进行文字说明</em></li>\n</ul>\n<h2 id=\"XXXXX功能设计-1\"><a href=\"#XXXXX功能设计-1\" class=\"headerlink\" title=\"XXXXX功能设计\"></a>XXXXX功能设计</h2><h1 id=\"关键质量的设计原理\"><a href=\"#关键质量的设计原理\" class=\"headerlink\" title=\"关键质量的设计原理\"></a>关键质量的设计原理</h1><h2 id=\"XXXX设计\"><a href=\"#XXXX设计\" class=\"headerlink\" title=\"XXXX设计\"></a>XXXX设计</h2><h3 id=\"影响质量的因素分解表-质量因素树\"><a href=\"#影响质量的因素分解表-质量因素树\" class=\"headerlink\" title=\"影响质量的因素分解表/质量因素树\"></a>影响质量的因素分解表/质量因素树</h3><p><em>本节的核心是运用分解思维、系统化思维，梳理影响质量的因素。可采用表格、树等形式。</em></p>\n<h3 id=\"目标-场景-决策表\"><a href=\"#目标-场景-决策表\" class=\"headerlink\" title=\"目标-场景-决策表\"></a>目标-场景-决策表</h3><p><em>本节的核心是运用场景思维、具体化思维，分析质量因素对系统的具体影响，并给出设计对策。</em></p>\n<p><em>【注意项】推荐使用目标-场景-决策表，表中场景按“质量场景规约”格式编写</em></p>\n<p><em><img src=\"/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/c7546c50623e8a8aa6ab33ead8fac6cb.png\" alt></em></p>\n<h3 id=\"设计原理图\"><a href=\"#设计原理图\" class=\"headerlink\" title=\"设计原理图\"></a>设计原理图</h3><p>【示例】<img src=\"/2023/07/qian-ru-shi-ruan-jian-kuang-jia-fang-an/e7176066eab77c0cf6e147aed0046ea7.png\" alt></p>\n<h2 id=\"XXXX设计-1\"><a href=\"#XXXX设计-1\" class=\"headerlink\" title=\"XXXX设计\"></a>XXXX设计</h2><h3 id=\"影响质量的因素分解表-质量因素树-1\"><a href=\"#影响质量的因素分解表-质量因素树-1\" class=\"headerlink\" title=\"影响质量的因素分解表/质量因素树\"></a>影响质量的因素分解表/质量因素树</h3><h3 id=\"目标-场景-决策表-1\"><a href=\"#目标-场景-决策表-1\" class=\"headerlink\" title=\"目标-场景-决策表\"></a>目标-场景-决策表</h3><h3 id=\"设计原理图-1\"><a href=\"#设计原理图-1\" class=\"headerlink\" title=\"设计原理图\"></a>设计原理图</h3><h2 id=\"XXXX设计-2\"><a href=\"#XXXX设计-2\" class=\"headerlink\" title=\"XXXX设计\"></a>XXXX设计</h2><h3 id=\"影响质量的因素分解表-质量因素树-2\"><a href=\"#影响质量的因素分解表-质量因素树-2\" class=\"headerlink\" title=\"影响质量的因素分解表/质量因素树\"></a>影响质量的因素分解表/质量因素树</h3><h3 id=\"目标-场景-决策表-2\"><a href=\"#目标-场景-决策表-2\" class=\"headerlink\" title=\"目标-场景-决策表\"></a>目标-场景-决策表</h3><h3 id=\"设计原理图-2\"><a href=\"#设计原理图-2\" class=\"headerlink\" title=\"设计原理图\"></a>设计原理图</h3><p># </p>\n"},{"title":"process-dbus-daemon","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-08-31T01:32:14.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"\n# dbus-daemon线程的作用\n`dbus-daemon` 是 D-Bus 通信系统的守护进程，用于在 Linux 和其他类 Unix 系统上提供进程间通信 (IPC) 功能。D-Bus 是一个跨进程通信机制，使得不同进程之间可以进行消息传递，共享数据以及调用方法。`dbus-daemon` 线程的作用包括以下几个方面：\n\n1. **进程间通信：** `dbus-daemon` 提供了一种在不同进程之间进行通信的机制。不同进程可以通过 D-Bus 发送和接收消息，从而实现数据共享和交互。\n\n2. **总线系统：** D-Bus 通过一种称为总线系统的方式来组织通信。`dbus-daemon` 提供了总线系统，允许多个进程在同一个总线上进行通信。总线可以分为系统总线和会话总线，分别用于系统级进程间通信和用户会话级进程间通信。\n\n3. **服务发布与发现：** `dbus-daemon` 允许进程注册自己提供的服务，以便其他进程能够发现并调用这些服务。这有助于实现解耦和模块化的系统设计。\n\n4. **对象和接口管理：** D-Bus 通过对象和接口的概念来组织数据和方法。`dbus-daemon` 确保对象和接口的正确注册和管理，以便进程可以通过合适的接口与其他对象交互。\n\n5. **权限和安全：** `dbus-daemon` 管理进程之间的通信权限，以确保只有授权的进程能够相互通信。这有助于维护系统的安全性。\n\n6. **解析地址：** `dbus-daemon` 用于解析 D-Bus 地址，以便确定要发送消息的目标进程。\n\n![](process-dbus-daemon/1.png)\nDBus 本身是构建在 Socket 机制之上。真正的通信还是由 Socket 来完成的。DBus 则是在这之上，制定了一些通信的协议，并提供了更高一层的接口，以更方便应用程序之间进行数据的交互。\n\n# dbus-daemon源码\n以等级5启动内核\n```shell\nroot@ATK-IMX6U:/etc/rc5.d# ls -l\ntotal 0\nlrwxrwxrwx 1 root root 20 Jun 10 18:21 S01networking -> ../init.d/networking\nlrwxrwxrwx 1 root root 22 Jun 10 18:21 S01xserver-nodm -> ../init.d/xserver-nodm\nlrwxrwxrwx 1 root root 16 Jun 10 18:21 S02dbus-1 -> ../init.d/dbus-1\nlrwxrwxrwx 1 root root 17 Jun 10 18:21 S05connman -> ../init.d/connman\nlrwxrwxrwx 1 root root 18 Jun 10 18:21 S10dropbear -> ../init.d/dropbear\nlrwxrwxrwx 1 root root 17 Jun 10 18:21 S12rpcbind -> ../init.d/rpcbind\nlrwxrwxrwx 1 root root 21 Jun 10 18:21 S15mountnfs.sh -> ../init.d/mountnfs.sh\nlrwxrwxrwx 1 root root 21 Jun 10 18:21 S15watchdog.sh -> ../init.d/watchdog.sh\nlrwxrwxrwx 1 root root 19 Jun 10 18:21 S19nfscommon -> ../init.d/nfscommon\nlrwxrwxrwx 1 root root 14 Jun 10 18:21 S20apmd -> ../init.d/apmd\nlrwxrwxrwx 1 root root 13 Jun 10 18:21 S20atd -> ../init.d/atd\nlrwxrwxrwx 1 root root 17 Jun 10 18:21 S20hostapd -> ../init.d/hostapd\nlrwxrwxrwx 1 root root 20 Jun 10 18:21 S20hwclock.sh -> ../init.d/hwclock.sh\nlrwxrwxrwx 1 root root 19 Jun 10 18:21 S20nfsserver -> ../init.d/nfsserver\nlrwxrwxrwx 1 root root 16 Jun 10 18:21 S20syslog -> ../init.d/syslog\nlrwxrwxrwx 1 root root 22 Jun 10 18:21 S21avahi-daemon -> ../init.d/avahi-daemon\nlrwxrwxrwx 1 root root 15 Jun 10 18:21 S22ofono -> ../init.d/ofono\nlrwxrwxrwx 1 root root 15 Jun 10 18:21 S64neard -> ../init.d/neard\nlrwxrwxrwx 1 root root 16 Jun 10 18:21 S80vsftpd -> ../init.d/vsftpd\nlrwxrwxrwx 1 root root 15 Jun 10 18:21 S90crond -> ../init.d/crond\nlrwxrwxrwx 1 root root 15 Jun 10 18:21 S92nginx -> ../init.d/nginx\nlrwxrwxrwx 1 root root 18 Jun 10 18:21 S99rc.local -> ../init.d/rc.local\nlrwxrwxrwx 1 root root 22 Jun 10 18:21 S99rmnologin.sh -> ../init.d/rmnologin.sh\nlrwxrwxrwx 1 root root 23 Jun 10 18:21 S99stop-bootlogd -> ../init.d/stop-bootlogd\n```\netc\\init.d\\dbus-1:\n```shell\n#! /bin/sh\n### BEGIN INIT INFO\n# Provides:          dbus\n# Required-Start:    $remote_fs $syslog\n# Required-Stop:     $remote_fs $syslog\n# Default-Start:     2 3 4 5\n# Default-Stop:      1\n# Short-Description: D-Bus systemwide message bus\n# Description:       D-Bus is a simple interprocess messaging system, used\n#                    for sending messages between applications.\n### END INIT INFO\n#\n# -*- coding: utf-8 -*-\n# Debian init.d script for D-BUS\n# Copyright © 2003 Colin Walters <walters@debian.org>\n\n# set -e\n\n# Source function library.\n#这行代码导入了 /etc/init.d/functions 文件，该文件通常包含了一些用于 init 脚本的通用函数。\n#可以用来处理日志、进程管理等任务。\n. /etc/init.d/functions\n\nDAEMON=/usr/bin/dbus-daemon # 设置了 D-Bus 守护进程的路径\nNAME=dbus-1\nDAEMONUSER=messagebus           # 必须与 /etc/dbus-1/system.conf 中的设置相匹配\nPIDFILE=/var/run/messagebus.pid # 必须与 /etc/dbus-1/system.conf 中的设置相匹配\nUUIDDIR=/var/lib/dbus\nDESC=\"system message bus\"\nEVENTDIR=/etc/dbus-1/event.d\n\n#检查给定的变量 $DAEMON 所表示的文件是否存在并且是否可执行\ntest -x $DAEMON || exit 0\n\n# Source defaults file; edit that file to configure this script.\nENABLED=1\nPARAMS=\"\"\nif [ -e /etc/default/dbus ]; then\n  . /etc/default/dbus\nfi\n\ntest \"$ENABLED\" != \"0\" || exit 0\n\nstart_it_up()\n{\n  mkdir -p \"`dirname $PIDFILE`\"\n  if [ -e $PIDFILE ]; then\n    PIDDIR=/proc/$(cat $PIDFILE)\n    if [ -d ${PIDDIR} -a  \"$(readlink -f ${PIDDIR}/exe)\" = \"${DAEMON}\" ]; then \n      echo \"$DESC already started; not starting.\"\n    else\n      echo \"Removing stale PID file $PIDFILE.\"\n      rm -f $PIDFILE\n    fi\n  fi\n\n  if [ ! -d $UUIDDIR ]; then\n    mkdir -p $UUIDDIR\n    chown $DAEMONUSER $UUIDDIR\n    chgrp $DAEMONUSER $UUIDDIR\n  fi\n \n  dbus-uuidgen --ensure  \n\n  echo -n \"Starting $DESC: \"\n  start-stop-daemon -o --start --quiet --pidfile $PIDFILE \\\n    --user $DAEMONUSER --exec $DAEMON -- --system $PARAMS\n  echo \"$NAME.\"\n  if [ -d $EVENTDIR ]; then\n      run-parts --arg=start $EVENTDIR\n  fi\n}\n\nshut_it_down()\n{\n  if [ -d $EVENTDIR ]; then\n      # TODO: --reverse when busybox supports it\n      run-parts --arg=stop $EVENTDIR\n  fi\n  echo -n \"Stopping $DESC: \"\n  start-stop-daemon -o --stop  --quiet --pidfile $PIDFILE \\\n    --user $DAEMONUSER\n  # We no longer include these arguments so that start-stop-daemon\n  # can do its job even given that we may have been upgraded.\n  # We rely on the pidfile being sanely managed\n  # --exec $DAEMON -- --system $PARAMS\n  echo \"$NAME.\"\n  rm -f $PIDFILE\n}\n\nreload_it()\n{\n  echo -n \"Reloading $DESC config: \"\n  dbus-send --print-reply --system --type=method_call \\\n            --dest=org.freedesktop.DBus \\\n            / org.freedesktop.DBus.ReloadConfig > /dev/null\n  # hopefully this is enough time for dbus to reload it's config file.\n  echo \"done.\"\n}\n\ncase \"$1\" in\n  start)\n    start_it_up\n  ;;\n  stop)\n    shut_it_down\n  ;;\n  status)\n    status $DAEMON\n    exit $?\n  ;;\n  reload|force-reload)\n    reload_it\n  ;;\n  restart)\n    shut_it_down\n    sleep 1\n    start_it_up\n  ;;\n  *)\n    echo \"Usage: /etc/init.d/$NAME {start|stop|status|restart|reload|force-reload}\" >&2\n    exit 1\n  ;;\nesac\n\nexit 0\n```\n显而易见执行了[/usr/bin/dbus-daemon](https://dbus.freedesktop.org/doc/dbus-daemon.1.html)这个软件,\n\n# dbus-daemon介绍\n[DBus API的使用](https://blog.csdn.net/f110300641/article/details/106822511)\n[dbus官网](https://www.freedesktop.org/wiki/Software/dbus/#sourcecode)","source":"_posts/2023/08/process-dbus-daemon.md","raw":"---\ntitle: process-dbus-daemon\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-08-31 09:32:14\npassword:\nsummary:\ntags:\n- linux\n- process\ncategories:\n- process\n- linux\nkeywords:\ndescription:\n---\n\n# dbus-daemon线程的作用\n`dbus-daemon` 是 D-Bus 通信系统的守护进程，用于在 Linux 和其他类 Unix 系统上提供进程间通信 (IPC) 功能。D-Bus 是一个跨进程通信机制，使得不同进程之间可以进行消息传递，共享数据以及调用方法。`dbus-daemon` 线程的作用包括以下几个方面：\n\n1. **进程间通信：** `dbus-daemon` 提供了一种在不同进程之间进行通信的机制。不同进程可以通过 D-Bus 发送和接收消息，从而实现数据共享和交互。\n\n2. **总线系统：** D-Bus 通过一种称为总线系统的方式来组织通信。`dbus-daemon` 提供了总线系统，允许多个进程在同一个总线上进行通信。总线可以分为系统总线和会话总线，分别用于系统级进程间通信和用户会话级进程间通信。\n\n3. **服务发布与发现：** `dbus-daemon` 允许进程注册自己提供的服务，以便其他进程能够发现并调用这些服务。这有助于实现解耦和模块化的系统设计。\n\n4. **对象和接口管理：** D-Bus 通过对象和接口的概念来组织数据和方法。`dbus-daemon` 确保对象和接口的正确注册和管理，以便进程可以通过合适的接口与其他对象交互。\n\n5. **权限和安全：** `dbus-daemon` 管理进程之间的通信权限，以确保只有授权的进程能够相互通信。这有助于维护系统的安全性。\n\n6. **解析地址：** `dbus-daemon` 用于解析 D-Bus 地址，以便确定要发送消息的目标进程。\n\n![](process-dbus-daemon/1.png)\nDBus 本身是构建在 Socket 机制之上。真正的通信还是由 Socket 来完成的。DBus 则是在这之上，制定了一些通信的协议，并提供了更高一层的接口，以更方便应用程序之间进行数据的交互。\n\n# dbus-daemon源码\n以等级5启动内核\n```shell\nroot@ATK-IMX6U:/etc/rc5.d# ls -l\ntotal 0\nlrwxrwxrwx 1 root root 20 Jun 10 18:21 S01networking -> ../init.d/networking\nlrwxrwxrwx 1 root root 22 Jun 10 18:21 S01xserver-nodm -> ../init.d/xserver-nodm\nlrwxrwxrwx 1 root root 16 Jun 10 18:21 S02dbus-1 -> ../init.d/dbus-1\nlrwxrwxrwx 1 root root 17 Jun 10 18:21 S05connman -> ../init.d/connman\nlrwxrwxrwx 1 root root 18 Jun 10 18:21 S10dropbear -> ../init.d/dropbear\nlrwxrwxrwx 1 root root 17 Jun 10 18:21 S12rpcbind -> ../init.d/rpcbind\nlrwxrwxrwx 1 root root 21 Jun 10 18:21 S15mountnfs.sh -> ../init.d/mountnfs.sh\nlrwxrwxrwx 1 root root 21 Jun 10 18:21 S15watchdog.sh -> ../init.d/watchdog.sh\nlrwxrwxrwx 1 root root 19 Jun 10 18:21 S19nfscommon -> ../init.d/nfscommon\nlrwxrwxrwx 1 root root 14 Jun 10 18:21 S20apmd -> ../init.d/apmd\nlrwxrwxrwx 1 root root 13 Jun 10 18:21 S20atd -> ../init.d/atd\nlrwxrwxrwx 1 root root 17 Jun 10 18:21 S20hostapd -> ../init.d/hostapd\nlrwxrwxrwx 1 root root 20 Jun 10 18:21 S20hwclock.sh -> ../init.d/hwclock.sh\nlrwxrwxrwx 1 root root 19 Jun 10 18:21 S20nfsserver -> ../init.d/nfsserver\nlrwxrwxrwx 1 root root 16 Jun 10 18:21 S20syslog -> ../init.d/syslog\nlrwxrwxrwx 1 root root 22 Jun 10 18:21 S21avahi-daemon -> ../init.d/avahi-daemon\nlrwxrwxrwx 1 root root 15 Jun 10 18:21 S22ofono -> ../init.d/ofono\nlrwxrwxrwx 1 root root 15 Jun 10 18:21 S64neard -> ../init.d/neard\nlrwxrwxrwx 1 root root 16 Jun 10 18:21 S80vsftpd -> ../init.d/vsftpd\nlrwxrwxrwx 1 root root 15 Jun 10 18:21 S90crond -> ../init.d/crond\nlrwxrwxrwx 1 root root 15 Jun 10 18:21 S92nginx -> ../init.d/nginx\nlrwxrwxrwx 1 root root 18 Jun 10 18:21 S99rc.local -> ../init.d/rc.local\nlrwxrwxrwx 1 root root 22 Jun 10 18:21 S99rmnologin.sh -> ../init.d/rmnologin.sh\nlrwxrwxrwx 1 root root 23 Jun 10 18:21 S99stop-bootlogd -> ../init.d/stop-bootlogd\n```\netc\\init.d\\dbus-1:\n```shell\n#! /bin/sh\n### BEGIN INIT INFO\n# Provides:          dbus\n# Required-Start:    $remote_fs $syslog\n# Required-Stop:     $remote_fs $syslog\n# Default-Start:     2 3 4 5\n# Default-Stop:      1\n# Short-Description: D-Bus systemwide message bus\n# Description:       D-Bus is a simple interprocess messaging system, used\n#                    for sending messages between applications.\n### END INIT INFO\n#\n# -*- coding: utf-8 -*-\n# Debian init.d script for D-BUS\n# Copyright © 2003 Colin Walters <walters@debian.org>\n\n# set -e\n\n# Source function library.\n#这行代码导入了 /etc/init.d/functions 文件，该文件通常包含了一些用于 init 脚本的通用函数。\n#可以用来处理日志、进程管理等任务。\n. /etc/init.d/functions\n\nDAEMON=/usr/bin/dbus-daemon # 设置了 D-Bus 守护进程的路径\nNAME=dbus-1\nDAEMONUSER=messagebus           # 必须与 /etc/dbus-1/system.conf 中的设置相匹配\nPIDFILE=/var/run/messagebus.pid # 必须与 /etc/dbus-1/system.conf 中的设置相匹配\nUUIDDIR=/var/lib/dbus\nDESC=\"system message bus\"\nEVENTDIR=/etc/dbus-1/event.d\n\n#检查给定的变量 $DAEMON 所表示的文件是否存在并且是否可执行\ntest -x $DAEMON || exit 0\n\n# Source defaults file; edit that file to configure this script.\nENABLED=1\nPARAMS=\"\"\nif [ -e /etc/default/dbus ]; then\n  . /etc/default/dbus\nfi\n\ntest \"$ENABLED\" != \"0\" || exit 0\n\nstart_it_up()\n{\n  mkdir -p \"`dirname $PIDFILE`\"\n  if [ -e $PIDFILE ]; then\n    PIDDIR=/proc/$(cat $PIDFILE)\n    if [ -d ${PIDDIR} -a  \"$(readlink -f ${PIDDIR}/exe)\" = \"${DAEMON}\" ]; then \n      echo \"$DESC already started; not starting.\"\n    else\n      echo \"Removing stale PID file $PIDFILE.\"\n      rm -f $PIDFILE\n    fi\n  fi\n\n  if [ ! -d $UUIDDIR ]; then\n    mkdir -p $UUIDDIR\n    chown $DAEMONUSER $UUIDDIR\n    chgrp $DAEMONUSER $UUIDDIR\n  fi\n \n  dbus-uuidgen --ensure  \n\n  echo -n \"Starting $DESC: \"\n  start-stop-daemon -o --start --quiet --pidfile $PIDFILE \\\n    --user $DAEMONUSER --exec $DAEMON -- --system $PARAMS\n  echo \"$NAME.\"\n  if [ -d $EVENTDIR ]; then\n      run-parts --arg=start $EVENTDIR\n  fi\n}\n\nshut_it_down()\n{\n  if [ -d $EVENTDIR ]; then\n      # TODO: --reverse when busybox supports it\n      run-parts --arg=stop $EVENTDIR\n  fi\n  echo -n \"Stopping $DESC: \"\n  start-stop-daemon -o --stop  --quiet --pidfile $PIDFILE \\\n    --user $DAEMONUSER\n  # We no longer include these arguments so that start-stop-daemon\n  # can do its job even given that we may have been upgraded.\n  # We rely on the pidfile being sanely managed\n  # --exec $DAEMON -- --system $PARAMS\n  echo \"$NAME.\"\n  rm -f $PIDFILE\n}\n\nreload_it()\n{\n  echo -n \"Reloading $DESC config: \"\n  dbus-send --print-reply --system --type=method_call \\\n            --dest=org.freedesktop.DBus \\\n            / org.freedesktop.DBus.ReloadConfig > /dev/null\n  # hopefully this is enough time for dbus to reload it's config file.\n  echo \"done.\"\n}\n\ncase \"$1\" in\n  start)\n    start_it_up\n  ;;\n  stop)\n    shut_it_down\n  ;;\n  status)\n    status $DAEMON\n    exit $?\n  ;;\n  reload|force-reload)\n    reload_it\n  ;;\n  restart)\n    shut_it_down\n    sleep 1\n    start_it_up\n  ;;\n  *)\n    echo \"Usage: /etc/init.d/$NAME {start|stop|status|restart|reload|force-reload}\" >&2\n    exit 1\n  ;;\nesac\n\nexit 0\n```\n显而易见执行了[/usr/bin/dbus-daemon](https://dbus.freedesktop.org/doc/dbus-daemon.1.html)这个软件,\n\n# dbus-daemon介绍\n[DBus API的使用](https://blog.csdn.net/f110300641/article/details/106822511)\n[dbus官网](https://www.freedesktop.org/wiki/Software/dbus/#sourcecode)","slug":"process-dbus-daemon","published":1,"updated":"2024-01-05T08:12:19.803Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clru1g21q0026s4fuedrkdte0","content":"<h1 id=\"dbus-daemon线程的作用\"><a href=\"#dbus-daemon线程的作用\" class=\"headerlink\" title=\"dbus-daemon线程的作用\"></a>dbus-daemon线程的作用</h1><p><code>dbus-daemon</code> 是 D-Bus 通信系统的守护进程，用于在 Linux 和其他类 Unix 系统上提供进程间通信 (IPC) 功能。D-Bus 是一个跨进程通信机制，使得不同进程之间可以进行消息传递，共享数据以及调用方法。<code>dbus-daemon</code> 线程的作用包括以下几个方面：</p>\n<ol>\n<li><p><strong>进程间通信：</strong> <code>dbus-daemon</code> 提供了一种在不同进程之间进行通信的机制。不同进程可以通过 D-Bus 发送和接收消息，从而实现数据共享和交互。</p>\n</li>\n<li><p><strong>总线系统：</strong> D-Bus 通过一种称为总线系统的方式来组织通信。<code>dbus-daemon</code> 提供了总线系统，允许多个进程在同一个总线上进行通信。总线可以分为系统总线和会话总线，分别用于系统级进程间通信和用户会话级进程间通信。</p>\n</li>\n<li><p><strong>服务发布与发现：</strong> <code>dbus-daemon</code> 允许进程注册自己提供的服务，以便其他进程能够发现并调用这些服务。这有助于实现解耦和模块化的系统设计。</p>\n</li>\n<li><p><strong>对象和接口管理：</strong> D-Bus 通过对象和接口的概念来组织数据和方法。<code>dbus-daemon</code> 确保对象和接口的正确注册和管理，以便进程可以通过合适的接口与其他对象交互。</p>\n</li>\n<li><p><strong>权限和安全：</strong> <code>dbus-daemon</code> 管理进程之间的通信权限，以确保只有授权的进程能够相互通信。这有助于维护系统的安全性。</p>\n</li>\n<li><p><strong>解析地址：</strong> <code>dbus-daemon</code> 用于解析 D-Bus 地址，以便确定要发送消息的目标进程。</p>\n</li>\n</ol>\n<p><img src=\"/2023/08/process-dbus-daemon/1.png\" alt><br>DBus 本身是构建在 Socket 机制之上。真正的通信还是由 Socket 来完成的。DBus 则是在这之上，制定了一些通信的协议，并提供了更高一层的接口，以更方便应用程序之间进行数据的交互。</p>\n<h1 id=\"dbus-daemon源码\"><a href=\"#dbus-daemon源码\" class=\"headerlink\" title=\"dbus-daemon源码\"></a>dbus-daemon源码</h1><p>以等级5启动内核</p>\n<pre class=\" language-shell\"><code class=\"language-shell\">root@ATK-IMX6U:/etc/rc5.d# ls -l\ntotal 0\nlrwxrwxrwx 1 root root 20 Jun 10 18:21 S01networking -> ../init.d/networking\nlrwxrwxrwx 1 root root 22 Jun 10 18:21 S01xserver-nodm -> ../init.d/xserver-nodm\nlrwxrwxrwx 1 root root 16 Jun 10 18:21 S02dbus-1 -> ../init.d/dbus-1\nlrwxrwxrwx 1 root root 17 Jun 10 18:21 S05connman -> ../init.d/connman\nlrwxrwxrwx 1 root root 18 Jun 10 18:21 S10dropbear -> ../init.d/dropbear\nlrwxrwxrwx 1 root root 17 Jun 10 18:21 S12rpcbind -> ../init.d/rpcbind\nlrwxrwxrwx 1 root root 21 Jun 10 18:21 S15mountnfs.sh -> ../init.d/mountnfs.sh\nlrwxrwxrwx 1 root root 21 Jun 10 18:21 S15watchdog.sh -> ../init.d/watchdog.sh\nlrwxrwxrwx 1 root root 19 Jun 10 18:21 S19nfscommon -> ../init.d/nfscommon\nlrwxrwxrwx 1 root root 14 Jun 10 18:21 S20apmd -> ../init.d/apmd\nlrwxrwxrwx 1 root root 13 Jun 10 18:21 S20atd -> ../init.d/atd\nlrwxrwxrwx 1 root root 17 Jun 10 18:21 S20hostapd -> ../init.d/hostapd\nlrwxrwxrwx 1 root root 20 Jun 10 18:21 S20hwclock.sh -> ../init.d/hwclock.sh\nlrwxrwxrwx 1 root root 19 Jun 10 18:21 S20nfsserver -> ../init.d/nfsserver\nlrwxrwxrwx 1 root root 16 Jun 10 18:21 S20syslog -> ../init.d/syslog\nlrwxrwxrwx 1 root root 22 Jun 10 18:21 S21avahi-daemon -> ../init.d/avahi-daemon\nlrwxrwxrwx 1 root root 15 Jun 10 18:21 S22ofono -> ../init.d/ofono\nlrwxrwxrwx 1 root root 15 Jun 10 18:21 S64neard -> ../init.d/neard\nlrwxrwxrwx 1 root root 16 Jun 10 18:21 S80vsftpd -> ../init.d/vsftpd\nlrwxrwxrwx 1 root root 15 Jun 10 18:21 S90crond -> ../init.d/crond\nlrwxrwxrwx 1 root root 15 Jun 10 18:21 S92nginx -> ../init.d/nginx\nlrwxrwxrwx 1 root root 18 Jun 10 18:21 S99rc.local -> ../init.d/rc.local\nlrwxrwxrwx 1 root root 22 Jun 10 18:21 S99rmnologin.sh -> ../init.d/rmnologin.sh\nlrwxrwxrwx 1 root root 23 Jun 10 18:21 S99stop-bootlogd -> ../init.d/stop-bootlogd</code></pre>\n<p>etc\\init.d\\dbus-1:</p>\n<pre class=\" language-shell\"><code class=\"language-shell\">#! /bin/sh\n### BEGIN INIT INFO\n# Provides:          dbus\n# Required-Start:    $remote_fs $syslog\n# Required-Stop:     $remote_fs $syslog\n# Default-Start:     2 3 4 5\n# Default-Stop:      1\n# Short-Description: D-Bus systemwide message bus\n# Description:       D-Bus is a simple interprocess messaging system, used\n#                    for sending messages between applications.\n### END INIT INFO\n#\n# -*- coding: utf-8 -*-\n# Debian init.d script for D-BUS\n# Copyright © 2003 Colin Walters <walters@debian.org>\n\n# set -e\n\n# Source function library.\n#这行代码导入了 /etc/init.d/functions 文件，该文件通常包含了一些用于 init 脚本的通用函数。\n#可以用来处理日志、进程管理等任务。\n. /etc/init.d/functions\n\nDAEMON=/usr/bin/dbus-daemon # 设置了 D-Bus 守护进程的路径\nNAME=dbus-1\nDAEMONUSER=messagebus           # 必须与 /etc/dbus-1/system.conf 中的设置相匹配\nPIDFILE=/var/run/messagebus.pid # 必须与 /etc/dbus-1/system.conf 中的设置相匹配\nUUIDDIR=/var/lib/dbus\nDESC=\"system message bus\"\nEVENTDIR=/etc/dbus-1/event.d\n\n#检查给定的变量 $DAEMON 所表示的文件是否存在并且是否可执行\ntest -x $DAEMON || exit 0\n\n# Source defaults file; edit that file to configure this script.\nENABLED=1\nPARAMS=\"\"\nif [ -e /etc/default/dbus ]; then\n  . /etc/default/dbus\nfi\n\ntest \"$ENABLED\" != \"0\" || exit 0\n\nstart_it_up()\n{\n  mkdir -p \"`dirname $PIDFILE`\"\n  if [ -e $PIDFILE ]; then\n    PIDDIR=/proc/$(cat $PIDFILE)\n    if [ -d ${PIDDIR} -a  \"$(readlink -f ${PIDDIR}/exe)\" = \"${DAEMON}\" ]; then \n      echo \"$DESC already started; not starting.\"\n    else\n      echo \"Removing stale PID file $PIDFILE.\"\n      rm -f $PIDFILE\n    fi\n  fi\n\n  if [ ! -d $UUIDDIR ]; then\n    mkdir -p $UUIDDIR\n    chown $DAEMONUSER $UUIDDIR\n    chgrp $DAEMONUSER $UUIDDIR\n  fi\n\n  dbus-uuidgen --ensure  \n\n  echo -n \"Starting $DESC: \"\n  start-stop-daemon -o --start --quiet --pidfile $PIDFILE \\\n    --user $DAEMONUSER --exec $DAEMON -- --system $PARAMS\n  echo \"$NAME.\"\n  if [ -d $EVENTDIR ]; then\n      run-parts --arg=start $EVENTDIR\n  fi\n}\n\nshut_it_down()\n{\n  if [ -d $EVENTDIR ]; then\n      # TODO: --reverse when busybox supports it\n      run-parts --arg=stop $EVENTDIR\n  fi\n  echo -n \"Stopping $DESC: \"\n  start-stop-daemon -o --stop  --quiet --pidfile $PIDFILE \\\n    --user $DAEMONUSER\n  # We no longer include these arguments so that start-stop-daemon\n  # can do its job even given that we may have been upgraded.\n  # We rely on the pidfile being sanely managed\n  # --exec $DAEMON -- --system $PARAMS\n  echo \"$NAME.\"\n  rm -f $PIDFILE\n}\n\nreload_it()\n{\n  echo -n \"Reloading $DESC config: \"\n  dbus-send --print-reply --system --type=method_call \\\n            --dest=org.freedesktop.DBus \\\n            / org.freedesktop.DBus.ReloadConfig > /dev/null\n  # hopefully this is enough time for dbus to reload it's config file.\n  echo \"done.\"\n}\n\ncase \"$1\" in\n  start)\n    start_it_up\n  ;;\n  stop)\n    shut_it_down\n  ;;\n  status)\n    status $DAEMON\n    exit $?\n  ;;\n  reload|force-reload)\n    reload_it\n  ;;\n  restart)\n    shut_it_down\n    sleep 1\n    start_it_up\n  ;;\n  *)\n    echo \"Usage: /etc/init.d/$NAME {start|stop|status|restart|reload|force-reload}\" >&2\n    exit 1\n  ;;\nesac\n\nexit 0</code></pre>\n<p>显而易见执行了<a href=\"https://dbus.freedesktop.org/doc/dbus-daemon.1.html\" target=\"_blank\" rel=\"noopener\">/usr/bin/dbus-daemon</a>这个软件,</p>\n<h1 id=\"dbus-daemon介绍\"><a href=\"#dbus-daemon介绍\" class=\"headerlink\" title=\"dbus-daemon介绍\"></a>dbus-daemon介绍</h1><p><a href=\"https://blog.csdn.net/f110300641/article/details/106822511\" target=\"_blank\" rel=\"noopener\">DBus API的使用</a><br><a href=\"https://www.freedesktop.org/wiki/Software/dbus/#sourcecode\" target=\"_blank\" rel=\"noopener\">dbus官网</a></p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<h1 id=\"dbus-daemon线程的作用\"><a href=\"#dbus-daemon线程的作用\" class=\"headerlink\" title=\"dbus-daemon线程的作用\"></a>dbus-daemon线程的作用</h1><p><code>dbus-daemon</code> 是 D-Bus 通信系统的守护进程，用于在 Linux 和其他类 Unix 系统上提供进程间通信 (IPC) 功能。D-Bus 是一个跨进程通信机制，使得不同进程之间可以进行消息传递，共享数据以及调用方法。<code>dbus-daemon</code> 线程的作用包括以下几个方面：</p>\n<ol>\n<li><p><strong>进程间通信：</strong> <code>dbus-daemon</code> 提供了一种在不同进程之间进行通信的机制。不同进程可以通过 D-Bus 发送和接收消息，从而实现数据共享和交互。</p>\n</li>\n<li><p><strong>总线系统：</strong> D-Bus 通过一种称为总线系统的方式来组织通信。<code>dbus-daemon</code> 提供了总线系统，允许多个进程在同一个总线上进行通信。总线可以分为系统总线和会话总线，分别用于系统级进程间通信和用户会话级进程间通信。</p>\n</li>\n<li><p><strong>服务发布与发现：</strong> <code>dbus-daemon</code> 允许进程注册自己提供的服务，以便其他进程能够发现并调用这些服务。这有助于实现解耦和模块化的系统设计。</p>\n</li>\n<li><p><strong>对象和接口管理：</strong> D-Bus 通过对象和接口的概念来组织数据和方法。<code>dbus-daemon</code> 确保对象和接口的正确注册和管理，以便进程可以通过合适的接口与其他对象交互。</p>\n</li>\n<li><p><strong>权限和安全：</strong> <code>dbus-daemon</code> 管理进程之间的通信权限，以确保只有授权的进程能够相互通信。这有助于维护系统的安全性。</p>\n</li>\n<li><p><strong>解析地址：</strong> <code>dbus-daemon</code> 用于解析 D-Bus 地址，以便确定要发送消息的目标进程。</p>\n</li>\n</ol>\n<p><img src=\"/2023/08/process-dbus-daemon/1.png\" alt><br>DBus 本身是构建在 Socket 机制之上。真正的通信还是由 Socket 来完成的。DBus 则是在这之上，制定了一些通信的协议，并提供了更高一层的接口，以更方便应用程序之间进行数据的交互。</p>\n<h1 id=\"dbus-daemon源码\"><a href=\"#dbus-daemon源码\" class=\"headerlink\" title=\"dbus-daemon源码\"></a>dbus-daemon源码</h1><p>以等级5启动内核</p>\n<pre><code class=\"shell\">root@ATK-IMX6U:/etc/rc5.d# ls -l\ntotal 0\nlrwxrwxrwx 1 root root 20 Jun 10 18:21 S01networking -&gt; ../init.d/networking\nlrwxrwxrwx 1 root root 22 Jun 10 18:21 S01xserver-nodm -&gt; ../init.d/xserver-nodm\nlrwxrwxrwx 1 root root 16 Jun 10 18:21 S02dbus-1 -&gt; ../init.d/dbus-1\nlrwxrwxrwx 1 root root 17 Jun 10 18:21 S05connman -&gt; ../init.d/connman\nlrwxrwxrwx 1 root root 18 Jun 10 18:21 S10dropbear -&gt; ../init.d/dropbear\nlrwxrwxrwx 1 root root 17 Jun 10 18:21 S12rpcbind -&gt; ../init.d/rpcbind\nlrwxrwxrwx 1 root root 21 Jun 10 18:21 S15mountnfs.sh -&gt; ../init.d/mountnfs.sh\nlrwxrwxrwx 1 root root 21 Jun 10 18:21 S15watchdog.sh -&gt; ../init.d/watchdog.sh\nlrwxrwxrwx 1 root root 19 Jun 10 18:21 S19nfscommon -&gt; ../init.d/nfscommon\nlrwxrwxrwx 1 root root 14 Jun 10 18:21 S20apmd -&gt; ../init.d/apmd\nlrwxrwxrwx 1 root root 13 Jun 10 18:21 S20atd -&gt; ../init.d/atd\nlrwxrwxrwx 1 root root 17 Jun 10 18:21 S20hostapd -&gt; ../init.d/hostapd\nlrwxrwxrwx 1 root root 20 Jun 10 18:21 S20hwclock.sh -&gt; ../init.d/hwclock.sh\nlrwxrwxrwx 1 root root 19 Jun 10 18:21 S20nfsserver -&gt; ../init.d/nfsserver\nlrwxrwxrwx 1 root root 16 Jun 10 18:21 S20syslog -&gt; ../init.d/syslog\nlrwxrwxrwx 1 root root 22 Jun 10 18:21 S21avahi-daemon -&gt; ../init.d/avahi-daemon\nlrwxrwxrwx 1 root root 15 Jun 10 18:21 S22ofono -&gt; ../init.d/ofono\nlrwxrwxrwx 1 root root 15 Jun 10 18:21 S64neard -&gt; ../init.d/neard\nlrwxrwxrwx 1 root root 16 Jun 10 18:21 S80vsftpd -&gt; ../init.d/vsftpd\nlrwxrwxrwx 1 root root 15 Jun 10 18:21 S90crond -&gt; ../init.d/crond\nlrwxrwxrwx 1 root root 15 Jun 10 18:21 S92nginx -&gt; ../init.d/nginx\nlrwxrwxrwx 1 root root 18 Jun 10 18:21 S99rc.local -&gt; ../init.d/rc.local\nlrwxrwxrwx 1 root root 22 Jun 10 18:21 S99rmnologin.sh -&gt; ../init.d/rmnologin.sh\nlrwxrwxrwx 1 root root 23 Jun 10 18:21 S99stop-bootlogd -&gt; ../init.d/stop-bootlogd</code></pre>\n<p>etc\\init.d\\dbus-1:</p>\n<pre><code class=\"shell\">#! /bin/sh\n### BEGIN INIT INFO\n# Provides:          dbus\n# Required-Start:    $remote_fs $syslog\n# Required-Stop:     $remote_fs $syslog\n# Default-Start:     2 3 4 5\n# Default-Stop:      1\n# Short-Description: D-Bus systemwide message bus\n# Description:       D-Bus is a simple interprocess messaging system, used\n#                    for sending messages between applications.\n### END INIT INFO\n#\n# -*- coding: utf-8 -*-\n# Debian init.d script for D-BUS\n# Copyright © 2003 Colin Walters &lt;walters@debian.org&gt;\n\n# set -e\n\n# Source function library.\n#这行代码导入了 /etc/init.d/functions 文件，该文件通常包含了一些用于 init 脚本的通用函数。\n#可以用来处理日志、进程管理等任务。\n. /etc/init.d/functions\n\nDAEMON=/usr/bin/dbus-daemon # 设置了 D-Bus 守护进程的路径\nNAME=dbus-1\nDAEMONUSER=messagebus           # 必须与 /etc/dbus-1/system.conf 中的设置相匹配\nPIDFILE=/var/run/messagebus.pid # 必须与 /etc/dbus-1/system.conf 中的设置相匹配\nUUIDDIR=/var/lib/dbus\nDESC=&quot;system message bus&quot;\nEVENTDIR=/etc/dbus-1/event.d\n\n#检查给定的变量 $DAEMON 所表示的文件是否存在并且是否可执行\ntest -x $DAEMON || exit 0\n\n# Source defaults file; edit that file to configure this script.\nENABLED=1\nPARAMS=&quot;&quot;\nif [ -e /etc/default/dbus ]; then\n  . /etc/default/dbus\nfi\n\ntest &quot;$ENABLED&quot; != &quot;0&quot; || exit 0\n\nstart_it_up()\n{\n  mkdir -p &quot;`dirname $PIDFILE`&quot;\n  if [ -e $PIDFILE ]; then\n    PIDDIR=/proc/$(cat $PIDFILE)\n    if [ -d ${PIDDIR} -a  &quot;$(readlink -f ${PIDDIR}/exe)&quot; = &quot;${DAEMON}&quot; ]; then \n      echo &quot;$DESC already started; not starting.&quot;\n    else\n      echo &quot;Removing stale PID file $PIDFILE.&quot;\n      rm -f $PIDFILE\n    fi\n  fi\n\n  if [ ! -d $UUIDDIR ]; then\n    mkdir -p $UUIDDIR\n    chown $DAEMONUSER $UUIDDIR\n    chgrp $DAEMONUSER $UUIDDIR\n  fi\n\n  dbus-uuidgen --ensure  \n\n  echo -n &quot;Starting $DESC: &quot;\n  start-stop-daemon -o --start --quiet --pidfile $PIDFILE \\\n    --user $DAEMONUSER --exec $DAEMON -- --system $PARAMS\n  echo &quot;$NAME.&quot;\n  if [ -d $EVENTDIR ]; then\n      run-parts --arg=start $EVENTDIR\n  fi\n}\n\nshut_it_down()\n{\n  if [ -d $EVENTDIR ]; then\n      # TODO: --reverse when busybox supports it\n      run-parts --arg=stop $EVENTDIR\n  fi\n  echo -n &quot;Stopping $DESC: &quot;\n  start-stop-daemon -o --stop  --quiet --pidfile $PIDFILE \\\n    --user $DAEMONUSER\n  # We no longer include these arguments so that start-stop-daemon\n  # can do its job even given that we may have been upgraded.\n  # We rely on the pidfile being sanely managed\n  # --exec $DAEMON -- --system $PARAMS\n  echo &quot;$NAME.&quot;\n  rm -f $PIDFILE\n}\n\nreload_it()\n{\n  echo -n &quot;Reloading $DESC config: &quot;\n  dbus-send --print-reply --system --type=method_call \\\n            --dest=org.freedesktop.DBus \\\n            / org.freedesktop.DBus.ReloadConfig &gt; /dev/null\n  # hopefully this is enough time for dbus to reload it&#39;s config file.\n  echo &quot;done.&quot;\n}\n\ncase &quot;$1&quot; in\n  start)\n    start_it_up\n  ;;\n  stop)\n    shut_it_down\n  ;;\n  status)\n    status $DAEMON\n    exit $?\n  ;;\n  reload|force-reload)\n    reload_it\n  ;;\n  restart)\n    shut_it_down\n    sleep 1\n    start_it_up\n  ;;\n  *)\n    echo &quot;Usage: /etc/init.d/$NAME {start|stop|status|restart|reload|force-reload}&quot; &gt;&amp;2\n    exit 1\n  ;;\nesac\n\nexit 0</code></pre>\n<p>显而易见执行了<a href=\"https://dbus.freedesktop.org/doc/dbus-daemon.1.html\" target=\"_blank\" rel=\"noopener\">/usr/bin/dbus-daemon</a>这个软件,</p>\n<h1 id=\"dbus-daemon介绍\"><a href=\"#dbus-daemon介绍\" class=\"headerlink\" title=\"dbus-daemon介绍\"></a>dbus-daemon介绍</h1><p><a href=\"https://blog.csdn.net/f110300641/article/details/106822511\" target=\"_blank\" rel=\"noopener\">DBus API的使用</a><br><a href=\"https://www.freedesktop.org/wiki/Software/dbus/#sourcecode\" target=\"_blank\" rel=\"noopener\">dbus官网</a></p>\n"},{"title":"process-init","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-08-24T06:37:55.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"\n# init进程\n在Linux系统中，`init` 是第一个被启动的进程，其进程ID为1。它是系统启动过程中的第一个用户级进程，负责初始化系统，并在系统运行时作为所有其他进程的祖先。然而，需要注意的是，在现代Linux系统中，`init` 进程通常被替代为更先进的初始化系统，比如 `systemd` 或 `Upstart`。\n\n原始的 `init` 进程主要负责以下几个任务：\n\n1. **系统初始化**: `init` 进程在系统启动时负责加载操作系统所需的核心模块和设备驱动程序，以确保系统的基本功能正常运行。\n\n2. **启动和管理系统服务**: `init` 进程通过运行启动脚本来启动系统中的各种服务和守护进程。这些服务可能包括网络服务、文件系统服务、打印服务等。\n\n3. **运行级别管理**: `init` 进程支持不同的运行级别，每个级别定义了不同的系统状态。例如，运行级别可能是单用户模式、多用户模式、图形用户界面模式等。`init` 进程负责根据需要切换不同的运行级别。\n\n然而，随着时间的推移，传统的 `init` 进程的功能显得有些有限，因此引入了更现代的初始化系统，如 `systemd`。`systemd` 在许多Linux发行版中取代了传统的 `init`，它提供了更强大的系统初始化和管理功能，可以更有效地处理并行启动、服务依赖、日志管理等。\n\n尽管如此，`init` 进程作为系统的第一个进程仍然具有重要的历史地位，并且在某些方面仍然发挥着作用，尤其是在一些较旧的或嵌入式系统中。\n\n# init源码\ninit/main.c：start_kernel()--->rest_init()\n```c\nstatic noinline void __init_refok rest_init(void)\n{\n    int pid;\n\n    // 启动RCU（Read-Copy-Update）调度器\n    rcu_scheduler_starting();\n\n    // 初始化SMP（Symmetric Multiprocessing）启动线程\n    smpboot_thread_init();\n\n    /*\n     * 我们需要首先生成 init 进程，以便它获得 pid 1，但是 init 任务最终会想要创建 kthread，\n     * 如果我们在创建 kthreadd 之前调度它，将会导致 OOPS（操作系统崩溃）。\n     */\n    kernel_thread(kernel_init, NULL, CLONE_FS);\n\n    // 设置 NUMA（Non-Uniform Memory Access）默认策略\n    numa_default_policy();\n\n    // 创建 kthreadd 进程，用于创建其他内核线程\n    pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES);\n\n    // 读取锁定 RCU，以查找 kthreadd 进程的任务结构体\n    rcu_read_lock();\n    kthreadd_task = find_task_by_pid_ns(pid, &init_pid_ns);\n    rcu_read_unlock();\n\n    // 标记 kthreadd 进程已完成初始化\n    complete(&kthreadd_done);\n\n    /*\n     * 引导空闲线程必须执行 schedule() 至少一次以启动系统：\n     */\n    init_idle_bootup_task(current);\n    schedule_preempt_disabled();\n    \n    /* 带有抢占禁用的情况下调用 cpu_idle */\n    cpu_startup_entry(CPUHP_ONLINE);\n}\n```\n这段代码主要完成以下任务：\n\n1.启动 RCU 调度器，这是一种内核中用于实现无锁并发访问的机制。\n2.初始化 SMP 启动线程，用于初始化多处理器系统。\n3.创建 init 进程，确保它获得 PID 1，但避免在创建 kthreadd 进程之前调度 init 进程。\n4.设置 NUMA 默认策略，处理非一致性内存访问。\n5.创建 kthreadd 进程，该进程用于在内核中创建其他线程。\n6.根据 PID 查找并初始化 kthreadd 进程的任务结构体。\n7.标记 kthreadd 进程初始化完成。\n8.启动引导空闲线程，执行初始的调度以启动系统。\n9.最后，调用 cpu_startup_entry，在线程上下文中启动 CPU，允许它执行调度。\n\n```c\n    static int __ref kernel_init(void *unused)\n    {\n        int ret;\n\n        // 运行 kernel_init_freeable 函数，执行一些必要的内核初始化\n        kernel_init_freeable();\n\n        // 在释放内存之前，需要完成所有异步 __init 代码\n        async_synchronize_full();\n\n        // 释放初始内存\n        free_initmem();\n\n        // 将只读数据段标记为只读\n        mark_rodata_ro();\n\n        // 设置系统状态为 SYSTEM_RUNNING，表示系统已运行\n        system_state = SYSTEM_RUNNING;\n\n        // 设置 NUMA 默认策略\n        numa_default_policy();\n\n        // 清理延迟的文件指针释放\n        flush_delayed_fput();\n\n        // 如果设置了 ramdisk_execute_command，则尝试运行对应的命令\n        if (ramdisk_execute_command) {\n            ret = run_init_process(ramdisk_execute_command);\n            if (!ret)\n                return 0;\n            pr_err(\"Failed to execute %s (error %d)\\n\",\n                ramdisk_execute_command, ret);\n        }\n\n        /*\n        * 我们尝试执行以下每个命令，直到成功为止。\n        *\n        * 如果我们尝试恢复一个非常破损的机器，可以使用 Bourne shell 代替 init。\n        */\n        if (execute_command) {\n            ret = run_init_process(execute_command);\n            if (!ret)\n                return 0;\n            panic(\"Requested init %s failed (error %d).\",\n                execute_command, ret);\n        }\n        if (!try_to_run_init_process(\"/sbin/init\") ||\n            !try_to_run_init_process(\"/etc/init\") ||\n            !try_to_run_init_process(\"/bin/init\") ||\n            !try_to_run_init_process(\"/bin/sh\"))\n            return 0;\n\n        // 如果没有找到可用的 init 进程，触发内核崩溃\n        panic(\"No working init found.  Try passing init= option to kernel. \"\n            \"See Linux Documentation/init.txt for guidance.\");\n    }\n```\n这段代码的主要功能是在系统引导期间执行一系列初始化操作，然后尝试启动系统的初始化进程（如 init）。它的核心步骤包括：\n\n运行 kernel_init_freeable 函数，执行一些必要的内核初始化,这个函数很重要后面分析。\n\n在释放内存之前，使用 async_synchronize_full 等待所有异步初始化代码的完成。\n\n释放初始内存，这是在引导过程中使用的一部分内存。\n\n将只读数据段标记为只读，以提高系统的安全性。\n\n设置系统状态为 SYSTEM_RUNNING，表示系统已经正常运行。\n\n设置 NUMA 默认策略，用于处理非一致性内存访问。\n\n清理延迟的文件指针释放，确保文件资源得到正确管理。\n\n尝试执行预设的 ramdisk_execute_command 命令（如果设置了）。\n\n尝试执行预设的 execute_command 命令（如果设置了）。\n\n如果以上尝试都失败，尝试依次执行一些默认的初始化命令路径，如 /sbin/init、/etc/init、/bin/init 和 /bin/sh。\n`/sbin/init实际是init.sysvinit。但是init.sysvinit是干嘛的不知道？？？？`\n暂时理解成init进程启动，通过/sbin/init准备系统软件的运行环境，读取/etc/inittab，获取运行级别数值 \n\n如果仍然找不到可用的初始化进程，系统进入崩溃状态，显示错误消息并建议尝试通过内核参数 init= 指定初始化进程。\n\n```c\n\nstatic noinline void __init kernel_init_freeable(void)\n{\n\t/*\n\t * Wait until kthreadd is all set-up.\n\t */\n\twait_for_completion(&kthreadd_done);\n\n\t/* Now the scheduler is fully set up and can do blocking allocations */\n\tgfp_allowed_mask = __GFP_BITS_MASK;\n\n\t/*\n\t * init can allocate pages on any node\n\t */\n\tset_mems_allowed(node_states[N_MEMORY]);\n\t/*\n\t * init can run on any cpu.\n\t */\n\tset_cpus_allowed_ptr(current, cpu_all_mask);\n\n\tcad_pid = task_pid(current);\n\n\tsmp_prepare_cpus(setup_max_cpus);\n\n\tdo_pre_smp_initcalls();\n\tlockup_detector_init();\n\n\tsmp_init();\n\tsched_init_smp();\n\n\tdo_basic_setup();   /* 设备初始化都在此函数中完成 */\n\n\t/* Open the /dev/console on the rootfs, this should never fail */\n\tif (sys_open((const char __user *) \"/dev/console\", O_RDWR, 0) < 0)\n\t\tpr_err(\"Warning: unable to open an initial console.\\n\");\n\n\t(void) sys_dup(0);\n\t(void) sys_dup(0);\n\t/*\n\t * check if there is an early userspace init.  If yes, let it do all\n\t * the work\n\t */\n\n\tif (!ramdisk_execute_command)\n\t\tramdisk_execute_command = \"/init\";\n\n\tif (sys_access((const char __user *) ramdisk_execute_command, 0) != 0) {\n\t\tramdisk_execute_command = NULL;\n\t\tprepare_namespace();\n\t}\n\n\t/*\n\t * Ok, we have completed the initial bootup, and\n\t * we're essentially up and running. Get rid of the\n\t * initmem segments and start the user-mode stuff..\n\t *\n\t * rootfs is available now, try loading the public keys\n\t * and default modules\n\t */\n\n\tintegrity_load_keys();\n\tload_default_modules();\n}\n```\n`kernel_init_freeable`函数执行的一系列操作：\n\n1. `wait_for_completion(&kthreadd_done);`：等待直到`kthreadd`进程初始化完成，确保`kthreadd`进程已经准备就绪。\n\n2. `gfp_allowed_mask = __GFP_BITS_MASK;`：设置内核的内存分配标志，允许使用所有内存分配标志位。\n\n3. `set_mems_allowed(node_states[N_MEMORY]);`：设置进程可以在所有NUMA节点上分配内存。\n\n4. `set_cpus_allowed_ptr(current, cpu_all_mask);`：设置当前进程可以在所有CPU上运行。\n\n5. `cad_pid = task_pid(current);`：设置`cad_pid`（Ctrl+Alt+Del进程）为当前进程的PID。\n\n6. `smp_prepare_cpus(setup_max_cpus);`：准备启动SMP（对称多处理）系统，设置CPU的最大数量。\n\n7. `do_pre_smp_initcalls();`：运行预初始化的SMP调用。\n\n8. `lockup_detector_init();`：初始化系统的死锁检测器。\n\n9. `smp_init();`：初始化SMP子系统。\n\n10. `sched_init_smp();`：初始化调度器的SMP相关部分。\n\n11. `do_basic_setup();`：do_basic_setup 函数用于完成 Linux 下设备驱动初始化工作！非常重要。do_basic_setup 会调用 driver_init 函数完成 Linux 下驱动模型子系统的初始化。\n\n12. `sys_open((const char __user *) \"/dev/console\", O_RDWR, 0)`：尝试打开`/dev/console`设备，用于系统控制台输出。\n\n13. `sys_dup(0)`：通过复制文件描述符0（标准输入）来创建文件描述符1和2（标准输出和标准错误），确保它们都指向同一个设备。\n\n14. `if (!ramdisk_execute_command) ramdisk_execute_command = \"/init\";`：如果没有定义`ramdisk_execute_command`，则设置默认的启动命令为`/init`。\n\n15. `if (sys_access((const char __user *) ramdisk_execute_command, 0) != 0)`：检查指定的启动命令是否存在。\n\n16. `prepare_namespace();`：准备初始化的根文件系统命名空间。\n\n17. `integrity_load_keys();`：加载完整性校验的公钥，用于验证文件系统上的数据完整性。\n\n18. `load_default_modules();`：加载默认的内核模块，增加系统功能。\n\n总之，这段代码在系统引导期间完成一系列重要的初始化步骤，包括设置内存分配、CPU调度、设备初始化、根文件系统设置等。最终，它准备好系统的运行环境，使得系统能够顺利进入用户模式运行，并提供用户可见的功能。\n\n# 执行脚本\n    sbin/init--->init.sysinit\n                    |调用\n                    v\n        /etc/inittab--->/etc/init.d/rcS--->/etc/default/rcS（默认设置）\n                                       --->/etc/init.d/rc（启动默认线程）\n                                            |\n                                            V\n                                        开启/etc/rc$.d/下面的进程\n## /etc/inittab\n```c\nroot@ATK-IMX6U:/etc# cat inittab \n# /etc/inittab: init(8) configuration.\n# $Id: inittab,v 1.91 2002/01/25 13:35:21 miquels Exp $\n\n# The default runlevel.\nid:5:initdefault:\n\n# Boot-time system configuration/initialization script.\n# This is run first except when booting in emergency (-b) mode.\nsi::sysinit:/etc/init.d/rcS\n\n# What to do in single-user mode.\n~~:S:wait:/sbin/sulogin\n\n# /etc/init.d executes the S and K scripts upon change\n# of runlevel.\n#\n# Runlevel 0 is halt.\n# Runlevel 1 is single-user.\n# Runlevels 2-5 are multi-user.\n# Runlevel 6 is reboot.\ntty1::askfirst:-/bin/sh\nl0:0:wait:/etc/init.d/rc 0\nl1:1:wait:/etc/init.d/rc 1\nl2:2:wait:/etc/init.d/rc 2\nl3:3:wait:/etc/init.d/rc 3\nl4:4:wait:/etc/init.d/rc 4\nl5:5:wait:/etc/init.d/rc 5\nl6:6:wait:/etc/init.d/rc 6\n# Normally not reached, but fallthrough in case of emergency.\nz6:6:respawn:/sbin/sulogin\n#mxc0:12345:respawn:/bin/start_getty 115200 ttymxc0\nmxc0:12345:respawn:/sbin/getty -l /bin/autologin -n -L 115200 ttymxc0\n# /sbin/getty invocations for the runlevels.\n#\n# The \"id\" field MUST be the same as the last\n# characters of the device (after \"tty\").\n#\n# Format:\n#  <id>:<runlevels>:<action>:<process>\n#\n\n1:12345:respawn:/sbin/getty 38400 tty1\n\n```\n这是一个典型的 `/etc/inittab` 文件，该文件在旧版本的 Linux 系统中用于配置系统初始化过程和运行级别。该文件告诉初始化系统（通常是 SysVinit）在不同运行级别下要执行的操作。以下是`inittab` 文件的内容解释：\n\n1. `id:5:initdefault:`：这指定默认的运行级别为 5，通常对应多用户图形界面模式（X11）。\n\n2. `si::sysinit:/etc/init.d/rcS`：在系统引导过程中运行 `/etc/init.d/rcS` 脚本，这是系统初始化脚本，执行一些基本的系统配置。\n\n3. `~~:S:wait:/sbin/sulogin`：在单用户模式下，等待并运行 `/sbin/sulogin`，该命令是用于单用户模式下的登录。\n\n4. 运行级别定义及操作：\n   - `l0:0:wait:/etc/init.d/rc 0` 切换到运行级别 0（关机）时，运行 `/etc/init.d/rc 0` 脚本。\n   - `l1:1:wait:/etc/init.d/rc 1` 切换到运行级别 1（单用户模式）时，运行 `/etc/init.d/rc 1` 脚本。\n   - `l2:2:wait:/etc/init.d/rc 2` 切换到运行级别 2 时，运行 `/etc/init.d/rc 2` 脚本。\n   - `l3:3:wait:/etc/init.d/rc 3` 切换到运行级别 3 时，运行 `/etc/init.d/rc 3` 脚本。\n   - `l4:4:wait:/etc/init.d/rc 4` 切换到运行级别 4 时，运行 `/etc/init.d/rc 4` 脚本。\n   - `l5:5:wait:/etc/init.d/rc 5` 切换到运行级别 5 时，运行 `/etc/init.d/rc 5` 脚本。\n   - `l6:6:wait:/etc/init.d/rc 6` 切换到运行级别 6（重启）时，运行 `/etc/init.d/rc 6` 脚本。\n\n5. `z6:6:respawn:/sbin/sulogin`：在运行级别 6（重启）时，启动 `/sbin/sulogin`。\n\n6. `mxc0:12345:respawn:/sbin/getty -l /bin/autologin -n -L 115200 ttymxc0`：在运行级别 1、2、3、4、5 时，通过 `getty` 在串口设备 `ttymxc0` 上启动自动登录的终端会话。\n\n7. `1:12345:respawn:/sbin/getty 38400 tty1`：在运行级别 1、2、3、4、5 时，通过 `getty` 在终端 `tty1` 上启动交互式终端会话。\n\n`/etc/inittab` 文件是一个配置文件，用于定义系统初始化进程的行为和运行级别。在早期的 UNIX 和类 UNIX 系统中，`init` 进程是系统中的第一个进程，它是所有其他进程的祖先。`/etc/inittab` 文件用于指定在系统引导过程中要执行的任务、默认运行级别以及其他与系统初始化和运行级别相关的设置。\n\n主要功能包括：\n\n1. **定义运行级别（Runlevels）：** `/etc/inittab` 文件允许您指定默认的运行级别，例如单用户模式、多用户模式等。每个运行级别对应于一组要在该级别下启动或停止的服务。\n\n2. **定义启动任务：** 您可以在 `/etc/inittab` 中定义在不同运行级别下要执行的任务和脚本。这些任务可以是初始化系统配置、启动服务、创建虚拟终端等。例如，在启动时自动运行网络配置脚本。\n\n3. **设置控制台：** `/etc/inittab` 可以配置系统的虚拟终端（TTY）。您可以定义哪个虚拟终端用于登录，哪个终端用于系统控制台，以及何时启动 getty 进程等。\n\n4. **设置自动登录：** 您可以配置系统以在特定终端上自动登录用户，这在某些场景下很有用，例如嵌入式系统中的自动化测试。\n\n5. **定义执行任务：** 您可以将执行任务与特定运行级别相关联。这些任务可能是脚本、命令或程序，会在切换到相关运行级别时自动执行。\n\n需要注意的是，现代 Linux 系统中，许多发行版已经迁移到了更现代的初始化系统，如 `systemd`。因此，`/etc/inittab` 在某些发行版中可能不再被广泛使用。不过，它在一些特定的环境中仍然可以用来定义一些系统初始化和运行级别相关的配置。\n\n## /etc/init.d/rcS\n```C\n#!/bin/sh\n#\n# rcS           Call all S??* scripts in /etc/rcS.d in\n#               numerical/alphabetical order.\n#\n# Version:      @(#)/etc/init.d/rcS  2.76  19-Apr-1999  miquels@cistron.nl\n#\n\nPATH=/sbin:/bin:/usr/sbin:/usr/bin\nrunlevel=S\nprevlevel=N\numask 022\nexport PATH runlevel prevlevel\n\n#       Make sure proc is mounted\n#\n[ -d \"/proc/1\" ] || mount /proc\n\n#\n#       Source defaults.\n#\n. /etc/default/rcS\n\n#\n#       Trap CTRL-C &c only in this shell so we can interrupt subprocesses.\n#\ntrap \":\" INT QUIT TSTP\n\n#\n#       Call all parts in order.\n#\nexec /etc/init.d/rc S\n```\n这是 `/etc/init.d/rcS` 脚本的内容，用于在引导过程中执行一些初始化操作：\n\n1. `PATH=/sbin:/bin:/usr/sbin:/usr/bin`：设置执行脚本时的环境变量路径，以确保能够找到所需的命令和工具。\n\n2. `runlevel=S`：设置当前运行级别为 S（系统启动）。\n\n3. `prevlevel=N`：设置上一个运行级别为 N（不存在的运行级别）。\n\n4. `umask 022`：设置文件创建的默认权限掩码，确保创建的文件不会过于开放。\n\n5. `export PATH runlevel prevlevel`：导出 `PATH`、`runlevel` 和 `prevlevel` 变量，以便在子进程中使用。\n\n6. `[ -d \"/proc/1\" ] || mount /proc`：检查 `/proc/1` 目录是否存在，如果不存在则挂载 `/proc` 文件系统，确保系统可以访问进程信息。\n\n7. `. /etc/default/rcS`：通过 sourcing（`.`）导入 `/etc/default/rcS` 文件，用于加载一些默认配置。\n\n8. `trap \":\" INT QUIT TSTP`：设置信号处理，将 `INT`、`QUIT` 和 `TSTP` 信号的处理设为什么都不做（`:` 表示空语句），以便可以中断子进程而不中断脚本自身。\n\n9. `exec /etc/init.d/rc S`：通过 `exec` 命令执行 `/etc/init.d/rc` 脚本，并传递参数 `S`，表示在运行级别 S 下执行脚本。\n\n`/etc/init.d/rcS` 文件是一个脚本文件，用于在系统引导过程中执行一系列初始化任务。这些任务通常是与系统硬件、网络、文件系统挂载等相关的操作，以确保系统在启动时能够正常运行。\n\n在许多 Linux 发行版中，`rcS` 脚本被称为\"System Initialization Script\"，它是启动过程中第一个执行的脚本。`rcS` 脚本的主要目的是准备系统环境，使其达到可用状态，然后将控制权交给其他初始化脚本，以继续完成系统启动。\n\n`/etc/init.d/rcS` 脚本的功能可能包括：\n\n1. **挂载文件系统：** `rcS` 可能会在此阶段挂载根文件系统和其他必需的文件系统，以确保系统可以访问所需的文件和配置信息。\n\n2. **设置网络：** 在启动过程中，`rcS` 可能会配置网络接口，启动网络服务并初始化网络设置，以便系统可以与其他计算机进行通信。\n\n3. **加载模块：** 一些硬件或功能可能需要内核模块支持。`rcS` 可能会加载所需的内核模块，以确保硬件能够正常运作。\n\n4. **启动服务：** `rcS` 可能会启动一些基本的系统服务，例如系统日志记录、时间同步等。\n\n5. **设置系统参数：** `rcS` 可能会设置系统参数、环境变量和其他系统配置，以确保系统在正常运行时能够获得正确的设置。\n\n6. **清理临时文件：** 在引导过程中，系统可能会生成临时文件。`rcS` 可能会在启动后清理这些临时文件，以保持系统的整洁性。\n\n7. **执行其他初始化任务：** 根据发行版和系统配置，`rcS` 可能会执行其他必要的初始化任务，以确保系统正确启动。\n\n需要注意的是，`/etc/init.d/rcS` 在不同的 Linux 发行版中可能会有不同的实现和用途。在一些现代发行版中，可能已经过渡到使用更现代的初始化系统，如 `systemd`，而一些传统的发行版可能仍然使用 `rcS` 脚本作为系统初始化的一部分。\n\n## /etc/default/rcS\n```c\n#\n#       /etc/rcS.d 中启动脚本的默认值\n#\n\n# 在 /tmp 中保留时间文件的天数。\nTMPTIME=0\n# 如果要在引导时启动 sulogin，请设置为 yes\nSULOGIN=no\n# 如果希望在系统启动完成之前（即 inetd 启动后）能够通过 telnet/rlogin 登录，请设置为 no\nDELAYLOGIN=no\n# 假定 BIOS 时钟设置为 UTC 时间（推荐）\nUTC=yes\n# 如果希望引导时更加安静，请将 VERBOSE 设置为 \"no\"\nVERBOSE=no\n# 如果不希望自动编辑 /etc/motd，请将 EDITMOTD 设置为 \"no\"\nEDITMOTD=no\n# 是否在引导时对根文件系统执行 fsck（文件系统检查）\nENABLE_ROOTFS_FSCK=no\n# 如果希望在启动时将 \"-y\" 添加到 fsck 命令，请将 FSCKFIX 设置为 \"yes\"\nFSCKFIX=yes\n# 将 TICKADJ 设置为适用于此特定机器的正确 tick 值\n#TICKADJ=10000\n# 在 populate-volatile.sh 中启用缓存\nVOLATILE_ENABLE_CACHE=yes\n# 指示根文件系统是否打算为只读。设置 ROOTFS_READ_ONLY 为 yes 并重新启动将使根文件系统变为只读。\n# 通常情况下，您不应更改此值。\nROOTFS_READ_ONLY=no\n\n```\n/etc/default/rcS 文件是一个配置文件，用于设置系统初始化过程中的默认参数和选项。该文件中的设置会影响系统引导和初始化的行为。在许多 Linux 发行版中，/etc/default/rcS 文件用于指定与系统启动过程有关的全局设置。\n\n## /etc/init.d/rc\n```shell\n#!/bin/sh\n#\n# rc            当运行级别变化时，此文件负责启动/停止服务。\n#\n# 优化特性：\n# 在服务在前一个运行级别中正在运行且在运行级别转换中没有被停止时，_不会_运行启动脚本\n# （大多数 Debian 服务在 rc{1,2,3,4,5} 中没有 K?? 链接）\n#\n# 作者：Miquel van Smoorenburg <miquels@cistron.nl>\n#      Bruce Perens <Bruce@Pixar.com>\n#\n# 版本：@(#)rc  2.78  1999 年 11 月 7 日  miquels@cistron.nl\n#\n\n. /etc/default/rcS\nexport VERBOSE\n\nstartup_progress() {\n    step=$(($step + $step_change))\n    if [ \"$num_steps\" != \"0\" ]; then\n        progress=$((($step * $progress_size / $num_steps) + $first_step))\n    else\n        progress=$progress_size\n    fi\n    #echo \"PROGRESS is $progress $runlevel $first_step + ($step of $num_steps) $step_change $progress_size\"\n    if type psplash-write >/dev/null 2>&1; then\n        TMPDIR=/mnt/.psplash psplash-write \"PROGRESS $progress\" || true\n    fi\n    #if [ -e /mnt/.psplash/psplash_fifo ]; then\n    #    echo \"PROGRESS $progress\" > /mnt/.psplash/psplash_fifo\n    #fi\n}\n\nstartup() {\n  # 处理冗长性\n  [ \"$VERBOSE\" = very ] && echo \"INIT: 正在运行 $@...\"\n\n  case \"$1\" in\n        *.sh)\n                # 为了提高速度，源码中的 shell 脚本。\n                (\n                        trap - INT QUIT TSTP\n                        scriptname=$1\n                        shift\n                        . $scriptname\n                )\n                ;;\n        *)\n                \"$@\"\n                ;;\n  esac\n  startup_progress\n}\n\n# 仅在此 shell 中忽略 CTRL-C，以便可以中断子进程。\ntrap \":\" INT QUIT TSTP\n\n# 设置 onlcr 以避免楼梯效应。\nstty onlcr 0>&1\n\n# 限制启动脚本的栈大小\n[ \"$STACK_SIZE\" == \"\" ] || ulimit -S -s $STACK_SIZE\n\n# 现在找出当前运行级别和上一个运行级别是什么。\n\nrunlevel=$RUNLEVEL\n# 获取第一个参数。将新运行级别设置为此参数。\n[ \"$1\" != \"\" ] && runlevel=$1\nif [ \"$runlevel\" = \"\" ]\nthen\n        echo \"用法：$0 <运行级别>\" >&2\n        exit 1\nfi\nprevious=$PREVLEVEL\n[ \"$previous\" = \"\" ] && previous=N\n\nexport runlevel previous\n\n# 是否有适用于这个新运行级别的 rc 目录？\nif [ -d /etc/rc$runlevel.d ]\nthen\n        # 找出 initramfs 在进度条中的位置。\n        PROGRESS_STATE=0\n        #if [ -f /dev/.initramfs/progress_state ]; then\n        #    . /dev/.initramfs/progress_state\n        #fi\n\n        # 将进度条的剩余部分分为三份\n        progress_size=$(((100 - $PROGRESS_STATE) / 3))\n\n        case \"$runlevel\" in\n                0|6)\n                        # 从 -100 倒计时到 0，使用整个进度条\n                        first_step=-100\n                        progress_size=100\n                        step_change=1\n                        ;;\n                S)\n                        # 从 initramfs 剩余的位置开始，使用剩余空间的 2/3\n                        first_step=$PROGRESS_STATE\n                        progress_size=$(($progress_size * 2))\n                        step_change=1\n                        ;;\n                *)\n                        # 从 rcS 停止的位置开始，使用最后 1/3 的空间（通过保持 progress_size 不变）\n                        first_step=$(($progress_size * 2 + $PROGRESS_STATE))\n                        step_change=1\n                        ;;\n        esac\n\n        num_steps=0\n        for s in /etc/rc$runlevel.d/[SK]*; do\n            case \"${s##/etc/rc$runlevel.d/S??}\" in\n                gdm|xdm|kdm|reboot|halt)\n                    break\n                    ;;\n            esac\n            num_steps=$(($num_steps + 1))\n        done\n        step=0\n\n        # 首先，运行 KILL 脚本。\n        if [ $previous != N ]\n        then\n                for i in /etc/rc$runlevel.d/K[0-9][0-9]*\n                do\n                        # 检查脚本是否存在。\n                        [ ! -f $i ] && continue\n\n                        # 停止服务。\n                        startup $i stop\n                done\n        fi\n\n        # 现在运行此运行级别的 START 脚本。\n        for i in /etc/rc$runlevel.d/S*\n        do\n                [ ! -f $i ] && continue\n\n                if [ $previous != N ] && [ $previous != S ]\n                then\n                        #\n                        # 在前一个运行级别中找到启动脚本和\n                        # 在这个运行级别中找到停止脚本。\n                        #\n                        suffix=${i#/etc/rc$runlevel.d/S[0-9][0-9]}\n                        stop=/etc/rc$runlevel.d/K[0-9][0-9]$suffix\n                        previous_start=/etc/rc$previous.d/S[0-9][0-9]$suffix\n                        #\n                        # 如果在上一个级别中有启动脚本\n                        # 并且在这个级别中没有停止脚本，我们就不需要重新启动服务。\n                        #\n                        [ -f $previous_start ] && [ ! -f $stop ] && continue\n                fi\n                case \"$runlevel\" in\n                        0|6)\n                                startup $i stop\n                                ;;\n                        *)\n                                startup $i start\n                                ;;\n                esac\n        done\n  fi\n\n# 取消注释以在手动退出 psplash，否则在看到 VC 切换时会退出\nif [ \"x$runlevel\" != \"xS\" ] && [ ! -x /etc/rc${runlevel}.d/S??xserver-nodm ]; then\n    if type psplash-write >/dev/null 2>&1; then\n        TMPDIR=/mnt/.psplash psplash-write \"QUIT\" || true\n        umount -l /mnt/.psplash\n    fi\nfi\n\n```\n由/etc/init.d/rc在执行等级切换的时候在/etc/rc$runlevel.d文件夹中启动相关程序，例如切换到runevel 5\n```c\nroot@ATK-IMX6U:/etc/rc5.d# ls -l\ntotal 0\nlrwxrwxrwx 1 root root 20 Jun 10 18:21 S01networking -> ../init.d/networking\nlrwxrwxrwx 1 root root 22 Jun 10 18:21 S01xserver-nodm -> ../init.d/xserver-nodm\nlrwxrwxrwx 1 root root 16 Jun 10 18:21 S02dbus-1 -> ../init.d/dbus-1\nlrwxrwxrwx 1 root root 17 Jun 10 18:21 S05connman -> ../init.d/connman\nlrwxrwxrwx 1 root root 18 Jun 10 18:21 S10dropbear -> ../init.d/dropbear\nlrwxrwxrwx 1 root root 17 Jun 10 18:21 S12rpcbind -> ../init.d/rpcbind\nlrwxrwxrwx 1 root root 21 Jun 10 18:21 S15mountnfs.sh -> ../init.d/mountnfs.sh\nlrwxrwxrwx 1 root root 21 Jun 10 18:21 S15watchdog.sh -> ../init.d/watchdog.sh\nlrwxrwxrwx 1 root root 19 Jun 10 18:21 S19nfscommon -> ../init.d/nfscommon\nlrwxrwxrwx 1 root root 14 Jun 10 18:21 S20apmd -> ../init.d/apmd\nlrwxrwxrwx 1 root root 13 Jun 10 18:21 S20atd -> ../init.d/atd\nlrwxrwxrwx 1 root root 17 Jun 10 18:21 S20hostapd -> ../init.d/hostapd\nlrwxrwxrwx 1 root root 20 Jun 10 18:21 S20hwclock.sh -> ../init.d/hwclock.sh\nlrwxrwxrwx 1 root root 19 Jun 10 18:21 S20nfsserver -> ../init.d/nfsserver\nlrwxrwxrwx 1 root root 16 Jun 10 18:21 S20syslog -> ../init.d/syslog\nlrwxrwxrwx 1 root root 22 Jun 10 18:21 S21avahi-daemon -> ../init.d/avahi-daemon\nlrwxrwxrwx 1 root root 15 Jun 10 18:21 S22ofono -> ../init.d/ofono\nlrwxrwxrwx 1 root root 15 Jun 10 18:21 S64neard -> ../init.d/neard\nlrwxrwxrwx 1 root root 16 Jun 10 18:21 S80vsftpd -> ../init.d/vsftpd\nlrwxrwxrwx 1 root root 15 Jun 10 18:21 S90crond -> ../init.d/crond\nlrwxrwxrwx 1 root root 15 Jun 10 18:21 S92nginx -> ../init.d/nginx\nlrwxrwxrwx 1 root root 18 Jun 10 18:21 S99rc.local -> ../init.d/rc.local\nlrwxrwxrwx 1 root root 22 Jun 10 18:21 S99rmnologin.sh -> ../init.d/rmnologin.sh\nlrwxrwxrwx 1 root root 23 Jun 10 18:21 S99stop-bootlogd -> ../init.d/stop-bootlogd\nroot@ATK-IMX6U:/etc/rc5.d# # diff  rc3.d/ rc5.d/\nOnly in rc3.d/: K01xserver-nodm\nOnly in rc5.d/: S01xserver-nodm\ndiff: rc3.d/S20hostapd: No such file or directory\ndiff: rc5.d/S20hostapd: No such file or directory\n\n```\n`/etc/init.d/rc` 文件是一个启动脚本，用于在系统的不同运行级别（runlevel）之间切换时启动或停止服务。在许多 Linux 系统中，运行级别是系统运行状态的一个标识，不同的运行级别对应于不同的系统配置和功能。\n\n在传统的 SysV init 系统中，`/etc/init.d/rc` 脚本是一个管理系统运行级别的关键脚本。它接受一个参数，即目标运行级别，然后根据当前运行级别和目标运行级别执行必要的操作以启动或停止服务。这通常涉及启动或停止各种服务脚本（以脚本符号 S 或 K 开头的脚本），以实现系统的初始化或关机。\n\n具体而言，`/etc/init.d/rc` 脚本的主要功能包括：\n\n1. **判断运行级别：** 根据脚本参数和当前运行级别，确定要切换到的目标运行级别。\n\n2. **执行运行级别切换操作：** 根据目标运行级别，执行一系列操作以启动或停止与该运行级别相关的服务。\n\n3. **启动服务：** 如果切换到一个新的运行级别，`rc` 脚本会依次启动以 `S` 开头的服务脚本。这些服务脚本负责启动系统所需的各种服务，如网络、文件系统挂载、系统日志等。\n\n4. **停止服务：** 如果切换到一个较低的运行级别，`rc` 脚本会依次停止以 `K` 开头的服务脚本。这些服务脚本负责停止系统中正在运行的服务。\n\n5. **设置环境：** `rc` 脚本可能会设置环境变量或其他参数，以便在运行服务脚本时传递所需的信息。\n\n需要注意的是，随着现代 Linux 发行版的发展，许多系统已经转向使用 `systemd` 或其他更现代的初始化系统，而不再使用传统的 SysV init 系统。因此，`/etc/init.d/rc` 在一些新的发行版中可能已经不再起到关键的作用，而是由更现代的初始化系统负责管理运行级别和服务启动。\n\n如果你使用的是基于 SysV init 的系统，并且遇到了与 `/etc/init.d/rc` 相关的问题，你可能需要深入了解你的系统文档和初始化流程，以理解脚本是如何工作的以及如何进行定制。","source":"_posts/2023/08/process-init.md","raw":"---\ntitle: process-init\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-08-24 14:37:55\npassword:\nsummary:\ntags:\n- linux\n- process\ncategories:\n- process\n- linux\nkeywords:\ndescription:\n---\n\n# init进程\n在Linux系统中，`init` 是第一个被启动的进程，其进程ID为1。它是系统启动过程中的第一个用户级进程，负责初始化系统，并在系统运行时作为所有其他进程的祖先。然而，需要注意的是，在现代Linux系统中，`init` 进程通常被替代为更先进的初始化系统，比如 `systemd` 或 `Upstart`。\n\n原始的 `init` 进程主要负责以下几个任务：\n\n1. **系统初始化**: `init` 进程在系统启动时负责加载操作系统所需的核心模块和设备驱动程序，以确保系统的基本功能正常运行。\n\n2. **启动和管理系统服务**: `init` 进程通过运行启动脚本来启动系统中的各种服务和守护进程。这些服务可能包括网络服务、文件系统服务、打印服务等。\n\n3. **运行级别管理**: `init` 进程支持不同的运行级别，每个级别定义了不同的系统状态。例如，运行级别可能是单用户模式、多用户模式、图形用户界面模式等。`init` 进程负责根据需要切换不同的运行级别。\n\n然而，随着时间的推移，传统的 `init` 进程的功能显得有些有限，因此引入了更现代的初始化系统，如 `systemd`。`systemd` 在许多Linux发行版中取代了传统的 `init`，它提供了更强大的系统初始化和管理功能，可以更有效地处理并行启动、服务依赖、日志管理等。\n\n尽管如此，`init` 进程作为系统的第一个进程仍然具有重要的历史地位，并且在某些方面仍然发挥着作用，尤其是在一些较旧的或嵌入式系统中。\n\n# init源码\ninit/main.c：start_kernel()--->rest_init()\n```c\nstatic noinline void __init_refok rest_init(void)\n{\n    int pid;\n\n    // 启动RCU（Read-Copy-Update）调度器\n    rcu_scheduler_starting();\n\n    // 初始化SMP（Symmetric Multiprocessing）启动线程\n    smpboot_thread_init();\n\n    /*\n     * 我们需要首先生成 init 进程，以便它获得 pid 1，但是 init 任务最终会想要创建 kthread，\n     * 如果我们在创建 kthreadd 之前调度它，将会导致 OOPS（操作系统崩溃）。\n     */\n    kernel_thread(kernel_init, NULL, CLONE_FS);\n\n    // 设置 NUMA（Non-Uniform Memory Access）默认策略\n    numa_default_policy();\n\n    // 创建 kthreadd 进程，用于创建其他内核线程\n    pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES);\n\n    // 读取锁定 RCU，以查找 kthreadd 进程的任务结构体\n    rcu_read_lock();\n    kthreadd_task = find_task_by_pid_ns(pid, &init_pid_ns);\n    rcu_read_unlock();\n\n    // 标记 kthreadd 进程已完成初始化\n    complete(&kthreadd_done);\n\n    /*\n     * 引导空闲线程必须执行 schedule() 至少一次以启动系统：\n     */\n    init_idle_bootup_task(current);\n    schedule_preempt_disabled();\n    \n    /* 带有抢占禁用的情况下调用 cpu_idle */\n    cpu_startup_entry(CPUHP_ONLINE);\n}\n```\n这段代码主要完成以下任务：\n\n1.启动 RCU 调度器，这是一种内核中用于实现无锁并发访问的机制。\n2.初始化 SMP 启动线程，用于初始化多处理器系统。\n3.创建 init 进程，确保它获得 PID 1，但避免在创建 kthreadd 进程之前调度 init 进程。\n4.设置 NUMA 默认策略，处理非一致性内存访问。\n5.创建 kthreadd 进程，该进程用于在内核中创建其他线程。\n6.根据 PID 查找并初始化 kthreadd 进程的任务结构体。\n7.标记 kthreadd 进程初始化完成。\n8.启动引导空闲线程，执行初始的调度以启动系统。\n9.最后，调用 cpu_startup_entry，在线程上下文中启动 CPU，允许它执行调度。\n\n```c\n    static int __ref kernel_init(void *unused)\n    {\n        int ret;\n\n        // 运行 kernel_init_freeable 函数，执行一些必要的内核初始化\n        kernel_init_freeable();\n\n        // 在释放内存之前，需要完成所有异步 __init 代码\n        async_synchronize_full();\n\n        // 释放初始内存\n        free_initmem();\n\n        // 将只读数据段标记为只读\n        mark_rodata_ro();\n\n        // 设置系统状态为 SYSTEM_RUNNING，表示系统已运行\n        system_state = SYSTEM_RUNNING;\n\n        // 设置 NUMA 默认策略\n        numa_default_policy();\n\n        // 清理延迟的文件指针释放\n        flush_delayed_fput();\n\n        // 如果设置了 ramdisk_execute_command，则尝试运行对应的命令\n        if (ramdisk_execute_command) {\n            ret = run_init_process(ramdisk_execute_command);\n            if (!ret)\n                return 0;\n            pr_err(\"Failed to execute %s (error %d)\\n\",\n                ramdisk_execute_command, ret);\n        }\n\n        /*\n        * 我们尝试执行以下每个命令，直到成功为止。\n        *\n        * 如果我们尝试恢复一个非常破损的机器，可以使用 Bourne shell 代替 init。\n        */\n        if (execute_command) {\n            ret = run_init_process(execute_command);\n            if (!ret)\n                return 0;\n            panic(\"Requested init %s failed (error %d).\",\n                execute_command, ret);\n        }\n        if (!try_to_run_init_process(\"/sbin/init\") ||\n            !try_to_run_init_process(\"/etc/init\") ||\n            !try_to_run_init_process(\"/bin/init\") ||\n            !try_to_run_init_process(\"/bin/sh\"))\n            return 0;\n\n        // 如果没有找到可用的 init 进程，触发内核崩溃\n        panic(\"No working init found.  Try passing init= option to kernel. \"\n            \"See Linux Documentation/init.txt for guidance.\");\n    }\n```\n这段代码的主要功能是在系统引导期间执行一系列初始化操作，然后尝试启动系统的初始化进程（如 init）。它的核心步骤包括：\n\n运行 kernel_init_freeable 函数，执行一些必要的内核初始化,这个函数很重要后面分析。\n\n在释放内存之前，使用 async_synchronize_full 等待所有异步初始化代码的完成。\n\n释放初始内存，这是在引导过程中使用的一部分内存。\n\n将只读数据段标记为只读，以提高系统的安全性。\n\n设置系统状态为 SYSTEM_RUNNING，表示系统已经正常运行。\n\n设置 NUMA 默认策略，用于处理非一致性内存访问。\n\n清理延迟的文件指针释放，确保文件资源得到正确管理。\n\n尝试执行预设的 ramdisk_execute_command 命令（如果设置了）。\n\n尝试执行预设的 execute_command 命令（如果设置了）。\n\n如果以上尝试都失败，尝试依次执行一些默认的初始化命令路径，如 /sbin/init、/etc/init、/bin/init 和 /bin/sh。\n`/sbin/init实际是init.sysvinit。但是init.sysvinit是干嘛的不知道？？？？`\n暂时理解成init进程启动，通过/sbin/init准备系统软件的运行环境，读取/etc/inittab，获取运行级别数值 \n\n如果仍然找不到可用的初始化进程，系统进入崩溃状态，显示错误消息并建议尝试通过内核参数 init= 指定初始化进程。\n\n```c\n\nstatic noinline void __init kernel_init_freeable(void)\n{\n\t/*\n\t * Wait until kthreadd is all set-up.\n\t */\n\twait_for_completion(&kthreadd_done);\n\n\t/* Now the scheduler is fully set up and can do blocking allocations */\n\tgfp_allowed_mask = __GFP_BITS_MASK;\n\n\t/*\n\t * init can allocate pages on any node\n\t */\n\tset_mems_allowed(node_states[N_MEMORY]);\n\t/*\n\t * init can run on any cpu.\n\t */\n\tset_cpus_allowed_ptr(current, cpu_all_mask);\n\n\tcad_pid = task_pid(current);\n\n\tsmp_prepare_cpus(setup_max_cpus);\n\n\tdo_pre_smp_initcalls();\n\tlockup_detector_init();\n\n\tsmp_init();\n\tsched_init_smp();\n\n\tdo_basic_setup();   /* 设备初始化都在此函数中完成 */\n\n\t/* Open the /dev/console on the rootfs, this should never fail */\n\tif (sys_open((const char __user *) \"/dev/console\", O_RDWR, 0) < 0)\n\t\tpr_err(\"Warning: unable to open an initial console.\\n\");\n\n\t(void) sys_dup(0);\n\t(void) sys_dup(0);\n\t/*\n\t * check if there is an early userspace init.  If yes, let it do all\n\t * the work\n\t */\n\n\tif (!ramdisk_execute_command)\n\t\tramdisk_execute_command = \"/init\";\n\n\tif (sys_access((const char __user *) ramdisk_execute_command, 0) != 0) {\n\t\tramdisk_execute_command = NULL;\n\t\tprepare_namespace();\n\t}\n\n\t/*\n\t * Ok, we have completed the initial bootup, and\n\t * we're essentially up and running. Get rid of the\n\t * initmem segments and start the user-mode stuff..\n\t *\n\t * rootfs is available now, try loading the public keys\n\t * and default modules\n\t */\n\n\tintegrity_load_keys();\n\tload_default_modules();\n}\n```\n`kernel_init_freeable`函数执行的一系列操作：\n\n1. `wait_for_completion(&kthreadd_done);`：等待直到`kthreadd`进程初始化完成，确保`kthreadd`进程已经准备就绪。\n\n2. `gfp_allowed_mask = __GFP_BITS_MASK;`：设置内核的内存分配标志，允许使用所有内存分配标志位。\n\n3. `set_mems_allowed(node_states[N_MEMORY]);`：设置进程可以在所有NUMA节点上分配内存。\n\n4. `set_cpus_allowed_ptr(current, cpu_all_mask);`：设置当前进程可以在所有CPU上运行。\n\n5. `cad_pid = task_pid(current);`：设置`cad_pid`（Ctrl+Alt+Del进程）为当前进程的PID。\n\n6. `smp_prepare_cpus(setup_max_cpus);`：准备启动SMP（对称多处理）系统，设置CPU的最大数量。\n\n7. `do_pre_smp_initcalls();`：运行预初始化的SMP调用。\n\n8. `lockup_detector_init();`：初始化系统的死锁检测器。\n\n9. `smp_init();`：初始化SMP子系统。\n\n10. `sched_init_smp();`：初始化调度器的SMP相关部分。\n\n11. `do_basic_setup();`：do_basic_setup 函数用于完成 Linux 下设备驱动初始化工作！非常重要。do_basic_setup 会调用 driver_init 函数完成 Linux 下驱动模型子系统的初始化。\n\n12. `sys_open((const char __user *) \"/dev/console\", O_RDWR, 0)`：尝试打开`/dev/console`设备，用于系统控制台输出。\n\n13. `sys_dup(0)`：通过复制文件描述符0（标准输入）来创建文件描述符1和2（标准输出和标准错误），确保它们都指向同一个设备。\n\n14. `if (!ramdisk_execute_command) ramdisk_execute_command = \"/init\";`：如果没有定义`ramdisk_execute_command`，则设置默认的启动命令为`/init`。\n\n15. `if (sys_access((const char __user *) ramdisk_execute_command, 0) != 0)`：检查指定的启动命令是否存在。\n\n16. `prepare_namespace();`：准备初始化的根文件系统命名空间。\n\n17. `integrity_load_keys();`：加载完整性校验的公钥，用于验证文件系统上的数据完整性。\n\n18. `load_default_modules();`：加载默认的内核模块，增加系统功能。\n\n总之，这段代码在系统引导期间完成一系列重要的初始化步骤，包括设置内存分配、CPU调度、设备初始化、根文件系统设置等。最终，它准备好系统的运行环境，使得系统能够顺利进入用户模式运行，并提供用户可见的功能。\n\n# 执行脚本\n    sbin/init--->init.sysinit\n                    |调用\n                    v\n        /etc/inittab--->/etc/init.d/rcS--->/etc/default/rcS（默认设置）\n                                       --->/etc/init.d/rc（启动默认线程）\n                                            |\n                                            V\n                                        开启/etc/rc$.d/下面的进程\n## /etc/inittab\n```c\nroot@ATK-IMX6U:/etc# cat inittab \n# /etc/inittab: init(8) configuration.\n# $Id: inittab,v 1.91 2002/01/25 13:35:21 miquels Exp $\n\n# The default runlevel.\nid:5:initdefault:\n\n# Boot-time system configuration/initialization script.\n# This is run first except when booting in emergency (-b) mode.\nsi::sysinit:/etc/init.d/rcS\n\n# What to do in single-user mode.\n~~:S:wait:/sbin/sulogin\n\n# /etc/init.d executes the S and K scripts upon change\n# of runlevel.\n#\n# Runlevel 0 is halt.\n# Runlevel 1 is single-user.\n# Runlevels 2-5 are multi-user.\n# Runlevel 6 is reboot.\ntty1::askfirst:-/bin/sh\nl0:0:wait:/etc/init.d/rc 0\nl1:1:wait:/etc/init.d/rc 1\nl2:2:wait:/etc/init.d/rc 2\nl3:3:wait:/etc/init.d/rc 3\nl4:4:wait:/etc/init.d/rc 4\nl5:5:wait:/etc/init.d/rc 5\nl6:6:wait:/etc/init.d/rc 6\n# Normally not reached, but fallthrough in case of emergency.\nz6:6:respawn:/sbin/sulogin\n#mxc0:12345:respawn:/bin/start_getty 115200 ttymxc0\nmxc0:12345:respawn:/sbin/getty -l /bin/autologin -n -L 115200 ttymxc0\n# /sbin/getty invocations for the runlevels.\n#\n# The \"id\" field MUST be the same as the last\n# characters of the device (after \"tty\").\n#\n# Format:\n#  <id>:<runlevels>:<action>:<process>\n#\n\n1:12345:respawn:/sbin/getty 38400 tty1\n\n```\n这是一个典型的 `/etc/inittab` 文件，该文件在旧版本的 Linux 系统中用于配置系统初始化过程和运行级别。该文件告诉初始化系统（通常是 SysVinit）在不同运行级别下要执行的操作。以下是`inittab` 文件的内容解释：\n\n1. `id:5:initdefault:`：这指定默认的运行级别为 5，通常对应多用户图形界面模式（X11）。\n\n2. `si::sysinit:/etc/init.d/rcS`：在系统引导过程中运行 `/etc/init.d/rcS` 脚本，这是系统初始化脚本，执行一些基本的系统配置。\n\n3. `~~:S:wait:/sbin/sulogin`：在单用户模式下，等待并运行 `/sbin/sulogin`，该命令是用于单用户模式下的登录。\n\n4. 运行级别定义及操作：\n   - `l0:0:wait:/etc/init.d/rc 0` 切换到运行级别 0（关机）时，运行 `/etc/init.d/rc 0` 脚本。\n   - `l1:1:wait:/etc/init.d/rc 1` 切换到运行级别 1（单用户模式）时，运行 `/etc/init.d/rc 1` 脚本。\n   - `l2:2:wait:/etc/init.d/rc 2` 切换到运行级别 2 时，运行 `/etc/init.d/rc 2` 脚本。\n   - `l3:3:wait:/etc/init.d/rc 3` 切换到运行级别 3 时，运行 `/etc/init.d/rc 3` 脚本。\n   - `l4:4:wait:/etc/init.d/rc 4` 切换到运行级别 4 时，运行 `/etc/init.d/rc 4` 脚本。\n   - `l5:5:wait:/etc/init.d/rc 5` 切换到运行级别 5 时，运行 `/etc/init.d/rc 5` 脚本。\n   - `l6:6:wait:/etc/init.d/rc 6` 切换到运行级别 6（重启）时，运行 `/etc/init.d/rc 6` 脚本。\n\n5. `z6:6:respawn:/sbin/sulogin`：在运行级别 6（重启）时，启动 `/sbin/sulogin`。\n\n6. `mxc0:12345:respawn:/sbin/getty -l /bin/autologin -n -L 115200 ttymxc0`：在运行级别 1、2、3、4、5 时，通过 `getty` 在串口设备 `ttymxc0` 上启动自动登录的终端会话。\n\n7. `1:12345:respawn:/sbin/getty 38400 tty1`：在运行级别 1、2、3、4、5 时，通过 `getty` 在终端 `tty1` 上启动交互式终端会话。\n\n`/etc/inittab` 文件是一个配置文件，用于定义系统初始化进程的行为和运行级别。在早期的 UNIX 和类 UNIX 系统中，`init` 进程是系统中的第一个进程，它是所有其他进程的祖先。`/etc/inittab` 文件用于指定在系统引导过程中要执行的任务、默认运行级别以及其他与系统初始化和运行级别相关的设置。\n\n主要功能包括：\n\n1. **定义运行级别（Runlevels）：** `/etc/inittab` 文件允许您指定默认的运行级别，例如单用户模式、多用户模式等。每个运行级别对应于一组要在该级别下启动或停止的服务。\n\n2. **定义启动任务：** 您可以在 `/etc/inittab` 中定义在不同运行级别下要执行的任务和脚本。这些任务可以是初始化系统配置、启动服务、创建虚拟终端等。例如，在启动时自动运行网络配置脚本。\n\n3. **设置控制台：** `/etc/inittab` 可以配置系统的虚拟终端（TTY）。您可以定义哪个虚拟终端用于登录，哪个终端用于系统控制台，以及何时启动 getty 进程等。\n\n4. **设置自动登录：** 您可以配置系统以在特定终端上自动登录用户，这在某些场景下很有用，例如嵌入式系统中的自动化测试。\n\n5. **定义执行任务：** 您可以将执行任务与特定运行级别相关联。这些任务可能是脚本、命令或程序，会在切换到相关运行级别时自动执行。\n\n需要注意的是，现代 Linux 系统中，许多发行版已经迁移到了更现代的初始化系统，如 `systemd`。因此，`/etc/inittab` 在某些发行版中可能不再被广泛使用。不过，它在一些特定的环境中仍然可以用来定义一些系统初始化和运行级别相关的配置。\n\n## /etc/init.d/rcS\n```C\n#!/bin/sh\n#\n# rcS           Call all S??* scripts in /etc/rcS.d in\n#               numerical/alphabetical order.\n#\n# Version:      @(#)/etc/init.d/rcS  2.76  19-Apr-1999  miquels@cistron.nl\n#\n\nPATH=/sbin:/bin:/usr/sbin:/usr/bin\nrunlevel=S\nprevlevel=N\numask 022\nexport PATH runlevel prevlevel\n\n#       Make sure proc is mounted\n#\n[ -d \"/proc/1\" ] || mount /proc\n\n#\n#       Source defaults.\n#\n. /etc/default/rcS\n\n#\n#       Trap CTRL-C &c only in this shell so we can interrupt subprocesses.\n#\ntrap \":\" INT QUIT TSTP\n\n#\n#       Call all parts in order.\n#\nexec /etc/init.d/rc S\n```\n这是 `/etc/init.d/rcS` 脚本的内容，用于在引导过程中执行一些初始化操作：\n\n1. `PATH=/sbin:/bin:/usr/sbin:/usr/bin`：设置执行脚本时的环境变量路径，以确保能够找到所需的命令和工具。\n\n2. `runlevel=S`：设置当前运行级别为 S（系统启动）。\n\n3. `prevlevel=N`：设置上一个运行级别为 N（不存在的运行级别）。\n\n4. `umask 022`：设置文件创建的默认权限掩码，确保创建的文件不会过于开放。\n\n5. `export PATH runlevel prevlevel`：导出 `PATH`、`runlevel` 和 `prevlevel` 变量，以便在子进程中使用。\n\n6. `[ -d \"/proc/1\" ] || mount /proc`：检查 `/proc/1` 目录是否存在，如果不存在则挂载 `/proc` 文件系统，确保系统可以访问进程信息。\n\n7. `. /etc/default/rcS`：通过 sourcing（`.`）导入 `/etc/default/rcS` 文件，用于加载一些默认配置。\n\n8. `trap \":\" INT QUIT TSTP`：设置信号处理，将 `INT`、`QUIT` 和 `TSTP` 信号的处理设为什么都不做（`:` 表示空语句），以便可以中断子进程而不中断脚本自身。\n\n9. `exec /etc/init.d/rc S`：通过 `exec` 命令执行 `/etc/init.d/rc` 脚本，并传递参数 `S`，表示在运行级别 S 下执行脚本。\n\n`/etc/init.d/rcS` 文件是一个脚本文件，用于在系统引导过程中执行一系列初始化任务。这些任务通常是与系统硬件、网络、文件系统挂载等相关的操作，以确保系统在启动时能够正常运行。\n\n在许多 Linux 发行版中，`rcS` 脚本被称为\"System Initialization Script\"，它是启动过程中第一个执行的脚本。`rcS` 脚本的主要目的是准备系统环境，使其达到可用状态，然后将控制权交给其他初始化脚本，以继续完成系统启动。\n\n`/etc/init.d/rcS` 脚本的功能可能包括：\n\n1. **挂载文件系统：** `rcS` 可能会在此阶段挂载根文件系统和其他必需的文件系统，以确保系统可以访问所需的文件和配置信息。\n\n2. **设置网络：** 在启动过程中，`rcS` 可能会配置网络接口，启动网络服务并初始化网络设置，以便系统可以与其他计算机进行通信。\n\n3. **加载模块：** 一些硬件或功能可能需要内核模块支持。`rcS` 可能会加载所需的内核模块，以确保硬件能够正常运作。\n\n4. **启动服务：** `rcS` 可能会启动一些基本的系统服务，例如系统日志记录、时间同步等。\n\n5. **设置系统参数：** `rcS` 可能会设置系统参数、环境变量和其他系统配置，以确保系统在正常运行时能够获得正确的设置。\n\n6. **清理临时文件：** 在引导过程中，系统可能会生成临时文件。`rcS` 可能会在启动后清理这些临时文件，以保持系统的整洁性。\n\n7. **执行其他初始化任务：** 根据发行版和系统配置，`rcS` 可能会执行其他必要的初始化任务，以确保系统正确启动。\n\n需要注意的是，`/etc/init.d/rcS` 在不同的 Linux 发行版中可能会有不同的实现和用途。在一些现代发行版中，可能已经过渡到使用更现代的初始化系统，如 `systemd`，而一些传统的发行版可能仍然使用 `rcS` 脚本作为系统初始化的一部分。\n\n## /etc/default/rcS\n```c\n#\n#       /etc/rcS.d 中启动脚本的默认值\n#\n\n# 在 /tmp 中保留时间文件的天数。\nTMPTIME=0\n# 如果要在引导时启动 sulogin，请设置为 yes\nSULOGIN=no\n# 如果希望在系统启动完成之前（即 inetd 启动后）能够通过 telnet/rlogin 登录，请设置为 no\nDELAYLOGIN=no\n# 假定 BIOS 时钟设置为 UTC 时间（推荐）\nUTC=yes\n# 如果希望引导时更加安静，请将 VERBOSE 设置为 \"no\"\nVERBOSE=no\n# 如果不希望自动编辑 /etc/motd，请将 EDITMOTD 设置为 \"no\"\nEDITMOTD=no\n# 是否在引导时对根文件系统执行 fsck（文件系统检查）\nENABLE_ROOTFS_FSCK=no\n# 如果希望在启动时将 \"-y\" 添加到 fsck 命令，请将 FSCKFIX 设置为 \"yes\"\nFSCKFIX=yes\n# 将 TICKADJ 设置为适用于此特定机器的正确 tick 值\n#TICKADJ=10000\n# 在 populate-volatile.sh 中启用缓存\nVOLATILE_ENABLE_CACHE=yes\n# 指示根文件系统是否打算为只读。设置 ROOTFS_READ_ONLY 为 yes 并重新启动将使根文件系统变为只读。\n# 通常情况下，您不应更改此值。\nROOTFS_READ_ONLY=no\n\n```\n/etc/default/rcS 文件是一个配置文件，用于设置系统初始化过程中的默认参数和选项。该文件中的设置会影响系统引导和初始化的行为。在许多 Linux 发行版中，/etc/default/rcS 文件用于指定与系统启动过程有关的全局设置。\n\n## /etc/init.d/rc\n```shell\n#!/bin/sh\n#\n# rc            当运行级别变化时，此文件负责启动/停止服务。\n#\n# 优化特性：\n# 在服务在前一个运行级别中正在运行且在运行级别转换中没有被停止时，_不会_运行启动脚本\n# （大多数 Debian 服务在 rc{1,2,3,4,5} 中没有 K?? 链接）\n#\n# 作者：Miquel van Smoorenburg <miquels@cistron.nl>\n#      Bruce Perens <Bruce@Pixar.com>\n#\n# 版本：@(#)rc  2.78  1999 年 11 月 7 日  miquels@cistron.nl\n#\n\n. /etc/default/rcS\nexport VERBOSE\n\nstartup_progress() {\n    step=$(($step + $step_change))\n    if [ \"$num_steps\" != \"0\" ]; then\n        progress=$((($step * $progress_size / $num_steps) + $first_step))\n    else\n        progress=$progress_size\n    fi\n    #echo \"PROGRESS is $progress $runlevel $first_step + ($step of $num_steps) $step_change $progress_size\"\n    if type psplash-write >/dev/null 2>&1; then\n        TMPDIR=/mnt/.psplash psplash-write \"PROGRESS $progress\" || true\n    fi\n    #if [ -e /mnt/.psplash/psplash_fifo ]; then\n    #    echo \"PROGRESS $progress\" > /mnt/.psplash/psplash_fifo\n    #fi\n}\n\nstartup() {\n  # 处理冗长性\n  [ \"$VERBOSE\" = very ] && echo \"INIT: 正在运行 $@...\"\n\n  case \"$1\" in\n        *.sh)\n                # 为了提高速度，源码中的 shell 脚本。\n                (\n                        trap - INT QUIT TSTP\n                        scriptname=$1\n                        shift\n                        . $scriptname\n                )\n                ;;\n        *)\n                \"$@\"\n                ;;\n  esac\n  startup_progress\n}\n\n# 仅在此 shell 中忽略 CTRL-C，以便可以中断子进程。\ntrap \":\" INT QUIT TSTP\n\n# 设置 onlcr 以避免楼梯效应。\nstty onlcr 0>&1\n\n# 限制启动脚本的栈大小\n[ \"$STACK_SIZE\" == \"\" ] || ulimit -S -s $STACK_SIZE\n\n# 现在找出当前运行级别和上一个运行级别是什么。\n\nrunlevel=$RUNLEVEL\n# 获取第一个参数。将新运行级别设置为此参数。\n[ \"$1\" != \"\" ] && runlevel=$1\nif [ \"$runlevel\" = \"\" ]\nthen\n        echo \"用法：$0 <运行级别>\" >&2\n        exit 1\nfi\nprevious=$PREVLEVEL\n[ \"$previous\" = \"\" ] && previous=N\n\nexport runlevel previous\n\n# 是否有适用于这个新运行级别的 rc 目录？\nif [ -d /etc/rc$runlevel.d ]\nthen\n        # 找出 initramfs 在进度条中的位置。\n        PROGRESS_STATE=0\n        #if [ -f /dev/.initramfs/progress_state ]; then\n        #    . /dev/.initramfs/progress_state\n        #fi\n\n        # 将进度条的剩余部分分为三份\n        progress_size=$(((100 - $PROGRESS_STATE) / 3))\n\n        case \"$runlevel\" in\n                0|6)\n                        # 从 -100 倒计时到 0，使用整个进度条\n                        first_step=-100\n                        progress_size=100\n                        step_change=1\n                        ;;\n                S)\n                        # 从 initramfs 剩余的位置开始，使用剩余空间的 2/3\n                        first_step=$PROGRESS_STATE\n                        progress_size=$(($progress_size * 2))\n                        step_change=1\n                        ;;\n                *)\n                        # 从 rcS 停止的位置开始，使用最后 1/3 的空间（通过保持 progress_size 不变）\n                        first_step=$(($progress_size * 2 + $PROGRESS_STATE))\n                        step_change=1\n                        ;;\n        esac\n\n        num_steps=0\n        for s in /etc/rc$runlevel.d/[SK]*; do\n            case \"${s##/etc/rc$runlevel.d/S??}\" in\n                gdm|xdm|kdm|reboot|halt)\n                    break\n                    ;;\n            esac\n            num_steps=$(($num_steps + 1))\n        done\n        step=0\n\n        # 首先，运行 KILL 脚本。\n        if [ $previous != N ]\n        then\n                for i in /etc/rc$runlevel.d/K[0-9][0-9]*\n                do\n                        # 检查脚本是否存在。\n                        [ ! -f $i ] && continue\n\n                        # 停止服务。\n                        startup $i stop\n                done\n        fi\n\n        # 现在运行此运行级别的 START 脚本。\n        for i in /etc/rc$runlevel.d/S*\n        do\n                [ ! -f $i ] && continue\n\n                if [ $previous != N ] && [ $previous != S ]\n                then\n                        #\n                        # 在前一个运行级别中找到启动脚本和\n                        # 在这个运行级别中找到停止脚本。\n                        #\n                        suffix=${i#/etc/rc$runlevel.d/S[0-9][0-9]}\n                        stop=/etc/rc$runlevel.d/K[0-9][0-9]$suffix\n                        previous_start=/etc/rc$previous.d/S[0-9][0-9]$suffix\n                        #\n                        # 如果在上一个级别中有启动脚本\n                        # 并且在这个级别中没有停止脚本，我们就不需要重新启动服务。\n                        #\n                        [ -f $previous_start ] && [ ! -f $stop ] && continue\n                fi\n                case \"$runlevel\" in\n                        0|6)\n                                startup $i stop\n                                ;;\n                        *)\n                                startup $i start\n                                ;;\n                esac\n        done\n  fi\n\n# 取消注释以在手动退出 psplash，否则在看到 VC 切换时会退出\nif [ \"x$runlevel\" != \"xS\" ] && [ ! -x /etc/rc${runlevel}.d/S??xserver-nodm ]; then\n    if type psplash-write >/dev/null 2>&1; then\n        TMPDIR=/mnt/.psplash psplash-write \"QUIT\" || true\n        umount -l /mnt/.psplash\n    fi\nfi\n\n```\n由/etc/init.d/rc在执行等级切换的时候在/etc/rc$runlevel.d文件夹中启动相关程序，例如切换到runevel 5\n```c\nroot@ATK-IMX6U:/etc/rc5.d# ls -l\ntotal 0\nlrwxrwxrwx 1 root root 20 Jun 10 18:21 S01networking -> ../init.d/networking\nlrwxrwxrwx 1 root root 22 Jun 10 18:21 S01xserver-nodm -> ../init.d/xserver-nodm\nlrwxrwxrwx 1 root root 16 Jun 10 18:21 S02dbus-1 -> ../init.d/dbus-1\nlrwxrwxrwx 1 root root 17 Jun 10 18:21 S05connman -> ../init.d/connman\nlrwxrwxrwx 1 root root 18 Jun 10 18:21 S10dropbear -> ../init.d/dropbear\nlrwxrwxrwx 1 root root 17 Jun 10 18:21 S12rpcbind -> ../init.d/rpcbind\nlrwxrwxrwx 1 root root 21 Jun 10 18:21 S15mountnfs.sh -> ../init.d/mountnfs.sh\nlrwxrwxrwx 1 root root 21 Jun 10 18:21 S15watchdog.sh -> ../init.d/watchdog.sh\nlrwxrwxrwx 1 root root 19 Jun 10 18:21 S19nfscommon -> ../init.d/nfscommon\nlrwxrwxrwx 1 root root 14 Jun 10 18:21 S20apmd -> ../init.d/apmd\nlrwxrwxrwx 1 root root 13 Jun 10 18:21 S20atd -> ../init.d/atd\nlrwxrwxrwx 1 root root 17 Jun 10 18:21 S20hostapd -> ../init.d/hostapd\nlrwxrwxrwx 1 root root 20 Jun 10 18:21 S20hwclock.sh -> ../init.d/hwclock.sh\nlrwxrwxrwx 1 root root 19 Jun 10 18:21 S20nfsserver -> ../init.d/nfsserver\nlrwxrwxrwx 1 root root 16 Jun 10 18:21 S20syslog -> ../init.d/syslog\nlrwxrwxrwx 1 root root 22 Jun 10 18:21 S21avahi-daemon -> ../init.d/avahi-daemon\nlrwxrwxrwx 1 root root 15 Jun 10 18:21 S22ofono -> ../init.d/ofono\nlrwxrwxrwx 1 root root 15 Jun 10 18:21 S64neard -> ../init.d/neard\nlrwxrwxrwx 1 root root 16 Jun 10 18:21 S80vsftpd -> ../init.d/vsftpd\nlrwxrwxrwx 1 root root 15 Jun 10 18:21 S90crond -> ../init.d/crond\nlrwxrwxrwx 1 root root 15 Jun 10 18:21 S92nginx -> ../init.d/nginx\nlrwxrwxrwx 1 root root 18 Jun 10 18:21 S99rc.local -> ../init.d/rc.local\nlrwxrwxrwx 1 root root 22 Jun 10 18:21 S99rmnologin.sh -> ../init.d/rmnologin.sh\nlrwxrwxrwx 1 root root 23 Jun 10 18:21 S99stop-bootlogd -> ../init.d/stop-bootlogd\nroot@ATK-IMX6U:/etc/rc5.d# # diff  rc3.d/ rc5.d/\nOnly in rc3.d/: K01xserver-nodm\nOnly in rc5.d/: S01xserver-nodm\ndiff: rc3.d/S20hostapd: No such file or directory\ndiff: rc5.d/S20hostapd: No such file or directory\n\n```\n`/etc/init.d/rc` 文件是一个启动脚本，用于在系统的不同运行级别（runlevel）之间切换时启动或停止服务。在许多 Linux 系统中，运行级别是系统运行状态的一个标识，不同的运行级别对应于不同的系统配置和功能。\n\n在传统的 SysV init 系统中，`/etc/init.d/rc` 脚本是一个管理系统运行级别的关键脚本。它接受一个参数，即目标运行级别，然后根据当前运行级别和目标运行级别执行必要的操作以启动或停止服务。这通常涉及启动或停止各种服务脚本（以脚本符号 S 或 K 开头的脚本），以实现系统的初始化或关机。\n\n具体而言，`/etc/init.d/rc` 脚本的主要功能包括：\n\n1. **判断运行级别：** 根据脚本参数和当前运行级别，确定要切换到的目标运行级别。\n\n2. **执行运行级别切换操作：** 根据目标运行级别，执行一系列操作以启动或停止与该运行级别相关的服务。\n\n3. **启动服务：** 如果切换到一个新的运行级别，`rc` 脚本会依次启动以 `S` 开头的服务脚本。这些服务脚本负责启动系统所需的各种服务，如网络、文件系统挂载、系统日志等。\n\n4. **停止服务：** 如果切换到一个较低的运行级别，`rc` 脚本会依次停止以 `K` 开头的服务脚本。这些服务脚本负责停止系统中正在运行的服务。\n\n5. **设置环境：** `rc` 脚本可能会设置环境变量或其他参数，以便在运行服务脚本时传递所需的信息。\n\n需要注意的是，随着现代 Linux 发行版的发展，许多系统已经转向使用 `systemd` 或其他更现代的初始化系统，而不再使用传统的 SysV init 系统。因此，`/etc/init.d/rc` 在一些新的发行版中可能已经不再起到关键的作用，而是由更现代的初始化系统负责管理运行级别和服务启动。\n\n如果你使用的是基于 SysV init 的系统，并且遇到了与 `/etc/init.d/rc` 相关的问题，你可能需要深入了解你的系统文档和初始化流程，以理解脚本是如何工作的以及如何进行定制。","slug":"process-init","published":1,"updated":"2024-01-05T08:12:19.806Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clru1g21t002as4fu67141sob","content":"<h1 id=\"init进程\"><a href=\"#init进程\" class=\"headerlink\" title=\"init进程\"></a>init进程</h1><p>在Linux系统中，<code>init</code> 是第一个被启动的进程，其进程ID为1。它是系统启动过程中的第一个用户级进程，负责初始化系统，并在系统运行时作为所有其他进程的祖先。然而，需要注意的是，在现代Linux系统中，<code>init</code> 进程通常被替代为更先进的初始化系统，比如 <code>systemd</code> 或 <code>Upstart</code>。</p>\n<p>原始的 <code>init</code> 进程主要负责以下几个任务：</p>\n<ol>\n<li><p><strong>系统初始化</strong>: <code>init</code> 进程在系统启动时负责加载操作系统所需的核心模块和设备驱动程序，以确保系统的基本功能正常运行。</p>\n</li>\n<li><p><strong>启动和管理系统服务</strong>: <code>init</code> 进程通过运行启动脚本来启动系统中的各种服务和守护进程。这些服务可能包括网络服务、文件系统服务、打印服务等。</p>\n</li>\n<li><p><strong>运行级别管理</strong>: <code>init</code> 进程支持不同的运行级别，每个级别定义了不同的系统状态。例如，运行级别可能是单用户模式、多用户模式、图形用户界面模式等。<code>init</code> 进程负责根据需要切换不同的运行级别。</p>\n</li>\n</ol>\n<p>然而，随着时间的推移，传统的 <code>init</code> 进程的功能显得有些有限，因此引入了更现代的初始化系统，如 <code>systemd</code>。<code>systemd</code> 在许多Linux发行版中取代了传统的 <code>init</code>，它提供了更强大的系统初始化和管理功能，可以更有效地处理并行启动、服务依赖、日志管理等。</p>\n<p>尽管如此，<code>init</code> 进程作为系统的第一个进程仍然具有重要的历史地位，并且在某些方面仍然发挥着作用，尤其是在一些较旧的或嵌入式系统中。</p>\n<h1 id=\"init源码\"><a href=\"#init源码\" class=\"headerlink\" title=\"init源码\"></a>init源码</h1><p>init/main.c：start_kernel()—&gt;rest_init()</p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">static</span> noinline <span class=\"token keyword\">void</span> __init_refok <span class=\"token function\">rest_init</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> pid<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 启动RCU（Read-Copy-Update）调度器</span>\n    <span class=\"token function\">rcu_scheduler_starting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 初始化SMP（Symmetric Multiprocessing）启动线程</span>\n    <span class=\"token function\">smpboot_thread_init</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/*\n     * 我们需要首先生成 init 进程，以便它获得 pid 1，但是 init 任务最终会想要创建 kthread，\n     * 如果我们在创建 kthreadd 之前调度它，将会导致 OOPS（操作系统崩溃）。\n     */</span>\n    <span class=\"token function\">kernel_thread</span><span class=\"token punctuation\">(</span>kernel_init<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> CLONE_FS<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 设置 NUMA（Non-Uniform Memory Access）默认策略</span>\n    <span class=\"token function\">numa_default_policy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 创建 kthreadd 进程，用于创建其他内核线程</span>\n    pid <span class=\"token operator\">=</span> <span class=\"token function\">kernel_thread</span><span class=\"token punctuation\">(</span>kthreadd<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> CLONE_FS <span class=\"token operator\">|</span> CLONE_FILES<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 读取锁定 RCU，以查找 kthreadd 进程的任务结构体</span>\n    <span class=\"token function\">rcu_read_lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    kthreadd_task <span class=\"token operator\">=</span> <span class=\"token function\">find_task_by_pid_ns</span><span class=\"token punctuation\">(</span>pid<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>init_pid_ns<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">rcu_read_unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 标记 kthreadd 进程已完成初始化</span>\n    <span class=\"token function\">complete</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>kthreadd_done<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/*\n     * 引导空闲线程必须执行 schedule() 至少一次以启动系统：\n     */</span>\n    <span class=\"token function\">init_idle_bootup_task</span><span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">schedule_preempt_disabled</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/* 带有抢占禁用的情况下调用 cpu_idle */</span>\n    <span class=\"token function\">cpu_startup_entry</span><span class=\"token punctuation\">(</span>CPUHP_ONLINE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>这段代码主要完成以下任务：</p>\n<p>1.启动 RCU 调度器，这是一种内核中用于实现无锁并发访问的机制。<br>2.初始化 SMP 启动线程，用于初始化多处理器系统。<br>3.创建 init 进程，确保它获得 PID 1，但避免在创建 kthreadd 进程之前调度 init 进程。<br>4.设置 NUMA 默认策略，处理非一致性内存访问。<br>5.创建 kthreadd 进程，该进程用于在内核中创建其他线程。<br>6.根据 PID 查找并初始化 kthreadd 进程的任务结构体。<br>7.标记 kthreadd 进程初始化完成。<br>8.启动引导空闲线程，执行初始的调度以启动系统。<br>9.最后，调用 cpu_startup_entry，在线程上下文中启动 CPU，允许它执行调度。</p>\n<pre class=\" language-c\"><code class=\"language-c\">    <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> __ref <span class=\"token function\">kernel_init</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>unused<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> ret<span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 运行 kernel_init_freeable 函数，执行一些必要的内核初始化</span>\n        <span class=\"token function\">kernel_init_freeable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 在释放内存之前，需要完成所有异步 __init 代码</span>\n        <span class=\"token function\">async_synchronize_full</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 释放初始内存</span>\n        <span class=\"token function\">free_initmem</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 将只读数据段标记为只读</span>\n        <span class=\"token function\">mark_rodata_ro</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 设置系统状态为 SYSTEM_RUNNING，表示系统已运行</span>\n        system_state <span class=\"token operator\">=</span> SYSTEM_RUNNING<span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 设置 NUMA 默认策略</span>\n        <span class=\"token function\">numa_default_policy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 清理延迟的文件指针释放</span>\n        <span class=\"token function\">flush_delayed_fput</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 如果设置了 ramdisk_execute_command，则尝试运行对应的命令</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ramdisk_execute_command<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            ret <span class=\"token operator\">=</span> <span class=\"token function\">run_init_process</span><span class=\"token punctuation\">(</span>ramdisk_execute_command<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>ret<span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">pr_err</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Failed to execute %s (error %d)\\n\"</span><span class=\"token punctuation\">,</span>\n                ramdisk_execute_command<span class=\"token punctuation\">,</span> ret<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">/*\n        * 我们尝试执行以下每个命令，直到成功为止。\n        *\n        * 如果我们尝试恢复一个非常破损的机器，可以使用 Bourne shell 代替 init。\n        */</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>execute_command<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            ret <span class=\"token operator\">=</span> <span class=\"token function\">run_init_process</span><span class=\"token punctuation\">(</span>execute_command<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>ret<span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">panic</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Requested init %s failed (error %d).\"</span><span class=\"token punctuation\">,</span>\n                execute_command<span class=\"token punctuation\">,</span> ret<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">try_to_run_init_process</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/sbin/init\"</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span>\n            <span class=\"token operator\">!</span><span class=\"token function\">try_to_run_init_process</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/etc/init\"</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span>\n            <span class=\"token operator\">!</span><span class=\"token function\">try_to_run_init_process</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/bin/init\"</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span>\n            <span class=\"token operator\">!</span><span class=\"token function\">try_to_run_init_process</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/bin/sh\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 如果没有找到可用的 init 进程，触发内核崩溃</span>\n        <span class=\"token function\">panic</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"No working init found.  Try passing init= option to kernel. \"</span>\n            <span class=\"token string\">\"See Linux Documentation/init.txt for guidance.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<p>这段代码的主要功能是在系统引导期间执行一系列初始化操作，然后尝试启动系统的初始化进程（如 init）。它的核心步骤包括：</p>\n<p>运行 kernel_init_freeable 函数，执行一些必要的内核初始化,这个函数很重要后面分析。</p>\n<p>在释放内存之前，使用 async_synchronize_full 等待所有异步初始化代码的完成。</p>\n<p>释放初始内存，这是在引导过程中使用的一部分内存。</p>\n<p>将只读数据段标记为只读，以提高系统的安全性。</p>\n<p>设置系统状态为 SYSTEM_RUNNING，表示系统已经正常运行。</p>\n<p>设置 NUMA 默认策略，用于处理非一致性内存访问。</p>\n<p>清理延迟的文件指针释放，确保文件资源得到正确管理。</p>\n<p>尝试执行预设的 ramdisk_execute_command 命令（如果设置了）。</p>\n<p>尝试执行预设的 execute_command 命令（如果设置了）。</p>\n<p>如果以上尝试都失败，尝试依次执行一些默认的初始化命令路径，如 /sbin/init、/etc/init、/bin/init 和 /bin/sh。<br><code>/sbin/init实际是init.sysvinit。但是init.sysvinit是干嘛的不知道？？？？</code><br>暂时理解成init进程启动，通过/sbin/init准备系统软件的运行环境，读取/etc/inittab，获取运行级别数值 </p>\n<p>如果仍然找不到可用的初始化进程，系统进入崩溃状态，显示错误消息并建议尝试通过内核参数 init= 指定初始化进程。</p>\n<pre class=\" language-c\"><code class=\"language-c\">\n<span class=\"token keyword\">static</span> noinline <span class=\"token keyword\">void</span> __init <span class=\"token function\">kernel_init_freeable</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">/*\n     * Wait until kthreadd is all set-up.\n     */</span>\n    <span class=\"token function\">wait_for_completion</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>kthreadd_done<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/* Now the scheduler is fully set up and can do blocking allocations */</span>\n    gfp_allowed_mask <span class=\"token operator\">=</span> __GFP_BITS_MASK<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/*\n     * init can allocate pages on any node\n     */</span>\n    <span class=\"token function\">set_mems_allowed</span><span class=\"token punctuation\">(</span>node_states<span class=\"token punctuation\">[</span>N_MEMORY<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">/*\n     * init can run on any cpu.\n     */</span>\n    <span class=\"token function\">set_cpus_allowed_ptr</span><span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">,</span> cpu_all_mask<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    cad_pid <span class=\"token operator\">=</span> <span class=\"token function\">task_pid</span><span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">smp_prepare_cpus</span><span class=\"token punctuation\">(</span>setup_max_cpus<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">do_pre_smp_initcalls</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">lockup_detector_init</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">smp_init</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">sched_init_smp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">do_basic_setup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\" spellcheck=\"true\">/* 设备初始化都在此函数中完成 */</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/* Open the /dev/console on the rootfs, this should never fail */</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">sys_open</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> __user <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"/dev/console\"</span><span class=\"token punctuation\">,</span> O_RDWR<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">pr_err</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Warning: unable to open an initial console.\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span> <span class=\"token function\">sys_dup</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span> <span class=\"token function\">sys_dup</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">/*\n     * check if there is an early userspace init.  If yes, let it do all\n     * the work\n     */</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>ramdisk_execute_command<span class=\"token punctuation\">)</span>\n        ramdisk_execute_command <span class=\"token operator\">=</span> <span class=\"token string\">\"/init\"</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">sys_access</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> __user <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> ramdisk_execute_command<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        ramdisk_execute_command <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">prepare_namespace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/*\n     * Ok, we have completed the initial bootup, and\n     * we're essentially up and running. Get rid of the\n     * initmem segments and start the user-mode stuff..\n     *\n     * rootfs is available now, try loading the public keys\n     * and default modules\n     */</span>\n\n    <span class=\"token function\">integrity_load_keys</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">load_default_modules</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><code>kernel_init_freeable</code>函数执行的一系列操作：</p>\n<ol>\n<li><p><code>wait_for_completion(&amp;kthreadd_done);</code>：等待直到<code>kthreadd</code>进程初始化完成，确保<code>kthreadd</code>进程已经准备就绪。</p>\n</li>\n<li><p><code>gfp_allowed_mask = __GFP_BITS_MASK;</code>：设置内核的内存分配标志，允许使用所有内存分配标志位。</p>\n</li>\n<li><p><code>set_mems_allowed(node_states[N_MEMORY]);</code>：设置进程可以在所有NUMA节点上分配内存。</p>\n</li>\n<li><p><code>set_cpus_allowed_ptr(current, cpu_all_mask);</code>：设置当前进程可以在所有CPU上运行。</p>\n</li>\n<li><p><code>cad_pid = task_pid(current);</code>：设置<code>cad_pid</code>（Ctrl+Alt+Del进程）为当前进程的PID。</p>\n</li>\n<li><p><code>smp_prepare_cpus(setup_max_cpus);</code>：准备启动SMP（对称多处理）系统，设置CPU的最大数量。</p>\n</li>\n<li><p><code>do_pre_smp_initcalls();</code>：运行预初始化的SMP调用。</p>\n</li>\n<li><p><code>lockup_detector_init();</code>：初始化系统的死锁检测器。</p>\n</li>\n<li><p><code>smp_init();</code>：初始化SMP子系统。</p>\n</li>\n<li><p><code>sched_init_smp();</code>：初始化调度器的SMP相关部分。</p>\n</li>\n<li><p><code>do_basic_setup();</code>：do_basic_setup 函数用于完成 Linux 下设备驱动初始化工作！非常重要。do_basic_setup 会调用 driver_init 函数完成 Linux 下驱动模型子系统的初始化。</p>\n</li>\n<li><p><code>sys_open((const char __user *) &quot;/dev/console&quot;, O_RDWR, 0)</code>：尝试打开<code>/dev/console</code>设备，用于系统控制台输出。</p>\n</li>\n<li><p><code>sys_dup(0)</code>：通过复制文件描述符0（标准输入）来创建文件描述符1和2（标准输出和标准错误），确保它们都指向同一个设备。</p>\n</li>\n<li><p><code>if (!ramdisk_execute_command) ramdisk_execute_command = &quot;/init&quot;;</code>：如果没有定义<code>ramdisk_execute_command</code>，则设置默认的启动命令为<code>/init</code>。</p>\n</li>\n<li><p><code>if (sys_access((const char __user *) ramdisk_execute_command, 0) != 0)</code>：检查指定的启动命令是否存在。</p>\n</li>\n<li><p><code>prepare_namespace();</code>：准备初始化的根文件系统命名空间。</p>\n</li>\n<li><p><code>integrity_load_keys();</code>：加载完整性校验的公钥，用于验证文件系统上的数据完整性。</p>\n</li>\n<li><p><code>load_default_modules();</code>：加载默认的内核模块，增加系统功能。</p>\n</li>\n</ol>\n<p>总之，这段代码在系统引导期间完成一系列重要的初始化步骤，包括设置内存分配、CPU调度、设备初始化、根文件系统设置等。最终，它准备好系统的运行环境，使得系统能够顺利进入用户模式运行，并提供用户可见的功能。</p>\n<h1 id=\"执行脚本\"><a href=\"#执行脚本\" class=\"headerlink\" title=\"执行脚本\"></a>执行脚本</h1><pre><code>sbin/init---&gt;init.sysinit\n                |调用\n                v\n    /etc/inittab---&gt;/etc/init.d/rcS---&gt;/etc/default/rcS（默认设置）\n                                   ---&gt;/etc/init.d/rc（启动默认线程）\n                                        |\n                                        V\n                                    开启/etc/rc$.d/下面的进程</code></pre><h2 id=\"etc-inittab\"><a href=\"#etc-inittab\" class=\"headerlink\" title=\"/etc/inittab\"></a>/etc/inittab</h2><pre class=\" language-c\"><code class=\"language-c\">root@ATK<span class=\"token operator\">-</span>IMX6U<span class=\"token punctuation\">:</span><span class=\"token operator\">/</span>etc# cat inittab \n# <span class=\"token operator\">/</span>etc<span class=\"token operator\">/</span>inittab<span class=\"token punctuation\">:</span> <span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token number\">8</span><span class=\"token punctuation\">)</span> configuration<span class=\"token punctuation\">.</span>\n# $Id<span class=\"token punctuation\">:</span> inittab<span class=\"token punctuation\">,</span>v <span class=\"token number\">1.91</span> <span class=\"token number\">2002</span><span class=\"token operator\">/</span><span class=\"token number\">01</span><span class=\"token operator\">/</span><span class=\"token number\">25</span> <span class=\"token number\">13</span><span class=\"token punctuation\">:</span><span class=\"token number\">35</span><span class=\"token punctuation\">:</span><span class=\"token number\">21</span> miquels Exp $\n\n<span class=\"token macro property\"># The default runlevel.</span>\nid<span class=\"token punctuation\">:</span><span class=\"token number\">5</span><span class=\"token punctuation\">:</span>initdefault<span class=\"token punctuation\">:</span>\n\n<span class=\"token macro property\"># Boot-time system configuration/initialization script.</span>\n<span class=\"token macro property\"># This is run first except when booting in emergency (-b) mode.</span>\nsi<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>sysinit<span class=\"token punctuation\">:</span><span class=\"token operator\">/</span>etc<span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>rcS\n\n<span class=\"token macro property\"># What to do in single-user mode.</span>\n<span class=\"token operator\">~</span><span class=\"token operator\">~</span><span class=\"token punctuation\">:</span>S<span class=\"token punctuation\">:</span>wait<span class=\"token punctuation\">:</span><span class=\"token operator\">/</span>sbin<span class=\"token operator\">/</span>sulogin\n\n# <span class=\"token operator\">/</span>etc<span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d executes the S and K scripts upon change\n<span class=\"token macro property\"># of runlevel.</span>\n#\n<span class=\"token macro property\"># Runlevel 0 is halt.</span>\n<span class=\"token macro property\"># Runlevel 1 is single-user.</span>\n<span class=\"token macro property\"># Runlevels 2-5 are multi-user.</span>\n<span class=\"token macro property\"># Runlevel 6 is reboot.</span>\ntty1<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>askfirst<span class=\"token punctuation\">:</span><span class=\"token operator\">-</span><span class=\"token operator\">/</span>bin<span class=\"token operator\">/</span>sh\nl0<span class=\"token punctuation\">:</span><span class=\"token number\">0</span><span class=\"token punctuation\">:</span>wait<span class=\"token punctuation\">:</span><span class=\"token operator\">/</span>etc<span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>rc <span class=\"token number\">0</span>\nl1<span class=\"token punctuation\">:</span><span class=\"token number\">1</span><span class=\"token punctuation\">:</span>wait<span class=\"token punctuation\">:</span><span class=\"token operator\">/</span>etc<span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>rc <span class=\"token number\">1</span>\nl2<span class=\"token punctuation\">:</span><span class=\"token number\">2</span><span class=\"token punctuation\">:</span>wait<span class=\"token punctuation\">:</span><span class=\"token operator\">/</span>etc<span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>rc <span class=\"token number\">2</span>\nl3<span class=\"token punctuation\">:</span><span class=\"token number\">3</span><span class=\"token punctuation\">:</span>wait<span class=\"token punctuation\">:</span><span class=\"token operator\">/</span>etc<span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>rc <span class=\"token number\">3</span>\nl4<span class=\"token punctuation\">:</span><span class=\"token number\">4</span><span class=\"token punctuation\">:</span>wait<span class=\"token punctuation\">:</span><span class=\"token operator\">/</span>etc<span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>rc <span class=\"token number\">4</span>\nl5<span class=\"token punctuation\">:</span><span class=\"token number\">5</span><span class=\"token punctuation\">:</span>wait<span class=\"token punctuation\">:</span><span class=\"token operator\">/</span>etc<span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>rc <span class=\"token number\">5</span>\nl6<span class=\"token punctuation\">:</span><span class=\"token number\">6</span><span class=\"token punctuation\">:</span>wait<span class=\"token punctuation\">:</span><span class=\"token operator\">/</span>etc<span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>rc <span class=\"token number\">6</span>\n<span class=\"token macro property\"># Normally not reached, but fallthrough in case of emergency.</span>\nz6<span class=\"token punctuation\">:</span><span class=\"token number\">6</span><span class=\"token punctuation\">:</span>respawn<span class=\"token punctuation\">:</span><span class=\"token operator\">/</span>sbin<span class=\"token operator\">/</span>sulogin\n<span class=\"token macro property\">#mxc0:12345:respawn:/bin/start_getty 115200 ttymxc0</span>\nmxc0<span class=\"token punctuation\">:</span><span class=\"token number\">12345</span><span class=\"token punctuation\">:</span>respawn<span class=\"token punctuation\">:</span><span class=\"token operator\">/</span>sbin<span class=\"token operator\">/</span>getty <span class=\"token operator\">-</span>l <span class=\"token operator\">/</span>bin<span class=\"token operator\">/</span>autologin <span class=\"token operator\">-</span>n <span class=\"token operator\">-</span>L <span class=\"token number\">115200</span> ttymxc0\n# <span class=\"token operator\">/</span>sbin<span class=\"token operator\">/</span>getty invocations <span class=\"token keyword\">for</span> the runlevels<span class=\"token punctuation\">.</span>\n#\n<span class=\"token macro property\"># The \"id\" field MUST be the same as the last</span>\n<span class=\"token macro property\"># characters of the device (after \"tty\").</span>\n#\n<span class=\"token macro property\"># Format:</span>\n#  <span class=\"token operator\">&lt;</span>id<span class=\"token operator\">></span><span class=\"token punctuation\">:</span><span class=\"token operator\">&lt;</span>runlevels<span class=\"token operator\">></span><span class=\"token punctuation\">:</span><span class=\"token operator\">&lt;</span>action<span class=\"token operator\">></span><span class=\"token punctuation\">:</span><span class=\"token operator\">&lt;</span>process<span class=\"token operator\">></span>\n#\n\n<span class=\"token number\">1</span><span class=\"token punctuation\">:</span><span class=\"token number\">12345</span><span class=\"token punctuation\">:</span>respawn<span class=\"token punctuation\">:</span><span class=\"token operator\">/</span>sbin<span class=\"token operator\">/</span>getty <span class=\"token number\">38400</span> tty1\n</code></pre>\n<p>这是一个典型的 <code>/etc/inittab</code> 文件，该文件在旧版本的 Linux 系统中用于配置系统初始化过程和运行级别。该文件告诉初始化系统（通常是 SysVinit）在不同运行级别下要执行的操作。以下是<code>inittab</code> 文件的内容解释：</p>\n<ol>\n<li><p><code>id:5:initdefault:</code>：这指定默认的运行级别为 5，通常对应多用户图形界面模式（X11）。</p>\n</li>\n<li><p><code>si::sysinit:/etc/init.d/rcS</code>：在系统引导过程中运行 <code>/etc/init.d/rcS</code> 脚本，这是系统初始化脚本，执行一些基本的系统配置。</p>\n</li>\n<li><p><code>~~:S:wait:/sbin/sulogin</code>：在单用户模式下，等待并运行 <code>/sbin/sulogin</code>，该命令是用于单用户模式下的登录。</p>\n</li>\n<li><p>运行级别定义及操作：</p>\n<ul>\n<li><code>l0:0:wait:/etc/init.d/rc 0</code> 切换到运行级别 0（关机）时，运行 <code>/etc/init.d/rc 0</code> 脚本。</li>\n<li><code>l1:1:wait:/etc/init.d/rc 1</code> 切换到运行级别 1（单用户模式）时，运行 <code>/etc/init.d/rc 1</code> 脚本。</li>\n<li><code>l2:2:wait:/etc/init.d/rc 2</code> 切换到运行级别 2 时，运行 <code>/etc/init.d/rc 2</code> 脚本。</li>\n<li><code>l3:3:wait:/etc/init.d/rc 3</code> 切换到运行级别 3 时，运行 <code>/etc/init.d/rc 3</code> 脚本。</li>\n<li><code>l4:4:wait:/etc/init.d/rc 4</code> 切换到运行级别 4 时，运行 <code>/etc/init.d/rc 4</code> 脚本。</li>\n<li><code>l5:5:wait:/etc/init.d/rc 5</code> 切换到运行级别 5 时，运行 <code>/etc/init.d/rc 5</code> 脚本。</li>\n<li><code>l6:6:wait:/etc/init.d/rc 6</code> 切换到运行级别 6（重启）时，运行 <code>/etc/init.d/rc 6</code> 脚本。</li>\n</ul>\n</li>\n<li><p><code>z6:6:respawn:/sbin/sulogin</code>：在运行级别 6（重启）时，启动 <code>/sbin/sulogin</code>。</p>\n</li>\n<li><p><code>mxc0:12345:respawn:/sbin/getty -l /bin/autologin -n -L 115200 ttymxc0</code>：在运行级别 1、2、3、4、5 时，通过 <code>getty</code> 在串口设备 <code>ttymxc0</code> 上启动自动登录的终端会话。</p>\n</li>\n<li><p><code>1:12345:respawn:/sbin/getty 38400 tty1</code>：在运行级别 1、2、3、4、5 时，通过 <code>getty</code> 在终端 <code>tty1</code> 上启动交互式终端会话。</p>\n</li>\n</ol>\n<p><code>/etc/inittab</code> 文件是一个配置文件，用于定义系统初始化进程的行为和运行级别。在早期的 UNIX 和类 UNIX 系统中，<code>init</code> 进程是系统中的第一个进程，它是所有其他进程的祖先。<code>/etc/inittab</code> 文件用于指定在系统引导过程中要执行的任务、默认运行级别以及其他与系统初始化和运行级别相关的设置。</p>\n<p>主要功能包括：</p>\n<ol>\n<li><p><strong>定义运行级别（Runlevels）：</strong> <code>/etc/inittab</code> 文件允许您指定默认的运行级别，例如单用户模式、多用户模式等。每个运行级别对应于一组要在该级别下启动或停止的服务。</p>\n</li>\n<li><p><strong>定义启动任务：</strong> 您可以在 <code>/etc/inittab</code> 中定义在不同运行级别下要执行的任务和脚本。这些任务可以是初始化系统配置、启动服务、创建虚拟终端等。例如，在启动时自动运行网络配置脚本。</p>\n</li>\n<li><p><strong>设置控制台：</strong> <code>/etc/inittab</code> 可以配置系统的虚拟终端（TTY）。您可以定义哪个虚拟终端用于登录，哪个终端用于系统控制台，以及何时启动 getty 进程等。</p>\n</li>\n<li><p><strong>设置自动登录：</strong> 您可以配置系统以在特定终端上自动登录用户，这在某些场景下很有用，例如嵌入式系统中的自动化测试。</p>\n</li>\n<li><p><strong>定义执行任务：</strong> 您可以将执行任务与特定运行级别相关联。这些任务可能是脚本、命令或程序，会在切换到相关运行级别时自动执行。</p>\n</li>\n</ol>\n<p>需要注意的是，现代 Linux 系统中，许多发行版已经迁移到了更现代的初始化系统，如 <code>systemd</code>。因此，<code>/etc/inittab</code> 在某些发行版中可能不再被广泛使用。不过，它在一些特定的环境中仍然可以用来定义一些系统初始化和运行级别相关的配置。</p>\n<h2 id=\"etc-init-d-rcS\"><a href=\"#etc-init-d-rcS\" class=\"headerlink\" title=\"/etc/init.d/rcS\"></a>/etc/init.d/rcS</h2><pre class=\" language-C\"><code class=\"language-C\">#!/bin/sh\n#\n# rcS           Call all S??* scripts in /etc/rcS.d in\n#               numerical/alphabetical order.\n#\n# Version:      @(#)/etc/init.d/rcS  2.76  19-Apr-1999  miquels@cistron.nl\n#\n\nPATH=/sbin:/bin:/usr/sbin:/usr/bin\nrunlevel=S\nprevlevel=N\numask 022\nexport PATH runlevel prevlevel\n\n#       Make sure proc is mounted\n#\n[ -d \"/proc/1\" ] || mount /proc\n\n#\n#       Source defaults.\n#\n. /etc/default/rcS\n\n#\n#       Trap CTRL-C &c only in this shell so we can interrupt subprocesses.\n#\ntrap \":\" INT QUIT TSTP\n\n#\n#       Call all parts in order.\n#\nexec /etc/init.d/rc S</code></pre>\n<p>这是 <code>/etc/init.d/rcS</code> 脚本的内容，用于在引导过程中执行一些初始化操作：</p>\n<ol>\n<li><p><code>PATH=/sbin:/bin:/usr/sbin:/usr/bin</code>：设置执行脚本时的环境变量路径，以确保能够找到所需的命令和工具。</p>\n</li>\n<li><p><code>runlevel=S</code>：设置当前运行级别为 S（系统启动）。</p>\n</li>\n<li><p><code>prevlevel=N</code>：设置上一个运行级别为 N（不存在的运行级别）。</p>\n</li>\n<li><p><code>umask 022</code>：设置文件创建的默认权限掩码，确保创建的文件不会过于开放。</p>\n</li>\n<li><p><code>export PATH runlevel prevlevel</code>：导出 <code>PATH</code>、<code>runlevel</code> 和 <code>prevlevel</code> 变量，以便在子进程中使用。</p>\n</li>\n<li><p><code>[ -d &quot;/proc/1&quot; ] || mount /proc</code>：检查 <code>/proc/1</code> 目录是否存在，如果不存在则挂载 <code>/proc</code> 文件系统，确保系统可以访问进程信息。</p>\n</li>\n<li><p><code>. /etc/default/rcS</code>：通过 sourcing（<code>.</code>）导入 <code>/etc/default/rcS</code> 文件，用于加载一些默认配置。</p>\n</li>\n<li><p><code>trap &quot;:&quot; INT QUIT TSTP</code>：设置信号处理，将 <code>INT</code>、<code>QUIT</code> 和 <code>TSTP</code> 信号的处理设为什么都不做（<code>:</code> 表示空语句），以便可以中断子进程而不中断脚本自身。</p>\n</li>\n<li><p><code>exec /etc/init.d/rc S</code>：通过 <code>exec</code> 命令执行 <code>/etc/init.d/rc</code> 脚本，并传递参数 <code>S</code>，表示在运行级别 S 下执行脚本。</p>\n</li>\n</ol>\n<p><code>/etc/init.d/rcS</code> 文件是一个脚本文件，用于在系统引导过程中执行一系列初始化任务。这些任务通常是与系统硬件、网络、文件系统挂载等相关的操作，以确保系统在启动时能够正常运行。</p>\n<p>在许多 Linux 发行版中，<code>rcS</code> 脚本被称为”System Initialization Script”，它是启动过程中第一个执行的脚本。<code>rcS</code> 脚本的主要目的是准备系统环境，使其达到可用状态，然后将控制权交给其他初始化脚本，以继续完成系统启动。</p>\n<p><code>/etc/init.d/rcS</code> 脚本的功能可能包括：</p>\n<ol>\n<li><p><strong>挂载文件系统：</strong> <code>rcS</code> 可能会在此阶段挂载根文件系统和其他必需的文件系统，以确保系统可以访问所需的文件和配置信息。</p>\n</li>\n<li><p><strong>设置网络：</strong> 在启动过程中，<code>rcS</code> 可能会配置网络接口，启动网络服务并初始化网络设置，以便系统可以与其他计算机进行通信。</p>\n</li>\n<li><p><strong>加载模块：</strong> 一些硬件或功能可能需要内核模块支持。<code>rcS</code> 可能会加载所需的内核模块，以确保硬件能够正常运作。</p>\n</li>\n<li><p><strong>启动服务：</strong> <code>rcS</code> 可能会启动一些基本的系统服务，例如系统日志记录、时间同步等。</p>\n</li>\n<li><p><strong>设置系统参数：</strong> <code>rcS</code> 可能会设置系统参数、环境变量和其他系统配置，以确保系统在正常运行时能够获得正确的设置。</p>\n</li>\n<li><p><strong>清理临时文件：</strong> 在引导过程中，系统可能会生成临时文件。<code>rcS</code> 可能会在启动后清理这些临时文件，以保持系统的整洁性。</p>\n</li>\n<li><p><strong>执行其他初始化任务：</strong> 根据发行版和系统配置，<code>rcS</code> 可能会执行其他必要的初始化任务，以确保系统正确启动。</p>\n</li>\n</ol>\n<p>需要注意的是，<code>/etc/init.d/rcS</code> 在不同的 Linux 发行版中可能会有不同的实现和用途。在一些现代发行版中，可能已经过渡到使用更现代的初始化系统，如 <code>systemd</code>，而一些传统的发行版可能仍然使用 <code>rcS</code> 脚本作为系统初始化的一部分。</p>\n<h2 id=\"etc-default-rcS\"><a href=\"#etc-default-rcS\" class=\"headerlink\" title=\"/etc/default/rcS\"></a>/etc/default/rcS</h2><pre class=\" language-c\"><code class=\"language-c\">#\n#       <span class=\"token operator\">/</span>etc<span class=\"token operator\">/</span>rcS<span class=\"token punctuation\">.</span>d 中启动脚本的默认值\n#\n\n# 在 <span class=\"token operator\">/</span>tmp 中保留时间文件的天数。\nTMPTIME<span class=\"token operator\">=</span><span class=\"token number\">0</span>\n# 如果要在引导时启动 sulogin，请设置为 yes\nSULOGIN<span class=\"token operator\">=</span>no\n# 如果希望在系统启动完成之前（即 inetd 启动后）能够通过 telnet<span class=\"token operator\">/</span>rlogin 登录，请设置为 no\nDELAYLOGIN<span class=\"token operator\">=</span>no\n# 假定 BIOS 时钟设置为 UTC 时间（推荐）\nUTC<span class=\"token operator\">=</span>yes\n# 如果希望引导时更加安静，请将 VERBOSE 设置为 <span class=\"token string\">\"no\"</span>\nVERBOSE<span class=\"token operator\">=</span>no\n# 如果不希望自动编辑 <span class=\"token operator\">/</span>etc<span class=\"token operator\">/</span>motd，请将 EDITMOTD 设置为 <span class=\"token string\">\"no\"</span>\nEDITMOTD<span class=\"token operator\">=</span>no\n# 是否在引导时对根文件系统执行 fsck（文件系统检查）\nENABLE_ROOTFS_FSCK<span class=\"token operator\">=</span>no\n# 如果希望在启动时将 <span class=\"token string\">\"-y\"</span> 添加到 fsck 命令，请将 FSCKFIX 设置为 <span class=\"token string\">\"yes\"</span>\nFSCKFIX<span class=\"token operator\">=</span>yes\n# 将 TICKADJ 设置为适用于此特定机器的正确 tick 值\n<span class=\"token macro property\">#TICKADJ=10000</span>\n# 在 populate<span class=\"token operator\">-</span><span class=\"token keyword\">volatile</span><span class=\"token punctuation\">.</span>sh 中启用缓存\nVOLATILE_ENABLE_CACHE<span class=\"token operator\">=</span>yes\n# 指示根文件系统是否打算为只读。设置 ROOTFS_READ_ONLY 为 yes 并重新启动将使根文件系统变为只读。\n# 通常情况下，您不应更改此值。\nROOTFS_READ_ONLY<span class=\"token operator\">=</span>no\n</code></pre>\n<p>/etc/default/rcS 文件是一个配置文件，用于设置系统初始化过程中的默认参数和选项。该文件中的设置会影响系统引导和初始化的行为。在许多 Linux 发行版中，/etc/default/rcS 文件用于指定与系统启动过程有关的全局设置。</p>\n<h2 id=\"etc-init-d-rc\"><a href=\"#etc-init-d-rc\" class=\"headerlink\" title=\"/etc/init.d/rc\"></a>/etc/init.d/rc</h2><pre class=\" language-shell\"><code class=\"language-shell\">#!/bin/sh\n#\n# rc            当运行级别变化时，此文件负责启动/停止服务。\n#\n# 优化特性：\n# 在服务在前一个运行级别中正在运行且在运行级别转换中没有被停止时，_不会_运行启动脚本\n# （大多数 Debian 服务在 rc{1,2,3,4,5} 中没有 K?? 链接）\n#\n# 作者：Miquel van Smoorenburg <miquels@cistron.nl>\n#      Bruce Perens <Bruce@Pixar.com>\n#\n# 版本：@(#)rc  2.78  1999 年 11 月 7 日  miquels@cistron.nl\n#\n\n. /etc/default/rcS\nexport VERBOSE\n\nstartup_progress() {\n    step=$(($step + $step_change))\n    if [ \"$num_steps\" != \"0\" ]; then\n        progress=$((($step * $progress_size / $num_steps) + $first_step))\n    else\n        progress=$progress_size\n    fi\n    #echo \"PROGRESS is $progress $runlevel $first_step + ($step of $num_steps) $step_change $progress_size\"\n    if type psplash-write >/dev/null 2>&1; then\n        TMPDIR=/mnt/.psplash psplash-write \"PROGRESS $progress\" || true\n    fi\n    #if [ -e /mnt/.psplash/psplash_fifo ]; then\n    #    echo \"PROGRESS $progress\" > /mnt/.psplash/psplash_fifo\n    #fi\n}\n\nstartup() {\n  # 处理冗长性\n  [ \"$VERBOSE\" = very ] && echo \"INIT: 正在运行 $@...\"\n\n  case \"$1\" in\n        *.sh)\n                # 为了提高速度，源码中的 shell 脚本。\n                (\n                        trap - INT QUIT TSTP\n                        scriptname=$1\n                        shift\n                        . $scriptname\n                )\n                ;;\n        *)\n                \"$@\"\n                ;;\n  esac\n  startup_progress\n}\n\n# 仅在此 shell 中忽略 CTRL-C，以便可以中断子进程。\ntrap \":\" INT QUIT TSTP\n\n# 设置 onlcr 以避免楼梯效应。\nstty onlcr 0>&1\n\n# 限制启动脚本的栈大小\n[ \"$STACK_SIZE\" == \"\" ] || ulimit -S -s $STACK_SIZE\n\n# 现在找出当前运行级别和上一个运行级别是什么。\n\nrunlevel=$RUNLEVEL\n# 获取第一个参数。将新运行级别设置为此参数。\n[ \"$1\" != \"\" ] && runlevel=$1\nif [ \"$runlevel\" = \"\" ]\nthen\n        echo \"用法：$0 <运行级别>\" >&2\n        exit 1\nfi\nprevious=$PREVLEVEL\n[ \"$previous\" = \"\" ] && previous=N\n\nexport runlevel previous\n\n# 是否有适用于这个新运行级别的 rc 目录？\nif [ -d /etc/rc$runlevel.d ]\nthen\n        # 找出 initramfs 在进度条中的位置。\n        PROGRESS_STATE=0\n        #if [ -f /dev/.initramfs/progress_state ]; then\n        #    . /dev/.initramfs/progress_state\n        #fi\n\n        # 将进度条的剩余部分分为三份\n        progress_size=$(((100 - $PROGRESS_STATE) / 3))\n\n        case \"$runlevel\" in\n                0|6)\n                        # 从 -100 倒计时到 0，使用整个进度条\n                        first_step=-100\n                        progress_size=100\n                        step_change=1\n                        ;;\n                S)\n                        # 从 initramfs 剩余的位置开始，使用剩余空间的 2/3\n                        first_step=$PROGRESS_STATE\n                        progress_size=$(($progress_size * 2))\n                        step_change=1\n                        ;;\n                *)\n                        # 从 rcS 停止的位置开始，使用最后 1/3 的空间（通过保持 progress_size 不变）\n                        first_step=$(($progress_size * 2 + $PROGRESS_STATE))\n                        step_change=1\n                        ;;\n        esac\n\n        num_steps=0\n        for s in /etc/rc$runlevel.d/[SK]*; do\n            case \"${s##/etc/rc$runlevel.d/S??}\" in\n                gdm|xdm|kdm|reboot|halt)\n                    break\n                    ;;\n            esac\n            num_steps=$(($num_steps + 1))\n        done\n        step=0\n\n        # 首先，运行 KILL 脚本。\n        if [ $previous != N ]\n        then\n                for i in /etc/rc$runlevel.d/K[0-9][0-9]*\n                do\n                        # 检查脚本是否存在。\n                        [ ! -f $i ] && continue\n\n                        # 停止服务。\n                        startup $i stop\n                done\n        fi\n\n        # 现在运行此运行级别的 START 脚本。\n        for i in /etc/rc$runlevel.d/S*\n        do\n                [ ! -f $i ] && continue\n\n                if [ $previous != N ] && [ $previous != S ]\n                then\n                        #\n                        # 在前一个运行级别中找到启动脚本和\n                        # 在这个运行级别中找到停止脚本。\n                        #\n                        suffix=${i#/etc/rc$runlevel.d/S[0-9][0-9]}\n                        stop=/etc/rc$runlevel.d/K[0-9][0-9]$suffix\n                        previous_start=/etc/rc$previous.d/S[0-9][0-9]$suffix\n                        #\n                        # 如果在上一个级别中有启动脚本\n                        # 并且在这个级别中没有停止脚本，我们就不需要重新启动服务。\n                        #\n                        [ -f $previous_start ] && [ ! -f $stop ] && continue\n                fi\n                case \"$runlevel\" in\n                        0|6)\n                                startup $i stop\n                                ;;\n                        *)\n                                startup $i start\n                                ;;\n                esac\n        done\n  fi\n\n# 取消注释以在手动退出 psplash，否则在看到 VC 切换时会退出\nif [ \"x$runlevel\" != \"xS\" ] && [ ! -x /etc/rc${runlevel}.d/S??xserver-nodm ]; then\n    if type psplash-write >/dev/null 2>&1; then\n        TMPDIR=/mnt/.psplash psplash-write \"QUIT\" || true\n        umount -l /mnt/.psplash\n    fi\nfi\n</code></pre>\n<p>由/etc/init.d/rc在执行等级切换的时候在/etc/rc$runlevel.d文件夹中启动相关程序，例如切换到runevel 5</p>\n<pre class=\" language-c\"><code class=\"language-c\">root@ATK<span class=\"token operator\">-</span>IMX6U<span class=\"token punctuation\">:</span><span class=\"token operator\">/</span>etc<span class=\"token operator\">/</span>rc5<span class=\"token punctuation\">.</span>d# ls <span class=\"token operator\">-</span>l\ntotal <span class=\"token number\">0</span>\nlrwxrwxrwx <span class=\"token number\">1</span> root root <span class=\"token number\">20</span> Jun <span class=\"token number\">10</span> <span class=\"token number\">18</span><span class=\"token punctuation\">:</span><span class=\"token number\">21</span> S01networking <span class=\"token operator\">-></span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>networking\nlrwxrwxrwx <span class=\"token number\">1</span> root root <span class=\"token number\">22</span> Jun <span class=\"token number\">10</span> <span class=\"token number\">18</span><span class=\"token punctuation\">:</span><span class=\"token number\">21</span> S01xserver<span class=\"token operator\">-</span>nodm <span class=\"token operator\">-></span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>xserver<span class=\"token operator\">-</span>nodm\nlrwxrwxrwx <span class=\"token number\">1</span> root root <span class=\"token number\">16</span> Jun <span class=\"token number\">10</span> <span class=\"token number\">18</span><span class=\"token punctuation\">:</span><span class=\"token number\">21</span> S02dbus<span class=\"token number\">-1</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>dbus<span class=\"token number\">-1</span>\nlrwxrwxrwx <span class=\"token number\">1</span> root root <span class=\"token number\">17</span> Jun <span class=\"token number\">10</span> <span class=\"token number\">18</span><span class=\"token punctuation\">:</span><span class=\"token number\">21</span> S05connman <span class=\"token operator\">-></span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>connman\nlrwxrwxrwx <span class=\"token number\">1</span> root root <span class=\"token number\">18</span> Jun <span class=\"token number\">10</span> <span class=\"token number\">18</span><span class=\"token punctuation\">:</span><span class=\"token number\">21</span> S10dropbear <span class=\"token operator\">-></span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>dropbear\nlrwxrwxrwx <span class=\"token number\">1</span> root root <span class=\"token number\">17</span> Jun <span class=\"token number\">10</span> <span class=\"token number\">18</span><span class=\"token punctuation\">:</span><span class=\"token number\">21</span> S12rpcbind <span class=\"token operator\">-></span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>rpcbind\nlrwxrwxrwx <span class=\"token number\">1</span> root root <span class=\"token number\">21</span> Jun <span class=\"token number\">10</span> <span class=\"token number\">18</span><span class=\"token punctuation\">:</span><span class=\"token number\">21</span> S15mountnfs<span class=\"token punctuation\">.</span>sh <span class=\"token operator\">-></span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>mountnfs<span class=\"token punctuation\">.</span>sh\nlrwxrwxrwx <span class=\"token number\">1</span> root root <span class=\"token number\">21</span> Jun <span class=\"token number\">10</span> <span class=\"token number\">18</span><span class=\"token punctuation\">:</span><span class=\"token number\">21</span> S15watchdog<span class=\"token punctuation\">.</span>sh <span class=\"token operator\">-></span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>watchdog<span class=\"token punctuation\">.</span>sh\nlrwxrwxrwx <span class=\"token number\">1</span> root root <span class=\"token number\">19</span> Jun <span class=\"token number\">10</span> <span class=\"token number\">18</span><span class=\"token punctuation\">:</span><span class=\"token number\">21</span> S19nfscommon <span class=\"token operator\">-></span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>nfscommon\nlrwxrwxrwx <span class=\"token number\">1</span> root root <span class=\"token number\">14</span> Jun <span class=\"token number\">10</span> <span class=\"token number\">18</span><span class=\"token punctuation\">:</span><span class=\"token number\">21</span> S20apmd <span class=\"token operator\">-></span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>apmd\nlrwxrwxrwx <span class=\"token number\">1</span> root root <span class=\"token number\">13</span> Jun <span class=\"token number\">10</span> <span class=\"token number\">18</span><span class=\"token punctuation\">:</span><span class=\"token number\">21</span> S20atd <span class=\"token operator\">-></span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>atd\nlrwxrwxrwx <span class=\"token number\">1</span> root root <span class=\"token number\">17</span> Jun <span class=\"token number\">10</span> <span class=\"token number\">18</span><span class=\"token punctuation\">:</span><span class=\"token number\">21</span> S20hostapd <span class=\"token operator\">-></span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>hostapd\nlrwxrwxrwx <span class=\"token number\">1</span> root root <span class=\"token number\">20</span> Jun <span class=\"token number\">10</span> <span class=\"token number\">18</span><span class=\"token punctuation\">:</span><span class=\"token number\">21</span> S20hwclock<span class=\"token punctuation\">.</span>sh <span class=\"token operator\">-></span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>hwclock<span class=\"token punctuation\">.</span>sh\nlrwxrwxrwx <span class=\"token number\">1</span> root root <span class=\"token number\">19</span> Jun <span class=\"token number\">10</span> <span class=\"token number\">18</span><span class=\"token punctuation\">:</span><span class=\"token number\">21</span> S20nfsserver <span class=\"token operator\">-></span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>nfsserver\nlrwxrwxrwx <span class=\"token number\">1</span> root root <span class=\"token number\">16</span> Jun <span class=\"token number\">10</span> <span class=\"token number\">18</span><span class=\"token punctuation\">:</span><span class=\"token number\">21</span> S20syslog <span class=\"token operator\">-></span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>syslog\nlrwxrwxrwx <span class=\"token number\">1</span> root root <span class=\"token number\">22</span> Jun <span class=\"token number\">10</span> <span class=\"token number\">18</span><span class=\"token punctuation\">:</span><span class=\"token number\">21</span> S21avahi<span class=\"token operator\">-</span>daemon <span class=\"token operator\">-></span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>avahi<span class=\"token operator\">-</span>daemon\nlrwxrwxrwx <span class=\"token number\">1</span> root root <span class=\"token number\">15</span> Jun <span class=\"token number\">10</span> <span class=\"token number\">18</span><span class=\"token punctuation\">:</span><span class=\"token number\">21</span> S22ofono <span class=\"token operator\">-></span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>ofono\nlrwxrwxrwx <span class=\"token number\">1</span> root root <span class=\"token number\">15</span> Jun <span class=\"token number\">10</span> <span class=\"token number\">18</span><span class=\"token punctuation\">:</span><span class=\"token number\">21</span> S64neard <span class=\"token operator\">-></span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>neard\nlrwxrwxrwx <span class=\"token number\">1</span> root root <span class=\"token number\">16</span> Jun <span class=\"token number\">10</span> <span class=\"token number\">18</span><span class=\"token punctuation\">:</span><span class=\"token number\">21</span> S80vsftpd <span class=\"token operator\">-></span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>vsftpd\nlrwxrwxrwx <span class=\"token number\">1</span> root root <span class=\"token number\">15</span> Jun <span class=\"token number\">10</span> <span class=\"token number\">18</span><span class=\"token punctuation\">:</span><span class=\"token number\">21</span> S90crond <span class=\"token operator\">-></span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>crond\nlrwxrwxrwx <span class=\"token number\">1</span> root root <span class=\"token number\">15</span> Jun <span class=\"token number\">10</span> <span class=\"token number\">18</span><span class=\"token punctuation\">:</span><span class=\"token number\">21</span> S92nginx <span class=\"token operator\">-></span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>nginx\nlrwxrwxrwx <span class=\"token number\">1</span> root root <span class=\"token number\">18</span> Jun <span class=\"token number\">10</span> <span class=\"token number\">18</span><span class=\"token punctuation\">:</span><span class=\"token number\">21</span> S99rc<span class=\"token punctuation\">.</span>local <span class=\"token operator\">-></span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>rc<span class=\"token punctuation\">.</span>local\nlrwxrwxrwx <span class=\"token number\">1</span> root root <span class=\"token number\">22</span> Jun <span class=\"token number\">10</span> <span class=\"token number\">18</span><span class=\"token punctuation\">:</span><span class=\"token number\">21</span> S99rmnologin<span class=\"token punctuation\">.</span>sh <span class=\"token operator\">-></span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>rmnologin<span class=\"token punctuation\">.</span>sh\nlrwxrwxrwx <span class=\"token number\">1</span> root root <span class=\"token number\">23</span> Jun <span class=\"token number\">10</span> <span class=\"token number\">18</span><span class=\"token punctuation\">:</span><span class=\"token number\">21</span> S99stop<span class=\"token operator\">-</span>bootlogd <span class=\"token operator\">-></span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>stop<span class=\"token operator\">-</span>bootlogd\nroot@ATK<span class=\"token operator\">-</span>IMX6U<span class=\"token punctuation\">:</span><span class=\"token operator\">/</span>etc<span class=\"token operator\">/</span>rc5<span class=\"token punctuation\">.</span>d# # diff  rc3<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span> rc5<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>\nOnly in rc3<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span><span class=\"token punctuation\">:</span> K01xserver<span class=\"token operator\">-</span>nodm\nOnly in rc5<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span><span class=\"token punctuation\">:</span> S01xserver<span class=\"token operator\">-</span>nodm\ndiff<span class=\"token punctuation\">:</span> rc3<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>S20hostapd<span class=\"token punctuation\">:</span> No such file or directory\ndiff<span class=\"token punctuation\">:</span> rc5<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>S20hostapd<span class=\"token punctuation\">:</span> No such file or directory\n</code></pre>\n<p><code>/etc/init.d/rc</code> 文件是一个启动脚本，用于在系统的不同运行级别（runlevel）之间切换时启动或停止服务。在许多 Linux 系统中，运行级别是系统运行状态的一个标识，不同的运行级别对应于不同的系统配置和功能。</p>\n<p>在传统的 SysV init 系统中，<code>/etc/init.d/rc</code> 脚本是一个管理系统运行级别的关键脚本。它接受一个参数，即目标运行级别，然后根据当前运行级别和目标运行级别执行必要的操作以启动或停止服务。这通常涉及启动或停止各种服务脚本（以脚本符号 S 或 K 开头的脚本），以实现系统的初始化或关机。</p>\n<p>具体而言，<code>/etc/init.d/rc</code> 脚本的主要功能包括：</p>\n<ol>\n<li><p><strong>判断运行级别：</strong> 根据脚本参数和当前运行级别，确定要切换到的目标运行级别。</p>\n</li>\n<li><p><strong>执行运行级别切换操作：</strong> 根据目标运行级别，执行一系列操作以启动或停止与该运行级别相关的服务。</p>\n</li>\n<li><p><strong>启动服务：</strong> 如果切换到一个新的运行级别，<code>rc</code> 脚本会依次启动以 <code>S</code> 开头的服务脚本。这些服务脚本负责启动系统所需的各种服务，如网络、文件系统挂载、系统日志等。</p>\n</li>\n<li><p><strong>停止服务：</strong> 如果切换到一个较低的运行级别，<code>rc</code> 脚本会依次停止以 <code>K</code> 开头的服务脚本。这些服务脚本负责停止系统中正在运行的服务。</p>\n</li>\n<li><p><strong>设置环境：</strong> <code>rc</code> 脚本可能会设置环境变量或其他参数，以便在运行服务脚本时传递所需的信息。</p>\n</li>\n</ol>\n<p>需要注意的是，随着现代 Linux 发行版的发展，许多系统已经转向使用 <code>systemd</code> 或其他更现代的初始化系统，而不再使用传统的 SysV init 系统。因此，<code>/etc/init.d/rc</code> 在一些新的发行版中可能已经不再起到关键的作用，而是由更现代的初始化系统负责管理运行级别和服务启动。</p>\n<p>如果你使用的是基于 SysV init 的系统，并且遇到了与 <code>/etc/init.d/rc</code> 相关的问题，你可能需要深入了解你的系统文档和初始化流程，以理解脚本是如何工作的以及如何进行定制。</p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<h1 id=\"init进程\"><a href=\"#init进程\" class=\"headerlink\" title=\"init进程\"></a>init进程</h1><p>在Linux系统中，<code>init</code> 是第一个被启动的进程，其进程ID为1。它是系统启动过程中的第一个用户级进程，负责初始化系统，并在系统运行时作为所有其他进程的祖先。然而，需要注意的是，在现代Linux系统中，<code>init</code> 进程通常被替代为更先进的初始化系统，比如 <code>systemd</code> 或 <code>Upstart</code>。</p>\n<p>原始的 <code>init</code> 进程主要负责以下几个任务：</p>\n<ol>\n<li><p><strong>系统初始化</strong>: <code>init</code> 进程在系统启动时负责加载操作系统所需的核心模块和设备驱动程序，以确保系统的基本功能正常运行。</p>\n</li>\n<li><p><strong>启动和管理系统服务</strong>: <code>init</code> 进程通过运行启动脚本来启动系统中的各种服务和守护进程。这些服务可能包括网络服务、文件系统服务、打印服务等。</p>\n</li>\n<li><p><strong>运行级别管理</strong>: <code>init</code> 进程支持不同的运行级别，每个级别定义了不同的系统状态。例如，运行级别可能是单用户模式、多用户模式、图形用户界面模式等。<code>init</code> 进程负责根据需要切换不同的运行级别。</p>\n</li>\n</ol>\n<p>然而，随着时间的推移，传统的 <code>init</code> 进程的功能显得有些有限，因此引入了更现代的初始化系统，如 <code>systemd</code>。<code>systemd</code> 在许多Linux发行版中取代了传统的 <code>init</code>，它提供了更强大的系统初始化和管理功能，可以更有效地处理并行启动、服务依赖、日志管理等。</p>\n<p>尽管如此，<code>init</code> 进程作为系统的第一个进程仍然具有重要的历史地位，并且在某些方面仍然发挥着作用，尤其是在一些较旧的或嵌入式系统中。</p>\n<h1 id=\"init源码\"><a href=\"#init源码\" class=\"headerlink\" title=\"init源码\"></a>init源码</h1><p>init/main.c：start_kernel()—&gt;rest_init()</p>\n<pre><code class=\"c\">static noinline void __init_refok rest_init(void)\n{\n    int pid;\n\n    // 启动RCU（Read-Copy-Update）调度器\n    rcu_scheduler_starting();\n\n    // 初始化SMP（Symmetric Multiprocessing）启动线程\n    smpboot_thread_init();\n\n    /*\n     * 我们需要首先生成 init 进程，以便它获得 pid 1，但是 init 任务最终会想要创建 kthread，\n     * 如果我们在创建 kthreadd 之前调度它，将会导致 OOPS（操作系统崩溃）。\n     */\n    kernel_thread(kernel_init, NULL, CLONE_FS);\n\n    // 设置 NUMA（Non-Uniform Memory Access）默认策略\n    numa_default_policy();\n\n    // 创建 kthreadd 进程，用于创建其他内核线程\n    pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES);\n\n    // 读取锁定 RCU，以查找 kthreadd 进程的任务结构体\n    rcu_read_lock();\n    kthreadd_task = find_task_by_pid_ns(pid, &amp;init_pid_ns);\n    rcu_read_unlock();\n\n    // 标记 kthreadd 进程已完成初始化\n    complete(&amp;kthreadd_done);\n\n    /*\n     * 引导空闲线程必须执行 schedule() 至少一次以启动系统：\n     */\n    init_idle_bootup_task(current);\n    schedule_preempt_disabled();\n\n    /* 带有抢占禁用的情况下调用 cpu_idle */\n    cpu_startup_entry(CPUHP_ONLINE);\n}</code></pre>\n<p>这段代码主要完成以下任务：</p>\n<p>1.启动 RCU 调度器，这是一种内核中用于实现无锁并发访问的机制。<br>2.初始化 SMP 启动线程，用于初始化多处理器系统。<br>3.创建 init 进程，确保它获得 PID 1，但避免在创建 kthreadd 进程之前调度 init 进程。<br>4.设置 NUMA 默认策略，处理非一致性内存访问。<br>5.创建 kthreadd 进程，该进程用于在内核中创建其他线程。<br>6.根据 PID 查找并初始化 kthreadd 进程的任务结构体。<br>7.标记 kthreadd 进程初始化完成。<br>8.启动引导空闲线程，执行初始的调度以启动系统。<br>9.最后，调用 cpu_startup_entry，在线程上下文中启动 CPU，允许它执行调度。</p>\n<pre><code class=\"c\">    static int __ref kernel_init(void *unused)\n    {\n        int ret;\n\n        // 运行 kernel_init_freeable 函数，执行一些必要的内核初始化\n        kernel_init_freeable();\n\n        // 在释放内存之前，需要完成所有异步 __init 代码\n        async_synchronize_full();\n\n        // 释放初始内存\n        free_initmem();\n\n        // 将只读数据段标记为只读\n        mark_rodata_ro();\n\n        // 设置系统状态为 SYSTEM_RUNNING，表示系统已运行\n        system_state = SYSTEM_RUNNING;\n\n        // 设置 NUMA 默认策略\n        numa_default_policy();\n\n        // 清理延迟的文件指针释放\n        flush_delayed_fput();\n\n        // 如果设置了 ramdisk_execute_command，则尝试运行对应的命令\n        if (ramdisk_execute_command) {\n            ret = run_init_process(ramdisk_execute_command);\n            if (!ret)\n                return 0;\n            pr_err(&quot;Failed to execute %s (error %d)\\n&quot;,\n                ramdisk_execute_command, ret);\n        }\n\n        /*\n        * 我们尝试执行以下每个命令，直到成功为止。\n        *\n        * 如果我们尝试恢复一个非常破损的机器，可以使用 Bourne shell 代替 init。\n        */\n        if (execute_command) {\n            ret = run_init_process(execute_command);\n            if (!ret)\n                return 0;\n            panic(&quot;Requested init %s failed (error %d).&quot;,\n                execute_command, ret);\n        }\n        if (!try_to_run_init_process(&quot;/sbin/init&quot;) ||\n            !try_to_run_init_process(&quot;/etc/init&quot;) ||\n            !try_to_run_init_process(&quot;/bin/init&quot;) ||\n            !try_to_run_init_process(&quot;/bin/sh&quot;))\n            return 0;\n\n        // 如果没有找到可用的 init 进程，触发内核崩溃\n        panic(&quot;No working init found.  Try passing init= option to kernel. &quot;\n            &quot;See Linux Documentation/init.txt for guidance.&quot;);\n    }</code></pre>\n<p>这段代码的主要功能是在系统引导期间执行一系列初始化操作，然后尝试启动系统的初始化进程（如 init）。它的核心步骤包括：</p>\n<p>运行 kernel_init_freeable 函数，执行一些必要的内核初始化,这个函数很重要后面分析。</p>\n<p>在释放内存之前，使用 async_synchronize_full 等待所有异步初始化代码的完成。</p>\n<p>释放初始内存，这是在引导过程中使用的一部分内存。</p>\n<p>将只读数据段标记为只读，以提高系统的安全性。</p>\n<p>设置系统状态为 SYSTEM_RUNNING，表示系统已经正常运行。</p>\n<p>设置 NUMA 默认策略，用于处理非一致性内存访问。</p>\n<p>清理延迟的文件指针释放，确保文件资源得到正确管理。</p>\n<p>尝试执行预设的 ramdisk_execute_command 命令（如果设置了）。</p>\n<p>尝试执行预设的 execute_command 命令（如果设置了）。</p>\n<p>如果以上尝试都失败，尝试依次执行一些默认的初始化命令路径，如 /sbin/init、/etc/init、/bin/init 和 /bin/sh。<br><code>/sbin/init实际是init.sysvinit。但是init.sysvinit是干嘛的不知道？？？？</code><br>暂时理解成init进程启动，通过/sbin/init准备系统软件的运行环境，读取/etc/inittab，获取运行级别数值 </p>\n<p>如果仍然找不到可用的初始化进程，系统进入崩溃状态，显示错误消息并建议尝试通过内核参数 init= 指定初始化进程。</p>\n<pre><code class=\"c\">\nstatic noinline void __init kernel_init_freeable(void)\n{\n    /*\n     * Wait until kthreadd is all set-up.\n     */\n    wait_for_completion(&amp;kthreadd_done);\n\n    /* Now the scheduler is fully set up and can do blocking allocations */\n    gfp_allowed_mask = __GFP_BITS_MASK;\n\n    /*\n     * init can allocate pages on any node\n     */\n    set_mems_allowed(node_states[N_MEMORY]);\n    /*\n     * init can run on any cpu.\n     */\n    set_cpus_allowed_ptr(current, cpu_all_mask);\n\n    cad_pid = task_pid(current);\n\n    smp_prepare_cpus(setup_max_cpus);\n\n    do_pre_smp_initcalls();\n    lockup_detector_init();\n\n    smp_init();\n    sched_init_smp();\n\n    do_basic_setup();   /* 设备初始化都在此函数中完成 */\n\n    /* Open the /dev/console on the rootfs, this should never fail */\n    if (sys_open((const char __user *) &quot;/dev/console&quot;, O_RDWR, 0) &lt; 0)\n        pr_err(&quot;Warning: unable to open an initial console.\\n&quot;);\n\n    (void) sys_dup(0);\n    (void) sys_dup(0);\n    /*\n     * check if there is an early userspace init.  If yes, let it do all\n     * the work\n     */\n\n    if (!ramdisk_execute_command)\n        ramdisk_execute_command = &quot;/init&quot;;\n\n    if (sys_access((const char __user *) ramdisk_execute_command, 0) != 0) {\n        ramdisk_execute_command = NULL;\n        prepare_namespace();\n    }\n\n    /*\n     * Ok, we have completed the initial bootup, and\n     * we&#39;re essentially up and running. Get rid of the\n     * initmem segments and start the user-mode stuff..\n     *\n     * rootfs is available now, try loading the public keys\n     * and default modules\n     */\n\n    integrity_load_keys();\n    load_default_modules();\n}</code></pre>\n<p><code>kernel_init_freeable</code>函数执行的一系列操作：</p>\n<ol>\n<li><p><code>wait_for_completion(&amp;kthreadd_done);</code>：等待直到<code>kthreadd</code>进程初始化完成，确保<code>kthreadd</code>进程已经准备就绪。</p>\n</li>\n<li><p><code>gfp_allowed_mask = __GFP_BITS_MASK;</code>：设置内核的内存分配标志，允许使用所有内存分配标志位。</p>\n</li>\n<li><p><code>set_mems_allowed(node_states[N_MEMORY]);</code>：设置进程可以在所有NUMA节点上分配内存。</p>\n</li>\n<li><p><code>set_cpus_allowed_ptr(current, cpu_all_mask);</code>：设置当前进程可以在所有CPU上运行。</p>\n</li>\n<li><p><code>cad_pid = task_pid(current);</code>：设置<code>cad_pid</code>（Ctrl+Alt+Del进程）为当前进程的PID。</p>\n</li>\n<li><p><code>smp_prepare_cpus(setup_max_cpus);</code>：准备启动SMP（对称多处理）系统，设置CPU的最大数量。</p>\n</li>\n<li><p><code>do_pre_smp_initcalls();</code>：运行预初始化的SMP调用。</p>\n</li>\n<li><p><code>lockup_detector_init();</code>：初始化系统的死锁检测器。</p>\n</li>\n<li><p><code>smp_init();</code>：初始化SMP子系统。</p>\n</li>\n<li><p><code>sched_init_smp();</code>：初始化调度器的SMP相关部分。</p>\n</li>\n<li><p><code>do_basic_setup();</code>：do_basic_setup 函数用于完成 Linux 下设备驱动初始化工作！非常重要。do_basic_setup 会调用 driver_init 函数完成 Linux 下驱动模型子系统的初始化。</p>\n</li>\n<li><p><code>sys_open((const char __user *) &quot;/dev/console&quot;, O_RDWR, 0)</code>：尝试打开<code>/dev/console</code>设备，用于系统控制台输出。</p>\n</li>\n<li><p><code>sys_dup(0)</code>：通过复制文件描述符0（标准输入）来创建文件描述符1和2（标准输出和标准错误），确保它们都指向同一个设备。</p>\n</li>\n<li><p><code>if (!ramdisk_execute_command) ramdisk_execute_command = &quot;/init&quot;;</code>：如果没有定义<code>ramdisk_execute_command</code>，则设置默认的启动命令为<code>/init</code>。</p>\n</li>\n<li><p><code>if (sys_access((const char __user *) ramdisk_execute_command, 0) != 0)</code>：检查指定的启动命令是否存在。</p>\n</li>\n<li><p><code>prepare_namespace();</code>：准备初始化的根文件系统命名空间。</p>\n</li>\n<li><p><code>integrity_load_keys();</code>：加载完整性校验的公钥，用于验证文件系统上的数据完整性。</p>\n</li>\n<li><p><code>load_default_modules();</code>：加载默认的内核模块，增加系统功能。</p>\n</li>\n</ol>\n<p>总之，这段代码在系统引导期间完成一系列重要的初始化步骤，包括设置内存分配、CPU调度、设备初始化、根文件系统设置等。最终，它准备好系统的运行环境，使得系统能够顺利进入用户模式运行，并提供用户可见的功能。</p>\n<h1 id=\"执行脚本\"><a href=\"#执行脚本\" class=\"headerlink\" title=\"执行脚本\"></a>执行脚本</h1><pre><code>sbin/init---&gt;init.sysinit\n                |调用\n                v\n    /etc/inittab---&gt;/etc/init.d/rcS---&gt;/etc/default/rcS（默认设置）\n                                   ---&gt;/etc/init.d/rc（启动默认线程）\n                                        |\n                                        V\n                                    开启/etc/rc$.d/下面的进程</code></pre><h2 id=\"etc-inittab\"><a href=\"#etc-inittab\" class=\"headerlink\" title=\"/etc/inittab\"></a>/etc/inittab</h2><pre><code class=\"c\">root@ATK-IMX6U:/etc# cat inittab \n# /etc/inittab: init(8) configuration.\n# $Id: inittab,v 1.91 2002/01/25 13:35:21 miquels Exp $\n\n# The default runlevel.\nid:5:initdefault:\n\n# Boot-time system configuration/initialization script.\n# This is run first except when booting in emergency (-b) mode.\nsi::sysinit:/etc/init.d/rcS\n\n# What to do in single-user mode.\n~~:S:wait:/sbin/sulogin\n\n# /etc/init.d executes the S and K scripts upon change\n# of runlevel.\n#\n# Runlevel 0 is halt.\n# Runlevel 1 is single-user.\n# Runlevels 2-5 are multi-user.\n# Runlevel 6 is reboot.\ntty1::askfirst:-/bin/sh\nl0:0:wait:/etc/init.d/rc 0\nl1:1:wait:/etc/init.d/rc 1\nl2:2:wait:/etc/init.d/rc 2\nl3:3:wait:/etc/init.d/rc 3\nl4:4:wait:/etc/init.d/rc 4\nl5:5:wait:/etc/init.d/rc 5\nl6:6:wait:/etc/init.d/rc 6\n# Normally not reached, but fallthrough in case of emergency.\nz6:6:respawn:/sbin/sulogin\n#mxc0:12345:respawn:/bin/start_getty 115200 ttymxc0\nmxc0:12345:respawn:/sbin/getty -l /bin/autologin -n -L 115200 ttymxc0\n# /sbin/getty invocations for the runlevels.\n#\n# The &quot;id&quot; field MUST be the same as the last\n# characters of the device (after &quot;tty&quot;).\n#\n# Format:\n#  &lt;id&gt;:&lt;runlevels&gt;:&lt;action&gt;:&lt;process&gt;\n#\n\n1:12345:respawn:/sbin/getty 38400 tty1\n</code></pre>\n<p>这是一个典型的 <code>/etc/inittab</code> 文件，该文件在旧版本的 Linux 系统中用于配置系统初始化过程和运行级别。该文件告诉初始化系统（通常是 SysVinit）在不同运行级别下要执行的操作。以下是<code>inittab</code> 文件的内容解释：</p>\n<ol>\n<li><p><code>id:5:initdefault:</code>：这指定默认的运行级别为 5，通常对应多用户图形界面模式（X11）。</p>\n</li>\n<li><p><code>si::sysinit:/etc/init.d/rcS</code>：在系统引导过程中运行 <code>/etc/init.d/rcS</code> 脚本，这是系统初始化脚本，执行一些基本的系统配置。</p>\n</li>\n<li><p><code>~~:S:wait:/sbin/sulogin</code>：在单用户模式下，等待并运行 <code>/sbin/sulogin</code>，该命令是用于单用户模式下的登录。</p>\n</li>\n<li><p>运行级别定义及操作：</p>\n<ul>\n<li><code>l0:0:wait:/etc/init.d/rc 0</code> 切换到运行级别 0（关机）时，运行 <code>/etc/init.d/rc 0</code> 脚本。</li>\n<li><code>l1:1:wait:/etc/init.d/rc 1</code> 切换到运行级别 1（单用户模式）时，运行 <code>/etc/init.d/rc 1</code> 脚本。</li>\n<li><code>l2:2:wait:/etc/init.d/rc 2</code> 切换到运行级别 2 时，运行 <code>/etc/init.d/rc 2</code> 脚本。</li>\n<li><code>l3:3:wait:/etc/init.d/rc 3</code> 切换到运行级别 3 时，运行 <code>/etc/init.d/rc 3</code> 脚本。</li>\n<li><code>l4:4:wait:/etc/init.d/rc 4</code> 切换到运行级别 4 时，运行 <code>/etc/init.d/rc 4</code> 脚本。</li>\n<li><code>l5:5:wait:/etc/init.d/rc 5</code> 切换到运行级别 5 时，运行 <code>/etc/init.d/rc 5</code> 脚本。</li>\n<li><code>l6:6:wait:/etc/init.d/rc 6</code> 切换到运行级别 6（重启）时，运行 <code>/etc/init.d/rc 6</code> 脚本。</li>\n</ul>\n</li>\n<li><p><code>z6:6:respawn:/sbin/sulogin</code>：在运行级别 6（重启）时，启动 <code>/sbin/sulogin</code>。</p>\n</li>\n<li><p><code>mxc0:12345:respawn:/sbin/getty -l /bin/autologin -n -L 115200 ttymxc0</code>：在运行级别 1、2、3、4、5 时，通过 <code>getty</code> 在串口设备 <code>ttymxc0</code> 上启动自动登录的终端会话。</p>\n</li>\n<li><p><code>1:12345:respawn:/sbin/getty 38400 tty1</code>：在运行级别 1、2、3、4、5 时，通过 <code>getty</code> 在终端 <code>tty1</code> 上启动交互式终端会话。</p>\n</li>\n</ol>\n<p><code>/etc/inittab</code> 文件是一个配置文件，用于定义系统初始化进程的行为和运行级别。在早期的 UNIX 和类 UNIX 系统中，<code>init</code> 进程是系统中的第一个进程，它是所有其他进程的祖先。<code>/etc/inittab</code> 文件用于指定在系统引导过程中要执行的任务、默认运行级别以及其他与系统初始化和运行级别相关的设置。</p>\n<p>主要功能包括：</p>\n<ol>\n<li><p><strong>定义运行级别（Runlevels）：</strong> <code>/etc/inittab</code> 文件允许您指定默认的运行级别，例如单用户模式、多用户模式等。每个运行级别对应于一组要在该级别下启动或停止的服务。</p>\n</li>\n<li><p><strong>定义启动任务：</strong> 您可以在 <code>/etc/inittab</code> 中定义在不同运行级别下要执行的任务和脚本。这些任务可以是初始化系统配置、启动服务、创建虚拟终端等。例如，在启动时自动运行网络配置脚本。</p>\n</li>\n<li><p><strong>设置控制台：</strong> <code>/etc/inittab</code> 可以配置系统的虚拟终端（TTY）。您可以定义哪个虚拟终端用于登录，哪个终端用于系统控制台，以及何时启动 getty 进程等。</p>\n</li>\n<li><p><strong>设置自动登录：</strong> 您可以配置系统以在特定终端上自动登录用户，这在某些场景下很有用，例如嵌入式系统中的自动化测试。</p>\n</li>\n<li><p><strong>定义执行任务：</strong> 您可以将执行任务与特定运行级别相关联。这些任务可能是脚本、命令或程序，会在切换到相关运行级别时自动执行。</p>\n</li>\n</ol>\n<p>需要注意的是，现代 Linux 系统中，许多发行版已经迁移到了更现代的初始化系统，如 <code>systemd</code>。因此，<code>/etc/inittab</code> 在某些发行版中可能不再被广泛使用。不过，它在一些特定的环境中仍然可以用来定义一些系统初始化和运行级别相关的配置。</p>\n<h2 id=\"etc-init-d-rcS\"><a href=\"#etc-init-d-rcS\" class=\"headerlink\" title=\"/etc/init.d/rcS\"></a>/etc/init.d/rcS</h2><pre><code class=\"C\">#!/bin/sh\n#\n# rcS           Call all S??* scripts in /etc/rcS.d in\n#               numerical/alphabetical order.\n#\n# Version:      @(#)/etc/init.d/rcS  2.76  19-Apr-1999  miquels@cistron.nl\n#\n\nPATH=/sbin:/bin:/usr/sbin:/usr/bin\nrunlevel=S\nprevlevel=N\numask 022\nexport PATH runlevel prevlevel\n\n#       Make sure proc is mounted\n#\n[ -d &quot;/proc/1&quot; ] || mount /proc\n\n#\n#       Source defaults.\n#\n. /etc/default/rcS\n\n#\n#       Trap CTRL-C &amp;c only in this shell so we can interrupt subprocesses.\n#\ntrap &quot;:&quot; INT QUIT TSTP\n\n#\n#       Call all parts in order.\n#\nexec /etc/init.d/rc S</code></pre>\n<p>这是 <code>/etc/init.d/rcS</code> 脚本的内容，用于在引导过程中执行一些初始化操作：</p>\n<ol>\n<li><p><code>PATH=/sbin:/bin:/usr/sbin:/usr/bin</code>：设置执行脚本时的环境变量路径，以确保能够找到所需的命令和工具。</p>\n</li>\n<li><p><code>runlevel=S</code>：设置当前运行级别为 S（系统启动）。</p>\n</li>\n<li><p><code>prevlevel=N</code>：设置上一个运行级别为 N（不存在的运行级别）。</p>\n</li>\n<li><p><code>umask 022</code>：设置文件创建的默认权限掩码，确保创建的文件不会过于开放。</p>\n</li>\n<li><p><code>export PATH runlevel prevlevel</code>：导出 <code>PATH</code>、<code>runlevel</code> 和 <code>prevlevel</code> 变量，以便在子进程中使用。</p>\n</li>\n<li><p><code>[ -d &quot;/proc/1&quot; ] || mount /proc</code>：检查 <code>/proc/1</code> 目录是否存在，如果不存在则挂载 <code>/proc</code> 文件系统，确保系统可以访问进程信息。</p>\n</li>\n<li><p><code>. /etc/default/rcS</code>：通过 sourcing（<code>.</code>）导入 <code>/etc/default/rcS</code> 文件，用于加载一些默认配置。</p>\n</li>\n<li><p><code>trap &quot;:&quot; INT QUIT TSTP</code>：设置信号处理，将 <code>INT</code>、<code>QUIT</code> 和 <code>TSTP</code> 信号的处理设为什么都不做（<code>:</code> 表示空语句），以便可以中断子进程而不中断脚本自身。</p>\n</li>\n<li><p><code>exec /etc/init.d/rc S</code>：通过 <code>exec</code> 命令执行 <code>/etc/init.d/rc</code> 脚本，并传递参数 <code>S</code>，表示在运行级别 S 下执行脚本。</p>\n</li>\n</ol>\n<p><code>/etc/init.d/rcS</code> 文件是一个脚本文件，用于在系统引导过程中执行一系列初始化任务。这些任务通常是与系统硬件、网络、文件系统挂载等相关的操作，以确保系统在启动时能够正常运行。</p>\n<p>在许多 Linux 发行版中，<code>rcS</code> 脚本被称为”System Initialization Script”，它是启动过程中第一个执行的脚本。<code>rcS</code> 脚本的主要目的是准备系统环境，使其达到可用状态，然后将控制权交给其他初始化脚本，以继续完成系统启动。</p>\n<p><code>/etc/init.d/rcS</code> 脚本的功能可能包括：</p>\n<ol>\n<li><p><strong>挂载文件系统：</strong> <code>rcS</code> 可能会在此阶段挂载根文件系统和其他必需的文件系统，以确保系统可以访问所需的文件和配置信息。</p>\n</li>\n<li><p><strong>设置网络：</strong> 在启动过程中，<code>rcS</code> 可能会配置网络接口，启动网络服务并初始化网络设置，以便系统可以与其他计算机进行通信。</p>\n</li>\n<li><p><strong>加载模块：</strong> 一些硬件或功能可能需要内核模块支持。<code>rcS</code> 可能会加载所需的内核模块，以确保硬件能够正常运作。</p>\n</li>\n<li><p><strong>启动服务：</strong> <code>rcS</code> 可能会启动一些基本的系统服务，例如系统日志记录、时间同步等。</p>\n</li>\n<li><p><strong>设置系统参数：</strong> <code>rcS</code> 可能会设置系统参数、环境变量和其他系统配置，以确保系统在正常运行时能够获得正确的设置。</p>\n</li>\n<li><p><strong>清理临时文件：</strong> 在引导过程中，系统可能会生成临时文件。<code>rcS</code> 可能会在启动后清理这些临时文件，以保持系统的整洁性。</p>\n</li>\n<li><p><strong>执行其他初始化任务：</strong> 根据发行版和系统配置，<code>rcS</code> 可能会执行其他必要的初始化任务，以确保系统正确启动。</p>\n</li>\n</ol>\n<p>需要注意的是，<code>/etc/init.d/rcS</code> 在不同的 Linux 发行版中可能会有不同的实现和用途。在一些现代发行版中，可能已经过渡到使用更现代的初始化系统，如 <code>systemd</code>，而一些传统的发行版可能仍然使用 <code>rcS</code> 脚本作为系统初始化的一部分。</p>\n<h2 id=\"etc-default-rcS\"><a href=\"#etc-default-rcS\" class=\"headerlink\" title=\"/etc/default/rcS\"></a>/etc/default/rcS</h2><pre><code class=\"c\">#\n#       /etc/rcS.d 中启动脚本的默认值\n#\n\n# 在 /tmp 中保留时间文件的天数。\nTMPTIME=0\n# 如果要在引导时启动 sulogin，请设置为 yes\nSULOGIN=no\n# 如果希望在系统启动完成之前（即 inetd 启动后）能够通过 telnet/rlogin 登录，请设置为 no\nDELAYLOGIN=no\n# 假定 BIOS 时钟设置为 UTC 时间（推荐）\nUTC=yes\n# 如果希望引导时更加安静，请将 VERBOSE 设置为 &quot;no&quot;\nVERBOSE=no\n# 如果不希望自动编辑 /etc/motd，请将 EDITMOTD 设置为 &quot;no&quot;\nEDITMOTD=no\n# 是否在引导时对根文件系统执行 fsck（文件系统检查）\nENABLE_ROOTFS_FSCK=no\n# 如果希望在启动时将 &quot;-y&quot; 添加到 fsck 命令，请将 FSCKFIX 设置为 &quot;yes&quot;\nFSCKFIX=yes\n# 将 TICKADJ 设置为适用于此特定机器的正确 tick 值\n#TICKADJ=10000\n# 在 populate-volatile.sh 中启用缓存\nVOLATILE_ENABLE_CACHE=yes\n# 指示根文件系统是否打算为只读。设置 ROOTFS_READ_ONLY 为 yes 并重新启动将使根文件系统变为只读。\n# 通常情况下，您不应更改此值。\nROOTFS_READ_ONLY=no\n</code></pre>\n<p>/etc/default/rcS 文件是一个配置文件，用于设置系统初始化过程中的默认参数和选项。该文件中的设置会影响系统引导和初始化的行为。在许多 Linux 发行版中，/etc/default/rcS 文件用于指定与系统启动过程有关的全局设置。</p>\n<h2 id=\"etc-init-d-rc\"><a href=\"#etc-init-d-rc\" class=\"headerlink\" title=\"/etc/init.d/rc\"></a>/etc/init.d/rc</h2><pre><code class=\"shell\">#!/bin/sh\n#\n# rc            当运行级别变化时，此文件负责启动/停止服务。\n#\n# 优化特性：\n# 在服务在前一个运行级别中正在运行且在运行级别转换中没有被停止时，_不会_运行启动脚本\n# （大多数 Debian 服务在 rc{1,2,3,4,5} 中没有 K?? 链接）\n#\n# 作者：Miquel van Smoorenburg &lt;miquels@cistron.nl&gt;\n#      Bruce Perens &lt;Bruce@Pixar.com&gt;\n#\n# 版本：@(#)rc  2.78  1999 年 11 月 7 日  miquels@cistron.nl\n#\n\n. /etc/default/rcS\nexport VERBOSE\n\nstartup_progress() {\n    step=$(($step + $step_change))\n    if [ &quot;$num_steps&quot; != &quot;0&quot; ]; then\n        progress=$((($step * $progress_size / $num_steps) + $first_step))\n    else\n        progress=$progress_size\n    fi\n    #echo &quot;PROGRESS is $progress $runlevel $first_step + ($step of $num_steps) $step_change $progress_size&quot;\n    if type psplash-write &gt;/dev/null 2&gt;&amp;1; then\n        TMPDIR=/mnt/.psplash psplash-write &quot;PROGRESS $progress&quot; || true\n    fi\n    #if [ -e /mnt/.psplash/psplash_fifo ]; then\n    #    echo &quot;PROGRESS $progress&quot; &gt; /mnt/.psplash/psplash_fifo\n    #fi\n}\n\nstartup() {\n  # 处理冗长性\n  [ &quot;$VERBOSE&quot; = very ] &amp;&amp; echo &quot;INIT: 正在运行 $@...&quot;\n\n  case &quot;$1&quot; in\n        *.sh)\n                # 为了提高速度，源码中的 shell 脚本。\n                (\n                        trap - INT QUIT TSTP\n                        scriptname=$1\n                        shift\n                        . $scriptname\n                )\n                ;;\n        *)\n                &quot;$@&quot;\n                ;;\n  esac\n  startup_progress\n}\n\n# 仅在此 shell 中忽略 CTRL-C，以便可以中断子进程。\ntrap &quot;:&quot; INT QUIT TSTP\n\n# 设置 onlcr 以避免楼梯效应。\nstty onlcr 0&gt;&amp;1\n\n# 限制启动脚本的栈大小\n[ &quot;$STACK_SIZE&quot; == &quot;&quot; ] || ulimit -S -s $STACK_SIZE\n\n# 现在找出当前运行级别和上一个运行级别是什么。\n\nrunlevel=$RUNLEVEL\n# 获取第一个参数。将新运行级别设置为此参数。\n[ &quot;$1&quot; != &quot;&quot; ] &amp;&amp; runlevel=$1\nif [ &quot;$runlevel&quot; = &quot;&quot; ]\nthen\n        echo &quot;用法：$0 &lt;运行级别&gt;&quot; &gt;&amp;2\n        exit 1\nfi\nprevious=$PREVLEVEL\n[ &quot;$previous&quot; = &quot;&quot; ] &amp;&amp; previous=N\n\nexport runlevel previous\n\n# 是否有适用于这个新运行级别的 rc 目录？\nif [ -d /etc/rc$runlevel.d ]\nthen\n        # 找出 initramfs 在进度条中的位置。\n        PROGRESS_STATE=0\n        #if [ -f /dev/.initramfs/progress_state ]; then\n        #    . /dev/.initramfs/progress_state\n        #fi\n\n        # 将进度条的剩余部分分为三份\n        progress_size=$(((100 - $PROGRESS_STATE) / 3))\n\n        case &quot;$runlevel&quot; in\n                0|6)\n                        # 从 -100 倒计时到 0，使用整个进度条\n                        first_step=-100\n                        progress_size=100\n                        step_change=1\n                        ;;\n                S)\n                        # 从 initramfs 剩余的位置开始，使用剩余空间的 2/3\n                        first_step=$PROGRESS_STATE\n                        progress_size=$(($progress_size * 2))\n                        step_change=1\n                        ;;\n                *)\n                        # 从 rcS 停止的位置开始，使用最后 1/3 的空间（通过保持 progress_size 不变）\n                        first_step=$(($progress_size * 2 + $PROGRESS_STATE))\n                        step_change=1\n                        ;;\n        esac\n\n        num_steps=0\n        for s in /etc/rc$runlevel.d/[SK]*; do\n            case &quot;${s##/etc/rc$runlevel.d/S??}&quot; in\n                gdm|xdm|kdm|reboot|halt)\n                    break\n                    ;;\n            esac\n            num_steps=$(($num_steps + 1))\n        done\n        step=0\n\n        # 首先，运行 KILL 脚本。\n        if [ $previous != N ]\n        then\n                for i in /etc/rc$runlevel.d/K[0-9][0-9]*\n                do\n                        # 检查脚本是否存在。\n                        [ ! -f $i ] &amp;&amp; continue\n\n                        # 停止服务。\n                        startup $i stop\n                done\n        fi\n\n        # 现在运行此运行级别的 START 脚本。\n        for i in /etc/rc$runlevel.d/S*\n        do\n                [ ! -f $i ] &amp;&amp; continue\n\n                if [ $previous != N ] &amp;&amp; [ $previous != S ]\n                then\n                        #\n                        # 在前一个运行级别中找到启动脚本和\n                        # 在这个运行级别中找到停止脚本。\n                        #\n                        suffix=${i#/etc/rc$runlevel.d/S[0-9][0-9]}\n                        stop=/etc/rc$runlevel.d/K[0-9][0-9]$suffix\n                        previous_start=/etc/rc$previous.d/S[0-9][0-9]$suffix\n                        #\n                        # 如果在上一个级别中有启动脚本\n                        # 并且在这个级别中没有停止脚本，我们就不需要重新启动服务。\n                        #\n                        [ -f $previous_start ] &amp;&amp; [ ! -f $stop ] &amp;&amp; continue\n                fi\n                case &quot;$runlevel&quot; in\n                        0|6)\n                                startup $i stop\n                                ;;\n                        *)\n                                startup $i start\n                                ;;\n                esac\n        done\n  fi\n\n# 取消注释以在手动退出 psplash，否则在看到 VC 切换时会退出\nif [ &quot;x$runlevel&quot; != &quot;xS&quot; ] &amp;&amp; [ ! -x /etc/rc${runlevel}.d/S??xserver-nodm ]; then\n    if type psplash-write &gt;/dev/null 2&gt;&amp;1; then\n        TMPDIR=/mnt/.psplash psplash-write &quot;QUIT&quot; || true\n        umount -l /mnt/.psplash\n    fi\nfi\n</code></pre>\n<p>由/etc/init.d/rc在执行等级切换的时候在/etc/rc$runlevel.d文件夹中启动相关程序，例如切换到runevel 5</p>\n<pre><code class=\"c\">root@ATK-IMX6U:/etc/rc5.d# ls -l\ntotal 0\nlrwxrwxrwx 1 root root 20 Jun 10 18:21 S01networking -&gt; ../init.d/networking\nlrwxrwxrwx 1 root root 22 Jun 10 18:21 S01xserver-nodm -&gt; ../init.d/xserver-nodm\nlrwxrwxrwx 1 root root 16 Jun 10 18:21 S02dbus-1 -&gt; ../init.d/dbus-1\nlrwxrwxrwx 1 root root 17 Jun 10 18:21 S05connman -&gt; ../init.d/connman\nlrwxrwxrwx 1 root root 18 Jun 10 18:21 S10dropbear -&gt; ../init.d/dropbear\nlrwxrwxrwx 1 root root 17 Jun 10 18:21 S12rpcbind -&gt; ../init.d/rpcbind\nlrwxrwxrwx 1 root root 21 Jun 10 18:21 S15mountnfs.sh -&gt; ../init.d/mountnfs.sh\nlrwxrwxrwx 1 root root 21 Jun 10 18:21 S15watchdog.sh -&gt; ../init.d/watchdog.sh\nlrwxrwxrwx 1 root root 19 Jun 10 18:21 S19nfscommon -&gt; ../init.d/nfscommon\nlrwxrwxrwx 1 root root 14 Jun 10 18:21 S20apmd -&gt; ../init.d/apmd\nlrwxrwxrwx 1 root root 13 Jun 10 18:21 S20atd -&gt; ../init.d/atd\nlrwxrwxrwx 1 root root 17 Jun 10 18:21 S20hostapd -&gt; ../init.d/hostapd\nlrwxrwxrwx 1 root root 20 Jun 10 18:21 S20hwclock.sh -&gt; ../init.d/hwclock.sh\nlrwxrwxrwx 1 root root 19 Jun 10 18:21 S20nfsserver -&gt; ../init.d/nfsserver\nlrwxrwxrwx 1 root root 16 Jun 10 18:21 S20syslog -&gt; ../init.d/syslog\nlrwxrwxrwx 1 root root 22 Jun 10 18:21 S21avahi-daemon -&gt; ../init.d/avahi-daemon\nlrwxrwxrwx 1 root root 15 Jun 10 18:21 S22ofono -&gt; ../init.d/ofono\nlrwxrwxrwx 1 root root 15 Jun 10 18:21 S64neard -&gt; ../init.d/neard\nlrwxrwxrwx 1 root root 16 Jun 10 18:21 S80vsftpd -&gt; ../init.d/vsftpd\nlrwxrwxrwx 1 root root 15 Jun 10 18:21 S90crond -&gt; ../init.d/crond\nlrwxrwxrwx 1 root root 15 Jun 10 18:21 S92nginx -&gt; ../init.d/nginx\nlrwxrwxrwx 1 root root 18 Jun 10 18:21 S99rc.local -&gt; ../init.d/rc.local\nlrwxrwxrwx 1 root root 22 Jun 10 18:21 S99rmnologin.sh -&gt; ../init.d/rmnologin.sh\nlrwxrwxrwx 1 root root 23 Jun 10 18:21 S99stop-bootlogd -&gt; ../init.d/stop-bootlogd\nroot@ATK-IMX6U:/etc/rc5.d# # diff  rc3.d/ rc5.d/\nOnly in rc3.d/: K01xserver-nodm\nOnly in rc5.d/: S01xserver-nodm\ndiff: rc3.d/S20hostapd: No such file or directory\ndiff: rc5.d/S20hostapd: No such file or directory\n</code></pre>\n<p><code>/etc/init.d/rc</code> 文件是一个启动脚本，用于在系统的不同运行级别（runlevel）之间切换时启动或停止服务。在许多 Linux 系统中，运行级别是系统运行状态的一个标识，不同的运行级别对应于不同的系统配置和功能。</p>\n<p>在传统的 SysV init 系统中，<code>/etc/init.d/rc</code> 脚本是一个管理系统运行级别的关键脚本。它接受一个参数，即目标运行级别，然后根据当前运行级别和目标运行级别执行必要的操作以启动或停止服务。这通常涉及启动或停止各种服务脚本（以脚本符号 S 或 K 开头的脚本），以实现系统的初始化或关机。</p>\n<p>具体而言，<code>/etc/init.d/rc</code> 脚本的主要功能包括：</p>\n<ol>\n<li><p><strong>判断运行级别：</strong> 根据脚本参数和当前运行级别，确定要切换到的目标运行级别。</p>\n</li>\n<li><p><strong>执行运行级别切换操作：</strong> 根据目标运行级别，执行一系列操作以启动或停止与该运行级别相关的服务。</p>\n</li>\n<li><p><strong>启动服务：</strong> 如果切换到一个新的运行级别，<code>rc</code> 脚本会依次启动以 <code>S</code> 开头的服务脚本。这些服务脚本负责启动系统所需的各种服务，如网络、文件系统挂载、系统日志等。</p>\n</li>\n<li><p><strong>停止服务：</strong> 如果切换到一个较低的运行级别，<code>rc</code> 脚本会依次停止以 <code>K</code> 开头的服务脚本。这些服务脚本负责停止系统中正在运行的服务。</p>\n</li>\n<li><p><strong>设置环境：</strong> <code>rc</code> 脚本可能会设置环境变量或其他参数，以便在运行服务脚本时传递所需的信息。</p>\n</li>\n</ol>\n<p>需要注意的是，随着现代 Linux 发行版的发展，许多系统已经转向使用 <code>systemd</code> 或其他更现代的初始化系统，而不再使用传统的 SysV init 系统。因此，<code>/etc/init.d/rc</code> 在一些新的发行版中可能已经不再起到关键的作用，而是由更现代的初始化系统负责管理运行级别和服务启动。</p>\n<p>如果你使用的是基于 SysV init 的系统，并且遇到了与 <code>/etc/init.d/rc</code> 相关的问题，你可能需要深入了解你的系统文档和初始化流程，以理解脚本是如何工作的以及如何进行定制。</p>\n"},{"title":"process-ksoftirqd","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-08-25T03:30:32.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"\n# ksoftirqd线程\n`ksoftirqd` 是一个内核线程，用于处理软中断（softirq）。软中断是一种低优先级的中断，与硬件中断（irq）相比，它们的优先级更低，不会直接打断正在执行的内核代码，而是在内核上下文中延迟处理。`ksoftirqd` 线程的主要任务是处理这些软中断。\n\n在Linux内核中，有多种软中断，每种都有不同的用途，例如网络处理、定时器处理、任务延迟等。以下是一些软中断的类型和用途：\n\n1. **NET_RX_SOFTIRQ：** 用于处理网络接收的数据包。当网络接口接收到数据包后，它会触发这个软中断，`ksoftirqd` 线程负责处理和处理这些数据包。\n\n2. **TIMER_SOFTIRQ：** 用于处理定时器事件。当一个定时器到期时，它会触发这个软中断，`ksoftirqd` 线程会执行相应的定时器处理函数。\n\n3. **TASKLET_SOFTIRQ：** 用于执行延迟处理的任务。这是一种低延迟的工作队列机制，用于处理需要在延迟上下文中执行的工作。\n\n4. **HI_SOFTIRQ：** 用于高优先级的软中断处理。这些软中断具有比普通软中断更高的优先级，通常用于处理紧急的任务。\n\n5. **RCU_SOFTIRQ：** 用于执行RCU（Read-Copy-Update）机制的回调。RCU是一种数据同步机制，用于在不阻塞读取操作的情况下更新共享数据结构。\n\n`ksoftirqd` 线程根据软中断的优先级处理这些不同类型的软中断。每个 CPU 内核都有一个对应的 `ksoftirqd` 线程，例如 `ksoftirqd/0` 表示第一个 CPU 的 `ksoftirqd` 线程。这些线程的任务是根据需要处理软中断，以确保内核能够高效地响应各种中断事件。\n\n# ksoftirqd源码\nkernel/softirq.c: spawn_ksoftirqd()--->smpboot_register_percpu_thread()--->__smpboot_create_thread()--->kthread_create_on_cpu()--->kthread_create_on_node()--->list_add_tail(&create->list, &kthread_create_list)<---kthread进程\n```c\nstatic __init int spawn_ksoftirqd(void)\n{\n    // 注册 CPU 通知器，以便在 CPU 状态发生变化时进行通知\n    register_cpu_notifier(&cpu_nfb);\n\n    // 注册软中断线程\n    // 使用 smpboot_register_percpu_thread() 函数在每个 CPU 内核上注册一个软中断线程\n    BUG_ON(smpboot_register_percpu_thread(&softirq_threads));\n\n    return 0;\n}\n// 在早期初始化阶段调用 spawn_ksoftirqd 函数\nearly_initcall(spawn_ksoftirqd);\n```\n```c\n/**\n * smpboot_register_percpu_thread - 注册与热插拔相关的 per_cpu 线程\n * @plug_thread: 热插拔线程描述符\n *\n * 在所有在线 CPU 上创建并启动线程。\n */\nint smpboot_register_percpu_thread(struct smp_hotplug_thread *plug_thread)\n{\n    unsigned int cpu;\n    int ret = 0;\n\n    // 获取在线的 CPU\n    get_online_cpus();\n    mutex_lock(&smpboot_threads_lock);\n    \n    // 遍历所有在线的 CPU\n    for_each_online_cpu(cpu) {\n        // 创建并启动线程\n        ret = __smpboot_create_thread(plug_thread, cpu);\n        if (ret) {\n            // 创建失败，销毁已创建的线程\n            smpboot_destroy_threads(plug_thread);\n            goto out;\n        }\n        \n        // 启动线程\n        smpboot_unpark_thread(plug_thread, cpu);\n    }\n    \n    // 将线程描述符添加到热插拔线程列表\n    list_add(&plug_thread->list, &hotplug_threads);\n\nout:\n    mutex_unlock(&smpboot_threads_lock);\n    // 释放在线 CPU\n    put_online_cpus();\n    return ret;\n}\nEXPORT_SYMBOL_GPL(smpboot_register_percpu_thread);\n```\n```c\nstatic int\n__smpboot_create_thread(struct smp_hotplug_thread *ht, unsigned int cpu)\n{\n    struct task_struct *tsk = *per_cpu_ptr(ht->store, cpu);\n    struct smpboot_thread_data *td;\n\n    // 如果在该 CPU 上已经存在一个任务（线程），则不需要再创建\n    if (tsk)\n        return 0;\n\n    // 为 smpboot_thread_data 结构体分配内存并初始化为零\n    td = kzalloc_node(sizeof(*td), GFP_KERNEL, cpu_to_node(cpu));\n    if (!td)\n        return -ENOMEM;\n    td->cpu = cpu;\n    td->ht = ht;\n\n    // 在指定的 CPU 上创建内核线程，使用 smpboot_thread_fn 作为线程函数\n    tsk = kthread_create_on_cpu(smpboot_thread_fn, td, cpu, ht->thread_comm);\n    if (IS_ERR(tsk)) {\n        // 创建失败，释放分配的内存并返回错误代码\n        kfree(td);\n        return PTR_ERR(tsk);\n    }\n\n    // 增加线程的引用计数\n    get_task_struct(tsk);\n    // 将线程指针保存到指定 CPU 的 ht->store 中\n    *per_cpu_ptr(ht->store, cpu) = tsk;\n\n    if (ht->create) {\n        /*\n         * 确保任务实际上已经进入了停放位置，然后再调用创建回调函数。\n         * 至少迁移线程回调要求任务已经离开了运行队列。\n         */\n        if (!wait_task_inactive(tsk, TASK_PARKED))\n            WARN_ON(1); // 若未成功进入停放状态，则发出警告\n        else\n            ht->create(cpu); // 执行创建回调函数\n    }\n\n    return 0;\n}\n```\n```c\n/**\n * kthread_create_on_cpu - 在指定 CPU 上创建内核线程\n * @threadfn: 线程函数\n * @data: 传递给线程函数的数据指针\n * @cpu: 要创建线程的目标 CPU\n * @namefmt: 线程名称的格式字符串\n *\n * 在指定的 CPU 上创建一个内核线程。\n * \n * 返回：指向新创建线程的 task_struct 结构体指针，或者错误指针。\n */\nstruct task_struct *kthread_create_on_cpu(int (*threadfn)(void *data),\n                                          void *data, unsigned int cpu,\n                                          const char *namefmt)\n{\n    struct task_struct *p;\n\n    // 在指定的 NUMA 节点上创建内核线程\n    p = kthread_create_on_node(threadfn, data, cpu_to_node(cpu), namefmt,\n                               cpu);\n    if (IS_ERR(p))\n        return p;\n\n    // 设置线程为 per_cpu 线程，标志位 KTHREAD_IS_PER_CPU\n    set_bit(KTHREAD_IS_PER_CPU, &to_kthread(p)->flags);\n    // 设置线程的 CPU 属性\n    to_kthread(p)->cpu = cpu;\n    /* 将线程停放以将其从 TASK_UNINTERRUPTIBLE 状态移出 */\n    kthread_park(p);\n    return p;\n}\n```\n\n```c\n/**\n * kthread_create_on_node - 在指定 NUMA 节点上创建内核线程\n * @threadfn: 线程函数\n * @data: 传递给线程函数的数据指针\n * @node: 要创建线程的目标 NUMA 节点\n * @namefmt: 线程名称的格式字符串\n * @...: 可变参数列表\n *\n * 在指定的 NUMA 节点上创建一个内核线程。此函数会创建一个 kthread_create_info 结构体，\n * 初始化线程相关的信息，并将线程请求添加到 kthread_create_list 中，然后唤醒 kthreadd_task\n * 来处理线程的创建。\n * \n * 返回：指向新创建线程的 task_struct 结构体指针，或者错误指针。\n */\nstruct task_struct *kthread_create_on_node(int (*threadfn)(void *data),\n                                           void *data, int node,\n                                           const char namefmt[],\n                                           ...)\n{\n    DECLARE_COMPLETION_ONSTACK(done);\n    struct task_struct *task;\n    struct kthread_create_info *create = kmalloc(sizeof(*create), GFP_KERNEL);\n\n    if (!create)\n        return ERR_PTR(-ENOMEM);\n    create->threadfn = threadfn;\n    create->data = data;\n    create->node = node;\n    create->done = &done;\n\n    spin_lock(&kthread_create_lock);\n    // 将线程创建请求添加到 kthread_create_list 中\n    list_add_tail(&create->list, &kthread_create_list);\n    spin_unlock(&kthread_create_lock);\n\n    // 唤醒 kthreadd_task 来处理线程的创建\n    wake_up_process(kthreadd_task);\n    /*\n     * 在可终止状态下等待完成，因为可能会在 kthreadd 尝试为新内核线程分配内存时\n     * 被 OOM 杀手选择。\n     */\n    if (unlikely(wait_for_completion_killable(&done))) {\n        /*\n         * 如果在 kthreadd（或新内核线程）调用 complete() 之前收到 SIGKILL 信号，\n         * 则将对此结构体的清理留给那个线程。\n         */\n        if (xchg(&create->done, NULL))\n            return ERR_PTR(-EINTR);\n        /*\n         * kthreadd（或新内核线程）将会很快调用 complete()。\n         */\n        wait_for_completion(&done);\n    }\n    task = create->result;\n    if (!IS_ERR(task)) {\n        static const struct sched_param param = { .sched_priority = 0 };\n        va_list args;\n\n        va_start(args, namefmt);\n        vsnprintf(task->comm, sizeof(task->comm), namefmt, args);\n        va_end(args);\n        /*\n         * root 可能会更改我们（kthreadd 的）优先级或 CPU 掩码。\n         * 内核线程不应继承这些属性。\n         */\n        sched_setscheduler_nocheck(task, SCHED_NORMAL, &param);\n        set_cpus_allowed_ptr(task, cpu_all_mask);\n    }\n    kfree(create);\n    return task;\n}\nEXPORT_SYMBOL(kthread_create_on_node);\n```\nlist_add_tail(&create->list, &kthread_create_list)就是将每个cpu创建一个软中断并添加到kthread_create_list链表中，由kthread线程初始化。所以你的ps -A --forest会出现ksoftirqd/x。\n\n# softirq函数\nrun_ksoftirqd()--->__do_softirq()--->softirq_vec[...].actions--->用户注册的软中断\n```c\nstatic struct smp_hotplug_thread softirq_threads = {\n\t.store\t\t\t= &ksoftirqd,\n\t.thread_should_run\t= ksoftirqd_should_run,\n\t.thread_fn\t\t= run_ksoftirqd,\n\t.thread_comm\t\t= \"ksoftirqd/%u\",\n};\n```\n传递给kthread创建的线程结构体\n```c\n/**\n * run_ksoftirqd - 在指定 CPU 上运行软中断处理程序\n * @cpu: 目标 CPU 的编号\n *\n * 在给定的 CPU 上运行软中断（softirq）处理程序，用于处理一些低优先级的中断任务。\n * \n * 该函数会先禁用本地中断，然后检查是否有待处理的软中断。如果有，它会调用 __do_softirq() 函数\n * 来运行软中断处理程序，处理各种不同类型的软中断任务。然后，它重新启用本地中断，允许其他中断继续发生。\n * 如果在软中断运行期间需要进行 RCU（Read-Copy-Update）的切换，函数会在必要时调度其他任务，\n * 以确保 RCU 安全切换。\n */\nstatic void run_ksoftirqd(unsigned int cpu)\n{\n    local_irq_disable(); // 禁用本地中断，确保软中断期间不会被其他中断打断\n\n    if (local_softirq_pending()) {\n        /*\n         * 我们可以在内联栈上安全运行软中断，\n         * 因为我们在这里不深入到任务堆栈中。\n         */\n        __do_softirq(); // 运行软中断处理程序\n        local_irq_enable(); // 重新启用本地中断\n        cond_resched_rcu_qs(); // 在需要时调度其他任务以确保 RCU 安全切换\n        return;\n    }\n\n    local_irq_enable(); // 重新启用本地中断\n}\n```\n```c\n/**\n * __do_softirq - 执行软中断处理程序\n *\n * 此函数用于在内核中运行软中断（softirq）的处理程序。软中断是一种低优先级的中断，\n * 用于处理一些延迟敏感但不需要立即响应的任务。该函数负责按顺序执行挂起的软中断，\n * 并在处理每个软中断时调用相应的处理函数。\n */\nasmlinkage __visible void __do_softirq(void)\n{\n    // 计算软中断处理的最大时间\n    unsigned long end = jiffies + MAX_SOFTIRQ_TIME;\n    // 保存旧的任务标志\n    unsigned long old_flags = current->flags;\n    // 最大允许重新启动次数\n    int max_restart = MAX_SOFTIRQ_RESTART;\n    // 指向软中断处理程序\n    struct softirq_action *h;\n    // 是否在硬中断上下文中\n    bool in_hardirq;\n    // 待处理的软中断位掩码\n    __u32 pending;\n    // 待处理的软中断位\n    int softirq_bit;\n\n    /* 屏蔽 PF_MEMALLOC，因为当前任务上下文被借用用于软中断处理。 */\n    current->flags &= ~PF_MEMALLOC;\n\n    // 获取待处理的软中断位掩码\n    pending = local_softirq_pending();\n    // 记录进入软中断处理的时间\n    account_irq_enter_time(current);\n\n    // 关闭本地底半部中断，开始软中断处理\n    __local_bh_disable_ip(_RET_IP_, SOFTIRQ_OFFSET);\n    // 开始跟踪软中断\n    in_hardirq = lockdep_softirq_start();\n\nrestart:\n    // 在启用 IRQ 之前重置挂起的位掩码\n    set_softirq_pending(0);\n\n    // 启用本地中断\n    local_irq_enable();\n\n    // 获取软中断处理程序向量的起始地址\n    h = softirq_vec;\n\n    // 逐个处理待处理的软中断\n    while ((softirq_bit = ffs(pending))) {\n        unsigned int vec_nr;\n        int prev_count;\n\n        // 选择要处理的软中断\n        h += softirq_bit - 1;\n        // 获取软中断号\n        vec_nr = h - softirq_vec;\n        // 保存进入软中断前的抢占计数\n        prev_count = preempt_count();\n\n        // 增加本 CPU 上的软中断计数\n        kstat_incr_softirqs_this_cpu(vec_nr);\n\n        // 跟踪软中断进入\n        trace_softirq_entry(vec_nr);\n        // 调用软中断处理函数\n        h->action(h);\n        // 跟踪软中断退出\n        trace_softirq_exit(vec_nr);\n        \n        // 检查软中断期间抢占计数的变化\n        if (unlikely(prev_count != preempt_count())) {\n            pr_err(\"huh, entered softirq %u %s %p with preempt_count %08x, exited with %08x?\\n\",\n                   vec_nr, softirq_to_name[vec_nr], h->action,\n                   prev_count, preempt_count());\n            preempt_count_set(prev_count);\n        }\n        // 移动到下一个软中断\n        h++;\n        // 清除已处理的软中断位\n        pending >>= softirq_bit;\n    }\n\n    // 在软中断处理完成后，执行 RCU 切换\n    rcu_bh_qs();\n    // 关闭本地中断\n    local_irq_disable();\n\n    // 再次获取待处理的软中断位掩码\n    pending = local_softirq_pending();\n    // 如果仍有未处理的软中断\n    if (pending) {\n        // 如果尚未超过最大处理时间，并且不需要任务调度，并且还可以重新尝试处理\n        if (time_before(jiffies, end) && !need_resched() && --max_restart)\n            goto restart;\n\n        // 唤醒软中断线程（ksoftirqd）\n        wakeup_softirqd();\n    }\n\n    // 结束软中断处理\n    lockdep_softirq_end(in_hardirq);\n    // 记录退出软中断处理的时间\n    account_irq_exit_time(current);\n    // 启用底半部中断\n    __local_bh_enable(SOFTIRQ_OFFSET);\n    // 在软中断处理后，不应该仍处于硬中断上下文中\n    WARN_ON_ONCE(in_interrupt());\n    // 恢复任务的标志和状态\n    tsk_restore_flags(current, old_flags, PF_MEMALLOC);\n}\n```\n```c\nstatic struct softirq_action softirq_vec[NR_SOFTIRQS] __cacheline_aligned_in_smp;\n```\nkernel/softirq.c定义了一个数组 `softirq_vec`，用于存储软中断（softirq）处理程序的函数指针。逐步解释其中的每个部分：\n\n1. `static`：这个关键字指示变量 `softirq_vec` 的作用范围仅限于当前文件。它是一个静态变量，意味着其生命周期从程序启动到终止，不会在不同的函数调用之间失去其值。\n\n2. `struct softirq_action`：这是一个结构体类型，用于存储软中断处理程序的信息。它包含了一个函数指针 `action`，指向一个具体的软中断处理函数。\n\n3. `softirq_vec[NR_SOFTIRQS]`：这是一个数组，长度为 `NR_SOFTIRQS`，它定义了一个能够容纳多个软中断处理程序的存储空间。每个元素都是一个 `struct softirq_action` 类型的结构体，其中存储了软中断处理函数的指针。\n\n4. `__cacheline_aligned_in_smp`：这个属性指示编译器在 SMP（对称多处理器）系统上，将 `softirq_vec` 数据结构对齐到 CPU 缓存行的边界，以提高访问性能。这是一种优化，可以减少因为不必要的缓存行填充而造成的性能损失。\n\n`softirq_vec`，用于存储软中断处理程序的函数指针。每个软中断在数组中对应一个元素，该元素包含了指向具体软中断处理函数的指针。这种机制允许内核注册多个不同类型的软中断处理程序，并在适当的时候调用这些函数来执行相应的任务。","source":"_posts/2023/08/process-ksoftirqd.md","raw":"---\ntitle: process-ksoftirqd\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-08-25 11:30:32\npassword:\nsummary:\ntags:\n- linux\n- process\ncategories:\n- process\n- linux\nkeywords:\ndescription:\n---\n\n# ksoftirqd线程\n`ksoftirqd` 是一个内核线程，用于处理软中断（softirq）。软中断是一种低优先级的中断，与硬件中断（irq）相比，它们的优先级更低，不会直接打断正在执行的内核代码，而是在内核上下文中延迟处理。`ksoftirqd` 线程的主要任务是处理这些软中断。\n\n在Linux内核中，有多种软中断，每种都有不同的用途，例如网络处理、定时器处理、任务延迟等。以下是一些软中断的类型和用途：\n\n1. **NET_RX_SOFTIRQ：** 用于处理网络接收的数据包。当网络接口接收到数据包后，它会触发这个软中断，`ksoftirqd` 线程负责处理和处理这些数据包。\n\n2. **TIMER_SOFTIRQ：** 用于处理定时器事件。当一个定时器到期时，它会触发这个软中断，`ksoftirqd` 线程会执行相应的定时器处理函数。\n\n3. **TASKLET_SOFTIRQ：** 用于执行延迟处理的任务。这是一种低延迟的工作队列机制，用于处理需要在延迟上下文中执行的工作。\n\n4. **HI_SOFTIRQ：** 用于高优先级的软中断处理。这些软中断具有比普通软中断更高的优先级，通常用于处理紧急的任务。\n\n5. **RCU_SOFTIRQ：** 用于执行RCU（Read-Copy-Update）机制的回调。RCU是一种数据同步机制，用于在不阻塞读取操作的情况下更新共享数据结构。\n\n`ksoftirqd` 线程根据软中断的优先级处理这些不同类型的软中断。每个 CPU 内核都有一个对应的 `ksoftirqd` 线程，例如 `ksoftirqd/0` 表示第一个 CPU 的 `ksoftirqd` 线程。这些线程的任务是根据需要处理软中断，以确保内核能够高效地响应各种中断事件。\n\n# ksoftirqd源码\nkernel/softirq.c: spawn_ksoftirqd()--->smpboot_register_percpu_thread()--->__smpboot_create_thread()--->kthread_create_on_cpu()--->kthread_create_on_node()--->list_add_tail(&create->list, &kthread_create_list)<---kthread进程\n```c\nstatic __init int spawn_ksoftirqd(void)\n{\n    // 注册 CPU 通知器，以便在 CPU 状态发生变化时进行通知\n    register_cpu_notifier(&cpu_nfb);\n\n    // 注册软中断线程\n    // 使用 smpboot_register_percpu_thread() 函数在每个 CPU 内核上注册一个软中断线程\n    BUG_ON(smpboot_register_percpu_thread(&softirq_threads));\n\n    return 0;\n}\n// 在早期初始化阶段调用 spawn_ksoftirqd 函数\nearly_initcall(spawn_ksoftirqd);\n```\n```c\n/**\n * smpboot_register_percpu_thread - 注册与热插拔相关的 per_cpu 线程\n * @plug_thread: 热插拔线程描述符\n *\n * 在所有在线 CPU 上创建并启动线程。\n */\nint smpboot_register_percpu_thread(struct smp_hotplug_thread *plug_thread)\n{\n    unsigned int cpu;\n    int ret = 0;\n\n    // 获取在线的 CPU\n    get_online_cpus();\n    mutex_lock(&smpboot_threads_lock);\n    \n    // 遍历所有在线的 CPU\n    for_each_online_cpu(cpu) {\n        // 创建并启动线程\n        ret = __smpboot_create_thread(plug_thread, cpu);\n        if (ret) {\n            // 创建失败，销毁已创建的线程\n            smpboot_destroy_threads(plug_thread);\n            goto out;\n        }\n        \n        // 启动线程\n        smpboot_unpark_thread(plug_thread, cpu);\n    }\n    \n    // 将线程描述符添加到热插拔线程列表\n    list_add(&plug_thread->list, &hotplug_threads);\n\nout:\n    mutex_unlock(&smpboot_threads_lock);\n    // 释放在线 CPU\n    put_online_cpus();\n    return ret;\n}\nEXPORT_SYMBOL_GPL(smpboot_register_percpu_thread);\n```\n```c\nstatic int\n__smpboot_create_thread(struct smp_hotplug_thread *ht, unsigned int cpu)\n{\n    struct task_struct *tsk = *per_cpu_ptr(ht->store, cpu);\n    struct smpboot_thread_data *td;\n\n    // 如果在该 CPU 上已经存在一个任务（线程），则不需要再创建\n    if (tsk)\n        return 0;\n\n    // 为 smpboot_thread_data 结构体分配内存并初始化为零\n    td = kzalloc_node(sizeof(*td), GFP_KERNEL, cpu_to_node(cpu));\n    if (!td)\n        return -ENOMEM;\n    td->cpu = cpu;\n    td->ht = ht;\n\n    // 在指定的 CPU 上创建内核线程，使用 smpboot_thread_fn 作为线程函数\n    tsk = kthread_create_on_cpu(smpboot_thread_fn, td, cpu, ht->thread_comm);\n    if (IS_ERR(tsk)) {\n        // 创建失败，释放分配的内存并返回错误代码\n        kfree(td);\n        return PTR_ERR(tsk);\n    }\n\n    // 增加线程的引用计数\n    get_task_struct(tsk);\n    // 将线程指针保存到指定 CPU 的 ht->store 中\n    *per_cpu_ptr(ht->store, cpu) = tsk;\n\n    if (ht->create) {\n        /*\n         * 确保任务实际上已经进入了停放位置，然后再调用创建回调函数。\n         * 至少迁移线程回调要求任务已经离开了运行队列。\n         */\n        if (!wait_task_inactive(tsk, TASK_PARKED))\n            WARN_ON(1); // 若未成功进入停放状态，则发出警告\n        else\n            ht->create(cpu); // 执行创建回调函数\n    }\n\n    return 0;\n}\n```\n```c\n/**\n * kthread_create_on_cpu - 在指定 CPU 上创建内核线程\n * @threadfn: 线程函数\n * @data: 传递给线程函数的数据指针\n * @cpu: 要创建线程的目标 CPU\n * @namefmt: 线程名称的格式字符串\n *\n * 在指定的 CPU 上创建一个内核线程。\n * \n * 返回：指向新创建线程的 task_struct 结构体指针，或者错误指针。\n */\nstruct task_struct *kthread_create_on_cpu(int (*threadfn)(void *data),\n                                          void *data, unsigned int cpu,\n                                          const char *namefmt)\n{\n    struct task_struct *p;\n\n    // 在指定的 NUMA 节点上创建内核线程\n    p = kthread_create_on_node(threadfn, data, cpu_to_node(cpu), namefmt,\n                               cpu);\n    if (IS_ERR(p))\n        return p;\n\n    // 设置线程为 per_cpu 线程，标志位 KTHREAD_IS_PER_CPU\n    set_bit(KTHREAD_IS_PER_CPU, &to_kthread(p)->flags);\n    // 设置线程的 CPU 属性\n    to_kthread(p)->cpu = cpu;\n    /* 将线程停放以将其从 TASK_UNINTERRUPTIBLE 状态移出 */\n    kthread_park(p);\n    return p;\n}\n```\n\n```c\n/**\n * kthread_create_on_node - 在指定 NUMA 节点上创建内核线程\n * @threadfn: 线程函数\n * @data: 传递给线程函数的数据指针\n * @node: 要创建线程的目标 NUMA 节点\n * @namefmt: 线程名称的格式字符串\n * @...: 可变参数列表\n *\n * 在指定的 NUMA 节点上创建一个内核线程。此函数会创建一个 kthread_create_info 结构体，\n * 初始化线程相关的信息，并将线程请求添加到 kthread_create_list 中，然后唤醒 kthreadd_task\n * 来处理线程的创建。\n * \n * 返回：指向新创建线程的 task_struct 结构体指针，或者错误指针。\n */\nstruct task_struct *kthread_create_on_node(int (*threadfn)(void *data),\n                                           void *data, int node,\n                                           const char namefmt[],\n                                           ...)\n{\n    DECLARE_COMPLETION_ONSTACK(done);\n    struct task_struct *task;\n    struct kthread_create_info *create = kmalloc(sizeof(*create), GFP_KERNEL);\n\n    if (!create)\n        return ERR_PTR(-ENOMEM);\n    create->threadfn = threadfn;\n    create->data = data;\n    create->node = node;\n    create->done = &done;\n\n    spin_lock(&kthread_create_lock);\n    // 将线程创建请求添加到 kthread_create_list 中\n    list_add_tail(&create->list, &kthread_create_list);\n    spin_unlock(&kthread_create_lock);\n\n    // 唤醒 kthreadd_task 来处理线程的创建\n    wake_up_process(kthreadd_task);\n    /*\n     * 在可终止状态下等待完成，因为可能会在 kthreadd 尝试为新内核线程分配内存时\n     * 被 OOM 杀手选择。\n     */\n    if (unlikely(wait_for_completion_killable(&done))) {\n        /*\n         * 如果在 kthreadd（或新内核线程）调用 complete() 之前收到 SIGKILL 信号，\n         * 则将对此结构体的清理留给那个线程。\n         */\n        if (xchg(&create->done, NULL))\n            return ERR_PTR(-EINTR);\n        /*\n         * kthreadd（或新内核线程）将会很快调用 complete()。\n         */\n        wait_for_completion(&done);\n    }\n    task = create->result;\n    if (!IS_ERR(task)) {\n        static const struct sched_param param = { .sched_priority = 0 };\n        va_list args;\n\n        va_start(args, namefmt);\n        vsnprintf(task->comm, sizeof(task->comm), namefmt, args);\n        va_end(args);\n        /*\n         * root 可能会更改我们（kthreadd 的）优先级或 CPU 掩码。\n         * 内核线程不应继承这些属性。\n         */\n        sched_setscheduler_nocheck(task, SCHED_NORMAL, &param);\n        set_cpus_allowed_ptr(task, cpu_all_mask);\n    }\n    kfree(create);\n    return task;\n}\nEXPORT_SYMBOL(kthread_create_on_node);\n```\nlist_add_tail(&create->list, &kthread_create_list)就是将每个cpu创建一个软中断并添加到kthread_create_list链表中，由kthread线程初始化。所以你的ps -A --forest会出现ksoftirqd/x。\n\n# softirq函数\nrun_ksoftirqd()--->__do_softirq()--->softirq_vec[...].actions--->用户注册的软中断\n```c\nstatic struct smp_hotplug_thread softirq_threads = {\n\t.store\t\t\t= &ksoftirqd,\n\t.thread_should_run\t= ksoftirqd_should_run,\n\t.thread_fn\t\t= run_ksoftirqd,\n\t.thread_comm\t\t= \"ksoftirqd/%u\",\n};\n```\n传递给kthread创建的线程结构体\n```c\n/**\n * run_ksoftirqd - 在指定 CPU 上运行软中断处理程序\n * @cpu: 目标 CPU 的编号\n *\n * 在给定的 CPU 上运行软中断（softirq）处理程序，用于处理一些低优先级的中断任务。\n * \n * 该函数会先禁用本地中断，然后检查是否有待处理的软中断。如果有，它会调用 __do_softirq() 函数\n * 来运行软中断处理程序，处理各种不同类型的软中断任务。然后，它重新启用本地中断，允许其他中断继续发生。\n * 如果在软中断运行期间需要进行 RCU（Read-Copy-Update）的切换，函数会在必要时调度其他任务，\n * 以确保 RCU 安全切换。\n */\nstatic void run_ksoftirqd(unsigned int cpu)\n{\n    local_irq_disable(); // 禁用本地中断，确保软中断期间不会被其他中断打断\n\n    if (local_softirq_pending()) {\n        /*\n         * 我们可以在内联栈上安全运行软中断，\n         * 因为我们在这里不深入到任务堆栈中。\n         */\n        __do_softirq(); // 运行软中断处理程序\n        local_irq_enable(); // 重新启用本地中断\n        cond_resched_rcu_qs(); // 在需要时调度其他任务以确保 RCU 安全切换\n        return;\n    }\n\n    local_irq_enable(); // 重新启用本地中断\n}\n```\n```c\n/**\n * __do_softirq - 执行软中断处理程序\n *\n * 此函数用于在内核中运行软中断（softirq）的处理程序。软中断是一种低优先级的中断，\n * 用于处理一些延迟敏感但不需要立即响应的任务。该函数负责按顺序执行挂起的软中断，\n * 并在处理每个软中断时调用相应的处理函数。\n */\nasmlinkage __visible void __do_softirq(void)\n{\n    // 计算软中断处理的最大时间\n    unsigned long end = jiffies + MAX_SOFTIRQ_TIME;\n    // 保存旧的任务标志\n    unsigned long old_flags = current->flags;\n    // 最大允许重新启动次数\n    int max_restart = MAX_SOFTIRQ_RESTART;\n    // 指向软中断处理程序\n    struct softirq_action *h;\n    // 是否在硬中断上下文中\n    bool in_hardirq;\n    // 待处理的软中断位掩码\n    __u32 pending;\n    // 待处理的软中断位\n    int softirq_bit;\n\n    /* 屏蔽 PF_MEMALLOC，因为当前任务上下文被借用用于软中断处理。 */\n    current->flags &= ~PF_MEMALLOC;\n\n    // 获取待处理的软中断位掩码\n    pending = local_softirq_pending();\n    // 记录进入软中断处理的时间\n    account_irq_enter_time(current);\n\n    // 关闭本地底半部中断，开始软中断处理\n    __local_bh_disable_ip(_RET_IP_, SOFTIRQ_OFFSET);\n    // 开始跟踪软中断\n    in_hardirq = lockdep_softirq_start();\n\nrestart:\n    // 在启用 IRQ 之前重置挂起的位掩码\n    set_softirq_pending(0);\n\n    // 启用本地中断\n    local_irq_enable();\n\n    // 获取软中断处理程序向量的起始地址\n    h = softirq_vec;\n\n    // 逐个处理待处理的软中断\n    while ((softirq_bit = ffs(pending))) {\n        unsigned int vec_nr;\n        int prev_count;\n\n        // 选择要处理的软中断\n        h += softirq_bit - 1;\n        // 获取软中断号\n        vec_nr = h - softirq_vec;\n        // 保存进入软中断前的抢占计数\n        prev_count = preempt_count();\n\n        // 增加本 CPU 上的软中断计数\n        kstat_incr_softirqs_this_cpu(vec_nr);\n\n        // 跟踪软中断进入\n        trace_softirq_entry(vec_nr);\n        // 调用软中断处理函数\n        h->action(h);\n        // 跟踪软中断退出\n        trace_softirq_exit(vec_nr);\n        \n        // 检查软中断期间抢占计数的变化\n        if (unlikely(prev_count != preempt_count())) {\n            pr_err(\"huh, entered softirq %u %s %p with preempt_count %08x, exited with %08x?\\n\",\n                   vec_nr, softirq_to_name[vec_nr], h->action,\n                   prev_count, preempt_count());\n            preempt_count_set(prev_count);\n        }\n        // 移动到下一个软中断\n        h++;\n        // 清除已处理的软中断位\n        pending >>= softirq_bit;\n    }\n\n    // 在软中断处理完成后，执行 RCU 切换\n    rcu_bh_qs();\n    // 关闭本地中断\n    local_irq_disable();\n\n    // 再次获取待处理的软中断位掩码\n    pending = local_softirq_pending();\n    // 如果仍有未处理的软中断\n    if (pending) {\n        // 如果尚未超过最大处理时间，并且不需要任务调度，并且还可以重新尝试处理\n        if (time_before(jiffies, end) && !need_resched() && --max_restart)\n            goto restart;\n\n        // 唤醒软中断线程（ksoftirqd）\n        wakeup_softirqd();\n    }\n\n    // 结束软中断处理\n    lockdep_softirq_end(in_hardirq);\n    // 记录退出软中断处理的时间\n    account_irq_exit_time(current);\n    // 启用底半部中断\n    __local_bh_enable(SOFTIRQ_OFFSET);\n    // 在软中断处理后，不应该仍处于硬中断上下文中\n    WARN_ON_ONCE(in_interrupt());\n    // 恢复任务的标志和状态\n    tsk_restore_flags(current, old_flags, PF_MEMALLOC);\n}\n```\n```c\nstatic struct softirq_action softirq_vec[NR_SOFTIRQS] __cacheline_aligned_in_smp;\n```\nkernel/softirq.c定义了一个数组 `softirq_vec`，用于存储软中断（softirq）处理程序的函数指针。逐步解释其中的每个部分：\n\n1. `static`：这个关键字指示变量 `softirq_vec` 的作用范围仅限于当前文件。它是一个静态变量，意味着其生命周期从程序启动到终止，不会在不同的函数调用之间失去其值。\n\n2. `struct softirq_action`：这是一个结构体类型，用于存储软中断处理程序的信息。它包含了一个函数指针 `action`，指向一个具体的软中断处理函数。\n\n3. `softirq_vec[NR_SOFTIRQS]`：这是一个数组，长度为 `NR_SOFTIRQS`，它定义了一个能够容纳多个软中断处理程序的存储空间。每个元素都是一个 `struct softirq_action` 类型的结构体，其中存储了软中断处理函数的指针。\n\n4. `__cacheline_aligned_in_smp`：这个属性指示编译器在 SMP（对称多处理器）系统上，将 `softirq_vec` 数据结构对齐到 CPU 缓存行的边界，以提高访问性能。这是一种优化，可以减少因为不必要的缓存行填充而造成的性能损失。\n\n`softirq_vec`，用于存储软中断处理程序的函数指针。每个软中断在数组中对应一个元素，该元素包含了指向具体软中断处理函数的指针。这种机制允许内核注册多个不同类型的软中断处理程序，并在适当的时候调用这些函数来执行相应的任务。","slug":"process-ksoftirqd","published":1,"updated":"2024-01-05T08:12:19.806Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clru1g21u002es4fuvy9zlc3p","content":"<h1 id=\"ksoftirqd线程\"><a href=\"#ksoftirqd线程\" class=\"headerlink\" title=\"ksoftirqd线程\"></a>ksoftirqd线程</h1><p><code>ksoftirqd</code> 是一个内核线程，用于处理软中断（softirq）。软中断是一种低优先级的中断，与硬件中断（irq）相比，它们的优先级更低，不会直接打断正在执行的内核代码，而是在内核上下文中延迟处理。<code>ksoftirqd</code> 线程的主要任务是处理这些软中断。</p>\n<p>在Linux内核中，有多种软中断，每种都有不同的用途，例如网络处理、定时器处理、任务延迟等。以下是一些软中断的类型和用途：</p>\n<ol>\n<li><p><strong>NET_RX_SOFTIRQ：</strong> 用于处理网络接收的数据包。当网络接口接收到数据包后，它会触发这个软中断，<code>ksoftirqd</code> 线程负责处理和处理这些数据包。</p>\n</li>\n<li><p><strong>TIMER_SOFTIRQ：</strong> 用于处理定时器事件。当一个定时器到期时，它会触发这个软中断，<code>ksoftirqd</code> 线程会执行相应的定时器处理函数。</p>\n</li>\n<li><p><strong>TASKLET_SOFTIRQ：</strong> 用于执行延迟处理的任务。这是一种低延迟的工作队列机制，用于处理需要在延迟上下文中执行的工作。</p>\n</li>\n<li><p><strong>HI_SOFTIRQ：</strong> 用于高优先级的软中断处理。这些软中断具有比普通软中断更高的优先级，通常用于处理紧急的任务。</p>\n</li>\n<li><p><strong>RCU_SOFTIRQ：</strong> 用于执行RCU（Read-Copy-Update）机制的回调。RCU是一种数据同步机制，用于在不阻塞读取操作的情况下更新共享数据结构。</p>\n</li>\n</ol>\n<p><code>ksoftirqd</code> 线程根据软中断的优先级处理这些不同类型的软中断。每个 CPU 内核都有一个对应的 <code>ksoftirqd</code> 线程，例如 <code>ksoftirqd/0</code> 表示第一个 CPU 的 <code>ksoftirqd</code> 线程。这些线程的任务是根据需要处理软中断，以确保内核能够高效地响应各种中断事件。</p>\n<h1 id=\"ksoftirqd源码\"><a href=\"#ksoftirqd源码\" class=\"headerlink\" title=\"ksoftirqd源码\"></a>ksoftirqd源码</h1><p>kernel/softirq.c: spawn_ksoftirqd()—&gt;smpboot_register_percpu_thread()—&gt;__smpboot_create_thread()—&gt;kthread_create_on_cpu()—&gt;kthread_create_on_node()—&gt;list_add_tail(&amp;create-&gt;list, &amp;kthread_create_list)&lt;—kthread进程</p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">static</span> __init <span class=\"token keyword\">int</span> <span class=\"token function\">spawn_ksoftirqd</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 注册 CPU 通知器，以便在 CPU 状态发生变化时进行通知</span>\n    <span class=\"token function\">register_cpu_notifier</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>cpu_nfb<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 注册软中断线程</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 使用 smpboot_register_percpu_thread() 函数在每个 CPU 内核上注册一个软中断线程</span>\n    <span class=\"token function\">BUG_ON</span><span class=\"token punctuation\">(</span><span class=\"token function\">smpboot_register_percpu_thread</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>softirq_threads<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">// 在早期初始化阶段调用 spawn_ksoftirqd 函数</span>\n<span class=\"token function\">early_initcall</span><span class=\"token punctuation\">(</span>spawn_ksoftirqd<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token comment\" spellcheck=\"true\">/**\n * smpboot_register_percpu_thread - 注册与热插拔相关的 per_cpu 线程\n * @plug_thread: 热插拔线程描述符\n *\n * 在所有在线 CPU 上创建并启动线程。\n */</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">smpboot_register_percpu_thread</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> smp_hotplug_thread <span class=\"token operator\">*</span>plug_thread<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> cpu<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> ret <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 获取在线的 CPU</span>\n    <span class=\"token function\">get_online_cpus</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">mutex_lock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>smpboot_threads_lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 遍历所有在线的 CPU</span>\n    <span class=\"token function\">for_each_online_cpu</span><span class=\"token punctuation\">(</span>cpu<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 创建并启动线程</span>\n        ret <span class=\"token operator\">=</span> <span class=\"token function\">__smpboot_create_thread</span><span class=\"token punctuation\">(</span>plug_thread<span class=\"token punctuation\">,</span> cpu<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ret<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 创建失败，销毁已创建的线程</span>\n            <span class=\"token function\">smpboot_destroy_threads</span><span class=\"token punctuation\">(</span>plug_thread<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">goto</span> out<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 启动线程</span>\n        <span class=\"token function\">smpboot_unpark_thread</span><span class=\"token punctuation\">(</span>plug_thread<span class=\"token punctuation\">,</span> cpu<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 将线程描述符添加到热插拔线程列表</span>\n    <span class=\"token function\">list_add</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>plug_thread<span class=\"token operator\">-></span>list<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>hotplug_threads<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nout<span class=\"token punctuation\">:</span>\n    <span class=\"token function\">mutex_unlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>smpboot_threads_lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 释放在线 CPU</span>\n    <span class=\"token function\">put_online_cpus</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> ret<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">EXPORT_SYMBOL_GPL</span><span class=\"token punctuation\">(</span>smpboot_register_percpu_thread<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span>\n<span class=\"token function\">__smpboot_create_thread</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> smp_hotplug_thread <span class=\"token operator\">*</span>ht<span class=\"token punctuation\">,</span> <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> cpu<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">struct</span> task_struct <span class=\"token operator\">*</span>tsk <span class=\"token operator\">=</span> <span class=\"token operator\">*</span><span class=\"token function\">per_cpu_ptr</span><span class=\"token punctuation\">(</span>ht<span class=\"token operator\">-></span>store<span class=\"token punctuation\">,</span> cpu<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">struct</span> smpboot_thread_data <span class=\"token operator\">*</span>td<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 如果在该 CPU 上已经存在一个任务（线程），则不需要再创建</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>tsk<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 为 smpboot_thread_data 结构体分配内存并初始化为零</span>\n    td <span class=\"token operator\">=</span> <span class=\"token function\">kzalloc_node</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>td<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> GFP_KERNEL<span class=\"token punctuation\">,</span> <span class=\"token function\">cpu_to_node</span><span class=\"token punctuation\">(</span>cpu<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>td<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span>ENOMEM<span class=\"token punctuation\">;</span>\n    td<span class=\"token operator\">-></span>cpu <span class=\"token operator\">=</span> cpu<span class=\"token punctuation\">;</span>\n    td<span class=\"token operator\">-></span>ht <span class=\"token operator\">=</span> ht<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 在指定的 CPU 上创建内核线程，使用 smpboot_thread_fn 作为线程函数</span>\n    tsk <span class=\"token operator\">=</span> <span class=\"token function\">kthread_create_on_cpu</span><span class=\"token punctuation\">(</span>smpboot_thread_fn<span class=\"token punctuation\">,</span> td<span class=\"token punctuation\">,</span> cpu<span class=\"token punctuation\">,</span> ht<span class=\"token operator\">-></span>thread_comm<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">IS_ERR</span><span class=\"token punctuation\">(</span>tsk<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 创建失败，释放分配的内存并返回错误代码</span>\n        <span class=\"token function\">kfree</span><span class=\"token punctuation\">(</span>td<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">PTR_ERR</span><span class=\"token punctuation\">(</span>tsk<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 增加线程的引用计数</span>\n    <span class=\"token function\">get_task_struct</span><span class=\"token punctuation\">(</span>tsk<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 将线程指针保存到指定 CPU 的 ht->store 中</span>\n    <span class=\"token operator\">*</span><span class=\"token function\">per_cpu_ptr</span><span class=\"token punctuation\">(</span>ht<span class=\"token operator\">-></span>store<span class=\"token punctuation\">,</span> cpu<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> tsk<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ht<span class=\"token operator\">-></span>create<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">/*\n         * 确保任务实际上已经进入了停放位置，然后再调用创建回调函数。\n         * 至少迁移线程回调要求任务已经离开了运行队列。\n         */</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">wait_task_inactive</span><span class=\"token punctuation\">(</span>tsk<span class=\"token punctuation\">,</span> TASK_PARKED<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token function\">WARN_ON</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 若未成功进入停放状态，则发出警告</span>\n        <span class=\"token keyword\">else</span>\n            ht<span class=\"token operator\">-></span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span>cpu<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 执行创建回调函数</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token comment\" spellcheck=\"true\">/**\n * kthread_create_on_cpu - 在指定 CPU 上创建内核线程\n * @threadfn: 线程函数\n * @data: 传递给线程函数的数据指针\n * @cpu: 要创建线程的目标 CPU\n * @namefmt: 线程名称的格式字符串\n *\n * 在指定的 CPU 上创建一个内核线程。\n * \n * 返回：指向新创建线程的 task_struct 结构体指针，或者错误指针。\n */</span>\n<span class=\"token keyword\">struct</span> task_struct <span class=\"token operator\">*</span><span class=\"token function\">kthread_create_on_cpu</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>threadfn<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n                                          <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>data<span class=\"token punctuation\">,</span> <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> cpu<span class=\"token punctuation\">,</span>\n                                          <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>namefmt<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">struct</span> task_struct <span class=\"token operator\">*</span>p<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 在指定的 NUMA 节点上创建内核线程</span>\n    p <span class=\"token operator\">=</span> <span class=\"token function\">kthread_create_on_node</span><span class=\"token punctuation\">(</span>threadfn<span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">,</span> <span class=\"token function\">cpu_to_node</span><span class=\"token punctuation\">(</span>cpu<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> namefmt<span class=\"token punctuation\">,</span>\n                               cpu<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">IS_ERR</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> p<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 设置线程为 per_cpu 线程，标志位 KTHREAD_IS_PER_CPU</span>\n    <span class=\"token function\">set_bit</span><span class=\"token punctuation\">(</span>KTHREAD_IS_PER_CPU<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span><span class=\"token function\">to_kthread</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span><span class=\"token operator\">-></span>flags<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 设置线程的 CPU 属性</span>\n    <span class=\"token function\">to_kthread</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span><span class=\"token operator\">-></span>cpu <span class=\"token operator\">=</span> cpu<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">/* 将线程停放以将其从 TASK_UNINTERRUPTIBLE 状态移出 */</span>\n    <span class=\"token function\">kthread_park</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> p<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token comment\" spellcheck=\"true\">/**\n * kthread_create_on_node - 在指定 NUMA 节点上创建内核线程\n * @threadfn: 线程函数\n * @data: 传递给线程函数的数据指针\n * @node: 要创建线程的目标 NUMA 节点\n * @namefmt: 线程名称的格式字符串\n * @...: 可变参数列表\n *\n * 在指定的 NUMA 节点上创建一个内核线程。此函数会创建一个 kthread_create_info 结构体，\n * 初始化线程相关的信息，并将线程请求添加到 kthread_create_list 中，然后唤醒 kthreadd_task\n * 来处理线程的创建。\n * \n * 返回：指向新创建线程的 task_struct 结构体指针，或者错误指针。\n */</span>\n<span class=\"token keyword\">struct</span> task_struct <span class=\"token operator\">*</span><span class=\"token function\">kthread_create_on_node</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>threadfn<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n                                           <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>data<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> node<span class=\"token punctuation\">,</span>\n                                           <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> namefmt<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n                                           <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token function\">DECLARE_COMPLETION_ONSTACK</span><span class=\"token punctuation\">(</span>done<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">struct</span> task_struct <span class=\"token operator\">*</span>task<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">struct</span> kthread_create_info <span class=\"token operator\">*</span>create <span class=\"token operator\">=</span> <span class=\"token function\">kmalloc</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>create<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> GFP_KERNEL<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>create<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">ERR_PTR</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span>ENOMEM<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    create<span class=\"token operator\">-></span>threadfn <span class=\"token operator\">=</span> threadfn<span class=\"token punctuation\">;</span>\n    create<span class=\"token operator\">-></span>data <span class=\"token operator\">=</span> data<span class=\"token punctuation\">;</span>\n    create<span class=\"token operator\">-></span>node <span class=\"token operator\">=</span> node<span class=\"token punctuation\">;</span>\n    create<span class=\"token operator\">-></span>done <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>done<span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">spin_lock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>kthread_create_lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 将线程创建请求添加到 kthread_create_list 中</span>\n    <span class=\"token function\">list_add_tail</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>create<span class=\"token operator\">-></span>list<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>kthread_create_list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">spin_unlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>kthread_create_lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 唤醒 kthreadd_task 来处理线程的创建</span>\n    <span class=\"token function\">wake_up_process</span><span class=\"token punctuation\">(</span>kthreadd_task<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">/*\n     * 在可终止状态下等待完成，因为可能会在 kthreadd 尝试为新内核线程分配内存时\n     * 被 OOM 杀手选择。\n     */</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">unlikely</span><span class=\"token punctuation\">(</span><span class=\"token function\">wait_for_completion_killable</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>done<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">/*\n         * 如果在 kthreadd（或新内核线程）调用 complete() 之前收到 SIGKILL 信号，\n         * 则将对此结构体的清理留给那个线程。\n         */</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">xchg</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>create<span class=\"token operator\">-></span>done<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> <span class=\"token function\">ERR_PTR</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span>EINTR<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">/*\n         * kthreadd（或新内核线程）将会很快调用 complete()。\n         */</span>\n        <span class=\"token function\">wait_for_completion</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>done<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    task <span class=\"token operator\">=</span> create<span class=\"token operator\">-></span>result<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">IS_ERR</span><span class=\"token punctuation\">(</span>task<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">static</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">struct</span> sched_param param <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">.</span>sched_priority <span class=\"token operator\">=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n        va_list args<span class=\"token punctuation\">;</span>\n\n        <span class=\"token function\">va_start</span><span class=\"token punctuation\">(</span>args<span class=\"token punctuation\">,</span> namefmt<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">vsnprintf</span><span class=\"token punctuation\">(</span>task<span class=\"token operator\">-></span>comm<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>task<span class=\"token operator\">-></span>comm<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> namefmt<span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">va_end</span><span class=\"token punctuation\">(</span>args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">/*\n         * root 可能会更改我们（kthreadd 的）优先级或 CPU 掩码。\n         * 内核线程不应继承这些属性。\n         */</span>\n        <span class=\"token function\">sched_setscheduler_nocheck</span><span class=\"token punctuation\">(</span>task<span class=\"token punctuation\">,</span> SCHED_NORMAL<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>param<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">set_cpus_allowed_ptr</span><span class=\"token punctuation\">(</span>task<span class=\"token punctuation\">,</span> cpu_all_mask<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">kfree</span><span class=\"token punctuation\">(</span>create<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> task<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">EXPORT_SYMBOL</span><span class=\"token punctuation\">(</span>kthread_create_on_node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>list_add_tail(&amp;create-&gt;list, &amp;kthread_create_list)就是将每个cpu创建一个软中断并添加到kthread_create_list链表中，由kthread线程初始化。所以你的ps -A –forest会出现ksoftirqd/x。</p>\n<h1 id=\"softirq函数\"><a href=\"#softirq函数\" class=\"headerlink\" title=\"softirq函数\"></a>softirq函数</h1><p>run_ksoftirqd()—&gt;__do_softirq()—&gt;softirq_vec[…].actions—&gt;用户注册的软中断</p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">static</span> <span class=\"token keyword\">struct</span> smp_hotplug_thread softirq_threads <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">.</span>store            <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>ksoftirqd<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">.</span>thread_should_run    <span class=\"token operator\">=</span> ksoftirqd_should_run<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">.</span>thread_fn        <span class=\"token operator\">=</span> run_ksoftirqd<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">.</span>thread_comm        <span class=\"token operator\">=</span> <span class=\"token string\">\"ksoftirqd/%u\"</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre>\n<p>传递给kthread创建的线程结构体</p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token comment\" spellcheck=\"true\">/**\n * run_ksoftirqd - 在指定 CPU 上运行软中断处理程序\n * @cpu: 目标 CPU 的编号\n *\n * 在给定的 CPU 上运行软中断（softirq）处理程序，用于处理一些低优先级的中断任务。\n * \n * 该函数会先禁用本地中断，然后检查是否有待处理的软中断。如果有，它会调用 __do_softirq() 函数\n * 来运行软中断处理程序，处理各种不同类型的软中断任务。然后，它重新启用本地中断，允许其他中断继续发生。\n * 如果在软中断运行期间需要进行 RCU（Read-Copy-Update）的切换，函数会在必要时调度其他任务，\n * 以确保 RCU 安全切换。\n */</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run_ksoftirqd</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> cpu<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token function\">local_irq_disable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 禁用本地中断，确保软中断期间不会被其他中断打断</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">local_softirq_pending</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">/*\n         * 我们可以在内联栈上安全运行软中断，\n         * 因为我们在这里不深入到任务堆栈中。\n         */</span>\n        <span class=\"token function\">__do_softirq</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 运行软中断处理程序</span>\n        <span class=\"token function\">local_irq_enable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 重新启用本地中断</span>\n        <span class=\"token function\">cond_resched_rcu_qs</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 在需要时调度其他任务以确保 RCU 安全切换</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">local_irq_enable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 重新启用本地中断</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token comment\" spellcheck=\"true\">/**\n * __do_softirq - 执行软中断处理程序\n *\n * 此函数用于在内核中运行软中断（softirq）的处理程序。软中断是一种低优先级的中断，\n * 用于处理一些延迟敏感但不需要立即响应的任务。该函数负责按顺序执行挂起的软中断，\n * 并在处理每个软中断时调用相应的处理函数。\n */</span>\nasmlinkage __visible <span class=\"token keyword\">void</span> <span class=\"token function\">__do_softirq</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 计算软中断处理的最大时间</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> end <span class=\"token operator\">=</span> jiffies <span class=\"token operator\">+</span> MAX_SOFTIRQ_TIME<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 保存旧的任务标志</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> old_flags <span class=\"token operator\">=</span> current<span class=\"token operator\">-></span>flags<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 最大允许重新启动次数</span>\n    <span class=\"token keyword\">int</span> max_restart <span class=\"token operator\">=</span> MAX_SOFTIRQ_RESTART<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 指向软中断处理程序</span>\n    <span class=\"token keyword\">struct</span> softirq_action <span class=\"token operator\">*</span>h<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 是否在硬中断上下文中</span>\n    bool in_hardirq<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 待处理的软中断位掩码</span>\n    __u32 pending<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 待处理的软中断位</span>\n    <span class=\"token keyword\">int</span> softirq_bit<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/* 屏蔽 PF_MEMALLOC，因为当前任务上下文被借用用于软中断处理。 */</span>\n    current<span class=\"token operator\">-></span>flags <span class=\"token operator\">&amp;</span><span class=\"token operator\">=</span> <span class=\"token operator\">~</span>PF_MEMALLOC<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 获取待处理的软中断位掩码</span>\n    pending <span class=\"token operator\">=</span> <span class=\"token function\">local_softirq_pending</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 记录进入软中断处理的时间</span>\n    <span class=\"token function\">account_irq_enter_time</span><span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 关闭本地底半部中断，开始软中断处理</span>\n    <span class=\"token function\">__local_bh_disable_ip</span><span class=\"token punctuation\">(</span>_RET_IP_<span class=\"token punctuation\">,</span> SOFTIRQ_OFFSET<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 开始跟踪软中断</span>\n    in_hardirq <span class=\"token operator\">=</span> <span class=\"token function\">lockdep_softirq_start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nrestart<span class=\"token punctuation\">:</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 在启用 IRQ 之前重置挂起的位掩码</span>\n    <span class=\"token function\">set_softirq_pending</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 启用本地中断</span>\n    <span class=\"token function\">local_irq_enable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 获取软中断处理程序向量的起始地址</span>\n    h <span class=\"token operator\">=</span> softirq_vec<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 逐个处理待处理的软中断</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>softirq_bit <span class=\"token operator\">=</span> <span class=\"token function\">ffs</span><span class=\"token punctuation\">(</span>pending<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> vec_nr<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> prev_count<span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 选择要处理的软中断</span>\n        h <span class=\"token operator\">+</span><span class=\"token operator\">=</span> softirq_bit <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 获取软中断号</span>\n        vec_nr <span class=\"token operator\">=</span> h <span class=\"token operator\">-</span> softirq_vec<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 保存进入软中断前的抢占计数</span>\n        prev_count <span class=\"token operator\">=</span> <span class=\"token function\">preempt_count</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 增加本 CPU 上的软中断计数</span>\n        <span class=\"token function\">kstat_incr_softirqs_this_cpu</span><span class=\"token punctuation\">(</span>vec_nr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 跟踪软中断进入</span>\n        <span class=\"token function\">trace_softirq_entry</span><span class=\"token punctuation\">(</span>vec_nr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 调用软中断处理函数</span>\n        h<span class=\"token operator\">-></span><span class=\"token function\">action</span><span class=\"token punctuation\">(</span>h<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 跟踪软中断退出</span>\n        <span class=\"token function\">trace_softirq_exit</span><span class=\"token punctuation\">(</span>vec_nr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 检查软中断期间抢占计数的变化</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">unlikely</span><span class=\"token punctuation\">(</span>prev_count <span class=\"token operator\">!=</span> <span class=\"token function\">preempt_count</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">pr_err</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"huh, entered softirq %u %s %p with preempt_count %08x, exited with %08x?\\n\"</span><span class=\"token punctuation\">,</span>\n                   vec_nr<span class=\"token punctuation\">,</span> softirq_to_name<span class=\"token punctuation\">[</span>vec_nr<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> h<span class=\"token operator\">-></span>action<span class=\"token punctuation\">,</span>\n                   prev_count<span class=\"token punctuation\">,</span> <span class=\"token function\">preempt_count</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">preempt_count_set</span><span class=\"token punctuation\">(</span>prev_count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 移动到下一个软中断</span>\n        h<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 清除已处理的软中断位</span>\n        pending <span class=\"token operator\">>>=</span> softirq_bit<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 在软中断处理完成后，执行 RCU 切换</span>\n    <span class=\"token function\">rcu_bh_qs</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 关闭本地中断</span>\n    <span class=\"token function\">local_irq_disable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 再次获取待处理的软中断位掩码</span>\n    pending <span class=\"token operator\">=</span> <span class=\"token function\">local_softirq_pending</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 如果仍有未处理的软中断</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pending<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 如果尚未超过最大处理时间，并且不需要任务调度，并且还可以重新尝试处理</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">time_before</span><span class=\"token punctuation\">(</span>jiffies<span class=\"token punctuation\">,</span> end<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span><span class=\"token function\">need_resched</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">--</span>max_restart<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">goto</span> restart<span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 唤醒软中断线程（ksoftirqd）</span>\n        <span class=\"token function\">wakeup_softirqd</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 结束软中断处理</span>\n    <span class=\"token function\">lockdep_softirq_end</span><span class=\"token punctuation\">(</span>in_hardirq<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 记录退出软中断处理的时间</span>\n    <span class=\"token function\">account_irq_exit_time</span><span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 启用底半部中断</span>\n    <span class=\"token function\">__local_bh_enable</span><span class=\"token punctuation\">(</span>SOFTIRQ_OFFSET<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 在软中断处理后，不应该仍处于硬中断上下文中</span>\n    <span class=\"token function\">WARN_ON_ONCE</span><span class=\"token punctuation\">(</span><span class=\"token function\">in_interrupt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 恢复任务的标志和状态</span>\n    <span class=\"token function\">tsk_restore_flags</span><span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">,</span> old_flags<span class=\"token punctuation\">,</span> PF_MEMALLOC<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">static</span> <span class=\"token keyword\">struct</span> softirq_action softirq_vec<span class=\"token punctuation\">[</span>NR_SOFTIRQS<span class=\"token punctuation\">]</span> __cacheline_aligned_in_smp<span class=\"token punctuation\">;</span></code></pre>\n<p>kernel/softirq.c定义了一个数组 <code>softirq_vec</code>，用于存储软中断（softirq）处理程序的函数指针。逐步解释其中的每个部分：</p>\n<ol>\n<li><p><code>static</code>：这个关键字指示变量 <code>softirq_vec</code> 的作用范围仅限于当前文件。它是一个静态变量，意味着其生命周期从程序启动到终止，不会在不同的函数调用之间失去其值。</p>\n</li>\n<li><p><code>struct softirq_action</code>：这是一个结构体类型，用于存储软中断处理程序的信息。它包含了一个函数指针 <code>action</code>，指向一个具体的软中断处理函数。</p>\n</li>\n<li><p><code>softirq_vec[NR_SOFTIRQS]</code>：这是一个数组，长度为 <code>NR_SOFTIRQS</code>，它定义了一个能够容纳多个软中断处理程序的存储空间。每个元素都是一个 <code>struct softirq_action</code> 类型的结构体，其中存储了软中断处理函数的指针。</p>\n</li>\n<li><p><code>__cacheline_aligned_in_smp</code>：这个属性指示编译器在 SMP（对称多处理器）系统上，将 <code>softirq_vec</code> 数据结构对齐到 CPU 缓存行的边界，以提高访问性能。这是一种优化，可以减少因为不必要的缓存行填充而造成的性能损失。</p>\n</li>\n</ol>\n<p><code>softirq_vec</code>，用于存储软中断处理程序的函数指针。每个软中断在数组中对应一个元素，该元素包含了指向具体软中断处理函数的指针。这种机制允许内核注册多个不同类型的软中断处理程序，并在适当的时候调用这些函数来执行相应的任务。</p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<h1 id=\"ksoftirqd线程\"><a href=\"#ksoftirqd线程\" class=\"headerlink\" title=\"ksoftirqd线程\"></a>ksoftirqd线程</h1><p><code>ksoftirqd</code> 是一个内核线程，用于处理软中断（softirq）。软中断是一种低优先级的中断，与硬件中断（irq）相比，它们的优先级更低，不会直接打断正在执行的内核代码，而是在内核上下文中延迟处理。<code>ksoftirqd</code> 线程的主要任务是处理这些软中断。</p>\n<p>在Linux内核中，有多种软中断，每种都有不同的用途，例如网络处理、定时器处理、任务延迟等。以下是一些软中断的类型和用途：</p>\n<ol>\n<li><p><strong>NET_RX_SOFTIRQ：</strong> 用于处理网络接收的数据包。当网络接口接收到数据包后，它会触发这个软中断，<code>ksoftirqd</code> 线程负责处理和处理这些数据包。</p>\n</li>\n<li><p><strong>TIMER_SOFTIRQ：</strong> 用于处理定时器事件。当一个定时器到期时，它会触发这个软中断，<code>ksoftirqd</code> 线程会执行相应的定时器处理函数。</p>\n</li>\n<li><p><strong>TASKLET_SOFTIRQ：</strong> 用于执行延迟处理的任务。这是一种低延迟的工作队列机制，用于处理需要在延迟上下文中执行的工作。</p>\n</li>\n<li><p><strong>HI_SOFTIRQ：</strong> 用于高优先级的软中断处理。这些软中断具有比普通软中断更高的优先级，通常用于处理紧急的任务。</p>\n</li>\n<li><p><strong>RCU_SOFTIRQ：</strong> 用于执行RCU（Read-Copy-Update）机制的回调。RCU是一种数据同步机制，用于在不阻塞读取操作的情况下更新共享数据结构。</p>\n</li>\n</ol>\n<p><code>ksoftirqd</code> 线程根据软中断的优先级处理这些不同类型的软中断。每个 CPU 内核都有一个对应的 <code>ksoftirqd</code> 线程，例如 <code>ksoftirqd/0</code> 表示第一个 CPU 的 <code>ksoftirqd</code> 线程。这些线程的任务是根据需要处理软中断，以确保内核能够高效地响应各种中断事件。</p>\n<h1 id=\"ksoftirqd源码\"><a href=\"#ksoftirqd源码\" class=\"headerlink\" title=\"ksoftirqd源码\"></a>ksoftirqd源码</h1><p>kernel/softirq.c: spawn_ksoftirqd()—&gt;smpboot_register_percpu_thread()—&gt;__smpboot_create_thread()—&gt;kthread_create_on_cpu()—&gt;kthread_create_on_node()—&gt;list_add_tail(&amp;create-&gt;list, &amp;kthread_create_list)&lt;—kthread进程</p>\n<pre><code class=\"c\">static __init int spawn_ksoftirqd(void)\n{\n    // 注册 CPU 通知器，以便在 CPU 状态发生变化时进行通知\n    register_cpu_notifier(&amp;cpu_nfb);\n\n    // 注册软中断线程\n    // 使用 smpboot_register_percpu_thread() 函数在每个 CPU 内核上注册一个软中断线程\n    BUG_ON(smpboot_register_percpu_thread(&amp;softirq_threads));\n\n    return 0;\n}\n// 在早期初始化阶段调用 spawn_ksoftirqd 函数\nearly_initcall(spawn_ksoftirqd);</code></pre>\n<pre><code class=\"c\">/**\n * smpboot_register_percpu_thread - 注册与热插拔相关的 per_cpu 线程\n * @plug_thread: 热插拔线程描述符\n *\n * 在所有在线 CPU 上创建并启动线程。\n */\nint smpboot_register_percpu_thread(struct smp_hotplug_thread *plug_thread)\n{\n    unsigned int cpu;\n    int ret = 0;\n\n    // 获取在线的 CPU\n    get_online_cpus();\n    mutex_lock(&amp;smpboot_threads_lock);\n\n    // 遍历所有在线的 CPU\n    for_each_online_cpu(cpu) {\n        // 创建并启动线程\n        ret = __smpboot_create_thread(plug_thread, cpu);\n        if (ret) {\n            // 创建失败，销毁已创建的线程\n            smpboot_destroy_threads(plug_thread);\n            goto out;\n        }\n\n        // 启动线程\n        smpboot_unpark_thread(plug_thread, cpu);\n    }\n\n    // 将线程描述符添加到热插拔线程列表\n    list_add(&amp;plug_thread-&gt;list, &amp;hotplug_threads);\n\nout:\n    mutex_unlock(&amp;smpboot_threads_lock);\n    // 释放在线 CPU\n    put_online_cpus();\n    return ret;\n}\nEXPORT_SYMBOL_GPL(smpboot_register_percpu_thread);</code></pre>\n<pre><code class=\"c\">static int\n__smpboot_create_thread(struct smp_hotplug_thread *ht, unsigned int cpu)\n{\n    struct task_struct *tsk = *per_cpu_ptr(ht-&gt;store, cpu);\n    struct smpboot_thread_data *td;\n\n    // 如果在该 CPU 上已经存在一个任务（线程），则不需要再创建\n    if (tsk)\n        return 0;\n\n    // 为 smpboot_thread_data 结构体分配内存并初始化为零\n    td = kzalloc_node(sizeof(*td), GFP_KERNEL, cpu_to_node(cpu));\n    if (!td)\n        return -ENOMEM;\n    td-&gt;cpu = cpu;\n    td-&gt;ht = ht;\n\n    // 在指定的 CPU 上创建内核线程，使用 smpboot_thread_fn 作为线程函数\n    tsk = kthread_create_on_cpu(smpboot_thread_fn, td, cpu, ht-&gt;thread_comm);\n    if (IS_ERR(tsk)) {\n        // 创建失败，释放分配的内存并返回错误代码\n        kfree(td);\n        return PTR_ERR(tsk);\n    }\n\n    // 增加线程的引用计数\n    get_task_struct(tsk);\n    // 将线程指针保存到指定 CPU 的 ht-&gt;store 中\n    *per_cpu_ptr(ht-&gt;store, cpu) = tsk;\n\n    if (ht-&gt;create) {\n        /*\n         * 确保任务实际上已经进入了停放位置，然后再调用创建回调函数。\n         * 至少迁移线程回调要求任务已经离开了运行队列。\n         */\n        if (!wait_task_inactive(tsk, TASK_PARKED))\n            WARN_ON(1); // 若未成功进入停放状态，则发出警告\n        else\n            ht-&gt;create(cpu); // 执行创建回调函数\n    }\n\n    return 0;\n}</code></pre>\n<pre><code class=\"c\">/**\n * kthread_create_on_cpu - 在指定 CPU 上创建内核线程\n * @threadfn: 线程函数\n * @data: 传递给线程函数的数据指针\n * @cpu: 要创建线程的目标 CPU\n * @namefmt: 线程名称的格式字符串\n *\n * 在指定的 CPU 上创建一个内核线程。\n * \n * 返回：指向新创建线程的 task_struct 结构体指针，或者错误指针。\n */\nstruct task_struct *kthread_create_on_cpu(int (*threadfn)(void *data),\n                                          void *data, unsigned int cpu,\n                                          const char *namefmt)\n{\n    struct task_struct *p;\n\n    // 在指定的 NUMA 节点上创建内核线程\n    p = kthread_create_on_node(threadfn, data, cpu_to_node(cpu), namefmt,\n                               cpu);\n    if (IS_ERR(p))\n        return p;\n\n    // 设置线程为 per_cpu 线程，标志位 KTHREAD_IS_PER_CPU\n    set_bit(KTHREAD_IS_PER_CPU, &amp;to_kthread(p)-&gt;flags);\n    // 设置线程的 CPU 属性\n    to_kthread(p)-&gt;cpu = cpu;\n    /* 将线程停放以将其从 TASK_UNINTERRUPTIBLE 状态移出 */\n    kthread_park(p);\n    return p;\n}</code></pre>\n<pre><code class=\"c\">/**\n * kthread_create_on_node - 在指定 NUMA 节点上创建内核线程\n * @threadfn: 线程函数\n * @data: 传递给线程函数的数据指针\n * @node: 要创建线程的目标 NUMA 节点\n * @namefmt: 线程名称的格式字符串\n * @...: 可变参数列表\n *\n * 在指定的 NUMA 节点上创建一个内核线程。此函数会创建一个 kthread_create_info 结构体，\n * 初始化线程相关的信息，并将线程请求添加到 kthread_create_list 中，然后唤醒 kthreadd_task\n * 来处理线程的创建。\n * \n * 返回：指向新创建线程的 task_struct 结构体指针，或者错误指针。\n */\nstruct task_struct *kthread_create_on_node(int (*threadfn)(void *data),\n                                           void *data, int node,\n                                           const char namefmt[],\n                                           ...)\n{\n    DECLARE_COMPLETION_ONSTACK(done);\n    struct task_struct *task;\n    struct kthread_create_info *create = kmalloc(sizeof(*create), GFP_KERNEL);\n\n    if (!create)\n        return ERR_PTR(-ENOMEM);\n    create-&gt;threadfn = threadfn;\n    create-&gt;data = data;\n    create-&gt;node = node;\n    create-&gt;done = &amp;done;\n\n    spin_lock(&amp;kthread_create_lock);\n    // 将线程创建请求添加到 kthread_create_list 中\n    list_add_tail(&amp;create-&gt;list, &amp;kthread_create_list);\n    spin_unlock(&amp;kthread_create_lock);\n\n    // 唤醒 kthreadd_task 来处理线程的创建\n    wake_up_process(kthreadd_task);\n    /*\n     * 在可终止状态下等待完成，因为可能会在 kthreadd 尝试为新内核线程分配内存时\n     * 被 OOM 杀手选择。\n     */\n    if (unlikely(wait_for_completion_killable(&amp;done))) {\n        /*\n         * 如果在 kthreadd（或新内核线程）调用 complete() 之前收到 SIGKILL 信号，\n         * 则将对此结构体的清理留给那个线程。\n         */\n        if (xchg(&amp;create-&gt;done, NULL))\n            return ERR_PTR(-EINTR);\n        /*\n         * kthreadd（或新内核线程）将会很快调用 complete()。\n         */\n        wait_for_completion(&amp;done);\n    }\n    task = create-&gt;result;\n    if (!IS_ERR(task)) {\n        static const struct sched_param param = { .sched_priority = 0 };\n        va_list args;\n\n        va_start(args, namefmt);\n        vsnprintf(task-&gt;comm, sizeof(task-&gt;comm), namefmt, args);\n        va_end(args);\n        /*\n         * root 可能会更改我们（kthreadd 的）优先级或 CPU 掩码。\n         * 内核线程不应继承这些属性。\n         */\n        sched_setscheduler_nocheck(task, SCHED_NORMAL, &amp;param);\n        set_cpus_allowed_ptr(task, cpu_all_mask);\n    }\n    kfree(create);\n    return task;\n}\nEXPORT_SYMBOL(kthread_create_on_node);</code></pre>\n<p>list_add_tail(&amp;create-&gt;list, &amp;kthread_create_list)就是将每个cpu创建一个软中断并添加到kthread_create_list链表中，由kthread线程初始化。所以你的ps -A –forest会出现ksoftirqd/x。</p>\n<h1 id=\"softirq函数\"><a href=\"#softirq函数\" class=\"headerlink\" title=\"softirq函数\"></a>softirq函数</h1><p>run_ksoftirqd()—&gt;__do_softirq()—&gt;softirq_vec[…].actions—&gt;用户注册的软中断</p>\n<pre><code class=\"c\">static struct smp_hotplug_thread softirq_threads = {\n    .store            = &amp;ksoftirqd,\n    .thread_should_run    = ksoftirqd_should_run,\n    .thread_fn        = run_ksoftirqd,\n    .thread_comm        = &quot;ksoftirqd/%u&quot;,\n};</code></pre>\n<p>传递给kthread创建的线程结构体</p>\n<pre><code class=\"c\">/**\n * run_ksoftirqd - 在指定 CPU 上运行软中断处理程序\n * @cpu: 目标 CPU 的编号\n *\n * 在给定的 CPU 上运行软中断（softirq）处理程序，用于处理一些低优先级的中断任务。\n * \n * 该函数会先禁用本地中断，然后检查是否有待处理的软中断。如果有，它会调用 __do_softirq() 函数\n * 来运行软中断处理程序，处理各种不同类型的软中断任务。然后，它重新启用本地中断，允许其他中断继续发生。\n * 如果在软中断运行期间需要进行 RCU（Read-Copy-Update）的切换，函数会在必要时调度其他任务，\n * 以确保 RCU 安全切换。\n */\nstatic void run_ksoftirqd(unsigned int cpu)\n{\n    local_irq_disable(); // 禁用本地中断，确保软中断期间不会被其他中断打断\n\n    if (local_softirq_pending()) {\n        /*\n         * 我们可以在内联栈上安全运行软中断，\n         * 因为我们在这里不深入到任务堆栈中。\n         */\n        __do_softirq(); // 运行软中断处理程序\n        local_irq_enable(); // 重新启用本地中断\n        cond_resched_rcu_qs(); // 在需要时调度其他任务以确保 RCU 安全切换\n        return;\n    }\n\n    local_irq_enable(); // 重新启用本地中断\n}</code></pre>\n<pre><code class=\"c\">/**\n * __do_softirq - 执行软中断处理程序\n *\n * 此函数用于在内核中运行软中断（softirq）的处理程序。软中断是一种低优先级的中断，\n * 用于处理一些延迟敏感但不需要立即响应的任务。该函数负责按顺序执行挂起的软中断，\n * 并在处理每个软中断时调用相应的处理函数。\n */\nasmlinkage __visible void __do_softirq(void)\n{\n    // 计算软中断处理的最大时间\n    unsigned long end = jiffies + MAX_SOFTIRQ_TIME;\n    // 保存旧的任务标志\n    unsigned long old_flags = current-&gt;flags;\n    // 最大允许重新启动次数\n    int max_restart = MAX_SOFTIRQ_RESTART;\n    // 指向软中断处理程序\n    struct softirq_action *h;\n    // 是否在硬中断上下文中\n    bool in_hardirq;\n    // 待处理的软中断位掩码\n    __u32 pending;\n    // 待处理的软中断位\n    int softirq_bit;\n\n    /* 屏蔽 PF_MEMALLOC，因为当前任务上下文被借用用于软中断处理。 */\n    current-&gt;flags &amp;= ~PF_MEMALLOC;\n\n    // 获取待处理的软中断位掩码\n    pending = local_softirq_pending();\n    // 记录进入软中断处理的时间\n    account_irq_enter_time(current);\n\n    // 关闭本地底半部中断，开始软中断处理\n    __local_bh_disable_ip(_RET_IP_, SOFTIRQ_OFFSET);\n    // 开始跟踪软中断\n    in_hardirq = lockdep_softirq_start();\n\nrestart:\n    // 在启用 IRQ 之前重置挂起的位掩码\n    set_softirq_pending(0);\n\n    // 启用本地中断\n    local_irq_enable();\n\n    // 获取软中断处理程序向量的起始地址\n    h = softirq_vec;\n\n    // 逐个处理待处理的软中断\n    while ((softirq_bit = ffs(pending))) {\n        unsigned int vec_nr;\n        int prev_count;\n\n        // 选择要处理的软中断\n        h += softirq_bit - 1;\n        // 获取软中断号\n        vec_nr = h - softirq_vec;\n        // 保存进入软中断前的抢占计数\n        prev_count = preempt_count();\n\n        // 增加本 CPU 上的软中断计数\n        kstat_incr_softirqs_this_cpu(vec_nr);\n\n        // 跟踪软中断进入\n        trace_softirq_entry(vec_nr);\n        // 调用软中断处理函数\n        h-&gt;action(h);\n        // 跟踪软中断退出\n        trace_softirq_exit(vec_nr);\n\n        // 检查软中断期间抢占计数的变化\n        if (unlikely(prev_count != preempt_count())) {\n            pr_err(&quot;huh, entered softirq %u %s %p with preempt_count %08x, exited with %08x?\\n&quot;,\n                   vec_nr, softirq_to_name[vec_nr], h-&gt;action,\n                   prev_count, preempt_count());\n            preempt_count_set(prev_count);\n        }\n        // 移动到下一个软中断\n        h++;\n        // 清除已处理的软中断位\n        pending &gt;&gt;= softirq_bit;\n    }\n\n    // 在软中断处理完成后，执行 RCU 切换\n    rcu_bh_qs();\n    // 关闭本地中断\n    local_irq_disable();\n\n    // 再次获取待处理的软中断位掩码\n    pending = local_softirq_pending();\n    // 如果仍有未处理的软中断\n    if (pending) {\n        // 如果尚未超过最大处理时间，并且不需要任务调度，并且还可以重新尝试处理\n        if (time_before(jiffies, end) &amp;&amp; !need_resched() &amp;&amp; --max_restart)\n            goto restart;\n\n        // 唤醒软中断线程（ksoftirqd）\n        wakeup_softirqd();\n    }\n\n    // 结束软中断处理\n    lockdep_softirq_end(in_hardirq);\n    // 记录退出软中断处理的时间\n    account_irq_exit_time(current);\n    // 启用底半部中断\n    __local_bh_enable(SOFTIRQ_OFFSET);\n    // 在软中断处理后，不应该仍处于硬中断上下文中\n    WARN_ON_ONCE(in_interrupt());\n    // 恢复任务的标志和状态\n    tsk_restore_flags(current, old_flags, PF_MEMALLOC);\n}</code></pre>\n<pre><code class=\"c\">static struct softirq_action softirq_vec[NR_SOFTIRQS] __cacheline_aligned_in_smp;</code></pre>\n<p>kernel/softirq.c定义了一个数组 <code>softirq_vec</code>，用于存储软中断（softirq）处理程序的函数指针。逐步解释其中的每个部分：</p>\n<ol>\n<li><p><code>static</code>：这个关键字指示变量 <code>softirq_vec</code> 的作用范围仅限于当前文件。它是一个静态变量，意味着其生命周期从程序启动到终止，不会在不同的函数调用之间失去其值。</p>\n</li>\n<li><p><code>struct softirq_action</code>：这是一个结构体类型，用于存储软中断处理程序的信息。它包含了一个函数指针 <code>action</code>，指向一个具体的软中断处理函数。</p>\n</li>\n<li><p><code>softirq_vec[NR_SOFTIRQS]</code>：这是一个数组，长度为 <code>NR_SOFTIRQS</code>，它定义了一个能够容纳多个软中断处理程序的存储空间。每个元素都是一个 <code>struct softirq_action</code> 类型的结构体，其中存储了软中断处理函数的指针。</p>\n</li>\n<li><p><code>__cacheline_aligned_in_smp</code>：这个属性指示编译器在 SMP（对称多处理器）系统上，将 <code>softirq_vec</code> 数据结构对齐到 CPU 缓存行的边界，以提高访问性能。这是一种优化，可以减少因为不必要的缓存行填充而造成的性能损失。</p>\n</li>\n</ol>\n<p><code>softirq_vec</code>，用于存储软中断处理程序的函数指针。每个软中断在数组中对应一个元素，该元素包含了指向具体软中断处理函数的指针。这种机制允许内核注册多个不同类型的软中断处理程序，并在适当的时候调用这些函数来执行相应的任务。</p>\n"},{"title":"process-udev","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-08-28T09:18:24.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"\n# udev\n`udev`（用户空间设备管理器）是用于管理 Linux 内核设备和设备事件的守护进程。它的主要目的是在系统中自动检测硬件设备的插入、拔出等事件，并根据这些事件进行相应的设备管理操作，例如加载适当的驱动程序、创建设备节点、设置权限等。\n\n`udev` 本质上是一个守护进程，它会监听内核发送的事件（例如设备插入、拔出、属性变化等），并采取适当的措施来管理这些设备。为了实现这一功能，`udev` 使用了多线程技术。其中，`udev` 线程的主要任务包括：\n\n1. **事件监听：** `udev` 线程会监听内核发送的设备事件，例如设备的插入或拔出。\n\n2. **事件处理：** 一旦接收到设备事件，`udev` 线程会根据事件的类型和属性执行相应的处理操作。这可能涉及到加载驱动程序、创建设备文件、设置设备权限等。\n\n3. **规则执行：** `udev` 使用规则来描述设备的管理操作。当设备事件发生时，`udev` 线程会根据预定义的规则来判断需要执行哪些操作。\n\n4. **设备节点管理：** `udev` 线程会负责在 `/dev` 目录下创建和管理设备节点文件，这些文件用于与用户空间应用程序进行通信。\n\n5. **热插拔支持：** `udev` 线程使系统能够自动识别硬件的热插拔操作，并在设备插入或拔出时自动执行相应的管理操作。\n\n6. **属性处理：** `udev` 可以从设备的属性信息中获取有关设备的信息，并在必要时将这些属性信息用于设备管理操作。\n\n# udevd程序\n## BusyBox 构建根文件系统\nBusyBox中具有udev的功能，生成文件系统的时候在sbin/中生成了udev\n## udev移植\n从udev下载网址可以下载到udev的源码。下面为移植步骤。\n\n    下载udev源码包，并解压\n    修改Makefile中的CROSS交叉编译工具为自己开发板的编译器\n    执行make进行编译。\n    然后执行strip udev uded udevstart udevinfo udevtest。并将这些文件拷贝到rootfs/sbin目录下。\n    添加对udev的支持，修改/etc/init.d/rcS脚本，添加如下命令：\n\n```c\nroot@ATK-IMX6U:/sbin# ls -ll | grep udev                                        \nlrwxrwxrwx 1 root root       16 Jun 10 18:21 udevadm -> /usr/bin/udevadm\n-rwxr-xr-x 1 root root     239K Jul 20  2021 udevd\n```\n\n# udevd如何被运行\n根据[init线程启动/etc/inittab](https://qian-qiang.github.io/2023/08/process-init.html)可知会先执行si::sysinit:/etc/init.d/rcS文件的启动脚本\n\n```c\n...................\n# Boot-time system configuration/initialization script.\n# This is run first except when booting in emergency (-b) mode.\nsi::sysinit:/etc/init.d/rcS\n\n....................\n```\n```c\nroot@ATK-IMX6U:/etc/rcS.d# ls -ll\ntotal 0\nlrwxrwxrwx 1 root root 20 Jun 10 18:21 S00psplash.sh -> ../init.d/psplash.sh\nlrwxrwxrwx 1 root root 19 Jun 10 18:21 S02banner.sh -> ../init.d/banner.sh\nlrwxrwxrwx 1 root root 18 Jun 10 18:21 S02sysfs.sh -> ../init.d/sysfs.sh\nlrwxrwxrwx 1 root root 21 Jun 10 18:21 S03mountall.sh -> ../init.d/mountall.sh\nlrwxrwxrwx 1 root root 14 Jun 10 18:21 S04udev -> ../init.d/udev\nlrwxrwxrwx 1 root root 21 Jun 10 18:21 S05modutils.sh -> ../init.d/modutils.sh\nlrwxrwxrwx 1 root root 22 Jun 10 18:21 S06alignment.sh -> ../init.d/alignment.sh\nlrwxrwxrwx 1 root root 22 Jun 10 18:21 S06checkroot.sh -> ../init.d/checkroot.sh\nlrwxrwxrwx 1 root root 18 Jun 10 18:21 S07bootlogd -> ../init.d/bootlogd\nlrwxrwxrwx 1 root root 34 Jun 10 18:21 S29read-only-rootfs-hook.sh -> ../init.d/read-only-rootfs-hook.sh\nlrwxrwxrwx 1 root root 20 Jun 10 18:21 S36udev-cache -> ../init.d/udev-cache\nlrwxrwxrwx 1 root root 30 Jun 10 18:21 S37populate-volatile.sh -> ../init.d/populate-volatile.sh\nlrwxrwxrwx 1 root root 19 Jun 10 18:21 S38devpts.sh -> ../init.d/devpts.sh\nlrwxrwxrwx 1 root root 18 Jun 10 18:21 S38dmesg.sh -> ../init.d/dmesg.sh\nlrwxrwxrwx 1 root root 17 Jun 10 18:21 S38urandom -> ../init.d/urandom\nlrwxrwxrwx 1 root root 20 Jun 10 18:21 S39alsa-state -> ../init.d/alsa-state\nlrwxrwxrwx 1 root root 21 Jun 10 18:21 S39hostname.sh -> ../init.d/hostname.sh\nlrwxrwxrwx 1 root root 21 Jun 10 18:21 S55bootmisc.sh -> ../init.d/bootmisc.sh\n```\n启动了../init.d/udev脚本\n\n```shell\n#!/bin/sh\n\n### BEGIN INIT INFO\n# Provides:          udev\n# Required-Start:    mountvirtfs\n# Required-Stop:     \n# Default-Start:     S\n# Default-Stop:\n# Short-Description: Start udevd, populate /dev and load drivers.\n### END INIT INFO\n\nexport TZ=/etc/localtime\n\n#检查是否存在 /sys/class 目录\n[ -d /sys/class ] || exit 1\n#检查 /proc/mounts 文件是否可读\n[ -r /proc/mounts ] || exit 1\n#检查 /sbin/udevd 是否可执行\n[ -x /sbin/udevd ] || exit 1\n\n# 路径到缓存的udev系统配置文件\nSYSCONF_CACHED=\"/etc/udev/cache.data\"\n\n# 路径到临时的udev系统配置文件\nSYSCONF_TMP=\"/dev/shm/udev.cache\"\n\n# 用于请求缓存重新生成的标记文件的路径\nDEVCACHE_REGEN=\"/dev/shm/udev-regen\" # 创建以请求缓存重新生成\n\n# 用作判断是否可以重新使用udev缓存的文件列表\nCMP_FILE_LIST=\"/proc/version /proc/cmdline /proc/devices\"\n[ -f /proc/atags ] && CMP_FILE_LIST=\"$CMP_FILE_LIST /proc/atags\"\n\n# 包含在缓存的系统状态中的文件的元数据（大小/修改时间/名称）的列表\nMETA_FILE_LIST=\"lib/udev/rules.d/* etc/udev/rules.d/*\"\n\n# 用于计算系统配置的命令函数\nsysconf_cmd () {\n\tcat -- $CMP_FILE_LIST        # 打印 CMP_FILE_LIST 中的文件内容\n\tstat -c '%s %Y %n' -- $META_FILE_LIST | awk -F/ '{print $1 \" \" $NF;}'  # 打印 META_FILE_LIST 中文件的元数据信息\n}\n\n\n[ -f /etc/default/udev-cache ] && . /etc/default/udev-cache\n[ -f /etc/udev/udev.conf ] && . /etc/udev/udev.conf\n[ -f /etc/default/rcS ] && . /etc/default/rcS\n\n# 终止正在运行的 udevd 进程的函数\nkill_udevd () {\n    pid=`pidof -x udevd`     # 获取 udevd 进程的 PID\n    [ -n \"$pid\" ] && kill $pid  # 如果 PID 存在，则使用 kill 命令终止进程\n}\n\ncase \"$1\" in\n  start)\n    export ACTION=add\n    # propagate /dev from /sys\n    echo \"Starting udev\"\n\n    # 在尝试启动 udev 之前，检查是否已加载了所需的 devtmpfs 文件系统，\n    # 如果未加载，则输出错误信息并停止系统。\n    if ! grep -q devtmpfs /proc/filesystems; then\n        echo \"Missing devtmpfs, which is required for udev to run\";\n        echo \"Halting...\"\n        halt\n    fi\n\n    # 如果尚未完成，在 /dev 上挂载 devtmpfs 文件系统\n    # 使用 LANG=C awk 来查找 /proc/mounts 文件中是否已挂载了 /dev 目录的 devtmpfs 文件系统。\n    # 如果找到，则退出状态为 1（表示没有找到），执行下面的花括号中的命令块。\n    LANG=C awk '$2 == \"/dev\" && ($3 == \"devtmpfs\") { exit 1 }' /proc/mounts && {\n        mount -n -o mode=0755 -t devtmpfs none \"/dev\"\n    }\n\n    # 如果 /dev/pts 不存在，则创建它，并设置权限为 0755。\n    [ -e /dev/pts ] || mkdir -m 0755 /dev/pts\n\n    # 如果 /dev/shm 不存在，则创建它，并设置权限为 1777。\n    [ -e /dev/shm ] || mkdir -m 1777 /dev/shm\n\n    # 为了满足 udev 的自动挂载规则，需要确保 /var/volatile/tmp 目录可用。\n    # 因为 /tmp 是一个符号链接到 /var/tmp，而 /var/tmp 又是一个符号链接到 /var/volatile/tmp，\n    # 所以需要确保 /var/volatile/tmp 目录存在。\n    mkdir -m 1777 -p /var/volatile/tmp\n\n\n    # Cache handling.\n    #DEVCACHE udev缓存我没使用不分析\n    if [ \"$DEVCACHE\" != \"\" ]; then\n            if [ -e $DEVCACHE ]; then\n\t\t    sysconf_cmd > \"$SYSCONF_TMP\"\n\t\t    if cmp $SYSCONF_CACHED $SYSCONF_TMP >/dev/null; then\n                            tar xmf $DEVCACHE -C / -m\n                            not_first_boot=1\n                            [ \"$VERBOSE\" != \"no\" ] && echo \"udev: using cache file $DEVCACHE\"\n                            [ -e $SYSCONF_TMP ] && rm -f \"$SYSCONF_TMP\"\n                            [ -e \"$DEVCACHE_REGEN\" ] && rm -f \"$DEVCACHE_REGEN\"\n                    else\n\t\t\t    # Output detailed reason why the cached /dev is not used\n\t\t\t    cat <<EOF\nudev: Not using udev cache because of changes detected in the following files:\nudev:     $CMP_FILE_LIST\nudev:     $META_FILE_LIST\nudev: The udev cache will be regenerated. To identify the detected changes,\nudev: compare the cached sysconf at   $SYSCONF_CACHED\nudev: against the current sysconf at  $SYSCONF_TMP\nEOF\n\t\t\t    touch \"$DEVCACHE_REGEN\"\n                    fi\n\t    else\n\t\t    if [ \"$ROOTFS_READ_ONLY\" != \"yes\" ]; then\n\t\t\t    # If rootfs is not read-only, it's possible that a new udev cache would be generated;\n\t\t\t    # otherwise, we do not bother to read files.\n\t\t\t    touch \"$DEVCACHE_REGEN\"\n\t\t    fi\n            fi\n    fi\n\n    # make_extra_nodes\n    # kill_udevd 函数用于终止 udevd 进程。在设备节点创建完成后，通常需要重新加载或者重启  # udevd 进程，以便它可以正确地识别和处理新增的设备。终止 udevd 进程后，它会重新启动并重新# 加载规则和配置，以适应新增的设备情况\n    kill_udevd > \"/dev/null\" 2>&1\n\n    # trigger the sorted events\n    # 这个文件通常用于指定在设备事件发生时要执行的热插拔处理程序（hotplug handler）。如果该文# 件存在，会将一个空字符写入该文件，这实际上是在通知系统要开始处理设备事件\n    [ -e /proc/sys/kernel/hotplug ] && echo -e '\\000' >/proc/sys/kernel/hotplug\n    # 这行代码启动 udevd 进程，参数 -d 表示以调试模式启动\n    /sbin/udevd -d\n\n    #这段代码是在设备事件触发后进行一系列的操作，以确保设备管理系统（udev）适当地处理新添加的设备\n    udevadm control --env=STARTUP=1\n    if [ \"$not_first_boot\" != \"\" ];then\n            if [ \"$PROBE_PLATFORM_BUS\" != \"yes\" ]; then\n                PLATFORM_BUS_NOMATCH=\"--subsystem-nomatch=platform\"\n            else\n                PLATFORM_BUS_NOMATCH=\"\"\n            fi\n            udevadm trigger --action=add --subsystem-nomatch=tty --subsystem-nomatch=mem --subsystem-nomatch=vc --subsystem-nomatch=vtconsole --subsystem-nomatch=misc --subsystem-nomatch=dcon --subsystem-nomatch=pci_bus --subsystem-nomatch=graphics --subsystem-nomatch=backlight --subsystem-nomatch=video4linux $PLATFORM_BUS_NOMATCH\n            (udevadm settle --timeout=3; udevadm control --env=STARTUP=)&\n    else\n            udevadm trigger --action=add\n            udevadm settle\n    fi\n    ;;\n  stop)\n    echo \"Stopping udevd\"\n    start-stop-daemon --stop --name udevd --quiet\n    ;;\n  restart)\n    $0 stop\n    sleep 1\n    $0 start\n    ;;\n  status)\n    pid=`pidof -x udevd`\n    if [ -n \"$pid\" ]; then\n\techo \"udevd (pid $pid) is running ...\"\n    else\n\techo \"udevd is stopped\"\n    fi\n    ;;\n  *)\n    echo \"Usage: $0 {start|stop|status|restart}\"\n    exit 1\nesac\nexit 0\n```\n\n# udevd使用方法\n[使用方法](https://linux.die.net/man/7/udev)\n\n## 配置文件-/etc/udev/udev.conf\n\nudev expects its main configuration file at /etc/udev/udev.conf. It consists of a set of variables allowing the user to override default udev values. The following variables can be set:\nudev 的主要配置文件位于 /etc/udev/udev.conf。它由一组变量组成，允许用户覆盖默认的 udev 值。可以设置以下变量： \n\nudev_root\n    Specifies where to place the device nodes in the filesystem. The default value is /dev. \n    指定在文件系统中放置设备节点的位置。默认值为/dev。 \nudev_log\n    The logging priority. Valid values are the numerical syslog priorities or their textual representations: err, info and debug. \n    记录优先级。有效值为数字系统日志优先级或其文本表示：err、info和debug。\n\n```shell\nroot@ATK-IMX6U:/etc/udev# cat udev.conf \n# see udev.conf(5) for details\nudev_root\"/dev/\"\nudev_log=\"info\"\nudev_rules=\"/etc/udev/rules.d/\"\n```\n\n## 规则文件-/etc/udev/rules.d/\n规则文件存放在udev_rules指定的目录下，并且文件名的后缀为.lures。规则文件可能有多个，匹配的先后顺序是安装ASCII码来进行的。如找到了比配的规则，则暂停匹配，不在去匹配后续的规则文件。所以自定义的规则文件基本上都是以数字开头，这样提高了规则文件的优先级。下图是简单的规则文件规则文件以行为单位，一行就是一条规则\n\n### udev规则所有操作符\n    “==”：　　比较键、值，若等于，则该条件满足；\n    “!=”： 　　比较键、值，若不等于，则该条件满足；\n    “=”： 　　 对一个键赋值；\n    “+=”：　　为一个表示多个条目的键赋值。\n    “:=”：　　对一个键赋值，并拒绝之后所有对该键的改动。目的是防止后面的规则文件对该键赋值。\n\n### udev规则的匹配键\n    ACTION： 　　 　　　事件 (uevent) 的行为，例如：add( 添加设备 )、remove( 删除设备 )。\n    KERNEL： 　　 　　　内核设备名称，例如：sda, cdrom。\n    DEVPATH：　　　　　 设备的 devpath 路径。\n    SUBSYSTEM： 　　　　设备的子系统名称，例如：sda 的子系统为 block。\n    BUS： 　　　　　　　 设备在 devpath 里的总线名称，例如：usb。\n    DRIVER： 　　　　 　设备在 devpath 里的设备驱动名称，例如：ide-cdrom。\n    ID： 　　　　　　　  设备在 devpath 里的识别号。\n    SYSFS{filename}： 设备的 devpath 路径下，设备的属性文件“filename”里的内容。例如：   SYSFS{model}==“ST936701SS”表示：如果设备的型号为 ST936701SS，则该设备匹配该匹配键。\n    \n    ENV{key}： 　　　　环境变量。在一条规则中，可以设定最多五条环境变量的 匹配键。\n    PROGRAM：　　　　　调用外部命令。\n    RESULT： 　　　　　外部命令 PROGRAM 的返回结果。\n\n### udev的重要赋值键\n    NAME： 　在 /dev下产生的设备文件名。只有第一次对某个设备的 NAME 的赋值行为生效，之后匹配的规则再对该设备的 NAME 赋值行为将被忽略。如果没有任何规则对设备的 NAME 赋值，udev 将使用内核设备名称来产生设备文件。\n    SYMLINK：　 为 /dev/下的设备文件产生符号链接。由于 udev 只能为某个设备产生一个设备文件，所以为了不覆盖系统默认的 udev 规则所产生的文件，推荐使用符号链接。\n    OWNER, GROUP, MODE：　　为设备设定权限。\n    ENV{key}：　　　　　　　　　导入一个环境变量。\n\n### udev的值和可调用的替换操作符\n    $kernel, %k：　　　　　　　　设备的内核设备名称，例如：sda、cdrom。\n    $number, %n：　　　　　　　 设备的内核号码，例如：sda3 的内核号码是 3。\n    $devpath, %p：　　　　　　　设备的 devpath路径。\n    $id, %b：　　　　　　　　　　设备在 devpath里的 ID 号。\n    $sysfs{file}, %s{file}：　　 设备的 sysfs里 file 的内容。其实就是设备的属性值。\n    $env{key}, %E{key}：　　　 一个环境变量的值。\n    $major, %M：　　　　　　　　设备的 major 号。\n    $minor %m：　　　　　　　　设备的 minor 号。\n    $result, %c：　　　　　　　　PROGRAM 返回的结果。\n    $parent, %P：　　　　　　 父设备的设备文件名。\n    $root, %r：　　　　　　　　 udev_root的值，默认是 /dev/。\n    $tempnode, %N：　　　　　　临时设备名。\n    %%：　　　　　　　　　　　　符号 % 本身。\n    $$：　　　　　　　　　　　　　符号 $ 本身。\n\n```shell\nroot@ATK-IMX6U:/etc/udev/rules.d# ls\n10-imx.rules         55-hpmud.rules              60-sysprof.rules        automount.rules   local.rules\n40-libgphoto2.rules  56-hpmud_add_printer.rules  80-net-name-slot.rules  autonet.rules\n50-firmware.rules    56-hpmud_support.rules      86-hpmud_plugin.rules   localextra.rules\nroot@ATK-IMX6U:/etc/udev/rules.d# cat 10-imx.rules \n# Create symlinks for i.mx keypads and touchscreens\n#SUBSYSTEM==\"input\" KERNEL==\"event*\" ATTRS{name}==\"mxckpd\",     SYMLINK+=\"input/keyboard0\"\n#SUBSYSTEM==\"input\" KERNEL==\"event*\" ATTRS{name}==\"mxc_ts\",     SYMLINK+=\"input/ts0\"\n#SUBSYSTEM==\"input\" KERNEL==\"event*\" ATTRS{name}==\"imx_adc_ts\", SYMLINK+=\"input/ts0\"\n#SUBSYSTEM==\"input\" KERNEL==\"event*\" ATTRS{name}==\"mpr084\",     SYMLINK+=\"input/keyboard0\"\n#SUBSYSTEM==\"input\" KERNEL==\"event*\" ATTRS{name}==\"tsc2007\",    SYMLINK+=\"input/ts0\"\n#SUBSYSTEM==\"input\" KERNEL==\"event*\" ATTRS{name} ==\"STMP3XXX touchscreen\",    SYMLINK+=\"input/ts0\"\n#SUBSYSTEM==\"input\" KERNEL==\"event*\" ATTRS{name} ==\"MXS touchscreen\",    SYMLINK+=\"input/ts0\"\n#SUBSYSTEM==\"input\" KERNEL==\"event*\" ATTRS{name} ==\"HannStar P1003 Touchscreen\",        SYMLINK+=\"input/ts0\"\n#SUBSYSTEM==\"input\" KERNEL==\"event*\" ATTRS{name} ==\"eGalax Touch Screen\",       SYMLINK+=\"input/ts0\"\n\n# The long class name gets cut off to be mc13783_connectiv in \n# /sys/class/mc13783_connectivity/mc13783_connectivit\nKERNEL==\"mc13783_connectiv*\",  NAME=\"mc13783_connectivity\"\n# Anyone has readonly permission to IIM device file\nKERNEL==\"mxc_iim\",  MODE=\"0444\", SYMLINK+=\"mxc_mem\"\nKERNEL==\"mxs_viim\", MODE=\"0444\", SYMLINK+=\"mxc_mem\"\nKERNEL==\"mxc_ipu\",  MODE=\"0666\"\nKERNEL==\"mxc_vpu\",  MODE=\"0666\"\nSUBSYSTEM==\"video\", MODE=\"0660\"\nKERNEL==\"fb[0-9]\",  MODE=\"0660\", GROUP=\"video\"\nKERNEL==\"gsl_kmod\", MODE=\"0660\", GROUP=\"video\"\nKERNEL==\"galcore\",  MODE=\"0660\", GROUP=\"video\"\n```\n\n# udev实战\nUDEV实现U盘SD卡自动挂载/卸载并且拷贝数据\n\n1.编译UDEV源码,执行arm-softfloat-linux-gnu-strip udev udevd udevstart udevinfo udevtest ,进行瘦身,并且拷贝这些文件到rootfs/bin文件夹下。\n\n2.修改rootfs/etc/init.d/rcS 脚本，添加如下命令：\n\n/bin/mount  -t  sysfs  sysfs /sys\n\n/bin/mount  -t  tmpfs  tmpfs /dev\n\n/bin/udevd  –-daemon              //创建udev的守护进程\n\n/bin/udevstart                    //启动\n\n3.在 /etc/udev/rules.d 目录下创建文件 10_usb.rules规则文件，他的语法是每个规则分成一个或多个“匹配”和“赋值”部分, 其内容如下\n\nKERNEL==\"sda1\", SUBSYSTEM==\"block\", RUN+=\"/sbin/usbmount.sh\"\n\nKERNEL SUBSYSTEM 为匹配，RUN就是赋值，意为执行usbmount.sh这个脚本。\n\n4.然后, 在 /sbin 目录中创建脚本文件usbmount.sh, 其内容为\n```shell\n#!/bin/sh\nif [ “$ACTION” = “add” ]\n    then\n        mount -t vfat  /dev/sda1 /tmp/udisk\n    mv   /mnt/yaffs/web_picture/*.jpg  /tmp/udisk\n    mv   /mnt/yaffs/collect_picture/*.jpg  /tmp/udisk\nelif [ “$ACTION” = \"remove\" ]\n    then\n        umount -l /tmp/udisk\nfi\n```\n注：udisk、web_piture、collect_picture文件需自己建立\n把该文件属性设置为可执行chmod 777 usbmount.sh\n有一点需要注意的是指定的脚本解析器是sh，如果指定bash正常情况是无法解析这个脚本的，我们的嵌入式系统都没有bash。\n插入U盘或者SD卡，触发add事件，执行10_usb.rules指定的/sbin/usbmount.sh脚本，因为是add ACTION，所以执行mount -t vfat  /dev/sda1 /tmp/udisk 。\n拔出时，触发remove事件，执行10_usb.rules指定的/sbin/usbmount.sh脚本，因为是 ACTION 这时为remove，所以执行umount –l /tmp/udisk 。\n\n# udevd源码分析\ndrivers/base/core.c：device_create()--->device_create_vargs()--->device_create_groups_vargs--->device_add()\n--->kobject_uevent()--->kobject_uevent_env()\n                            |\n                            |\n                            V\n```c\n/**\n * kobject_uevent_env - send an uevent with environmental data\n *\n * @action: action that is happening\n * @kobj: struct kobject that the action is happening to\n * @envp_ext: pointer to environmental data\n *\n * Returns 0 if kobject_uevent_env() is completed with success or the\n * corresponding error when it fails.\n */\nint kobject_uevent_env(struct kobject *kobj, enum kobject_action action,\n\t\t       char *envp_ext[])\n{\n    // ... （省略其他注释）\n\n    // search the kset we belong to\n    // 寻找所属的 kset\n    top_kobj = kobj;\n    while (!top_kobj->kset && top_kobj->parent)\n        top_kobj = top_kobj->parent;\n\n    if (!top_kobj->kset) {\n        pr_debug(\"kobject: '%s' (%p): %s: attempted to send uevent \"\n                 \"without kset!\\n\", kobject_name(kobj), kobj,\n                 __func__);\n        return -EINVAL;\n    }\n\n    // ... （省略其他注释）\n\n    // originating subsystem\n    // 事件的来源子系统\n    if (uevent_ops && uevent_ops->name)\n        subsystem = uevent_ops->name(kset, kobj);\n    else\n        subsystem = kobject_name(&kset->kobj);\n    if (!subsystem) {\n        pr_debug(\"kobject: '%s' (%p): %s: unset subsystem caused the \"\n                 \"event to drop!\\n\", kobject_name(kobj), kobj,\n                 __func__);\n        return 0;\n    }\n\n    // ... （省略其他注释）\n\n    // environment buffer\n    // 创建环境数据缓冲区\n    env = kzalloc(sizeof(struct kobj_uevent_env), GFP_KERNEL);\n    if (!env)\n        return -ENOMEM;\n\n    // ... （省略其他注释）\n\n    // complete object path\n    // 构建完整的对象路径\n    devpath = kobject_get_path(kobj, GFP_KERNEL);\n    if (!devpath) {\n        retval = -ENOENT;\n        goto exit;\n    }\n\n    // default keys\n    // 添加默认键\n    retval = add_uevent_var(env, \"ACTION=%s\", action_string);\n    if (retval)\n        goto exit;\n    retval = add_uevent_var(env, \"DEVPATH=%s\", devpath);\n    if (retval)\n        goto exit;\n    retval = add_uevent_var(env, \"SUBSYSTEM=%s\", subsystem);\n    if (retval)\n        goto exit;\n\n    // keys passed in from the caller\n    // 添加从调用者传入的键值对\n    if (envp_ext) {\n        for (i = 0; envp_ext[i]; i++) {\n            retval = add_uevent_var(env, \"%s\", envp_ext[i]);\n            if (retval)\n                goto exit;\n        }\n    }\n\n    // ... （省略其他注释）\n\n    /* let the kset specific function add its stuff */\n    // 调用 kset 特定函数添加额外的内容\n    if (uevent_ops && uevent_ops->uevent) {\n        // 如果 uevent_ops 存在且具有 uevent 函数\n        retval = uevent_ops->uevent(kset, kobj, env);\n        // 调用 kset 的 uevent 函数，并传递相应的参数\n        if (retval) {\n            // 如果 uevent 函数返回值不为零，表示出现了错误\n            pr_debug(\"kobject: '%s' (%p): %s: uevent() returned \"\n                    \"%d\\n\", kobject_name(kobj), kobj,\n                    __func__, retval);\n            goto exit;\n        }\n    }\n\n\nexit:\n    kfree(devpath);\n    kfree(env);\n    return retval;\n}\nEXPORT_SYMBOL_GPL(kobject_uevent_env);\n\n```\nudev工作过程如下：\n（1）当内核检测到系统中出现新设备后，内核会通过netlink套接字发送uevent;\n（2）udev获取内核发送的信息，进行规则匹配。从而创建设备节点。\nudev是在设备模块加载时，通过扫描/sys/class/下的设备目录，继而在/dev/目录下生成设备文件节点的。\n\nclass_create/device_create/udev的基本工作流程：\n\n（1） 驱动中使用class_create(…)函数，可以用它来创建一个类，这个类存放于sysfs下面（/sys/class）\n\n（2）一旦创建好了这个类，再调用device_create(…)函数在/dev目录下创建相应的设备节点。\n\n（3）insmod *.ko 加载模块的时候，用户空间中的udev会自动响应device_create(…)函数，去/sysfs下寻找对应的类从而创建设备节\n\n# device_create能创建dev的设备又需要udevd干什么\n \n`device_create` 函数是在 Linux 内核中用于创建设备节点的函数，通常在驱动程序中使用。这个函数创建的设备节点是内核空间的对象，用于向用户空间提供访问硬件设备的接口。`device_create` 并不依赖于 `udevd`，它在内核空间执行。\n\n然而，用户空间的 `/dev` 目录中的设备文件通常是由 `udev` 守护进程创建和管理的。`udev` 负责在设备插拔事件发生时自动创建、删除和管理设备文件，使得用户和应用程序能够方便地访问硬件设备。`udev` 的作用在于：\n\n1. **自动创建设备文件：** 当设备插入系统时，`udev` 可以自动为设备创建相应的设备文件，这样用户和应用程序可以通过这些设备文件来访问硬件设备，而无需手动创建设备文件。\n\n2. **根据规则进行设备管理：** `udev` 使用预定义的规则来确定如何为特定设备创建设备文件，以及如何设置权限、属性等。这使得设备管理变得灵活，可以根据设备属性和类型进行不同的处理。\n\n3. **设备节点持久化：** `udev` 确保设备文件的名称是持久的，并不会因为设备插拔而变化。这有助于应用程序在设备插拔后继续正常工作。\n\n因此，虽然 `device_create` 可以在内核中创建设备节点，但是 `udev` 在用户空间中负责创建和管理 `/dev` 目录下的设备文件，使设备访问更加方便、自动化和持久化。两者在不同的层级发挥作用，`device_create` 在内核空间创建设备节点，而 `udev` 在用户空间创建和管理设备文件。","source":"_posts/2023/08/process-udev.md","raw":"---\ntitle: process-udev\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-08-28 17:18:24\npassword:\nsummary:\ntags:\n- linux\n- process\ncategories:\n- process\n- linux\nkeywords:\ndescription:\n---\n\n# udev\n`udev`（用户空间设备管理器）是用于管理 Linux 内核设备和设备事件的守护进程。它的主要目的是在系统中自动检测硬件设备的插入、拔出等事件，并根据这些事件进行相应的设备管理操作，例如加载适当的驱动程序、创建设备节点、设置权限等。\n\n`udev` 本质上是一个守护进程，它会监听内核发送的事件（例如设备插入、拔出、属性变化等），并采取适当的措施来管理这些设备。为了实现这一功能，`udev` 使用了多线程技术。其中，`udev` 线程的主要任务包括：\n\n1. **事件监听：** `udev` 线程会监听内核发送的设备事件，例如设备的插入或拔出。\n\n2. **事件处理：** 一旦接收到设备事件，`udev` 线程会根据事件的类型和属性执行相应的处理操作。这可能涉及到加载驱动程序、创建设备文件、设置设备权限等。\n\n3. **规则执行：** `udev` 使用规则来描述设备的管理操作。当设备事件发生时，`udev` 线程会根据预定义的规则来判断需要执行哪些操作。\n\n4. **设备节点管理：** `udev` 线程会负责在 `/dev` 目录下创建和管理设备节点文件，这些文件用于与用户空间应用程序进行通信。\n\n5. **热插拔支持：** `udev` 线程使系统能够自动识别硬件的热插拔操作，并在设备插入或拔出时自动执行相应的管理操作。\n\n6. **属性处理：** `udev` 可以从设备的属性信息中获取有关设备的信息，并在必要时将这些属性信息用于设备管理操作。\n\n# udevd程序\n## BusyBox 构建根文件系统\nBusyBox中具有udev的功能，生成文件系统的时候在sbin/中生成了udev\n## udev移植\n从udev下载网址可以下载到udev的源码。下面为移植步骤。\n\n    下载udev源码包，并解压\n    修改Makefile中的CROSS交叉编译工具为自己开发板的编译器\n    执行make进行编译。\n    然后执行strip udev uded udevstart udevinfo udevtest。并将这些文件拷贝到rootfs/sbin目录下。\n    添加对udev的支持，修改/etc/init.d/rcS脚本，添加如下命令：\n\n```c\nroot@ATK-IMX6U:/sbin# ls -ll | grep udev                                        \nlrwxrwxrwx 1 root root       16 Jun 10 18:21 udevadm -> /usr/bin/udevadm\n-rwxr-xr-x 1 root root     239K Jul 20  2021 udevd\n```\n\n# udevd如何被运行\n根据[init线程启动/etc/inittab](https://qian-qiang.github.io/2023/08/process-init.html)可知会先执行si::sysinit:/etc/init.d/rcS文件的启动脚本\n\n```c\n...................\n# Boot-time system configuration/initialization script.\n# This is run first except when booting in emergency (-b) mode.\nsi::sysinit:/etc/init.d/rcS\n\n....................\n```\n```c\nroot@ATK-IMX6U:/etc/rcS.d# ls -ll\ntotal 0\nlrwxrwxrwx 1 root root 20 Jun 10 18:21 S00psplash.sh -> ../init.d/psplash.sh\nlrwxrwxrwx 1 root root 19 Jun 10 18:21 S02banner.sh -> ../init.d/banner.sh\nlrwxrwxrwx 1 root root 18 Jun 10 18:21 S02sysfs.sh -> ../init.d/sysfs.sh\nlrwxrwxrwx 1 root root 21 Jun 10 18:21 S03mountall.sh -> ../init.d/mountall.sh\nlrwxrwxrwx 1 root root 14 Jun 10 18:21 S04udev -> ../init.d/udev\nlrwxrwxrwx 1 root root 21 Jun 10 18:21 S05modutils.sh -> ../init.d/modutils.sh\nlrwxrwxrwx 1 root root 22 Jun 10 18:21 S06alignment.sh -> ../init.d/alignment.sh\nlrwxrwxrwx 1 root root 22 Jun 10 18:21 S06checkroot.sh -> ../init.d/checkroot.sh\nlrwxrwxrwx 1 root root 18 Jun 10 18:21 S07bootlogd -> ../init.d/bootlogd\nlrwxrwxrwx 1 root root 34 Jun 10 18:21 S29read-only-rootfs-hook.sh -> ../init.d/read-only-rootfs-hook.sh\nlrwxrwxrwx 1 root root 20 Jun 10 18:21 S36udev-cache -> ../init.d/udev-cache\nlrwxrwxrwx 1 root root 30 Jun 10 18:21 S37populate-volatile.sh -> ../init.d/populate-volatile.sh\nlrwxrwxrwx 1 root root 19 Jun 10 18:21 S38devpts.sh -> ../init.d/devpts.sh\nlrwxrwxrwx 1 root root 18 Jun 10 18:21 S38dmesg.sh -> ../init.d/dmesg.sh\nlrwxrwxrwx 1 root root 17 Jun 10 18:21 S38urandom -> ../init.d/urandom\nlrwxrwxrwx 1 root root 20 Jun 10 18:21 S39alsa-state -> ../init.d/alsa-state\nlrwxrwxrwx 1 root root 21 Jun 10 18:21 S39hostname.sh -> ../init.d/hostname.sh\nlrwxrwxrwx 1 root root 21 Jun 10 18:21 S55bootmisc.sh -> ../init.d/bootmisc.sh\n```\n启动了../init.d/udev脚本\n\n```shell\n#!/bin/sh\n\n### BEGIN INIT INFO\n# Provides:          udev\n# Required-Start:    mountvirtfs\n# Required-Stop:     \n# Default-Start:     S\n# Default-Stop:\n# Short-Description: Start udevd, populate /dev and load drivers.\n### END INIT INFO\n\nexport TZ=/etc/localtime\n\n#检查是否存在 /sys/class 目录\n[ -d /sys/class ] || exit 1\n#检查 /proc/mounts 文件是否可读\n[ -r /proc/mounts ] || exit 1\n#检查 /sbin/udevd 是否可执行\n[ -x /sbin/udevd ] || exit 1\n\n# 路径到缓存的udev系统配置文件\nSYSCONF_CACHED=\"/etc/udev/cache.data\"\n\n# 路径到临时的udev系统配置文件\nSYSCONF_TMP=\"/dev/shm/udev.cache\"\n\n# 用于请求缓存重新生成的标记文件的路径\nDEVCACHE_REGEN=\"/dev/shm/udev-regen\" # 创建以请求缓存重新生成\n\n# 用作判断是否可以重新使用udev缓存的文件列表\nCMP_FILE_LIST=\"/proc/version /proc/cmdline /proc/devices\"\n[ -f /proc/atags ] && CMP_FILE_LIST=\"$CMP_FILE_LIST /proc/atags\"\n\n# 包含在缓存的系统状态中的文件的元数据（大小/修改时间/名称）的列表\nMETA_FILE_LIST=\"lib/udev/rules.d/* etc/udev/rules.d/*\"\n\n# 用于计算系统配置的命令函数\nsysconf_cmd () {\n\tcat -- $CMP_FILE_LIST        # 打印 CMP_FILE_LIST 中的文件内容\n\tstat -c '%s %Y %n' -- $META_FILE_LIST | awk -F/ '{print $1 \" \" $NF;}'  # 打印 META_FILE_LIST 中文件的元数据信息\n}\n\n\n[ -f /etc/default/udev-cache ] && . /etc/default/udev-cache\n[ -f /etc/udev/udev.conf ] && . /etc/udev/udev.conf\n[ -f /etc/default/rcS ] && . /etc/default/rcS\n\n# 终止正在运行的 udevd 进程的函数\nkill_udevd () {\n    pid=`pidof -x udevd`     # 获取 udevd 进程的 PID\n    [ -n \"$pid\" ] && kill $pid  # 如果 PID 存在，则使用 kill 命令终止进程\n}\n\ncase \"$1\" in\n  start)\n    export ACTION=add\n    # propagate /dev from /sys\n    echo \"Starting udev\"\n\n    # 在尝试启动 udev 之前，检查是否已加载了所需的 devtmpfs 文件系统，\n    # 如果未加载，则输出错误信息并停止系统。\n    if ! grep -q devtmpfs /proc/filesystems; then\n        echo \"Missing devtmpfs, which is required for udev to run\";\n        echo \"Halting...\"\n        halt\n    fi\n\n    # 如果尚未完成，在 /dev 上挂载 devtmpfs 文件系统\n    # 使用 LANG=C awk 来查找 /proc/mounts 文件中是否已挂载了 /dev 目录的 devtmpfs 文件系统。\n    # 如果找到，则退出状态为 1（表示没有找到），执行下面的花括号中的命令块。\n    LANG=C awk '$2 == \"/dev\" && ($3 == \"devtmpfs\") { exit 1 }' /proc/mounts && {\n        mount -n -o mode=0755 -t devtmpfs none \"/dev\"\n    }\n\n    # 如果 /dev/pts 不存在，则创建它，并设置权限为 0755。\n    [ -e /dev/pts ] || mkdir -m 0755 /dev/pts\n\n    # 如果 /dev/shm 不存在，则创建它，并设置权限为 1777。\n    [ -e /dev/shm ] || mkdir -m 1777 /dev/shm\n\n    # 为了满足 udev 的自动挂载规则，需要确保 /var/volatile/tmp 目录可用。\n    # 因为 /tmp 是一个符号链接到 /var/tmp，而 /var/tmp 又是一个符号链接到 /var/volatile/tmp，\n    # 所以需要确保 /var/volatile/tmp 目录存在。\n    mkdir -m 1777 -p /var/volatile/tmp\n\n\n    # Cache handling.\n    #DEVCACHE udev缓存我没使用不分析\n    if [ \"$DEVCACHE\" != \"\" ]; then\n            if [ -e $DEVCACHE ]; then\n\t\t    sysconf_cmd > \"$SYSCONF_TMP\"\n\t\t    if cmp $SYSCONF_CACHED $SYSCONF_TMP >/dev/null; then\n                            tar xmf $DEVCACHE -C / -m\n                            not_first_boot=1\n                            [ \"$VERBOSE\" != \"no\" ] && echo \"udev: using cache file $DEVCACHE\"\n                            [ -e $SYSCONF_TMP ] && rm -f \"$SYSCONF_TMP\"\n                            [ -e \"$DEVCACHE_REGEN\" ] && rm -f \"$DEVCACHE_REGEN\"\n                    else\n\t\t\t    # Output detailed reason why the cached /dev is not used\n\t\t\t    cat <<EOF\nudev: Not using udev cache because of changes detected in the following files:\nudev:     $CMP_FILE_LIST\nudev:     $META_FILE_LIST\nudev: The udev cache will be regenerated. To identify the detected changes,\nudev: compare the cached sysconf at   $SYSCONF_CACHED\nudev: against the current sysconf at  $SYSCONF_TMP\nEOF\n\t\t\t    touch \"$DEVCACHE_REGEN\"\n                    fi\n\t    else\n\t\t    if [ \"$ROOTFS_READ_ONLY\" != \"yes\" ]; then\n\t\t\t    # If rootfs is not read-only, it's possible that a new udev cache would be generated;\n\t\t\t    # otherwise, we do not bother to read files.\n\t\t\t    touch \"$DEVCACHE_REGEN\"\n\t\t    fi\n            fi\n    fi\n\n    # make_extra_nodes\n    # kill_udevd 函数用于终止 udevd 进程。在设备节点创建完成后，通常需要重新加载或者重启  # udevd 进程，以便它可以正确地识别和处理新增的设备。终止 udevd 进程后，它会重新启动并重新# 加载规则和配置，以适应新增的设备情况\n    kill_udevd > \"/dev/null\" 2>&1\n\n    # trigger the sorted events\n    # 这个文件通常用于指定在设备事件发生时要执行的热插拔处理程序（hotplug handler）。如果该文# 件存在，会将一个空字符写入该文件，这实际上是在通知系统要开始处理设备事件\n    [ -e /proc/sys/kernel/hotplug ] && echo -e '\\000' >/proc/sys/kernel/hotplug\n    # 这行代码启动 udevd 进程，参数 -d 表示以调试模式启动\n    /sbin/udevd -d\n\n    #这段代码是在设备事件触发后进行一系列的操作，以确保设备管理系统（udev）适当地处理新添加的设备\n    udevadm control --env=STARTUP=1\n    if [ \"$not_first_boot\" != \"\" ];then\n            if [ \"$PROBE_PLATFORM_BUS\" != \"yes\" ]; then\n                PLATFORM_BUS_NOMATCH=\"--subsystem-nomatch=platform\"\n            else\n                PLATFORM_BUS_NOMATCH=\"\"\n            fi\n            udevadm trigger --action=add --subsystem-nomatch=tty --subsystem-nomatch=mem --subsystem-nomatch=vc --subsystem-nomatch=vtconsole --subsystem-nomatch=misc --subsystem-nomatch=dcon --subsystem-nomatch=pci_bus --subsystem-nomatch=graphics --subsystem-nomatch=backlight --subsystem-nomatch=video4linux $PLATFORM_BUS_NOMATCH\n            (udevadm settle --timeout=3; udevadm control --env=STARTUP=)&\n    else\n            udevadm trigger --action=add\n            udevadm settle\n    fi\n    ;;\n  stop)\n    echo \"Stopping udevd\"\n    start-stop-daemon --stop --name udevd --quiet\n    ;;\n  restart)\n    $0 stop\n    sleep 1\n    $0 start\n    ;;\n  status)\n    pid=`pidof -x udevd`\n    if [ -n \"$pid\" ]; then\n\techo \"udevd (pid $pid) is running ...\"\n    else\n\techo \"udevd is stopped\"\n    fi\n    ;;\n  *)\n    echo \"Usage: $0 {start|stop|status|restart}\"\n    exit 1\nesac\nexit 0\n```\n\n# udevd使用方法\n[使用方法](https://linux.die.net/man/7/udev)\n\n## 配置文件-/etc/udev/udev.conf\n\nudev expects its main configuration file at /etc/udev/udev.conf. It consists of a set of variables allowing the user to override default udev values. The following variables can be set:\nudev 的主要配置文件位于 /etc/udev/udev.conf。它由一组变量组成，允许用户覆盖默认的 udev 值。可以设置以下变量： \n\nudev_root\n    Specifies where to place the device nodes in the filesystem. The default value is /dev. \n    指定在文件系统中放置设备节点的位置。默认值为/dev。 \nudev_log\n    The logging priority. Valid values are the numerical syslog priorities or their textual representations: err, info and debug. \n    记录优先级。有效值为数字系统日志优先级或其文本表示：err、info和debug。\n\n```shell\nroot@ATK-IMX6U:/etc/udev# cat udev.conf \n# see udev.conf(5) for details\nudev_root\"/dev/\"\nudev_log=\"info\"\nudev_rules=\"/etc/udev/rules.d/\"\n```\n\n## 规则文件-/etc/udev/rules.d/\n规则文件存放在udev_rules指定的目录下，并且文件名的后缀为.lures。规则文件可能有多个，匹配的先后顺序是安装ASCII码来进行的。如找到了比配的规则，则暂停匹配，不在去匹配后续的规则文件。所以自定义的规则文件基本上都是以数字开头，这样提高了规则文件的优先级。下图是简单的规则文件规则文件以行为单位，一行就是一条规则\n\n### udev规则所有操作符\n    “==”：　　比较键、值，若等于，则该条件满足；\n    “!=”： 　　比较键、值，若不等于，则该条件满足；\n    “=”： 　　 对一个键赋值；\n    “+=”：　　为一个表示多个条目的键赋值。\n    “:=”：　　对一个键赋值，并拒绝之后所有对该键的改动。目的是防止后面的规则文件对该键赋值。\n\n### udev规则的匹配键\n    ACTION： 　　 　　　事件 (uevent) 的行为，例如：add( 添加设备 )、remove( 删除设备 )。\n    KERNEL： 　　 　　　内核设备名称，例如：sda, cdrom。\n    DEVPATH：　　　　　 设备的 devpath 路径。\n    SUBSYSTEM： 　　　　设备的子系统名称，例如：sda 的子系统为 block。\n    BUS： 　　　　　　　 设备在 devpath 里的总线名称，例如：usb。\n    DRIVER： 　　　　 　设备在 devpath 里的设备驱动名称，例如：ide-cdrom。\n    ID： 　　　　　　　  设备在 devpath 里的识别号。\n    SYSFS{filename}： 设备的 devpath 路径下，设备的属性文件“filename”里的内容。例如：   SYSFS{model}==“ST936701SS”表示：如果设备的型号为 ST936701SS，则该设备匹配该匹配键。\n    \n    ENV{key}： 　　　　环境变量。在一条规则中，可以设定最多五条环境变量的 匹配键。\n    PROGRAM：　　　　　调用外部命令。\n    RESULT： 　　　　　外部命令 PROGRAM 的返回结果。\n\n### udev的重要赋值键\n    NAME： 　在 /dev下产生的设备文件名。只有第一次对某个设备的 NAME 的赋值行为生效，之后匹配的规则再对该设备的 NAME 赋值行为将被忽略。如果没有任何规则对设备的 NAME 赋值，udev 将使用内核设备名称来产生设备文件。\n    SYMLINK：　 为 /dev/下的设备文件产生符号链接。由于 udev 只能为某个设备产生一个设备文件，所以为了不覆盖系统默认的 udev 规则所产生的文件，推荐使用符号链接。\n    OWNER, GROUP, MODE：　　为设备设定权限。\n    ENV{key}：　　　　　　　　　导入一个环境变量。\n\n### udev的值和可调用的替换操作符\n    $kernel, %k：　　　　　　　　设备的内核设备名称，例如：sda、cdrom。\n    $number, %n：　　　　　　　 设备的内核号码，例如：sda3 的内核号码是 3。\n    $devpath, %p：　　　　　　　设备的 devpath路径。\n    $id, %b：　　　　　　　　　　设备在 devpath里的 ID 号。\n    $sysfs{file}, %s{file}：　　 设备的 sysfs里 file 的内容。其实就是设备的属性值。\n    $env{key}, %E{key}：　　　 一个环境变量的值。\n    $major, %M：　　　　　　　　设备的 major 号。\n    $minor %m：　　　　　　　　设备的 minor 号。\n    $result, %c：　　　　　　　　PROGRAM 返回的结果。\n    $parent, %P：　　　　　　 父设备的设备文件名。\n    $root, %r：　　　　　　　　 udev_root的值，默认是 /dev/。\n    $tempnode, %N：　　　　　　临时设备名。\n    %%：　　　　　　　　　　　　符号 % 本身。\n    $$：　　　　　　　　　　　　　符号 $ 本身。\n\n```shell\nroot@ATK-IMX6U:/etc/udev/rules.d# ls\n10-imx.rules         55-hpmud.rules              60-sysprof.rules        automount.rules   local.rules\n40-libgphoto2.rules  56-hpmud_add_printer.rules  80-net-name-slot.rules  autonet.rules\n50-firmware.rules    56-hpmud_support.rules      86-hpmud_plugin.rules   localextra.rules\nroot@ATK-IMX6U:/etc/udev/rules.d# cat 10-imx.rules \n# Create symlinks for i.mx keypads and touchscreens\n#SUBSYSTEM==\"input\" KERNEL==\"event*\" ATTRS{name}==\"mxckpd\",     SYMLINK+=\"input/keyboard0\"\n#SUBSYSTEM==\"input\" KERNEL==\"event*\" ATTRS{name}==\"mxc_ts\",     SYMLINK+=\"input/ts0\"\n#SUBSYSTEM==\"input\" KERNEL==\"event*\" ATTRS{name}==\"imx_adc_ts\", SYMLINK+=\"input/ts0\"\n#SUBSYSTEM==\"input\" KERNEL==\"event*\" ATTRS{name}==\"mpr084\",     SYMLINK+=\"input/keyboard0\"\n#SUBSYSTEM==\"input\" KERNEL==\"event*\" ATTRS{name}==\"tsc2007\",    SYMLINK+=\"input/ts0\"\n#SUBSYSTEM==\"input\" KERNEL==\"event*\" ATTRS{name} ==\"STMP3XXX touchscreen\",    SYMLINK+=\"input/ts0\"\n#SUBSYSTEM==\"input\" KERNEL==\"event*\" ATTRS{name} ==\"MXS touchscreen\",    SYMLINK+=\"input/ts0\"\n#SUBSYSTEM==\"input\" KERNEL==\"event*\" ATTRS{name} ==\"HannStar P1003 Touchscreen\",        SYMLINK+=\"input/ts0\"\n#SUBSYSTEM==\"input\" KERNEL==\"event*\" ATTRS{name} ==\"eGalax Touch Screen\",       SYMLINK+=\"input/ts0\"\n\n# The long class name gets cut off to be mc13783_connectiv in \n# /sys/class/mc13783_connectivity/mc13783_connectivit\nKERNEL==\"mc13783_connectiv*\",  NAME=\"mc13783_connectivity\"\n# Anyone has readonly permission to IIM device file\nKERNEL==\"mxc_iim\",  MODE=\"0444\", SYMLINK+=\"mxc_mem\"\nKERNEL==\"mxs_viim\", MODE=\"0444\", SYMLINK+=\"mxc_mem\"\nKERNEL==\"mxc_ipu\",  MODE=\"0666\"\nKERNEL==\"mxc_vpu\",  MODE=\"0666\"\nSUBSYSTEM==\"video\", MODE=\"0660\"\nKERNEL==\"fb[0-9]\",  MODE=\"0660\", GROUP=\"video\"\nKERNEL==\"gsl_kmod\", MODE=\"0660\", GROUP=\"video\"\nKERNEL==\"galcore\",  MODE=\"0660\", GROUP=\"video\"\n```\n\n# udev实战\nUDEV实现U盘SD卡自动挂载/卸载并且拷贝数据\n\n1.编译UDEV源码,执行arm-softfloat-linux-gnu-strip udev udevd udevstart udevinfo udevtest ,进行瘦身,并且拷贝这些文件到rootfs/bin文件夹下。\n\n2.修改rootfs/etc/init.d/rcS 脚本，添加如下命令：\n\n/bin/mount  -t  sysfs  sysfs /sys\n\n/bin/mount  -t  tmpfs  tmpfs /dev\n\n/bin/udevd  –-daemon              //创建udev的守护进程\n\n/bin/udevstart                    //启动\n\n3.在 /etc/udev/rules.d 目录下创建文件 10_usb.rules规则文件，他的语法是每个规则分成一个或多个“匹配”和“赋值”部分, 其内容如下\n\nKERNEL==\"sda1\", SUBSYSTEM==\"block\", RUN+=\"/sbin/usbmount.sh\"\n\nKERNEL SUBSYSTEM 为匹配，RUN就是赋值，意为执行usbmount.sh这个脚本。\n\n4.然后, 在 /sbin 目录中创建脚本文件usbmount.sh, 其内容为\n```shell\n#!/bin/sh\nif [ “$ACTION” = “add” ]\n    then\n        mount -t vfat  /dev/sda1 /tmp/udisk\n    mv   /mnt/yaffs/web_picture/*.jpg  /tmp/udisk\n    mv   /mnt/yaffs/collect_picture/*.jpg  /tmp/udisk\nelif [ “$ACTION” = \"remove\" ]\n    then\n        umount -l /tmp/udisk\nfi\n```\n注：udisk、web_piture、collect_picture文件需自己建立\n把该文件属性设置为可执行chmod 777 usbmount.sh\n有一点需要注意的是指定的脚本解析器是sh，如果指定bash正常情况是无法解析这个脚本的，我们的嵌入式系统都没有bash。\n插入U盘或者SD卡，触发add事件，执行10_usb.rules指定的/sbin/usbmount.sh脚本，因为是add ACTION，所以执行mount -t vfat  /dev/sda1 /tmp/udisk 。\n拔出时，触发remove事件，执行10_usb.rules指定的/sbin/usbmount.sh脚本，因为是 ACTION 这时为remove，所以执行umount –l /tmp/udisk 。\n\n# udevd源码分析\ndrivers/base/core.c：device_create()--->device_create_vargs()--->device_create_groups_vargs--->device_add()\n--->kobject_uevent()--->kobject_uevent_env()\n                            |\n                            |\n                            V\n```c\n/**\n * kobject_uevent_env - send an uevent with environmental data\n *\n * @action: action that is happening\n * @kobj: struct kobject that the action is happening to\n * @envp_ext: pointer to environmental data\n *\n * Returns 0 if kobject_uevent_env() is completed with success or the\n * corresponding error when it fails.\n */\nint kobject_uevent_env(struct kobject *kobj, enum kobject_action action,\n\t\t       char *envp_ext[])\n{\n    // ... （省略其他注释）\n\n    // search the kset we belong to\n    // 寻找所属的 kset\n    top_kobj = kobj;\n    while (!top_kobj->kset && top_kobj->parent)\n        top_kobj = top_kobj->parent;\n\n    if (!top_kobj->kset) {\n        pr_debug(\"kobject: '%s' (%p): %s: attempted to send uevent \"\n                 \"without kset!\\n\", kobject_name(kobj), kobj,\n                 __func__);\n        return -EINVAL;\n    }\n\n    // ... （省略其他注释）\n\n    // originating subsystem\n    // 事件的来源子系统\n    if (uevent_ops && uevent_ops->name)\n        subsystem = uevent_ops->name(kset, kobj);\n    else\n        subsystem = kobject_name(&kset->kobj);\n    if (!subsystem) {\n        pr_debug(\"kobject: '%s' (%p): %s: unset subsystem caused the \"\n                 \"event to drop!\\n\", kobject_name(kobj), kobj,\n                 __func__);\n        return 0;\n    }\n\n    // ... （省略其他注释）\n\n    // environment buffer\n    // 创建环境数据缓冲区\n    env = kzalloc(sizeof(struct kobj_uevent_env), GFP_KERNEL);\n    if (!env)\n        return -ENOMEM;\n\n    // ... （省略其他注释）\n\n    // complete object path\n    // 构建完整的对象路径\n    devpath = kobject_get_path(kobj, GFP_KERNEL);\n    if (!devpath) {\n        retval = -ENOENT;\n        goto exit;\n    }\n\n    // default keys\n    // 添加默认键\n    retval = add_uevent_var(env, \"ACTION=%s\", action_string);\n    if (retval)\n        goto exit;\n    retval = add_uevent_var(env, \"DEVPATH=%s\", devpath);\n    if (retval)\n        goto exit;\n    retval = add_uevent_var(env, \"SUBSYSTEM=%s\", subsystem);\n    if (retval)\n        goto exit;\n\n    // keys passed in from the caller\n    // 添加从调用者传入的键值对\n    if (envp_ext) {\n        for (i = 0; envp_ext[i]; i++) {\n            retval = add_uevent_var(env, \"%s\", envp_ext[i]);\n            if (retval)\n                goto exit;\n        }\n    }\n\n    // ... （省略其他注释）\n\n    /* let the kset specific function add its stuff */\n    // 调用 kset 特定函数添加额外的内容\n    if (uevent_ops && uevent_ops->uevent) {\n        // 如果 uevent_ops 存在且具有 uevent 函数\n        retval = uevent_ops->uevent(kset, kobj, env);\n        // 调用 kset 的 uevent 函数，并传递相应的参数\n        if (retval) {\n            // 如果 uevent 函数返回值不为零，表示出现了错误\n            pr_debug(\"kobject: '%s' (%p): %s: uevent() returned \"\n                    \"%d\\n\", kobject_name(kobj), kobj,\n                    __func__, retval);\n            goto exit;\n        }\n    }\n\n\nexit:\n    kfree(devpath);\n    kfree(env);\n    return retval;\n}\nEXPORT_SYMBOL_GPL(kobject_uevent_env);\n\n```\nudev工作过程如下：\n（1）当内核检测到系统中出现新设备后，内核会通过netlink套接字发送uevent;\n（2）udev获取内核发送的信息，进行规则匹配。从而创建设备节点。\nudev是在设备模块加载时，通过扫描/sys/class/下的设备目录，继而在/dev/目录下生成设备文件节点的。\n\nclass_create/device_create/udev的基本工作流程：\n\n（1） 驱动中使用class_create(…)函数，可以用它来创建一个类，这个类存放于sysfs下面（/sys/class）\n\n（2）一旦创建好了这个类，再调用device_create(…)函数在/dev目录下创建相应的设备节点。\n\n（3）insmod *.ko 加载模块的时候，用户空间中的udev会自动响应device_create(…)函数，去/sysfs下寻找对应的类从而创建设备节\n\n# device_create能创建dev的设备又需要udevd干什么\n \n`device_create` 函数是在 Linux 内核中用于创建设备节点的函数，通常在驱动程序中使用。这个函数创建的设备节点是内核空间的对象，用于向用户空间提供访问硬件设备的接口。`device_create` 并不依赖于 `udevd`，它在内核空间执行。\n\n然而，用户空间的 `/dev` 目录中的设备文件通常是由 `udev` 守护进程创建和管理的。`udev` 负责在设备插拔事件发生时自动创建、删除和管理设备文件，使得用户和应用程序能够方便地访问硬件设备。`udev` 的作用在于：\n\n1. **自动创建设备文件：** 当设备插入系统时，`udev` 可以自动为设备创建相应的设备文件，这样用户和应用程序可以通过这些设备文件来访问硬件设备，而无需手动创建设备文件。\n\n2. **根据规则进行设备管理：** `udev` 使用预定义的规则来确定如何为特定设备创建设备文件，以及如何设置权限、属性等。这使得设备管理变得灵活，可以根据设备属性和类型进行不同的处理。\n\n3. **设备节点持久化：** `udev` 确保设备文件的名称是持久的，并不会因为设备插拔而变化。这有助于应用程序在设备插拔后继续正常工作。\n\n因此，虽然 `device_create` 可以在内核中创建设备节点，但是 `udev` 在用户空间中负责创建和管理 `/dev` 目录下的设备文件，使设备访问更加方便、自动化和持久化。两者在不同的层级发挥作用，`device_create` 在内核空间创建设备节点，而 `udev` 在用户空间创建和管理设备文件。","slug":"process-udev","published":1,"updated":"2024-01-05T08:12:19.809Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clru1g21w002is4fufa8aksmk","content":"<h1 id=\"udev\"><a href=\"#udev\" class=\"headerlink\" title=\"udev\"></a>udev</h1><p><code>udev</code>（用户空间设备管理器）是用于管理 Linux 内核设备和设备事件的守护进程。它的主要目的是在系统中自动检测硬件设备的插入、拔出等事件，并根据这些事件进行相应的设备管理操作，例如加载适当的驱动程序、创建设备节点、设置权限等。</p>\n<p><code>udev</code> 本质上是一个守护进程，它会监听内核发送的事件（例如设备插入、拔出、属性变化等），并采取适当的措施来管理这些设备。为了实现这一功能，<code>udev</code> 使用了多线程技术。其中，<code>udev</code> 线程的主要任务包括：</p>\n<ol>\n<li><p><strong>事件监听：</strong> <code>udev</code> 线程会监听内核发送的设备事件，例如设备的插入或拔出。</p>\n</li>\n<li><p><strong>事件处理：</strong> 一旦接收到设备事件，<code>udev</code> 线程会根据事件的类型和属性执行相应的处理操作。这可能涉及到加载驱动程序、创建设备文件、设置设备权限等。</p>\n</li>\n<li><p><strong>规则执行：</strong> <code>udev</code> 使用规则来描述设备的管理操作。当设备事件发生时，<code>udev</code> 线程会根据预定义的规则来判断需要执行哪些操作。</p>\n</li>\n<li><p><strong>设备节点管理：</strong> <code>udev</code> 线程会负责在 <code>/dev</code> 目录下创建和管理设备节点文件，这些文件用于与用户空间应用程序进行通信。</p>\n</li>\n<li><p><strong>热插拔支持：</strong> <code>udev</code> 线程使系统能够自动识别硬件的热插拔操作，并在设备插入或拔出时自动执行相应的管理操作。</p>\n</li>\n<li><p><strong>属性处理：</strong> <code>udev</code> 可以从设备的属性信息中获取有关设备的信息，并在必要时将这些属性信息用于设备管理操作。</p>\n</li>\n</ol>\n<h1 id=\"udevd程序\"><a href=\"#udevd程序\" class=\"headerlink\" title=\"udevd程序\"></a>udevd程序</h1><h2 id=\"BusyBox-构建根文件系统\"><a href=\"#BusyBox-构建根文件系统\" class=\"headerlink\" title=\"BusyBox 构建根文件系统\"></a>BusyBox 构建根文件系统</h2><p>BusyBox中具有udev的功能，生成文件系统的时候在sbin/中生成了udev</p>\n<h2 id=\"udev移植\"><a href=\"#udev移植\" class=\"headerlink\" title=\"udev移植\"></a>udev移植</h2><p>从udev下载网址可以下载到udev的源码。下面为移植步骤。</p>\n<pre><code>下载udev源码包，并解压\n修改Makefile中的CROSS交叉编译工具为自己开发板的编译器\n执行make进行编译。\n然后执行strip udev uded udevstart udevinfo udevtest。并将这些文件拷贝到rootfs/sbin目录下。\n添加对udev的支持，修改/etc/init.d/rcS脚本，添加如下命令：</code></pre><pre class=\" language-c\"><code class=\"language-c\">root@ATK<span class=\"token operator\">-</span>IMX6U<span class=\"token punctuation\">:</span><span class=\"token operator\">/</span>sbin# ls <span class=\"token operator\">-</span>ll <span class=\"token operator\">|</span> grep udev                                        \nlrwxrwxrwx <span class=\"token number\">1</span> root root       <span class=\"token number\">16</span> Jun <span class=\"token number\">10</span> <span class=\"token number\">18</span><span class=\"token punctuation\">:</span><span class=\"token number\">21</span> udevadm <span class=\"token operator\">-></span> <span class=\"token operator\">/</span>usr<span class=\"token operator\">/</span>bin<span class=\"token operator\">/</span>udevadm\n<span class=\"token operator\">-</span>rwxr<span class=\"token operator\">-</span>xr<span class=\"token operator\">-</span>x <span class=\"token number\">1</span> root root     239K Jul <span class=\"token number\">20</span>  <span class=\"token number\">2021</span> udevd</code></pre>\n<h1 id=\"udevd如何被运行\"><a href=\"#udevd如何被运行\" class=\"headerlink\" title=\"udevd如何被运行\"></a>udevd如何被运行</h1><p>根据<a href=\"https://qian-qiang.github.io/2023/08/process-init.html\">init线程启动/etc/inittab</a>可知会先执行si::sysinit:/etc/init.d/rcS文件的启动脚本</p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token macro property\"># Boot-time system configuration/initialization script.</span>\n<span class=\"token macro property\"># This is run first except when booting in emergency (-b) mode.</span>\nsi<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>sysinit<span class=\"token punctuation\">:</span><span class=\"token operator\">/</span>etc<span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>rcS\n\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></code></pre>\n<pre class=\" language-c\"><code class=\"language-c\">root@ATK<span class=\"token operator\">-</span>IMX6U<span class=\"token punctuation\">:</span><span class=\"token operator\">/</span>etc<span class=\"token operator\">/</span>rcS<span class=\"token punctuation\">.</span>d# ls <span class=\"token operator\">-</span>ll\ntotal <span class=\"token number\">0</span>\nlrwxrwxrwx <span class=\"token number\">1</span> root root <span class=\"token number\">20</span> Jun <span class=\"token number\">10</span> <span class=\"token number\">18</span><span class=\"token punctuation\">:</span><span class=\"token number\">21</span> S00psplash<span class=\"token punctuation\">.</span>sh <span class=\"token operator\">-></span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>psplash<span class=\"token punctuation\">.</span>sh\nlrwxrwxrwx <span class=\"token number\">1</span> root root <span class=\"token number\">19</span> Jun <span class=\"token number\">10</span> <span class=\"token number\">18</span><span class=\"token punctuation\">:</span><span class=\"token number\">21</span> S02banner<span class=\"token punctuation\">.</span>sh <span class=\"token operator\">-></span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>banner<span class=\"token punctuation\">.</span>sh\nlrwxrwxrwx <span class=\"token number\">1</span> root root <span class=\"token number\">18</span> Jun <span class=\"token number\">10</span> <span class=\"token number\">18</span><span class=\"token punctuation\">:</span><span class=\"token number\">21</span> S02sysfs<span class=\"token punctuation\">.</span>sh <span class=\"token operator\">-></span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>sysfs<span class=\"token punctuation\">.</span>sh\nlrwxrwxrwx <span class=\"token number\">1</span> root root <span class=\"token number\">21</span> Jun <span class=\"token number\">10</span> <span class=\"token number\">18</span><span class=\"token punctuation\">:</span><span class=\"token number\">21</span> S03mountall<span class=\"token punctuation\">.</span>sh <span class=\"token operator\">-></span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>mountall<span class=\"token punctuation\">.</span>sh\nlrwxrwxrwx <span class=\"token number\">1</span> root root <span class=\"token number\">14</span> Jun <span class=\"token number\">10</span> <span class=\"token number\">18</span><span class=\"token punctuation\">:</span><span class=\"token number\">21</span> S04udev <span class=\"token operator\">-></span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>udev\nlrwxrwxrwx <span class=\"token number\">1</span> root root <span class=\"token number\">21</span> Jun <span class=\"token number\">10</span> <span class=\"token number\">18</span><span class=\"token punctuation\">:</span><span class=\"token number\">21</span> S05modutils<span class=\"token punctuation\">.</span>sh <span class=\"token operator\">-></span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>modutils<span class=\"token punctuation\">.</span>sh\nlrwxrwxrwx <span class=\"token number\">1</span> root root <span class=\"token number\">22</span> Jun <span class=\"token number\">10</span> <span class=\"token number\">18</span><span class=\"token punctuation\">:</span><span class=\"token number\">21</span> S06alignment<span class=\"token punctuation\">.</span>sh <span class=\"token operator\">-></span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>alignment<span class=\"token punctuation\">.</span>sh\nlrwxrwxrwx <span class=\"token number\">1</span> root root <span class=\"token number\">22</span> Jun <span class=\"token number\">10</span> <span class=\"token number\">18</span><span class=\"token punctuation\">:</span><span class=\"token number\">21</span> S06checkroot<span class=\"token punctuation\">.</span>sh <span class=\"token operator\">-></span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>checkroot<span class=\"token punctuation\">.</span>sh\nlrwxrwxrwx <span class=\"token number\">1</span> root root <span class=\"token number\">18</span> Jun <span class=\"token number\">10</span> <span class=\"token number\">18</span><span class=\"token punctuation\">:</span><span class=\"token number\">21</span> S07bootlogd <span class=\"token operator\">-></span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>bootlogd\nlrwxrwxrwx <span class=\"token number\">1</span> root root <span class=\"token number\">34</span> Jun <span class=\"token number\">10</span> <span class=\"token number\">18</span><span class=\"token punctuation\">:</span><span class=\"token number\">21</span> S29read<span class=\"token operator\">-</span>only<span class=\"token operator\">-</span>rootfs<span class=\"token operator\">-</span>hook<span class=\"token punctuation\">.</span>sh <span class=\"token operator\">-></span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>read<span class=\"token operator\">-</span>only<span class=\"token operator\">-</span>rootfs<span class=\"token operator\">-</span>hook<span class=\"token punctuation\">.</span>sh\nlrwxrwxrwx <span class=\"token number\">1</span> root root <span class=\"token number\">20</span> Jun <span class=\"token number\">10</span> <span class=\"token number\">18</span><span class=\"token punctuation\">:</span><span class=\"token number\">21</span> S36udev<span class=\"token operator\">-</span>cache <span class=\"token operator\">-></span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>udev<span class=\"token operator\">-</span>cache\nlrwxrwxrwx <span class=\"token number\">1</span> root root <span class=\"token number\">30</span> Jun <span class=\"token number\">10</span> <span class=\"token number\">18</span><span class=\"token punctuation\">:</span><span class=\"token number\">21</span> S37populate<span class=\"token operator\">-</span><span class=\"token keyword\">volatile</span><span class=\"token punctuation\">.</span>sh <span class=\"token operator\">-></span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>populate<span class=\"token operator\">-</span><span class=\"token keyword\">volatile</span><span class=\"token punctuation\">.</span>sh\nlrwxrwxrwx <span class=\"token number\">1</span> root root <span class=\"token number\">19</span> Jun <span class=\"token number\">10</span> <span class=\"token number\">18</span><span class=\"token punctuation\">:</span><span class=\"token number\">21</span> S38devpts<span class=\"token punctuation\">.</span>sh <span class=\"token operator\">-></span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>devpts<span class=\"token punctuation\">.</span>sh\nlrwxrwxrwx <span class=\"token number\">1</span> root root <span class=\"token number\">18</span> Jun <span class=\"token number\">10</span> <span class=\"token number\">18</span><span class=\"token punctuation\">:</span><span class=\"token number\">21</span> S38dmesg<span class=\"token punctuation\">.</span>sh <span class=\"token operator\">-></span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>dmesg<span class=\"token punctuation\">.</span>sh\nlrwxrwxrwx <span class=\"token number\">1</span> root root <span class=\"token number\">17</span> Jun <span class=\"token number\">10</span> <span class=\"token number\">18</span><span class=\"token punctuation\">:</span><span class=\"token number\">21</span> S38urandom <span class=\"token operator\">-></span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>urandom\nlrwxrwxrwx <span class=\"token number\">1</span> root root <span class=\"token number\">20</span> Jun <span class=\"token number\">10</span> <span class=\"token number\">18</span><span class=\"token punctuation\">:</span><span class=\"token number\">21</span> S39alsa<span class=\"token operator\">-</span>state <span class=\"token operator\">-></span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>alsa<span class=\"token operator\">-</span>state\nlrwxrwxrwx <span class=\"token number\">1</span> root root <span class=\"token number\">21</span> Jun <span class=\"token number\">10</span> <span class=\"token number\">18</span><span class=\"token punctuation\">:</span><span class=\"token number\">21</span> S39hostname<span class=\"token punctuation\">.</span>sh <span class=\"token operator\">-></span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>hostname<span class=\"token punctuation\">.</span>sh\nlrwxrwxrwx <span class=\"token number\">1</span> root root <span class=\"token number\">21</span> Jun <span class=\"token number\">10</span> <span class=\"token number\">18</span><span class=\"token punctuation\">:</span><span class=\"token number\">21</span> S55bootmisc<span class=\"token punctuation\">.</span>sh <span class=\"token operator\">-></span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>init<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>bootmisc<span class=\"token punctuation\">.</span>sh</code></pre>\n<p>启动了../init.d/udev脚本</p>\n<pre class=\" language-shell\"><code class=\"language-shell\">#!/bin/sh\n\n### BEGIN INIT INFO\n# Provides:          udev\n# Required-Start:    mountvirtfs\n# Required-Stop:     \n# Default-Start:     S\n# Default-Stop:\n# Short-Description: Start udevd, populate /dev and load drivers.\n### END INIT INFO\n\nexport TZ=/etc/localtime\n\n#检查是否存在 /sys/class 目录\n[ -d /sys/class ] || exit 1\n#检查 /proc/mounts 文件是否可读\n[ -r /proc/mounts ] || exit 1\n#检查 /sbin/udevd 是否可执行\n[ -x /sbin/udevd ] || exit 1\n\n# 路径到缓存的udev系统配置文件\nSYSCONF_CACHED=\"/etc/udev/cache.data\"\n\n# 路径到临时的udev系统配置文件\nSYSCONF_TMP=\"/dev/shm/udev.cache\"\n\n# 用于请求缓存重新生成的标记文件的路径\nDEVCACHE_REGEN=\"/dev/shm/udev-regen\" # 创建以请求缓存重新生成\n\n# 用作判断是否可以重新使用udev缓存的文件列表\nCMP_FILE_LIST=\"/proc/version /proc/cmdline /proc/devices\"\n[ -f /proc/atags ] && CMP_FILE_LIST=\"$CMP_FILE_LIST /proc/atags\"\n\n# 包含在缓存的系统状态中的文件的元数据（大小/修改时间/名称）的列表\nMETA_FILE_LIST=\"lib/udev/rules.d/* etc/udev/rules.d/*\"\n\n# 用于计算系统配置的命令函数\nsysconf_cmd () {\n    cat -- $CMP_FILE_LIST        # 打印 CMP_FILE_LIST 中的文件内容\n    stat -c '%s %Y %n' -- $META_FILE_LIST | awk -F/ '{print $1 \" \" $NF;}'  # 打印 META_FILE_LIST 中文件的元数据信息\n}\n\n\n[ -f /etc/default/udev-cache ] && . /etc/default/udev-cache\n[ -f /etc/udev/udev.conf ] && . /etc/udev/udev.conf\n[ -f /etc/default/rcS ] && . /etc/default/rcS\n\n# 终止正在运行的 udevd 进程的函数\nkill_udevd () {\n    pid=`pidof -x udevd`     # 获取 udevd 进程的 PID\n    [ -n \"$pid\" ] && kill $pid  # 如果 PID 存在，则使用 kill 命令终止进程\n}\n\ncase \"$1\" in\n  start)\n    export ACTION=add\n    # propagate /dev from /sys\n    echo \"Starting udev\"\n\n    # 在尝试启动 udev 之前，检查是否已加载了所需的 devtmpfs 文件系统，\n    # 如果未加载，则输出错误信息并停止系统。\n    if ! grep -q devtmpfs /proc/filesystems; then\n        echo \"Missing devtmpfs, which is required for udev to run\";\n        echo \"Halting...\"\n        halt\n    fi\n\n    # 如果尚未完成，在 /dev 上挂载 devtmpfs 文件系统\n    # 使用 LANG=C awk 来查找 /proc/mounts 文件中是否已挂载了 /dev 目录的 devtmpfs 文件系统。\n    # 如果找到，则退出状态为 1（表示没有找到），执行下面的花括号中的命令块。\n    LANG=C awk '$2 == \"/dev\" && ($3 == \"devtmpfs\") { exit 1 }' /proc/mounts && {\n        mount -n -o mode=0755 -t devtmpfs none \"/dev\"\n    }\n\n    # 如果 /dev/pts 不存在，则创建它，并设置权限为 0755。\n    [ -e /dev/pts ] || mkdir -m 0755 /dev/pts\n\n    # 如果 /dev/shm 不存在，则创建它，并设置权限为 1777。\n    [ -e /dev/shm ] || mkdir -m 1777 /dev/shm\n\n    # 为了满足 udev 的自动挂载规则，需要确保 /var/volatile/tmp 目录可用。\n    # 因为 /tmp 是一个符号链接到 /var/tmp，而 /var/tmp 又是一个符号链接到 /var/volatile/tmp，\n    # 所以需要确保 /var/volatile/tmp 目录存在。\n    mkdir -m 1777 -p /var/volatile/tmp\n\n\n    # Cache handling.\n    #DEVCACHE udev缓存我没使用不分析\n    if [ \"$DEVCACHE\" != \"\" ]; then\n            if [ -e $DEVCACHE ]; then\n            sysconf_cmd > \"$SYSCONF_TMP\"\n            if cmp $SYSCONF_CACHED $SYSCONF_TMP >/dev/null; then\n                            tar xmf $DEVCACHE -C / -m\n                            not_first_boot=1\n                            [ \"$VERBOSE\" != \"no\" ] && echo \"udev: using cache file $DEVCACHE\"\n                            [ -e $SYSCONF_TMP ] && rm -f \"$SYSCONF_TMP\"\n                            [ -e \"$DEVCACHE_REGEN\" ] && rm -f \"$DEVCACHE_REGEN\"\n                    else\n                # Output detailed reason why the cached /dev is not used\n                cat <<EOF\nudev: Not using udev cache because of changes detected in the following files:\nudev:     $CMP_FILE_LIST\nudev:     $META_FILE_LIST\nudev: The udev cache will be regenerated. To identify the detected changes,\nudev: compare the cached sysconf at   $SYSCONF_CACHED\nudev: against the current sysconf at  $SYSCONF_TMP\nEOF\n                touch \"$DEVCACHE_REGEN\"\n                    fi\n        else\n            if [ \"$ROOTFS_READ_ONLY\" != \"yes\" ]; then\n                # If rootfs is not read-only, it's possible that a new udev cache would be generated;\n                # otherwise, we do not bother to read files.\n                touch \"$DEVCACHE_REGEN\"\n            fi\n            fi\n    fi\n\n    # make_extra_nodes\n    # kill_udevd 函数用于终止 udevd 进程。在设备节点创建完成后，通常需要重新加载或者重启  # udevd 进程，以便它可以正确地识别和处理新增的设备。终止 udevd 进程后，它会重新启动并重新# 加载规则和配置，以适应新增的设备情况\n    kill_udevd > \"/dev/null\" 2>&1\n\n    # trigger the sorted events\n    # 这个文件通常用于指定在设备事件发生时要执行的热插拔处理程序（hotplug handler）。如果该文# 件存在，会将一个空字符写入该文件，这实际上是在通知系统要开始处理设备事件\n    [ -e /proc/sys/kernel/hotplug ] && echo -e '\\000' >/proc/sys/kernel/hotplug\n    # 这行代码启动 udevd 进程，参数 -d 表示以调试模式启动\n    /sbin/udevd -d\n\n    #这段代码是在设备事件触发后进行一系列的操作，以确保设备管理系统（udev）适当地处理新添加的设备\n    udevadm control --env=STARTUP=1\n    if [ \"$not_first_boot\" != \"\" ];then\n            if [ \"$PROBE_PLATFORM_BUS\" != \"yes\" ]; then\n                PLATFORM_BUS_NOMATCH=\"--subsystem-nomatch=platform\"\n            else\n                PLATFORM_BUS_NOMATCH=\"\"\n            fi\n            udevadm trigger --action=add --subsystem-nomatch=tty --subsystem-nomatch=mem --subsystem-nomatch=vc --subsystem-nomatch=vtconsole --subsystem-nomatch=misc --subsystem-nomatch=dcon --subsystem-nomatch=pci_bus --subsystem-nomatch=graphics --subsystem-nomatch=backlight --subsystem-nomatch=video4linux $PLATFORM_BUS_NOMATCH\n            (udevadm settle --timeout=3; udevadm control --env=STARTUP=)&\n    else\n            udevadm trigger --action=add\n            udevadm settle\n    fi\n    ;;\n  stop)\n    echo \"Stopping udevd\"\n    start-stop-daemon --stop --name udevd --quiet\n    ;;\n  restart)\n    $0 stop\n    sleep 1\n    $0 start\n    ;;\n  status)\n    pid=`pidof -x udevd`\n    if [ -n \"$pid\" ]; then\n    echo \"udevd (pid $pid) is running ...\"\n    else\n    echo \"udevd is stopped\"\n    fi\n    ;;\n  *)\n    echo \"Usage: $0 {start|stop|status|restart}\"\n    exit 1\nesac\nexit 0</code></pre>\n<h1 id=\"udevd使用方法\"><a href=\"#udevd使用方法\" class=\"headerlink\" title=\"udevd使用方法\"></a>udevd使用方法</h1><p><a href=\"https://linux.die.net/man/7/udev\" target=\"_blank\" rel=\"noopener\">使用方法</a></p>\n<h2 id=\"配置文件-etc-udev-udev-conf\"><a href=\"#配置文件-etc-udev-udev-conf\" class=\"headerlink\" title=\"配置文件-/etc/udev/udev.conf\"></a>配置文件-/etc/udev/udev.conf</h2><p>udev expects its main configuration file at /etc/udev/udev.conf. It consists of a set of variables allowing the user to override default udev values. The following variables can be set:<br>udev 的主要配置文件位于 /etc/udev/udev.conf。它由一组变量组成，允许用户覆盖默认的 udev 值。可以设置以下变量： </p>\n<p>udev_root<br>    Specifies where to place the device nodes in the filesystem. The default value is /dev.<br>    指定在文件系统中放置设备节点的位置。默认值为/dev。<br>udev_log<br>    The logging priority. Valid values are the numerical syslog priorities or their textual representations: err, info and debug.<br>    记录优先级。有效值为数字系统日志优先级或其文本表示：err、info和debug。</p>\n<pre class=\" language-shell\"><code class=\"language-shell\">root@ATK-IMX6U:/etc/udev# cat udev.conf \n# see udev.conf(5) for details\nudev_root\"/dev/\"\nudev_log=\"info\"\nudev_rules=\"/etc/udev/rules.d/\"</code></pre>\n<h2 id=\"规则文件-etc-udev-rules-d\"><a href=\"#规则文件-etc-udev-rules-d\" class=\"headerlink\" title=\"规则文件-/etc/udev/rules.d/\"></a>规则文件-/etc/udev/rules.d/</h2><p>规则文件存放在udev_rules指定的目录下，并且文件名的后缀为.lures。规则文件可能有多个，匹配的先后顺序是安装ASCII码来进行的。如找到了比配的规则，则暂停匹配，不在去匹配后续的规则文件。所以自定义的规则文件基本上都是以数字开头，这样提高了规则文件的优先级。下图是简单的规则文件规则文件以行为单位，一行就是一条规则</p>\n<h3 id=\"udev规则所有操作符\"><a href=\"#udev规则所有操作符\" class=\"headerlink\" title=\"udev规则所有操作符\"></a>udev规则所有操作符</h3><pre><code>“==”：　　比较键、值，若等于，则该条件满足；\n“!=”： 　　比较键、值，若不等于，则该条件满足；\n“=”： 　　 对一个键赋值；\n“+=”：　　为一个表示多个条目的键赋值。\n“:=”：　　对一个键赋值，并拒绝之后所有对该键的改动。目的是防止后面的规则文件对该键赋值。</code></pre><h3 id=\"udev规则的匹配键\"><a href=\"#udev规则的匹配键\" class=\"headerlink\" title=\"udev规则的匹配键\"></a>udev规则的匹配键</h3><pre><code>ACTION： 　　 　　　事件 (uevent) 的行为，例如：add( 添加设备 )、remove( 删除设备 )。\nKERNEL： 　　 　　　内核设备名称，例如：sda, cdrom。\nDEVPATH：　　　　　 设备的 devpath 路径。\nSUBSYSTEM： 　　　　设备的子系统名称，例如：sda 的子系统为 block。\nBUS： 　　　　　　　 设备在 devpath 里的总线名称，例如：usb。\nDRIVER： 　　　　 　设备在 devpath 里的设备驱动名称，例如：ide-cdrom。\nID： 　　　　　　　  设备在 devpath 里的识别号。\nSYSFS{filename}： 设备的 devpath 路径下，设备的属性文件“filename”里的内容。例如：   SYSFS{model}==“ST936701SS”表示：如果设备的型号为 ST936701SS，则该设备匹配该匹配键。\n\nENV{key}： 　　　　环境变量。在一条规则中，可以设定最多五条环境变量的 匹配键。\nPROGRAM：　　　　　调用外部命令。\nRESULT： 　　　　　外部命令 PROGRAM 的返回结果。</code></pre><h3 id=\"udev的重要赋值键\"><a href=\"#udev的重要赋值键\" class=\"headerlink\" title=\"udev的重要赋值键\"></a>udev的重要赋值键</h3><pre><code>NAME： 　在 /dev下产生的设备文件名。只有第一次对某个设备的 NAME 的赋值行为生效，之后匹配的规则再对该设备的 NAME 赋值行为将被忽略。如果没有任何规则对设备的 NAME 赋值，udev 将使用内核设备名称来产生设备文件。\nSYMLINK：　 为 /dev/下的设备文件产生符号链接。由于 udev 只能为某个设备产生一个设备文件，所以为了不覆盖系统默认的 udev 规则所产生的文件，推荐使用符号链接。\nOWNER, GROUP, MODE：　　为设备设定权限。\nENV{key}：　　　　　　　　　导入一个环境变量。</code></pre><h3 id=\"udev的值和可调用的替换操作符\"><a href=\"#udev的值和可调用的替换操作符\" class=\"headerlink\" title=\"udev的值和可调用的替换操作符\"></a>udev的值和可调用的替换操作符</h3><pre><code>$kernel, %k：　　　　　　　　设备的内核设备名称，例如：sda、cdrom。\n$number, %n：　　　　　　　 设备的内核号码，例如：sda3 的内核号码是 3。\n$devpath, %p：　　　　　　　设备的 devpath路径。\n$id, %b：　　　　　　　　　　设备在 devpath里的 ID 号。\n$sysfs{file}, %s{file}：　　 设备的 sysfs里 file 的内容。其实就是设备的属性值。\n$env{key}, %E{key}：　　　 一个环境变量的值。\n$major, %M：　　　　　　　　设备的 major 号。\n$minor %m：　　　　　　　　设备的 minor 号。\n$result, %c：　　　　　　　　PROGRAM 返回的结果。\n$parent, %P：　　　　　　 父设备的设备文件名。\n$root, %r：　　　　　　　　 udev_root的值，默认是 /dev/。\n$tempnode, %N：　　　　　　临时设备名。\n%%：　　　　　　　　　　　　符号 % 本身。\n$$：　　　　　　　　　　　　　符号 $ 本身。</code></pre><pre class=\" language-shell\"><code class=\"language-shell\">root@ATK-IMX6U:/etc/udev/rules.d# ls\n10-imx.rules         55-hpmud.rules              60-sysprof.rules        automount.rules   local.rules\n40-libgphoto2.rules  56-hpmud_add_printer.rules  80-net-name-slot.rules  autonet.rules\n50-firmware.rules    56-hpmud_support.rules      86-hpmud_plugin.rules   localextra.rules\nroot@ATK-IMX6U:/etc/udev/rules.d# cat 10-imx.rules \n# Create symlinks for i.mx keypads and touchscreens\n#SUBSYSTEM==\"input\" KERNEL==\"event*\" ATTRS{name}==\"mxckpd\",     SYMLINK+=\"input/keyboard0\"\n#SUBSYSTEM==\"input\" KERNEL==\"event*\" ATTRS{name}==\"mxc_ts\",     SYMLINK+=\"input/ts0\"\n#SUBSYSTEM==\"input\" KERNEL==\"event*\" ATTRS{name}==\"imx_adc_ts\", SYMLINK+=\"input/ts0\"\n#SUBSYSTEM==\"input\" KERNEL==\"event*\" ATTRS{name}==\"mpr084\",     SYMLINK+=\"input/keyboard0\"\n#SUBSYSTEM==\"input\" KERNEL==\"event*\" ATTRS{name}==\"tsc2007\",    SYMLINK+=\"input/ts0\"\n#SUBSYSTEM==\"input\" KERNEL==\"event*\" ATTRS{name} ==\"STMP3XXX touchscreen\",    SYMLINK+=\"input/ts0\"\n#SUBSYSTEM==\"input\" KERNEL==\"event*\" ATTRS{name} ==\"MXS touchscreen\",    SYMLINK+=\"input/ts0\"\n#SUBSYSTEM==\"input\" KERNEL==\"event*\" ATTRS{name} ==\"HannStar P1003 Touchscreen\",        SYMLINK+=\"input/ts0\"\n#SUBSYSTEM==\"input\" KERNEL==\"event*\" ATTRS{name} ==\"eGalax Touch Screen\",       SYMLINK+=\"input/ts0\"\n\n# The long class name gets cut off to be mc13783_connectiv in \n# /sys/class/mc13783_connectivity/mc13783_connectivit\nKERNEL==\"mc13783_connectiv*\",  NAME=\"mc13783_connectivity\"\n# Anyone has readonly permission to IIM device file\nKERNEL==\"mxc_iim\",  MODE=\"0444\", SYMLINK+=\"mxc_mem\"\nKERNEL==\"mxs_viim\", MODE=\"0444\", SYMLINK+=\"mxc_mem\"\nKERNEL==\"mxc_ipu\",  MODE=\"0666\"\nKERNEL==\"mxc_vpu\",  MODE=\"0666\"\nSUBSYSTEM==\"video\", MODE=\"0660\"\nKERNEL==\"fb[0-9]\",  MODE=\"0660\", GROUP=\"video\"\nKERNEL==\"gsl_kmod\", MODE=\"0660\", GROUP=\"video\"\nKERNEL==\"galcore\",  MODE=\"0660\", GROUP=\"video\"</code></pre>\n<h1 id=\"udev实战\"><a href=\"#udev实战\" class=\"headerlink\" title=\"udev实战\"></a>udev实战</h1><p>UDEV实现U盘SD卡自动挂载/卸载并且拷贝数据</p>\n<p>1.编译UDEV源码,执行arm-softfloat-linux-gnu-strip udev udevd udevstart udevinfo udevtest ,进行瘦身,并且拷贝这些文件到rootfs/bin文件夹下。</p>\n<p>2.修改rootfs/etc/init.d/rcS 脚本，添加如下命令：</p>\n<p>/bin/mount  -t  sysfs  sysfs /sys</p>\n<p>/bin/mount  -t  tmpfs  tmpfs /dev</p>\n<p>/bin/udevd  –-daemon              //创建udev的守护进程</p>\n<p>/bin/udevstart                    //启动</p>\n<p>3.在 /etc/udev/rules.d 目录下创建文件 10_usb.rules规则文件，他的语法是每个规则分成一个或多个“匹配”和“赋值”部分, 其内容如下</p>\n<p>KERNEL==”sda1”, SUBSYSTEM==”block”, RUN+=”/sbin/usbmount.sh”</p>\n<p>KERNEL SUBSYSTEM 为匹配，RUN就是赋值，意为执行usbmount.sh这个脚本。</p>\n<p>4.然后, 在 /sbin 目录中创建脚本文件usbmount.sh, 其内容为</p>\n<pre class=\" language-shell\"><code class=\"language-shell\">#!/bin/sh\nif [ “$ACTION” = “add” ]\n    then\n        mount -t vfat  /dev/sda1 /tmp/udisk\n    mv   /mnt/yaffs/web_picture/*.jpg  /tmp/udisk\n    mv   /mnt/yaffs/collect_picture/*.jpg  /tmp/udisk\nelif [ “$ACTION” = \"remove\" ]\n    then\n        umount -l /tmp/udisk\nfi</code></pre>\n<p>注：udisk、web_piture、collect_picture文件需自己建立<br>把该文件属性设置为可执行chmod 777 usbmount.sh<br>有一点需要注意的是指定的脚本解析器是sh，如果指定bash正常情况是无法解析这个脚本的，我们的嵌入式系统都没有bash。<br>插入U盘或者SD卡，触发add事件，执行10_usb.rules指定的/sbin/usbmount.sh脚本，因为是add ACTION，所以执行mount -t vfat  /dev/sda1 /tmp/udisk 。<br>拔出时，触发remove事件，执行10_usb.rules指定的/sbin/usbmount.sh脚本，因为是 ACTION 这时为remove，所以执行umount –l /tmp/udisk 。</p>\n<h1 id=\"udevd源码分析\"><a href=\"#udevd源码分析\" class=\"headerlink\" title=\"udevd源码分析\"></a>udevd源码分析</h1><p>drivers/base/core.c：device_create()—&gt;device_create_vargs()—&gt;device_create_groups_vargs—&gt;device_add()<br>—&gt;kobject_uevent()—&gt;kobject_uevent_env()<br>                            |<br>                            |<br>                            V</p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token comment\" spellcheck=\"true\">/**\n * kobject_uevent_env - send an uevent with environmental data\n *\n * @action: action that is happening\n * @kobj: struct kobject that the action is happening to\n * @envp_ext: pointer to environmental data\n *\n * Returns 0 if kobject_uevent_env() is completed with success or the\n * corresponding error when it fails.\n */</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">kobject_uevent_env</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> kobject <span class=\"token operator\">*</span>kobj<span class=\"token punctuation\">,</span> <span class=\"token keyword\">enum</span> kobject_action action<span class=\"token punctuation\">,</span>\n               <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>envp_ext<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// ... （省略其他注释）</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// search the kset we belong to</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 寻找所属的 kset</span>\n    top_kobj <span class=\"token operator\">=</span> kobj<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>top_kobj<span class=\"token operator\">-></span>kset <span class=\"token operator\">&amp;&amp;</span> top_kobj<span class=\"token operator\">-></span>parent<span class=\"token punctuation\">)</span>\n        top_kobj <span class=\"token operator\">=</span> top_kobj<span class=\"token operator\">-></span>parent<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>top_kobj<span class=\"token operator\">-></span>kset<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">pr_debug</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"kobject: '%s' (%p): %s: attempted to send uevent \"</span>\n                 <span class=\"token string\">\"without kset!\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">kobject_name</span><span class=\"token punctuation\">(</span>kobj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> kobj<span class=\"token punctuation\">,</span>\n                 <span class=\"token constant\">__func__</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span>EINVAL<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// ... （省略其他注释）</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// originating subsystem</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 事件的来源子系统</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>uevent_ops <span class=\"token operator\">&amp;&amp;</span> uevent_ops<span class=\"token operator\">-></span>name<span class=\"token punctuation\">)</span>\n        subsystem <span class=\"token operator\">=</span> uevent_ops<span class=\"token operator\">-></span><span class=\"token function\">name</span><span class=\"token punctuation\">(</span>kset<span class=\"token punctuation\">,</span> kobj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span>\n        subsystem <span class=\"token operator\">=</span> <span class=\"token function\">kobject_name</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>kset<span class=\"token operator\">-></span>kobj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>subsystem<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">pr_debug</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"kobject: '%s' (%p): %s: unset subsystem caused the \"</span>\n                 <span class=\"token string\">\"event to drop!\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">kobject_name</span><span class=\"token punctuation\">(</span>kobj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> kobj<span class=\"token punctuation\">,</span>\n                 <span class=\"token constant\">__func__</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// ... （省略其他注释）</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// environment buffer</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 创建环境数据缓冲区</span>\n    env <span class=\"token operator\">=</span> <span class=\"token function\">kzalloc</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> kobj_uevent_env<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> GFP_KERNEL<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>env<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span>ENOMEM<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// ... （省略其他注释）</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// complete object path</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 构建完整的对象路径</span>\n    devpath <span class=\"token operator\">=</span> <span class=\"token function\">kobject_get_path</span><span class=\"token punctuation\">(</span>kobj<span class=\"token punctuation\">,</span> GFP_KERNEL<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>devpath<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        retval <span class=\"token operator\">=</span> <span class=\"token operator\">-</span>ENOENT<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">goto</span> exit<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// default keys</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 添加默认键</span>\n    retval <span class=\"token operator\">=</span> <span class=\"token function\">add_uevent_var</span><span class=\"token punctuation\">(</span>env<span class=\"token punctuation\">,</span> <span class=\"token string\">\"ACTION=%s\"</span><span class=\"token punctuation\">,</span> action_string<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>retval<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">goto</span> exit<span class=\"token punctuation\">;</span>\n    retval <span class=\"token operator\">=</span> <span class=\"token function\">add_uevent_var</span><span class=\"token punctuation\">(</span>env<span class=\"token punctuation\">,</span> <span class=\"token string\">\"DEVPATH=%s\"</span><span class=\"token punctuation\">,</span> devpath<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>retval<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">goto</span> exit<span class=\"token punctuation\">;</span>\n    retval <span class=\"token operator\">=</span> <span class=\"token function\">add_uevent_var</span><span class=\"token punctuation\">(</span>env<span class=\"token punctuation\">,</span> <span class=\"token string\">\"SUBSYSTEM=%s\"</span><span class=\"token punctuation\">,</span> subsystem<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>retval<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">goto</span> exit<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// keys passed in from the caller</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 添加从调用者传入的键值对</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>envp_ext<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> envp_ext<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            retval <span class=\"token operator\">=</span> <span class=\"token function\">add_uevent_var</span><span class=\"token punctuation\">(</span>env<span class=\"token punctuation\">,</span> <span class=\"token string\">\"%s\"</span><span class=\"token punctuation\">,</span> envp_ext<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>retval<span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">goto</span> exit<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// ... （省略其他注释）</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/* let the kset specific function add its stuff */</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 调用 kset 特定函数添加额外的内容</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>uevent_ops <span class=\"token operator\">&amp;&amp;</span> uevent_ops<span class=\"token operator\">-></span>uevent<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 如果 uevent_ops 存在且具有 uevent 函数</span>\n        retval <span class=\"token operator\">=</span> uevent_ops<span class=\"token operator\">-></span><span class=\"token function\">uevent</span><span class=\"token punctuation\">(</span>kset<span class=\"token punctuation\">,</span> kobj<span class=\"token punctuation\">,</span> env<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 调用 kset 的 uevent 函数，并传递相应的参数</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>retval<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 如果 uevent 函数返回值不为零，表示出现了错误</span>\n            <span class=\"token function\">pr_debug</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"kobject: '%s' (%p): %s: uevent() returned \"</span>\n                    <span class=\"token string\">\"%d\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">kobject_name</span><span class=\"token punctuation\">(</span>kobj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> kobj<span class=\"token punctuation\">,</span>\n                    <span class=\"token constant\">__func__</span><span class=\"token punctuation\">,</span> retval<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">goto</span> exit<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n\nexit<span class=\"token punctuation\">:</span>\n    <span class=\"token function\">kfree</span><span class=\"token punctuation\">(</span>devpath<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">kfree</span><span class=\"token punctuation\">(</span>env<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> retval<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">EXPORT_SYMBOL_GPL</span><span class=\"token punctuation\">(</span>kobject_uevent_env<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>udev工作过程如下：<br>（1）当内核检测到系统中出现新设备后，内核会通过netlink套接字发送uevent;<br>（2）udev获取内核发送的信息，进行规则匹配。从而创建设备节点。<br>udev是在设备模块加载时，通过扫描/sys/class/下的设备目录，继而在/dev/目录下生成设备文件节点的。</p>\n<p>class_create/device_create/udev的基本工作流程：</p>\n<p>（1） 驱动中使用class_create(…)函数，可以用它来创建一个类，这个类存放于sysfs下面（/sys/class）</p>\n<p>（2）一旦创建好了这个类，再调用device_create(…)函数在/dev目录下创建相应的设备节点。</p>\n<p>（3）insmod *.ko 加载模块的时候，用户空间中的udev会自动响应device_create(…)函数，去/sysfs下寻找对应的类从而创建设备节</p>\n<h1 id=\"device-create能创建dev的设备又需要udevd干什么\"><a href=\"#device-create能创建dev的设备又需要udevd干什么\" class=\"headerlink\" title=\"device_create能创建dev的设备又需要udevd干什么\"></a>device_create能创建dev的设备又需要udevd干什么</h1><p><code>device_create</code> 函数是在 Linux 内核中用于创建设备节点的函数，通常在驱动程序中使用。这个函数创建的设备节点是内核空间的对象，用于向用户空间提供访问硬件设备的接口。<code>device_create</code> 并不依赖于 <code>udevd</code>，它在内核空间执行。</p>\n<p>然而，用户空间的 <code>/dev</code> 目录中的设备文件通常是由 <code>udev</code> 守护进程创建和管理的。<code>udev</code> 负责在设备插拔事件发生时自动创建、删除和管理设备文件，使得用户和应用程序能够方便地访问硬件设备。<code>udev</code> 的作用在于：</p>\n<ol>\n<li><p><strong>自动创建设备文件：</strong> 当设备插入系统时，<code>udev</code> 可以自动为设备创建相应的设备文件，这样用户和应用程序可以通过这些设备文件来访问硬件设备，而无需手动创建设备文件。</p>\n</li>\n<li><p><strong>根据规则进行设备管理：</strong> <code>udev</code> 使用预定义的规则来确定如何为特定设备创建设备文件，以及如何设置权限、属性等。这使得设备管理变得灵活，可以根据设备属性和类型进行不同的处理。</p>\n</li>\n<li><p><strong>设备节点持久化：</strong> <code>udev</code> 确保设备文件的名称是持久的，并不会因为设备插拔而变化。这有助于应用程序在设备插拔后继续正常工作。</p>\n</li>\n</ol>\n<p>因此，虽然 <code>device_create</code> 可以在内核中创建设备节点，但是 <code>udev</code> 在用户空间中负责创建和管理 <code>/dev</code> 目录下的设备文件，使设备访问更加方便、自动化和持久化。两者在不同的层级发挥作用，<code>device_create</code> 在内核空间创建设备节点，而 <code>udev</code> 在用户空间创建和管理设备文件。</p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<h1 id=\"udev\"><a href=\"#udev\" class=\"headerlink\" title=\"udev\"></a>udev</h1><p><code>udev</code>（用户空间设备管理器）是用于管理 Linux 内核设备和设备事件的守护进程。它的主要目的是在系统中自动检测硬件设备的插入、拔出等事件，并根据这些事件进行相应的设备管理操作，例如加载适当的驱动程序、创建设备节点、设置权限等。</p>\n<p><code>udev</code> 本质上是一个守护进程，它会监听内核发送的事件（例如设备插入、拔出、属性变化等），并采取适当的措施来管理这些设备。为了实现这一功能，<code>udev</code> 使用了多线程技术。其中，<code>udev</code> 线程的主要任务包括：</p>\n<ol>\n<li><p><strong>事件监听：</strong> <code>udev</code> 线程会监听内核发送的设备事件，例如设备的插入或拔出。</p>\n</li>\n<li><p><strong>事件处理：</strong> 一旦接收到设备事件，<code>udev</code> 线程会根据事件的类型和属性执行相应的处理操作。这可能涉及到加载驱动程序、创建设备文件、设置设备权限等。</p>\n</li>\n<li><p><strong>规则执行：</strong> <code>udev</code> 使用规则来描述设备的管理操作。当设备事件发生时，<code>udev</code> 线程会根据预定义的规则来判断需要执行哪些操作。</p>\n</li>\n<li><p><strong>设备节点管理：</strong> <code>udev</code> 线程会负责在 <code>/dev</code> 目录下创建和管理设备节点文件，这些文件用于与用户空间应用程序进行通信。</p>\n</li>\n<li><p><strong>热插拔支持：</strong> <code>udev</code> 线程使系统能够自动识别硬件的热插拔操作，并在设备插入或拔出时自动执行相应的管理操作。</p>\n</li>\n<li><p><strong>属性处理：</strong> <code>udev</code> 可以从设备的属性信息中获取有关设备的信息，并在必要时将这些属性信息用于设备管理操作。</p>\n</li>\n</ol>\n<h1 id=\"udevd程序\"><a href=\"#udevd程序\" class=\"headerlink\" title=\"udevd程序\"></a>udevd程序</h1><h2 id=\"BusyBox-构建根文件系统\"><a href=\"#BusyBox-构建根文件系统\" class=\"headerlink\" title=\"BusyBox 构建根文件系统\"></a>BusyBox 构建根文件系统</h2><p>BusyBox中具有udev的功能，生成文件系统的时候在sbin/中生成了udev</p>\n<h2 id=\"udev移植\"><a href=\"#udev移植\" class=\"headerlink\" title=\"udev移植\"></a>udev移植</h2><p>从udev下载网址可以下载到udev的源码。下面为移植步骤。</p>\n<pre><code>下载udev源码包，并解压\n修改Makefile中的CROSS交叉编译工具为自己开发板的编译器\n执行make进行编译。\n然后执行strip udev uded udevstart udevinfo udevtest。并将这些文件拷贝到rootfs/sbin目录下。\n添加对udev的支持，修改/etc/init.d/rcS脚本，添加如下命令：</code></pre><pre><code class=\"c\">root@ATK-IMX6U:/sbin# ls -ll | grep udev                                        \nlrwxrwxrwx 1 root root       16 Jun 10 18:21 udevadm -&gt; /usr/bin/udevadm\n-rwxr-xr-x 1 root root     239K Jul 20  2021 udevd</code></pre>\n<h1 id=\"udevd如何被运行\"><a href=\"#udevd如何被运行\" class=\"headerlink\" title=\"udevd如何被运行\"></a>udevd如何被运行</h1><p>根据<a href=\"https://qian-qiang.github.io/2023/08/process-init.html\">init线程启动/etc/inittab</a>可知会先执行si::sysinit:/etc/init.d/rcS文件的启动脚本</p>\n<pre><code class=\"c\">...................\n# Boot-time system configuration/initialization script.\n# This is run first except when booting in emergency (-b) mode.\nsi::sysinit:/etc/init.d/rcS\n\n....................</code></pre>\n<pre><code class=\"c\">root@ATK-IMX6U:/etc/rcS.d# ls -ll\ntotal 0\nlrwxrwxrwx 1 root root 20 Jun 10 18:21 S00psplash.sh -&gt; ../init.d/psplash.sh\nlrwxrwxrwx 1 root root 19 Jun 10 18:21 S02banner.sh -&gt; ../init.d/banner.sh\nlrwxrwxrwx 1 root root 18 Jun 10 18:21 S02sysfs.sh -&gt; ../init.d/sysfs.sh\nlrwxrwxrwx 1 root root 21 Jun 10 18:21 S03mountall.sh -&gt; ../init.d/mountall.sh\nlrwxrwxrwx 1 root root 14 Jun 10 18:21 S04udev -&gt; ../init.d/udev\nlrwxrwxrwx 1 root root 21 Jun 10 18:21 S05modutils.sh -&gt; ../init.d/modutils.sh\nlrwxrwxrwx 1 root root 22 Jun 10 18:21 S06alignment.sh -&gt; ../init.d/alignment.sh\nlrwxrwxrwx 1 root root 22 Jun 10 18:21 S06checkroot.sh -&gt; ../init.d/checkroot.sh\nlrwxrwxrwx 1 root root 18 Jun 10 18:21 S07bootlogd -&gt; ../init.d/bootlogd\nlrwxrwxrwx 1 root root 34 Jun 10 18:21 S29read-only-rootfs-hook.sh -&gt; ../init.d/read-only-rootfs-hook.sh\nlrwxrwxrwx 1 root root 20 Jun 10 18:21 S36udev-cache -&gt; ../init.d/udev-cache\nlrwxrwxrwx 1 root root 30 Jun 10 18:21 S37populate-volatile.sh -&gt; ../init.d/populate-volatile.sh\nlrwxrwxrwx 1 root root 19 Jun 10 18:21 S38devpts.sh -&gt; ../init.d/devpts.sh\nlrwxrwxrwx 1 root root 18 Jun 10 18:21 S38dmesg.sh -&gt; ../init.d/dmesg.sh\nlrwxrwxrwx 1 root root 17 Jun 10 18:21 S38urandom -&gt; ../init.d/urandom\nlrwxrwxrwx 1 root root 20 Jun 10 18:21 S39alsa-state -&gt; ../init.d/alsa-state\nlrwxrwxrwx 1 root root 21 Jun 10 18:21 S39hostname.sh -&gt; ../init.d/hostname.sh\nlrwxrwxrwx 1 root root 21 Jun 10 18:21 S55bootmisc.sh -&gt; ../init.d/bootmisc.sh</code></pre>\n<p>启动了../init.d/udev脚本</p>\n<pre><code class=\"shell\">#!/bin/sh\n\n### BEGIN INIT INFO\n# Provides:          udev\n# Required-Start:    mountvirtfs\n# Required-Stop:     \n# Default-Start:     S\n# Default-Stop:\n# Short-Description: Start udevd, populate /dev and load drivers.\n### END INIT INFO\n\nexport TZ=/etc/localtime\n\n#检查是否存在 /sys/class 目录\n[ -d /sys/class ] || exit 1\n#检查 /proc/mounts 文件是否可读\n[ -r /proc/mounts ] || exit 1\n#检查 /sbin/udevd 是否可执行\n[ -x /sbin/udevd ] || exit 1\n\n# 路径到缓存的udev系统配置文件\nSYSCONF_CACHED=&quot;/etc/udev/cache.data&quot;\n\n# 路径到临时的udev系统配置文件\nSYSCONF_TMP=&quot;/dev/shm/udev.cache&quot;\n\n# 用于请求缓存重新生成的标记文件的路径\nDEVCACHE_REGEN=&quot;/dev/shm/udev-regen&quot; # 创建以请求缓存重新生成\n\n# 用作判断是否可以重新使用udev缓存的文件列表\nCMP_FILE_LIST=&quot;/proc/version /proc/cmdline /proc/devices&quot;\n[ -f /proc/atags ] &amp;&amp; CMP_FILE_LIST=&quot;$CMP_FILE_LIST /proc/atags&quot;\n\n# 包含在缓存的系统状态中的文件的元数据（大小/修改时间/名称）的列表\nMETA_FILE_LIST=&quot;lib/udev/rules.d/* etc/udev/rules.d/*&quot;\n\n# 用于计算系统配置的命令函数\nsysconf_cmd () {\n    cat -- $CMP_FILE_LIST        # 打印 CMP_FILE_LIST 中的文件内容\n    stat -c &#39;%s %Y %n&#39; -- $META_FILE_LIST | awk -F/ &#39;{print $1 &quot; &quot; $NF;}&#39;  # 打印 META_FILE_LIST 中文件的元数据信息\n}\n\n\n[ -f /etc/default/udev-cache ] &amp;&amp; . /etc/default/udev-cache\n[ -f /etc/udev/udev.conf ] &amp;&amp; . /etc/udev/udev.conf\n[ -f /etc/default/rcS ] &amp;&amp; . /etc/default/rcS\n\n# 终止正在运行的 udevd 进程的函数\nkill_udevd () {\n    pid=`pidof -x udevd`     # 获取 udevd 进程的 PID\n    [ -n &quot;$pid&quot; ] &amp;&amp; kill $pid  # 如果 PID 存在，则使用 kill 命令终止进程\n}\n\ncase &quot;$1&quot; in\n  start)\n    export ACTION=add\n    # propagate /dev from /sys\n    echo &quot;Starting udev&quot;\n\n    # 在尝试启动 udev 之前，检查是否已加载了所需的 devtmpfs 文件系统，\n    # 如果未加载，则输出错误信息并停止系统。\n    if ! grep -q devtmpfs /proc/filesystems; then\n        echo &quot;Missing devtmpfs, which is required for udev to run&quot;;\n        echo &quot;Halting...&quot;\n        halt\n    fi\n\n    # 如果尚未完成，在 /dev 上挂载 devtmpfs 文件系统\n    # 使用 LANG=C awk 来查找 /proc/mounts 文件中是否已挂载了 /dev 目录的 devtmpfs 文件系统。\n    # 如果找到，则退出状态为 1（表示没有找到），执行下面的花括号中的命令块。\n    LANG=C awk &#39;$2 == &quot;/dev&quot; &amp;&amp; ($3 == &quot;devtmpfs&quot;) { exit 1 }&#39; /proc/mounts &amp;&amp; {\n        mount -n -o mode=0755 -t devtmpfs none &quot;/dev&quot;\n    }\n\n    # 如果 /dev/pts 不存在，则创建它，并设置权限为 0755。\n    [ -e /dev/pts ] || mkdir -m 0755 /dev/pts\n\n    # 如果 /dev/shm 不存在，则创建它，并设置权限为 1777。\n    [ -e /dev/shm ] || mkdir -m 1777 /dev/shm\n\n    # 为了满足 udev 的自动挂载规则，需要确保 /var/volatile/tmp 目录可用。\n    # 因为 /tmp 是一个符号链接到 /var/tmp，而 /var/tmp 又是一个符号链接到 /var/volatile/tmp，\n    # 所以需要确保 /var/volatile/tmp 目录存在。\n    mkdir -m 1777 -p /var/volatile/tmp\n\n\n    # Cache handling.\n    #DEVCACHE udev缓存我没使用不分析\n    if [ &quot;$DEVCACHE&quot; != &quot;&quot; ]; then\n            if [ -e $DEVCACHE ]; then\n            sysconf_cmd &gt; &quot;$SYSCONF_TMP&quot;\n            if cmp $SYSCONF_CACHED $SYSCONF_TMP &gt;/dev/null; then\n                            tar xmf $DEVCACHE -C / -m\n                            not_first_boot=1\n                            [ &quot;$VERBOSE&quot; != &quot;no&quot; ] &amp;&amp; echo &quot;udev: using cache file $DEVCACHE&quot;\n                            [ -e $SYSCONF_TMP ] &amp;&amp; rm -f &quot;$SYSCONF_TMP&quot;\n                            [ -e &quot;$DEVCACHE_REGEN&quot; ] &amp;&amp; rm -f &quot;$DEVCACHE_REGEN&quot;\n                    else\n                # Output detailed reason why the cached /dev is not used\n                cat &lt;&lt;EOF\nudev: Not using udev cache because of changes detected in the following files:\nudev:     $CMP_FILE_LIST\nudev:     $META_FILE_LIST\nudev: The udev cache will be regenerated. To identify the detected changes,\nudev: compare the cached sysconf at   $SYSCONF_CACHED\nudev: against the current sysconf at  $SYSCONF_TMP\nEOF\n                touch &quot;$DEVCACHE_REGEN&quot;\n                    fi\n        else\n            if [ &quot;$ROOTFS_READ_ONLY&quot; != &quot;yes&quot; ]; then\n                # If rootfs is not read-only, it&#39;s possible that a new udev cache would be generated;\n                # otherwise, we do not bother to read files.\n                touch &quot;$DEVCACHE_REGEN&quot;\n            fi\n            fi\n    fi\n\n    # make_extra_nodes\n    # kill_udevd 函数用于终止 udevd 进程。在设备节点创建完成后，通常需要重新加载或者重启  # udevd 进程，以便它可以正确地识别和处理新增的设备。终止 udevd 进程后，它会重新启动并重新# 加载规则和配置，以适应新增的设备情况\n    kill_udevd &gt; &quot;/dev/null&quot; 2&gt;&amp;1\n\n    # trigger the sorted events\n    # 这个文件通常用于指定在设备事件发生时要执行的热插拔处理程序（hotplug handler）。如果该文# 件存在，会将一个空字符写入该文件，这实际上是在通知系统要开始处理设备事件\n    [ -e /proc/sys/kernel/hotplug ] &amp;&amp; echo -e &#39;\\000&#39; &gt;/proc/sys/kernel/hotplug\n    # 这行代码启动 udevd 进程，参数 -d 表示以调试模式启动\n    /sbin/udevd -d\n\n    #这段代码是在设备事件触发后进行一系列的操作，以确保设备管理系统（udev）适当地处理新添加的设备\n    udevadm control --env=STARTUP=1\n    if [ &quot;$not_first_boot&quot; != &quot;&quot; ];then\n            if [ &quot;$PROBE_PLATFORM_BUS&quot; != &quot;yes&quot; ]; then\n                PLATFORM_BUS_NOMATCH=&quot;--subsystem-nomatch=platform&quot;\n            else\n                PLATFORM_BUS_NOMATCH=&quot;&quot;\n            fi\n            udevadm trigger --action=add --subsystem-nomatch=tty --subsystem-nomatch=mem --subsystem-nomatch=vc --subsystem-nomatch=vtconsole --subsystem-nomatch=misc --subsystem-nomatch=dcon --subsystem-nomatch=pci_bus --subsystem-nomatch=graphics --subsystem-nomatch=backlight --subsystem-nomatch=video4linux $PLATFORM_BUS_NOMATCH\n            (udevadm settle --timeout=3; udevadm control --env=STARTUP=)&amp;\n    else\n            udevadm trigger --action=add\n            udevadm settle\n    fi\n    ;;\n  stop)\n    echo &quot;Stopping udevd&quot;\n    start-stop-daemon --stop --name udevd --quiet\n    ;;\n  restart)\n    $0 stop\n    sleep 1\n    $0 start\n    ;;\n  status)\n    pid=`pidof -x udevd`\n    if [ -n &quot;$pid&quot; ]; then\n    echo &quot;udevd (pid $pid) is running ...&quot;\n    else\n    echo &quot;udevd is stopped&quot;\n    fi\n    ;;\n  *)\n    echo &quot;Usage: $0 {start|stop|status|restart}&quot;\n    exit 1\nesac\nexit 0</code></pre>\n<h1 id=\"udevd使用方法\"><a href=\"#udevd使用方法\" class=\"headerlink\" title=\"udevd使用方法\"></a>udevd使用方法</h1><p><a href=\"https://linux.die.net/man/7/udev\" target=\"_blank\" rel=\"noopener\">使用方法</a></p>\n<h2 id=\"配置文件-etc-udev-udev-conf\"><a href=\"#配置文件-etc-udev-udev-conf\" class=\"headerlink\" title=\"配置文件-/etc/udev/udev.conf\"></a>配置文件-/etc/udev/udev.conf</h2><p>udev expects its main configuration file at /etc/udev/udev.conf. It consists of a set of variables allowing the user to override default udev values. The following variables can be set:<br>udev 的主要配置文件位于 /etc/udev/udev.conf。它由一组变量组成，允许用户覆盖默认的 udev 值。可以设置以下变量： </p>\n<p>udev_root<br>    Specifies where to place the device nodes in the filesystem. The default value is /dev.<br>    指定在文件系统中放置设备节点的位置。默认值为/dev。<br>udev_log<br>    The logging priority. Valid values are the numerical syslog priorities or their textual representations: err, info and debug.<br>    记录优先级。有效值为数字系统日志优先级或其文本表示：err、info和debug。</p>\n<pre><code class=\"shell\">root@ATK-IMX6U:/etc/udev# cat udev.conf \n# see udev.conf(5) for details\nudev_root&quot;/dev/&quot;\nudev_log=&quot;info&quot;\nudev_rules=&quot;/etc/udev/rules.d/&quot;</code></pre>\n<h2 id=\"规则文件-etc-udev-rules-d\"><a href=\"#规则文件-etc-udev-rules-d\" class=\"headerlink\" title=\"规则文件-/etc/udev/rules.d/\"></a>规则文件-/etc/udev/rules.d/</h2><p>规则文件存放在udev_rules指定的目录下，并且文件名的后缀为.lures。规则文件可能有多个，匹配的先后顺序是安装ASCII码来进行的。如找到了比配的规则，则暂停匹配，不在去匹配后续的规则文件。所以自定义的规则文件基本上都是以数字开头，这样提高了规则文件的优先级。下图是简单的规则文件规则文件以行为单位，一行就是一条规则</p>\n<h3 id=\"udev规则所有操作符\"><a href=\"#udev规则所有操作符\" class=\"headerlink\" title=\"udev规则所有操作符\"></a>udev规则所有操作符</h3><pre><code>“==”：　　比较键、值，若等于，则该条件满足；\n“!=”： 　　比较键、值，若不等于，则该条件满足；\n“=”： 　　 对一个键赋值；\n“+=”：　　为一个表示多个条目的键赋值。\n“:=”：　　对一个键赋值，并拒绝之后所有对该键的改动。目的是防止后面的规则文件对该键赋值。</code></pre><h3 id=\"udev规则的匹配键\"><a href=\"#udev规则的匹配键\" class=\"headerlink\" title=\"udev规则的匹配键\"></a>udev规则的匹配键</h3><pre><code>ACTION： 　　 　　　事件 (uevent) 的行为，例如：add( 添加设备 )、remove( 删除设备 )。\nKERNEL： 　　 　　　内核设备名称，例如：sda, cdrom。\nDEVPATH：　　　　　 设备的 devpath 路径。\nSUBSYSTEM： 　　　　设备的子系统名称，例如：sda 的子系统为 block。\nBUS： 　　　　　　　 设备在 devpath 里的总线名称，例如：usb。\nDRIVER： 　　　　 　设备在 devpath 里的设备驱动名称，例如：ide-cdrom。\nID： 　　　　　　　  设备在 devpath 里的识别号。\nSYSFS{filename}： 设备的 devpath 路径下，设备的属性文件“filename”里的内容。例如：   SYSFS{model}==“ST936701SS”表示：如果设备的型号为 ST936701SS，则该设备匹配该匹配键。\n\nENV{key}： 　　　　环境变量。在一条规则中，可以设定最多五条环境变量的 匹配键。\nPROGRAM：　　　　　调用外部命令。\nRESULT： 　　　　　外部命令 PROGRAM 的返回结果。</code></pre><h3 id=\"udev的重要赋值键\"><a href=\"#udev的重要赋值键\" class=\"headerlink\" title=\"udev的重要赋值键\"></a>udev的重要赋值键</h3><pre><code>NAME： 　在 /dev下产生的设备文件名。只有第一次对某个设备的 NAME 的赋值行为生效，之后匹配的规则再对该设备的 NAME 赋值行为将被忽略。如果没有任何规则对设备的 NAME 赋值，udev 将使用内核设备名称来产生设备文件。\nSYMLINK：　 为 /dev/下的设备文件产生符号链接。由于 udev 只能为某个设备产生一个设备文件，所以为了不覆盖系统默认的 udev 规则所产生的文件，推荐使用符号链接。\nOWNER, GROUP, MODE：　　为设备设定权限。\nENV{key}：　　　　　　　　　导入一个环境变量。</code></pre><h3 id=\"udev的值和可调用的替换操作符\"><a href=\"#udev的值和可调用的替换操作符\" class=\"headerlink\" title=\"udev的值和可调用的替换操作符\"></a>udev的值和可调用的替换操作符</h3><pre><code>$kernel, %k：　　　　　　　　设备的内核设备名称，例如：sda、cdrom。\n$number, %n：　　　　　　　 设备的内核号码，例如：sda3 的内核号码是 3。\n$devpath, %p：　　　　　　　设备的 devpath路径。\n$id, %b：　　　　　　　　　　设备在 devpath里的 ID 号。\n$sysfs{file}, %s{file}：　　 设备的 sysfs里 file 的内容。其实就是设备的属性值。\n$env{key}, %E{key}：　　　 一个环境变量的值。\n$major, %M：　　　　　　　　设备的 major 号。\n$minor %m：　　　　　　　　设备的 minor 号。\n$result, %c：　　　　　　　　PROGRAM 返回的结果。\n$parent, %P：　　　　　　 父设备的设备文件名。\n$root, %r：　　　　　　　　 udev_root的值，默认是 /dev/。\n$tempnode, %N：　　　　　　临时设备名。\n%%：　　　　　　　　　　　　符号 % 本身。\n$$：　　　　　　　　　　　　　符号 $ 本身。</code></pre><pre><code class=\"shell\">root@ATK-IMX6U:/etc/udev/rules.d# ls\n10-imx.rules         55-hpmud.rules              60-sysprof.rules        automount.rules   local.rules\n40-libgphoto2.rules  56-hpmud_add_printer.rules  80-net-name-slot.rules  autonet.rules\n50-firmware.rules    56-hpmud_support.rules      86-hpmud_plugin.rules   localextra.rules\nroot@ATK-IMX6U:/etc/udev/rules.d# cat 10-imx.rules \n# Create symlinks for i.mx keypads and touchscreens\n#SUBSYSTEM==&quot;input&quot; KERNEL==&quot;event*&quot; ATTRS{name}==&quot;mxckpd&quot;,     SYMLINK+=&quot;input/keyboard0&quot;\n#SUBSYSTEM==&quot;input&quot; KERNEL==&quot;event*&quot; ATTRS{name}==&quot;mxc_ts&quot;,     SYMLINK+=&quot;input/ts0&quot;\n#SUBSYSTEM==&quot;input&quot; KERNEL==&quot;event*&quot; ATTRS{name}==&quot;imx_adc_ts&quot;, SYMLINK+=&quot;input/ts0&quot;\n#SUBSYSTEM==&quot;input&quot; KERNEL==&quot;event*&quot; ATTRS{name}==&quot;mpr084&quot;,     SYMLINK+=&quot;input/keyboard0&quot;\n#SUBSYSTEM==&quot;input&quot; KERNEL==&quot;event*&quot; ATTRS{name}==&quot;tsc2007&quot;,    SYMLINK+=&quot;input/ts0&quot;\n#SUBSYSTEM==&quot;input&quot; KERNEL==&quot;event*&quot; ATTRS{name} ==&quot;STMP3XXX touchscreen&quot;,    SYMLINK+=&quot;input/ts0&quot;\n#SUBSYSTEM==&quot;input&quot; KERNEL==&quot;event*&quot; ATTRS{name} ==&quot;MXS touchscreen&quot;,    SYMLINK+=&quot;input/ts0&quot;\n#SUBSYSTEM==&quot;input&quot; KERNEL==&quot;event*&quot; ATTRS{name} ==&quot;HannStar P1003 Touchscreen&quot;,        SYMLINK+=&quot;input/ts0&quot;\n#SUBSYSTEM==&quot;input&quot; KERNEL==&quot;event*&quot; ATTRS{name} ==&quot;eGalax Touch Screen&quot;,       SYMLINK+=&quot;input/ts0&quot;\n\n# The long class name gets cut off to be mc13783_connectiv in \n# /sys/class/mc13783_connectivity/mc13783_connectivit\nKERNEL==&quot;mc13783_connectiv*&quot;,  NAME=&quot;mc13783_connectivity&quot;\n# Anyone has readonly permission to IIM device file\nKERNEL==&quot;mxc_iim&quot;,  MODE=&quot;0444&quot;, SYMLINK+=&quot;mxc_mem&quot;\nKERNEL==&quot;mxs_viim&quot;, MODE=&quot;0444&quot;, SYMLINK+=&quot;mxc_mem&quot;\nKERNEL==&quot;mxc_ipu&quot;,  MODE=&quot;0666&quot;\nKERNEL==&quot;mxc_vpu&quot;,  MODE=&quot;0666&quot;\nSUBSYSTEM==&quot;video&quot;, MODE=&quot;0660&quot;\nKERNEL==&quot;fb[0-9]&quot;,  MODE=&quot;0660&quot;, GROUP=&quot;video&quot;\nKERNEL==&quot;gsl_kmod&quot;, MODE=&quot;0660&quot;, GROUP=&quot;video&quot;\nKERNEL==&quot;galcore&quot;,  MODE=&quot;0660&quot;, GROUP=&quot;video&quot;</code></pre>\n<h1 id=\"udev实战\"><a href=\"#udev实战\" class=\"headerlink\" title=\"udev实战\"></a>udev实战</h1><p>UDEV实现U盘SD卡自动挂载/卸载并且拷贝数据</p>\n<p>1.编译UDEV源码,执行arm-softfloat-linux-gnu-strip udev udevd udevstart udevinfo udevtest ,进行瘦身,并且拷贝这些文件到rootfs/bin文件夹下。</p>\n<p>2.修改rootfs/etc/init.d/rcS 脚本，添加如下命令：</p>\n<p>/bin/mount  -t  sysfs  sysfs /sys</p>\n<p>/bin/mount  -t  tmpfs  tmpfs /dev</p>\n<p>/bin/udevd  –-daemon              //创建udev的守护进程</p>\n<p>/bin/udevstart                    //启动</p>\n<p>3.在 /etc/udev/rules.d 目录下创建文件 10_usb.rules规则文件，他的语法是每个规则分成一个或多个“匹配”和“赋值”部分, 其内容如下</p>\n<p>KERNEL==”sda1”, SUBSYSTEM==”block”, RUN+=”/sbin/usbmount.sh”</p>\n<p>KERNEL SUBSYSTEM 为匹配，RUN就是赋值，意为执行usbmount.sh这个脚本。</p>\n<p>4.然后, 在 /sbin 目录中创建脚本文件usbmount.sh, 其内容为</p>\n<pre><code class=\"shell\">#!/bin/sh\nif [ “$ACTION” = “add” ]\n    then\n        mount -t vfat  /dev/sda1 /tmp/udisk\n    mv   /mnt/yaffs/web_picture/*.jpg  /tmp/udisk\n    mv   /mnt/yaffs/collect_picture/*.jpg  /tmp/udisk\nelif [ “$ACTION” = &quot;remove&quot; ]\n    then\n        umount -l /tmp/udisk\nfi</code></pre>\n<p>注：udisk、web_piture、collect_picture文件需自己建立<br>把该文件属性设置为可执行chmod 777 usbmount.sh<br>有一点需要注意的是指定的脚本解析器是sh，如果指定bash正常情况是无法解析这个脚本的，我们的嵌入式系统都没有bash。<br>插入U盘或者SD卡，触发add事件，执行10_usb.rules指定的/sbin/usbmount.sh脚本，因为是add ACTION，所以执行mount -t vfat  /dev/sda1 /tmp/udisk 。<br>拔出时，触发remove事件，执行10_usb.rules指定的/sbin/usbmount.sh脚本，因为是 ACTION 这时为remove，所以执行umount –l /tmp/udisk 。</p>\n<h1 id=\"udevd源码分析\"><a href=\"#udevd源码分析\" class=\"headerlink\" title=\"udevd源码分析\"></a>udevd源码分析</h1><p>drivers/base/core.c：device_create()—&gt;device_create_vargs()—&gt;device_create_groups_vargs—&gt;device_add()<br>—&gt;kobject_uevent()—&gt;kobject_uevent_env()<br>                            |<br>                            |<br>                            V</p>\n<pre><code class=\"c\">/**\n * kobject_uevent_env - send an uevent with environmental data\n *\n * @action: action that is happening\n * @kobj: struct kobject that the action is happening to\n * @envp_ext: pointer to environmental data\n *\n * Returns 0 if kobject_uevent_env() is completed with success or the\n * corresponding error when it fails.\n */\nint kobject_uevent_env(struct kobject *kobj, enum kobject_action action,\n               char *envp_ext[])\n{\n    // ... （省略其他注释）\n\n    // search the kset we belong to\n    // 寻找所属的 kset\n    top_kobj = kobj;\n    while (!top_kobj-&gt;kset &amp;&amp; top_kobj-&gt;parent)\n        top_kobj = top_kobj-&gt;parent;\n\n    if (!top_kobj-&gt;kset) {\n        pr_debug(&quot;kobject: &#39;%s&#39; (%p): %s: attempted to send uevent &quot;\n                 &quot;without kset!\\n&quot;, kobject_name(kobj), kobj,\n                 __func__);\n        return -EINVAL;\n    }\n\n    // ... （省略其他注释）\n\n    // originating subsystem\n    // 事件的来源子系统\n    if (uevent_ops &amp;&amp; uevent_ops-&gt;name)\n        subsystem = uevent_ops-&gt;name(kset, kobj);\n    else\n        subsystem = kobject_name(&amp;kset-&gt;kobj);\n    if (!subsystem) {\n        pr_debug(&quot;kobject: &#39;%s&#39; (%p): %s: unset subsystem caused the &quot;\n                 &quot;event to drop!\\n&quot;, kobject_name(kobj), kobj,\n                 __func__);\n        return 0;\n    }\n\n    // ... （省略其他注释）\n\n    // environment buffer\n    // 创建环境数据缓冲区\n    env = kzalloc(sizeof(struct kobj_uevent_env), GFP_KERNEL);\n    if (!env)\n        return -ENOMEM;\n\n    // ... （省略其他注释）\n\n    // complete object path\n    // 构建完整的对象路径\n    devpath = kobject_get_path(kobj, GFP_KERNEL);\n    if (!devpath) {\n        retval = -ENOENT;\n        goto exit;\n    }\n\n    // default keys\n    // 添加默认键\n    retval = add_uevent_var(env, &quot;ACTION=%s&quot;, action_string);\n    if (retval)\n        goto exit;\n    retval = add_uevent_var(env, &quot;DEVPATH=%s&quot;, devpath);\n    if (retval)\n        goto exit;\n    retval = add_uevent_var(env, &quot;SUBSYSTEM=%s&quot;, subsystem);\n    if (retval)\n        goto exit;\n\n    // keys passed in from the caller\n    // 添加从调用者传入的键值对\n    if (envp_ext) {\n        for (i = 0; envp_ext[i]; i++) {\n            retval = add_uevent_var(env, &quot;%s&quot;, envp_ext[i]);\n            if (retval)\n                goto exit;\n        }\n    }\n\n    // ... （省略其他注释）\n\n    /* let the kset specific function add its stuff */\n    // 调用 kset 特定函数添加额外的内容\n    if (uevent_ops &amp;&amp; uevent_ops-&gt;uevent) {\n        // 如果 uevent_ops 存在且具有 uevent 函数\n        retval = uevent_ops-&gt;uevent(kset, kobj, env);\n        // 调用 kset 的 uevent 函数，并传递相应的参数\n        if (retval) {\n            // 如果 uevent 函数返回值不为零，表示出现了错误\n            pr_debug(&quot;kobject: &#39;%s&#39; (%p): %s: uevent() returned &quot;\n                    &quot;%d\\n&quot;, kobject_name(kobj), kobj,\n                    __func__, retval);\n            goto exit;\n        }\n    }\n\n\nexit:\n    kfree(devpath);\n    kfree(env);\n    return retval;\n}\nEXPORT_SYMBOL_GPL(kobject_uevent_env);\n</code></pre>\n<p>udev工作过程如下：<br>（1）当内核检测到系统中出现新设备后，内核会通过netlink套接字发送uevent;<br>（2）udev获取内核发送的信息，进行规则匹配。从而创建设备节点。<br>udev是在设备模块加载时，通过扫描/sys/class/下的设备目录，继而在/dev/目录下生成设备文件节点的。</p>\n<p>class_create/device_create/udev的基本工作流程：</p>\n<p>（1） 驱动中使用class_create(…)函数，可以用它来创建一个类，这个类存放于sysfs下面（/sys/class）</p>\n<p>（2）一旦创建好了这个类，再调用device_create(…)函数在/dev目录下创建相应的设备节点。</p>\n<p>（3）insmod *.ko 加载模块的时候，用户空间中的udev会自动响应device_create(…)函数，去/sysfs下寻找对应的类从而创建设备节</p>\n<h1 id=\"device-create能创建dev的设备又需要udevd干什么\"><a href=\"#device-create能创建dev的设备又需要udevd干什么\" class=\"headerlink\" title=\"device_create能创建dev的设备又需要udevd干什么\"></a>device_create能创建dev的设备又需要udevd干什么</h1><p><code>device_create</code> 函数是在 Linux 内核中用于创建设备节点的函数，通常在驱动程序中使用。这个函数创建的设备节点是内核空间的对象，用于向用户空间提供访问硬件设备的接口。<code>device_create</code> 并不依赖于 <code>udevd</code>，它在内核空间执行。</p>\n<p>然而，用户空间的 <code>/dev</code> 目录中的设备文件通常是由 <code>udev</code> 守护进程创建和管理的。<code>udev</code> 负责在设备插拔事件发生时自动创建、删除和管理设备文件，使得用户和应用程序能够方便地访问硬件设备。<code>udev</code> 的作用在于：</p>\n<ol>\n<li><p><strong>自动创建设备文件：</strong> 当设备插入系统时，<code>udev</code> 可以自动为设备创建相应的设备文件，这样用户和应用程序可以通过这些设备文件来访问硬件设备，而无需手动创建设备文件。</p>\n</li>\n<li><p><strong>根据规则进行设备管理：</strong> <code>udev</code> 使用预定义的规则来确定如何为特定设备创建设备文件，以及如何设置权限、属性等。这使得设备管理变得灵活，可以根据设备属性和类型进行不同的处理。</p>\n</li>\n<li><p><strong>设备节点持久化：</strong> <code>udev</code> 确保设备文件的名称是持久的，并不会因为设备插拔而变化。这有助于应用程序在设备插拔后继续正常工作。</p>\n</li>\n</ol>\n<p>因此，虽然 <code>device_create</code> 可以在内核中创建设备节点，但是 <code>udev</code> 在用户空间中负责创建和管理 <code>/dev</code> 目录下的设备文件，使设备访问更加方便、自动化和持久化。两者在不同的层级发挥作用，<code>device_create</code> 在内核空间创建设备节点，而 <code>udev</code> 在用户空间创建和管理设备文件。</p>\n"},{"title":"process-kworker","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-08-25T06:11:57.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"\n# kworker线程\n`kworker` 是一类内核线程，用于执行一些与内核相关的后台任务。这些线程被用于处理一些异步工作，以避免阻塞主线程或其他关键内核线程。`kworker` 线程通常不与用户空间交互，而是专注于内核级别的任务。\n\n主要特点和用途：\n\n1. **后台任务处理**：`kworker` 线程主要用于处理一些后台任务，如延迟的工作队列、定时器、中断处理等。\n\n2. **异步执行**：它们允许内核在不同的上下文中执行一些工作，而不会干扰到主线程或其他关键的内核线程。\n\n3. **并发性能优化**：在多核系统中，`kworker` 线程可以并行执行，从而提高系统的并发性能。\n\n4. **避免阻塞**：`kworker` 线程通常用于处理一些可能会阻塞主线程的工作，以确保内核的响应性不受影响。\n\n5. **调度策略**：它们可以使用不同的调度策略，以便在不同的上下文中执行任务，而不会竞争其他关键任务的资源。\n\n`kworker` 线程是一种在内核中用于执行后台任务的机制，有助于提高系统的性能和响应性。这些线程的设计允许内核在不同的上下文中执行任务，从而保持系统的平稳运行。不同的内核版本和配置可能会有不同数量的 `kworker` 线程，以适应系统的需求。\n\n# kworker源码\nkernel/workqueue.c：init_workqueues()--->create_worker()--->kthread_create_on_node()<---kthread进程\n```c\n/**\n * init_workqueues - 初始化工作队列\n *\n * 这个函数在内核启动过程中被调用，用于初始化工作队列相关的数据结构和参数。\n * 工作队列是内核中用于处理异步任务的机制，它允许后台任务在不阻塞主要线程的情况下执行。\n */\nstatic int __init init_workqueues(void)\n{\n    // 各个工作队列池的标准优先级设置\n    int std_nice[NR_STD_WORKER_POOLS] = { 0, HIGHPRI_NICE_LEVEL };\n    int i, cpu;\n\n    // 检查结构体对齐，确保池子工作队列和 long long 类型对齐\n    WARN_ON(__alignof__(struct pool_workqueue) < __alignof__(long long));\n\n    // 初始化工作队列池缓存\n    pwq_cache = KMEM_CACHE(pool_workqueue, SLAB_PANIC);\n\n    // 注册 CPU 通知回调，用于处理 CPU 的上线事件\n    cpu_notifier(workqueue_cpu_up_callback, CPU_PRI_WORKQUEUE_UP);\n    // 注册 CPU 热移除通知回调，用于处理 CPU 的下线事件\n    hotcpu_notifier(workqueue_cpu_down_callback, CPU_PRI_WORKQUEUE_DOWN);\n\n    // 初始化 NUMA 相关设置\n    wq_numa_init();\n\n    // 初始化 CPU 池子\n    for_each_possible_cpu(cpu) {\n        struct worker_pool *pool;\n\n        i = 0;\n        for_each_cpu_worker_pool(pool, cpu) {\n            // 初始化池子工作队列\n            BUG_ON(init_worker_pool(pool));\n            pool->cpu = cpu;\n            cpumask_copy(pool->attrs->cpumask, cpumask_of(cpu));\n            pool->attrs->nice = std_nice[i++];\n            pool->node = cpu_to_node(cpu);\n\n            /* 分配池子 ID */\n            mutex_lock(&wq_pool_mutex);\n            BUG_ON(worker_pool_assign_id(pool));\n            mutex_unlock(&wq_pool_mutex);\n        }\n    }\n\n    // 创建初始工作者\n    for_each_online_cpu(cpu) {\n        struct worker_pool *pool;\n\n        for_each_cpu_worker_pool(pool, cpu) {\n            pool->flags &= ~POOL_DISASSOCIATED;\n            BUG_ON(!create_worker(pool));\n        }\n    }\n\n    // 创建默认的 unbound 和 ordered 工作队列属性\n    for (i = 0; i < NR_STD_WORKER_POOLS; i++) {\n        struct workqueue_attrs *attrs;\n\n        // 分配工作队列属性\n        BUG_ON(!(attrs = alloc_workqueue_attrs(GFP_KERNEL)));\n        attrs->nice = std_nice[i];\n        unbound_std_wq_attrs[i] = attrs;\n\n        /*\n         * 有序工作队列只应有一个 pwq，由 pwqs 强制执行排序。\n         * 关闭 NUMA 以便 dfl_pwq 用于所有节点。\n         */\n        BUG_ON(!(attrs = alloc_workqueue_attrs(GFP_KERNEL)));\n        attrs->nice = std_nice[i];\n        attrs->no_numa = true;\n        ordered_wq_attrs[i] = attrs;\n    }\n\n    // 创建系统工作队列\n    system_wq = alloc_workqueue(\"events\", 0, 0);\n    system_highpri_wq = alloc_workqueue(\"events_highpri\", WQ_HIGHPRI, 0);\n    system_long_wq = alloc_workqueue(\"events_long\", 0, 0);\n    system_unbound_wq = alloc_workqueue(\"events_unbound\", WQ_UNBOUND,\n                                        WQ_UNBOUND_MAX_ACTIVE);\n    system_freezable_wq = alloc_workqueue(\"events_freezable\",\n                                          WQ_FREEZABLE, 0);\n    system_power_efficient_wq = alloc_workqueue(\"events_power_efficient\",\n                                                WQ_POWER_EFFICIENT, 0);\n    system_freezable_power_efficient_wq = alloc_workqueue(\"events_freezable_power_efficient\",\n                                                          WQ_FREEZABLE | WQ_POWER_EFFICIENT,\n                                                          0);\n    // 检查系统工作队列是否成功创建\n    BUG_ON(!system_wq || !system_highpri_wq || !system_long_wq ||\n           !system_unbound_wq || !system_freezable_wq ||\n           !system_power_efficient_wq ||\n           !system_freezable_power_efficient_wq);\n    return 0;\n}\n// 在内核初始化阶段调用 init_workqueues 函数\nearly_initcall(init_workqueues);\n```\n```c\n/**\n * create_worker - 创建一个新的工作队列工作者\n * @pool: 新工作者将属于的池子\n *\n * 这个函数用于创建并启动一个新的工作队列工作者，该工作者将附属于指定的池子 @pool。\n *\n * 上下文：\n * 这个函数可能会进行休眠操作（可能会分配内存，可能会导致调度器切换）。\n *\n * 返回：\n * 返回指向新创建的工作者的指针，如果创建失败则返回 NULL。\n */\nstatic struct worker *create_worker(struct worker_pool *pool)\n{\n    struct worker *worker = NULL;  // 初始化工作者指针\n    int id = -1;  // 初始化工作者的 ID\n    char id_buf[16];  // 用于存储 ID 的字符缓冲区\n\n    // 获取一个唯一的工作者 ID\n    id = ida_simple_get(&pool->worker_ida, 0, 0, GFP_KERNEL);\n    if (id < 0)\n        goto fail;\n\n    // 分配工作者的内存\n    worker = alloc_worker(pool->node);\n    if (!worker)\n        goto fail;\n\n    // 初始化工作者的属性\n    worker->pool = pool;\n    worker->id = id;\n\n    // 创建工作者的线程名\n    if (pool->cpu >= 0)\n        snprintf(id_buf, sizeof(id_buf), \"%d:%d%s\", pool->cpu, id,\n                 pool->attrs->nice < 0  ? \"H\" : \"\");\n    else\n        snprintf(id_buf, sizeof(id_buf), \"u%d:%d\", pool->id, id);\n\n    // 在指定的 NUMA 节点上创建工作者线程\n    worker->task = kthread_create_on_node(worker_thread, worker, pool->node,\n                                          \"kworker/%s\", id_buf);\n    if (IS_ERR(worker->task))\n        goto fail;\n\n    // 设置工作者线程的优先级\n    set_user_nice(worker->task, pool->attrs->nice);\n\n    // 防止用户干扰工作者线程的 CPU 亲和性设置\n    worker->task->flags |= PF_NO_SETAFFINITY;\n\n    // 将工作者附加到池子\n    worker_attach_to_pool(worker, pool);\n\n    // 启动新创建的工作者线程\n    spin_lock_irq(&pool->lock);\n    worker->pool->nr_workers++;\n    worker_enter_idle(worker);\n    wake_up_process(worker->task);\n    spin_unlock_irq(&pool->lock);\n\n    return worker;  // 返回新创建的工作者指针\n\nfail:\n    if (id >= 0)\n        ida_simple_remove(&pool->worker_ida, id);  // 清理 ID 分配\n    kfree(worker);  // 释放工作者内存\n    return NULL;  // 返回 NULL 表示创建失败\n}\n```\n根据工作者所属的池子属性来为工作者线程生成一个名称。生成的名称将包含一些池子和工作者的信息，以便在内核中识别工作者线程的用途。具体的命名方式如下：\n\n- 如果 `pool->cpu >= 0`，即工作者线程分配到了特定的 CPU，则名称将按以下格式生成：\n  - `%d:%d` 用于表示池子所在的 CPU 编号和工作者的 ID\n  - `%s` 根据池子的属性 `pool->attrs->nice`，如果优先级小于 0（HIGHPRI_NICE_LEVEL），则附加 \"H\"，表示高优先级\n\n- 如果 `pool->cpu` 小于 0，即工作者线程是无绑定到特定 CPU 的，则名称将按以下格式生成：\n  - `u%d:%d` 用于表示池子的 ID 和工作者的 ID\n\n例如，如果 `pool->cpu` 是 2，`id` 是 5，并且 `pool->attrs->nice` 为正值，则生成的名称可能是 \"2:5\"。如果 `pool->cpu` 是 -1，`pool->id` 是 1，`id` 是 3，则生成的名称可能是 \"u1:3\"。\n\n这个命名方式是为了在内核中更好地识别不同的工作者线程以及它们所属的池子和属性。这对于调试和监控工作者线程的活动非常有帮助。\n\n# kworker函数\nworker_thread()--->process_scheduled_works()--->process_one_work()\n```c\n/**\n * worker_thread - 工作者线程函数\n * @__worker: 自身工作者\n *\n * 工作者线程函数。所有工作者都属于一个工作者池（worker_pool） - 可能是每个 CPU 的一个或动态的无绑定池。这些工作者处理所有工作项，不管它们的特定目标工作队列。唯一的例外是属于具有救援者（rescuer）的工作队列的工作项，这将在 rescuer_thread() 中解释。\n\n * 返回值：0\n */\nstatic int worker_thread(void *__worker)\n{\n\tstruct worker *worker = __worker;\n\tstruct worker_pool *pool = worker->pool;\n\n\t// 告诉调度器这是一个工作队列工作者\n\tworker->task->flags |= PF_WQ_WORKER;\n\nwoke_up:\n\tspin_lock_irq(&pool->lock);\n\n\t// 是否应该终止？\n\tif (unlikely(worker->flags & WORKER_DIE)) {\n\t\tspin_unlock_irq(&pool->lock);\n\t\t\n\t\t// 确保 worker 不在任何列表中\n\t\tWARN_ON_ONCE(!list_empty(&worker->entry));\n\n\t\t// 清除工作者标志\n\t\tworker->task->flags &= ~PF_WQ_WORKER;\n\n\t\t// 设置任务的名称为 \"kworker/dying\"\n\t\tset_task_comm(worker->task, \"kworker/dying\");\n\n\t\t// 从工作者池的 worker_ida 中移除工作者 ID\n\t\tida_simple_remove(&pool->worker_ida, worker->id);\n\n\t\t// 从工作者池中分离工作者\n\t\tworker_detach_from_pool(worker, pool);\n\n\t\t// 释放工作者内存\n\t\tkfree(worker);\n\t\treturn 0;\n\t}\n\n\t// 让工作者离开空闲状态，准备处理工作\n\tworker_leave_idle(worker);\n\nrecheck:\n\t// 是否不再需要更多工作者？\n\tif (!need_more_worker(pool))\n\t\tgoto sleep;\n\n\t// 是否需要进行管理？\n\tif (unlikely(!may_start_working(pool)) && manage_workers(worker))\n\t\tgoto recheck;\n\n\t/*\n\t * ->scheduled 列表只能在工作者准备处理工作或实际处理工作时填充。\n\t * 确保在休眠时没有人干扰它。\n\t */\n\tWARN_ON_ONCE(!list_empty(&worker->scheduled));\n\n\t/*\n\t * 完成 PREP 阶段。我们保证至少有一个空闲工作者或其他人已经承担了管理者角色。\n\t * 如果适用，这是 @worker 开始参与并发管理的地方，并在重新绑定后恢复并发管理。\n\t * 有关详细信息，请参阅 rebind_workers()。\n\t */\n\tworker_clr_flags(worker, WORKER_PREP | WORKER_REBOUND);\n\n\tdo {\n\t\tstruct work_struct *work =\n\t\t\tlist_first_entry(&pool->worklist,\n\t\t\t\t\t struct work_struct, entry);\n\n\t\tif (likely(!(*work_data_bits(work) & WORK_STRUCT_LINKED))) {\n\t\t\t/* 优化路径，不是严格必需的 */\n\t\t\tprocess_one_work(worker, work);\n\t\t\tif (unlikely(!list_empty(&worker->scheduled)))\n\t\t\t\tprocess_scheduled_works(worker);\n\t\t} else {\n\t\t\tmove_linked_works(work, &worker->scheduled, NULL);\n\t\t\tprocess_scheduled_works(worker);\n\t\t}\n\t} while (keep_working(pool));\n\n\t// 设置工作者为准备状态\n\tworker_set_flags(worker, WORKER_PREP);\n\nsleep:\n\t/*\n\t * 池->lock 已经持有，没有要处理的工作也没有必要管理，进入休眠。\n\t * 工作者只在持有池->lock 或从本地 CPU 中唤醒时被唤醒，因此在释放池->lock 之前设置当前状态足以防止丢失任何事件。\n\t */\n\tworker_enter_idle(worker);\n\t\n\t// 设置当前线程状态为可中断睡眠\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\tspin_unlock_irq(&pool->lock);\n\n\t// 进入调度器，等待被唤醒\n\tschedule();\n\tgoto woke_up;\n}\n```\n```c\n/**\n * process_scheduled_works - 处理预定的工作项\n * @worker: 自身工作者\n *\n * 处理所有预定的工作项。请注意，预定的工作项列表在处理工作项时可能会发生变化，因此此函数反复从顶部获取工作项并执行它们。\n\n * 上下文：\n * 在 spin_lock_irq(pool->lock) 下，可能会多次释放和重新获取锁。\n */\nstatic void process_scheduled_works(struct worker *worker)\n{\n\twhile (!list_empty(&worker->scheduled)) {\n\t\tstruct work_struct *work = list_first_entry(&worker->scheduled,\n\t\t\t\t\t\tstruct work_struct, entry);\n\t\tprocess_one_work(worker, work);\n\t}\n}\n```\n```c\n/**\n * process_one_work - 处理单个工作项\n * @worker: 自身工作者\n * @work: 要处理的工作项\n *\n * 处理 @work。此函数包含处理单个工作项所需的所有逻辑，包括与同一 CPU 上的其他工作者的同步和交互、排队和刷新。只要满足上下文要求，任何工作者都可以调用此函数来处理工作项。\n\n * 上下文：\n * 在 spin_lock_irq(pool->lock) 下，会释放并重新获取锁。\n */\nstatic void process_one_work(struct worker *worker, struct work_struct *work)\n__releases(&pool->lock)\n__acquires(&pool->lock)\n{\n\tstruct pool_workqueue *pwq = get_work_pwq(work);\n\tstruct worker_pool *pool = worker->pool;\n\tbool cpu_intensive = pwq->wq->flags & WQ_CPU_INTENSIVE;\n\tint work_color;\n\tstruct worker *collision;\n#ifdef CONFIG_LOCKDEP\n\t/*\n\t * 可以在从工作项调用的函数内部释放 struct work_struct，因此我们也需要在 lockdep 中考虑这一点。为了避免虚假的“已持有的锁被释放”警告，\n\t * 以及在查看 work->lockdep_map 时出现问题，我们在这里创建一个副本并使用它。\n\t */\n\tstruct lockdep_map lockdep_map;\n\n\tlockdep_copy_map(&lockdep_map, &work->lockdep_map);\n#endif\n\t/* 确保我们在正确的 CPU 上 */\n\tWARN_ON_ONCE(!(pool->flags & POOL_DISASSOCIATED) &&\n\t\t     raw_smp_processor_id() != pool->cpu);\n\n\t/*\n\t * 一个工作项不应在单个 CPU 上的多个工作者之间并发执行。\n\t * 检查是否有其他工作者已经在处理这个工作项。如果是这样，则将工作项推迟到当前正在执行的工作者。\n\t */\n\tcollision = find_worker_executing_work(pool, work);\n\tif (unlikely(collision)) {\n\t\tmove_linked_works(work, &collision->scheduled, NULL);\n\t\treturn;\n\t}\n\n\t/* 认领并出队 */\n\tdebug_work_deactivate(work);\n\thash_add(pool->busy_hash, &worker->hentry, (unsigned long)work);\n\tworker->current_work = work;\n\tworker->current_func = work->func;\n\tworker->current_pwq = pwq;\n\twork_color = get_work_color(work);\n\n\tlist_del_init(&work->entry);\n\n\t/*\n\t * CPU 密集型的工作项不参与并发管理。它们由调度器负责。\n\t * 这将把 @worker 从并发管理中移出，并且下一个代码块将链接执行挂起的工作项。\n\t */\n\tif (unlikely(cpu_intensive))\n\t\tworker_set_flags(worker, WORKER_CPU_INTENSIVE);\n\n\t/*\n\t * 如果需要的话唤醒另一个工作者。对于正常的每个 CPU 工作者，条件始终为 false，因为 nr_running 在此时总是 >= 1。\n\t * 这用于链接执行挂起的工作项，对于 WORKER_NOT_RUNNING 工作者（如 UNBOUND 和 CPU_INTENSIVE）。\n\t */\n\tif (need_more_worker(pool))\n\t\twake_up_worker(pool);\n\n\t/*\n\t * 记录最后一个工作池并清除 PENDING，这应该是对 @work 的最后一次更新。\n\t * 同时，这在 @pool->lock 中完成，以便在禁用 IRQ 时同时发生 PENDING 和队列状态的变化。\n\t */\n\tset_work_pool_and_clear_pending(work, pool->id);\n\n\tspin_unlock_irq(&pool->lock);\n\n\tlock_map_acquire_read(&pwq->wq->lockdep_map);\n\tlock_map_acquire(&lockdep_map);\n\ttrace_workqueue_execute_start(work);\n\tworker->current_func(work);\n\t/*\n\t * 虽然我们必须小心，以免在此之后使用“work”，但跟踪点只会记录其地址。\n\t */\n\ttrace_workqueue_execute_end(work);\n\tlock_map_release(&lockdep_map);\n\tlock_map_release(&pwq->wq->lockdep_map);\n\n\tif (unlikely(in_atomic() || lockdep_depth(current) > 0)) {\n\t\tpr_err(\"BUG: workqueue leaked lock or atomic: %s/0x%08x/%d\\n\"\n\t\t       \"     last function: %pf\\n\",\n\t\t       current->comm, preempt_count(), task_pid_nr(current),\n\t\t       worker->current_func);\n\t\tdebug_show_held_locks(current);\n\t\tdump_stack();\n\t}\n\n\t/*\n\t * 以下内容可以防止 kworker 在没有 PREEMPT 的内核上占用 CPU，\n\t * 在这种情况下，等待重新排队的工作项等待某些事情发生可能会与 stop_machine 死锁，\n\t * 因为这种工作项可以无限期地重新排队自己，而所有其他 CPU 都被困在 stop_machine 中。\n\t * 同时，报告一个静止的 RCU 状态，以便相同的条件不会冻结 RCU。\n\t */\n\tcond_resched_rcu_qs();\n\n\tspin_lock_irq(&pool->lock);\n\n\t/* 清除 CPU 密集状态 */\n\tif (unlikely(cpu_intensive))\n\t\tworker_clr_flags(worker, WORKER_CPU_INTENSIVE);\n\n\t/* 我们已经完成了它，释放 */\n\thash_del(&worker->hentry);\n\tworker->current_work = NULL;\n\tworker->current_func = NULL;\n\tworker->current_pwq = NULL;\n\tworker->desc_valid = false;\n\tpwq_dec_nr_in_flight(pwq, work_color);\n}\n```\n# ps -A --forest \n```c\nps -A --forest\n  PID TTY          TIME CMD\n    2 ?        00:00:00 kthreadd\n    3 ?        00:00:01  \\_ ksoftirqd/0\n    5 ?        00:00:00  \\_ kworker/0:0H\n    7 ?        00:00:06  \\_ rcu_preempt\n    8 ?        00:00:00  \\_ rcu_sched\n    9 ?        00:00:00  \\_ rcu_bh\n   10 ?        00:00:00  \\_ migration/0\n   11 ?        00:00:00  \\_ khelper\n   12 ?        00:00:00  \\_ kdevtmpfs\n   13 ?        00:00:00  \\_ perf\n   14 ?        00:00:00  \\_ writeback\n   15 ?        00:00:00  \\_ crypto\n   16 ?        00:00:00  \\_ bioset\n   17 ?        00:00:00  \\_ kblockd\n   18 ?        00:00:00  \\_ ata_sff\n   20 ?        00:00:00  \\_ cfg80211\n   21 ?        00:00:00  \\_ rpciod\n   22 ?        00:00:00  \\_ kswapd0\n   23 ?        00:00:00  \\_ fsnotify_mark\n   24 ?        00:00:00  \\_ nfsiod\n   61 ?        00:00:00  \\_ kapmd\n   62 ?        00:00:00  \\_ spi2\n   63 ?        00:00:00  \\_ kworker/u2:1\n   68 ?        00:00:00  \\_ ci_otg\n   70 ?        00:00:00  \\_ goodix_wq\n   71 ?        00:00:00  \\_ cfinteractive\n   72 ?        00:00:00  \\_ irq/224-mmc0\n   73 ?        00:00:00  \\_ irq/49-2190000.\n   74 ?        00:00:00  \\_ mxs_dcp_chan/sh\n   75 ?        00:00:00  \\_ mxs_dcp_chan/ae\n   81 ?        00:00:00  \\_ kworker/u2:3\n   82 ?        00:00:00  \\_ ipv6_addrconf\n   83 ?        00:00:00  \\_ krfcommd\n   84 ?        00:00:00  \\_ pxp_dispatch\n   85 ?        00:00:00  \\_ deferwq\n   86 ?        00:00:00  \\_ irq/204-imx_the\n   87 ?        00:00:00  \\_ ubi_bgt0d\n  140 ?        00:00:00  \\_ ubifs_bgt0_0\n 1037 ?        00:00:00  \\_ kworker/0:0\n 1041 ?        00:00:00  \\_ kworker/0:2\n 1042 ?        00:00:00  \\_ kworker/0:1\n```\nkworker/x_x即是你的工作线程\n","source":"_posts/2023/08/process-kworker.md","raw":"---\ntitle: process-kworker\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-08-25 14:11:57\npassword:\nsummary:\ntags:\n- linux\n- process\ncategories:\n- process\n- linux\nkeywords:\ndescription:\n---\n\n# kworker线程\n`kworker` 是一类内核线程，用于执行一些与内核相关的后台任务。这些线程被用于处理一些异步工作，以避免阻塞主线程或其他关键内核线程。`kworker` 线程通常不与用户空间交互，而是专注于内核级别的任务。\n\n主要特点和用途：\n\n1. **后台任务处理**：`kworker` 线程主要用于处理一些后台任务，如延迟的工作队列、定时器、中断处理等。\n\n2. **异步执行**：它们允许内核在不同的上下文中执行一些工作，而不会干扰到主线程或其他关键的内核线程。\n\n3. **并发性能优化**：在多核系统中，`kworker` 线程可以并行执行，从而提高系统的并发性能。\n\n4. **避免阻塞**：`kworker` 线程通常用于处理一些可能会阻塞主线程的工作，以确保内核的响应性不受影响。\n\n5. **调度策略**：它们可以使用不同的调度策略，以便在不同的上下文中执行任务，而不会竞争其他关键任务的资源。\n\n`kworker` 线程是一种在内核中用于执行后台任务的机制，有助于提高系统的性能和响应性。这些线程的设计允许内核在不同的上下文中执行任务，从而保持系统的平稳运行。不同的内核版本和配置可能会有不同数量的 `kworker` 线程，以适应系统的需求。\n\n# kworker源码\nkernel/workqueue.c：init_workqueues()--->create_worker()--->kthread_create_on_node()<---kthread进程\n```c\n/**\n * init_workqueues - 初始化工作队列\n *\n * 这个函数在内核启动过程中被调用，用于初始化工作队列相关的数据结构和参数。\n * 工作队列是内核中用于处理异步任务的机制，它允许后台任务在不阻塞主要线程的情况下执行。\n */\nstatic int __init init_workqueues(void)\n{\n    // 各个工作队列池的标准优先级设置\n    int std_nice[NR_STD_WORKER_POOLS] = { 0, HIGHPRI_NICE_LEVEL };\n    int i, cpu;\n\n    // 检查结构体对齐，确保池子工作队列和 long long 类型对齐\n    WARN_ON(__alignof__(struct pool_workqueue) < __alignof__(long long));\n\n    // 初始化工作队列池缓存\n    pwq_cache = KMEM_CACHE(pool_workqueue, SLAB_PANIC);\n\n    // 注册 CPU 通知回调，用于处理 CPU 的上线事件\n    cpu_notifier(workqueue_cpu_up_callback, CPU_PRI_WORKQUEUE_UP);\n    // 注册 CPU 热移除通知回调，用于处理 CPU 的下线事件\n    hotcpu_notifier(workqueue_cpu_down_callback, CPU_PRI_WORKQUEUE_DOWN);\n\n    // 初始化 NUMA 相关设置\n    wq_numa_init();\n\n    // 初始化 CPU 池子\n    for_each_possible_cpu(cpu) {\n        struct worker_pool *pool;\n\n        i = 0;\n        for_each_cpu_worker_pool(pool, cpu) {\n            // 初始化池子工作队列\n            BUG_ON(init_worker_pool(pool));\n            pool->cpu = cpu;\n            cpumask_copy(pool->attrs->cpumask, cpumask_of(cpu));\n            pool->attrs->nice = std_nice[i++];\n            pool->node = cpu_to_node(cpu);\n\n            /* 分配池子 ID */\n            mutex_lock(&wq_pool_mutex);\n            BUG_ON(worker_pool_assign_id(pool));\n            mutex_unlock(&wq_pool_mutex);\n        }\n    }\n\n    // 创建初始工作者\n    for_each_online_cpu(cpu) {\n        struct worker_pool *pool;\n\n        for_each_cpu_worker_pool(pool, cpu) {\n            pool->flags &= ~POOL_DISASSOCIATED;\n            BUG_ON(!create_worker(pool));\n        }\n    }\n\n    // 创建默认的 unbound 和 ordered 工作队列属性\n    for (i = 0; i < NR_STD_WORKER_POOLS; i++) {\n        struct workqueue_attrs *attrs;\n\n        // 分配工作队列属性\n        BUG_ON(!(attrs = alloc_workqueue_attrs(GFP_KERNEL)));\n        attrs->nice = std_nice[i];\n        unbound_std_wq_attrs[i] = attrs;\n\n        /*\n         * 有序工作队列只应有一个 pwq，由 pwqs 强制执行排序。\n         * 关闭 NUMA 以便 dfl_pwq 用于所有节点。\n         */\n        BUG_ON(!(attrs = alloc_workqueue_attrs(GFP_KERNEL)));\n        attrs->nice = std_nice[i];\n        attrs->no_numa = true;\n        ordered_wq_attrs[i] = attrs;\n    }\n\n    // 创建系统工作队列\n    system_wq = alloc_workqueue(\"events\", 0, 0);\n    system_highpri_wq = alloc_workqueue(\"events_highpri\", WQ_HIGHPRI, 0);\n    system_long_wq = alloc_workqueue(\"events_long\", 0, 0);\n    system_unbound_wq = alloc_workqueue(\"events_unbound\", WQ_UNBOUND,\n                                        WQ_UNBOUND_MAX_ACTIVE);\n    system_freezable_wq = alloc_workqueue(\"events_freezable\",\n                                          WQ_FREEZABLE, 0);\n    system_power_efficient_wq = alloc_workqueue(\"events_power_efficient\",\n                                                WQ_POWER_EFFICIENT, 0);\n    system_freezable_power_efficient_wq = alloc_workqueue(\"events_freezable_power_efficient\",\n                                                          WQ_FREEZABLE | WQ_POWER_EFFICIENT,\n                                                          0);\n    // 检查系统工作队列是否成功创建\n    BUG_ON(!system_wq || !system_highpri_wq || !system_long_wq ||\n           !system_unbound_wq || !system_freezable_wq ||\n           !system_power_efficient_wq ||\n           !system_freezable_power_efficient_wq);\n    return 0;\n}\n// 在内核初始化阶段调用 init_workqueues 函数\nearly_initcall(init_workqueues);\n```\n```c\n/**\n * create_worker - 创建一个新的工作队列工作者\n * @pool: 新工作者将属于的池子\n *\n * 这个函数用于创建并启动一个新的工作队列工作者，该工作者将附属于指定的池子 @pool。\n *\n * 上下文：\n * 这个函数可能会进行休眠操作（可能会分配内存，可能会导致调度器切换）。\n *\n * 返回：\n * 返回指向新创建的工作者的指针，如果创建失败则返回 NULL。\n */\nstatic struct worker *create_worker(struct worker_pool *pool)\n{\n    struct worker *worker = NULL;  // 初始化工作者指针\n    int id = -1;  // 初始化工作者的 ID\n    char id_buf[16];  // 用于存储 ID 的字符缓冲区\n\n    // 获取一个唯一的工作者 ID\n    id = ida_simple_get(&pool->worker_ida, 0, 0, GFP_KERNEL);\n    if (id < 0)\n        goto fail;\n\n    // 分配工作者的内存\n    worker = alloc_worker(pool->node);\n    if (!worker)\n        goto fail;\n\n    // 初始化工作者的属性\n    worker->pool = pool;\n    worker->id = id;\n\n    // 创建工作者的线程名\n    if (pool->cpu >= 0)\n        snprintf(id_buf, sizeof(id_buf), \"%d:%d%s\", pool->cpu, id,\n                 pool->attrs->nice < 0  ? \"H\" : \"\");\n    else\n        snprintf(id_buf, sizeof(id_buf), \"u%d:%d\", pool->id, id);\n\n    // 在指定的 NUMA 节点上创建工作者线程\n    worker->task = kthread_create_on_node(worker_thread, worker, pool->node,\n                                          \"kworker/%s\", id_buf);\n    if (IS_ERR(worker->task))\n        goto fail;\n\n    // 设置工作者线程的优先级\n    set_user_nice(worker->task, pool->attrs->nice);\n\n    // 防止用户干扰工作者线程的 CPU 亲和性设置\n    worker->task->flags |= PF_NO_SETAFFINITY;\n\n    // 将工作者附加到池子\n    worker_attach_to_pool(worker, pool);\n\n    // 启动新创建的工作者线程\n    spin_lock_irq(&pool->lock);\n    worker->pool->nr_workers++;\n    worker_enter_idle(worker);\n    wake_up_process(worker->task);\n    spin_unlock_irq(&pool->lock);\n\n    return worker;  // 返回新创建的工作者指针\n\nfail:\n    if (id >= 0)\n        ida_simple_remove(&pool->worker_ida, id);  // 清理 ID 分配\n    kfree(worker);  // 释放工作者内存\n    return NULL;  // 返回 NULL 表示创建失败\n}\n```\n根据工作者所属的池子属性来为工作者线程生成一个名称。生成的名称将包含一些池子和工作者的信息，以便在内核中识别工作者线程的用途。具体的命名方式如下：\n\n- 如果 `pool->cpu >= 0`，即工作者线程分配到了特定的 CPU，则名称将按以下格式生成：\n  - `%d:%d` 用于表示池子所在的 CPU 编号和工作者的 ID\n  - `%s` 根据池子的属性 `pool->attrs->nice`，如果优先级小于 0（HIGHPRI_NICE_LEVEL），则附加 \"H\"，表示高优先级\n\n- 如果 `pool->cpu` 小于 0，即工作者线程是无绑定到特定 CPU 的，则名称将按以下格式生成：\n  - `u%d:%d` 用于表示池子的 ID 和工作者的 ID\n\n例如，如果 `pool->cpu` 是 2，`id` 是 5，并且 `pool->attrs->nice` 为正值，则生成的名称可能是 \"2:5\"。如果 `pool->cpu` 是 -1，`pool->id` 是 1，`id` 是 3，则生成的名称可能是 \"u1:3\"。\n\n这个命名方式是为了在内核中更好地识别不同的工作者线程以及它们所属的池子和属性。这对于调试和监控工作者线程的活动非常有帮助。\n\n# kworker函数\nworker_thread()--->process_scheduled_works()--->process_one_work()\n```c\n/**\n * worker_thread - 工作者线程函数\n * @__worker: 自身工作者\n *\n * 工作者线程函数。所有工作者都属于一个工作者池（worker_pool） - 可能是每个 CPU 的一个或动态的无绑定池。这些工作者处理所有工作项，不管它们的特定目标工作队列。唯一的例外是属于具有救援者（rescuer）的工作队列的工作项，这将在 rescuer_thread() 中解释。\n\n * 返回值：0\n */\nstatic int worker_thread(void *__worker)\n{\n\tstruct worker *worker = __worker;\n\tstruct worker_pool *pool = worker->pool;\n\n\t// 告诉调度器这是一个工作队列工作者\n\tworker->task->flags |= PF_WQ_WORKER;\n\nwoke_up:\n\tspin_lock_irq(&pool->lock);\n\n\t// 是否应该终止？\n\tif (unlikely(worker->flags & WORKER_DIE)) {\n\t\tspin_unlock_irq(&pool->lock);\n\t\t\n\t\t// 确保 worker 不在任何列表中\n\t\tWARN_ON_ONCE(!list_empty(&worker->entry));\n\n\t\t// 清除工作者标志\n\t\tworker->task->flags &= ~PF_WQ_WORKER;\n\n\t\t// 设置任务的名称为 \"kworker/dying\"\n\t\tset_task_comm(worker->task, \"kworker/dying\");\n\n\t\t// 从工作者池的 worker_ida 中移除工作者 ID\n\t\tida_simple_remove(&pool->worker_ida, worker->id);\n\n\t\t// 从工作者池中分离工作者\n\t\tworker_detach_from_pool(worker, pool);\n\n\t\t// 释放工作者内存\n\t\tkfree(worker);\n\t\treturn 0;\n\t}\n\n\t// 让工作者离开空闲状态，准备处理工作\n\tworker_leave_idle(worker);\n\nrecheck:\n\t// 是否不再需要更多工作者？\n\tif (!need_more_worker(pool))\n\t\tgoto sleep;\n\n\t// 是否需要进行管理？\n\tif (unlikely(!may_start_working(pool)) && manage_workers(worker))\n\t\tgoto recheck;\n\n\t/*\n\t * ->scheduled 列表只能在工作者准备处理工作或实际处理工作时填充。\n\t * 确保在休眠时没有人干扰它。\n\t */\n\tWARN_ON_ONCE(!list_empty(&worker->scheduled));\n\n\t/*\n\t * 完成 PREP 阶段。我们保证至少有一个空闲工作者或其他人已经承担了管理者角色。\n\t * 如果适用，这是 @worker 开始参与并发管理的地方，并在重新绑定后恢复并发管理。\n\t * 有关详细信息，请参阅 rebind_workers()。\n\t */\n\tworker_clr_flags(worker, WORKER_PREP | WORKER_REBOUND);\n\n\tdo {\n\t\tstruct work_struct *work =\n\t\t\tlist_first_entry(&pool->worklist,\n\t\t\t\t\t struct work_struct, entry);\n\n\t\tif (likely(!(*work_data_bits(work) & WORK_STRUCT_LINKED))) {\n\t\t\t/* 优化路径，不是严格必需的 */\n\t\t\tprocess_one_work(worker, work);\n\t\t\tif (unlikely(!list_empty(&worker->scheduled)))\n\t\t\t\tprocess_scheduled_works(worker);\n\t\t} else {\n\t\t\tmove_linked_works(work, &worker->scheduled, NULL);\n\t\t\tprocess_scheduled_works(worker);\n\t\t}\n\t} while (keep_working(pool));\n\n\t// 设置工作者为准备状态\n\tworker_set_flags(worker, WORKER_PREP);\n\nsleep:\n\t/*\n\t * 池->lock 已经持有，没有要处理的工作也没有必要管理，进入休眠。\n\t * 工作者只在持有池->lock 或从本地 CPU 中唤醒时被唤醒，因此在释放池->lock 之前设置当前状态足以防止丢失任何事件。\n\t */\n\tworker_enter_idle(worker);\n\t\n\t// 设置当前线程状态为可中断睡眠\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\tspin_unlock_irq(&pool->lock);\n\n\t// 进入调度器，等待被唤醒\n\tschedule();\n\tgoto woke_up;\n}\n```\n```c\n/**\n * process_scheduled_works - 处理预定的工作项\n * @worker: 自身工作者\n *\n * 处理所有预定的工作项。请注意，预定的工作项列表在处理工作项时可能会发生变化，因此此函数反复从顶部获取工作项并执行它们。\n\n * 上下文：\n * 在 spin_lock_irq(pool->lock) 下，可能会多次释放和重新获取锁。\n */\nstatic void process_scheduled_works(struct worker *worker)\n{\n\twhile (!list_empty(&worker->scheduled)) {\n\t\tstruct work_struct *work = list_first_entry(&worker->scheduled,\n\t\t\t\t\t\tstruct work_struct, entry);\n\t\tprocess_one_work(worker, work);\n\t}\n}\n```\n```c\n/**\n * process_one_work - 处理单个工作项\n * @worker: 自身工作者\n * @work: 要处理的工作项\n *\n * 处理 @work。此函数包含处理单个工作项所需的所有逻辑，包括与同一 CPU 上的其他工作者的同步和交互、排队和刷新。只要满足上下文要求，任何工作者都可以调用此函数来处理工作项。\n\n * 上下文：\n * 在 spin_lock_irq(pool->lock) 下，会释放并重新获取锁。\n */\nstatic void process_one_work(struct worker *worker, struct work_struct *work)\n__releases(&pool->lock)\n__acquires(&pool->lock)\n{\n\tstruct pool_workqueue *pwq = get_work_pwq(work);\n\tstruct worker_pool *pool = worker->pool;\n\tbool cpu_intensive = pwq->wq->flags & WQ_CPU_INTENSIVE;\n\tint work_color;\n\tstruct worker *collision;\n#ifdef CONFIG_LOCKDEP\n\t/*\n\t * 可以在从工作项调用的函数内部释放 struct work_struct，因此我们也需要在 lockdep 中考虑这一点。为了避免虚假的“已持有的锁被释放”警告，\n\t * 以及在查看 work->lockdep_map 时出现问题，我们在这里创建一个副本并使用它。\n\t */\n\tstruct lockdep_map lockdep_map;\n\n\tlockdep_copy_map(&lockdep_map, &work->lockdep_map);\n#endif\n\t/* 确保我们在正确的 CPU 上 */\n\tWARN_ON_ONCE(!(pool->flags & POOL_DISASSOCIATED) &&\n\t\t     raw_smp_processor_id() != pool->cpu);\n\n\t/*\n\t * 一个工作项不应在单个 CPU 上的多个工作者之间并发执行。\n\t * 检查是否有其他工作者已经在处理这个工作项。如果是这样，则将工作项推迟到当前正在执行的工作者。\n\t */\n\tcollision = find_worker_executing_work(pool, work);\n\tif (unlikely(collision)) {\n\t\tmove_linked_works(work, &collision->scheduled, NULL);\n\t\treturn;\n\t}\n\n\t/* 认领并出队 */\n\tdebug_work_deactivate(work);\n\thash_add(pool->busy_hash, &worker->hentry, (unsigned long)work);\n\tworker->current_work = work;\n\tworker->current_func = work->func;\n\tworker->current_pwq = pwq;\n\twork_color = get_work_color(work);\n\n\tlist_del_init(&work->entry);\n\n\t/*\n\t * CPU 密集型的工作项不参与并发管理。它们由调度器负责。\n\t * 这将把 @worker 从并发管理中移出，并且下一个代码块将链接执行挂起的工作项。\n\t */\n\tif (unlikely(cpu_intensive))\n\t\tworker_set_flags(worker, WORKER_CPU_INTENSIVE);\n\n\t/*\n\t * 如果需要的话唤醒另一个工作者。对于正常的每个 CPU 工作者，条件始终为 false，因为 nr_running 在此时总是 >= 1。\n\t * 这用于链接执行挂起的工作项，对于 WORKER_NOT_RUNNING 工作者（如 UNBOUND 和 CPU_INTENSIVE）。\n\t */\n\tif (need_more_worker(pool))\n\t\twake_up_worker(pool);\n\n\t/*\n\t * 记录最后一个工作池并清除 PENDING，这应该是对 @work 的最后一次更新。\n\t * 同时，这在 @pool->lock 中完成，以便在禁用 IRQ 时同时发生 PENDING 和队列状态的变化。\n\t */\n\tset_work_pool_and_clear_pending(work, pool->id);\n\n\tspin_unlock_irq(&pool->lock);\n\n\tlock_map_acquire_read(&pwq->wq->lockdep_map);\n\tlock_map_acquire(&lockdep_map);\n\ttrace_workqueue_execute_start(work);\n\tworker->current_func(work);\n\t/*\n\t * 虽然我们必须小心，以免在此之后使用“work”，但跟踪点只会记录其地址。\n\t */\n\ttrace_workqueue_execute_end(work);\n\tlock_map_release(&lockdep_map);\n\tlock_map_release(&pwq->wq->lockdep_map);\n\n\tif (unlikely(in_atomic() || lockdep_depth(current) > 0)) {\n\t\tpr_err(\"BUG: workqueue leaked lock or atomic: %s/0x%08x/%d\\n\"\n\t\t       \"     last function: %pf\\n\",\n\t\t       current->comm, preempt_count(), task_pid_nr(current),\n\t\t       worker->current_func);\n\t\tdebug_show_held_locks(current);\n\t\tdump_stack();\n\t}\n\n\t/*\n\t * 以下内容可以防止 kworker 在没有 PREEMPT 的内核上占用 CPU，\n\t * 在这种情况下，等待重新排队的工作项等待某些事情发生可能会与 stop_machine 死锁，\n\t * 因为这种工作项可以无限期地重新排队自己，而所有其他 CPU 都被困在 stop_machine 中。\n\t * 同时，报告一个静止的 RCU 状态，以便相同的条件不会冻结 RCU。\n\t */\n\tcond_resched_rcu_qs();\n\n\tspin_lock_irq(&pool->lock);\n\n\t/* 清除 CPU 密集状态 */\n\tif (unlikely(cpu_intensive))\n\t\tworker_clr_flags(worker, WORKER_CPU_INTENSIVE);\n\n\t/* 我们已经完成了它，释放 */\n\thash_del(&worker->hentry);\n\tworker->current_work = NULL;\n\tworker->current_func = NULL;\n\tworker->current_pwq = NULL;\n\tworker->desc_valid = false;\n\tpwq_dec_nr_in_flight(pwq, work_color);\n}\n```\n# ps -A --forest \n```c\nps -A --forest\n  PID TTY          TIME CMD\n    2 ?        00:00:00 kthreadd\n    3 ?        00:00:01  \\_ ksoftirqd/0\n    5 ?        00:00:00  \\_ kworker/0:0H\n    7 ?        00:00:06  \\_ rcu_preempt\n    8 ?        00:00:00  \\_ rcu_sched\n    9 ?        00:00:00  \\_ rcu_bh\n   10 ?        00:00:00  \\_ migration/0\n   11 ?        00:00:00  \\_ khelper\n   12 ?        00:00:00  \\_ kdevtmpfs\n   13 ?        00:00:00  \\_ perf\n   14 ?        00:00:00  \\_ writeback\n   15 ?        00:00:00  \\_ crypto\n   16 ?        00:00:00  \\_ bioset\n   17 ?        00:00:00  \\_ kblockd\n   18 ?        00:00:00  \\_ ata_sff\n   20 ?        00:00:00  \\_ cfg80211\n   21 ?        00:00:00  \\_ rpciod\n   22 ?        00:00:00  \\_ kswapd0\n   23 ?        00:00:00  \\_ fsnotify_mark\n   24 ?        00:00:00  \\_ nfsiod\n   61 ?        00:00:00  \\_ kapmd\n   62 ?        00:00:00  \\_ spi2\n   63 ?        00:00:00  \\_ kworker/u2:1\n   68 ?        00:00:00  \\_ ci_otg\n   70 ?        00:00:00  \\_ goodix_wq\n   71 ?        00:00:00  \\_ cfinteractive\n   72 ?        00:00:00  \\_ irq/224-mmc0\n   73 ?        00:00:00  \\_ irq/49-2190000.\n   74 ?        00:00:00  \\_ mxs_dcp_chan/sh\n   75 ?        00:00:00  \\_ mxs_dcp_chan/ae\n   81 ?        00:00:00  \\_ kworker/u2:3\n   82 ?        00:00:00  \\_ ipv6_addrconf\n   83 ?        00:00:00  \\_ krfcommd\n   84 ?        00:00:00  \\_ pxp_dispatch\n   85 ?        00:00:00  \\_ deferwq\n   86 ?        00:00:00  \\_ irq/204-imx_the\n   87 ?        00:00:00  \\_ ubi_bgt0d\n  140 ?        00:00:00  \\_ ubifs_bgt0_0\n 1037 ?        00:00:00  \\_ kworker/0:0\n 1041 ?        00:00:00  \\_ kworker/0:2\n 1042 ?        00:00:00  \\_ kworker/0:1\n```\nkworker/x_x即是你的工作线程\n","slug":"process-kworker","published":1,"updated":"2024-01-05T08:12:19.808Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clru1g21y002ms4fucr22ff2f","content":"<h1 id=\"kworker线程\"><a href=\"#kworker线程\" class=\"headerlink\" title=\"kworker线程\"></a>kworker线程</h1><p><code>kworker</code> 是一类内核线程，用于执行一些与内核相关的后台任务。这些线程被用于处理一些异步工作，以避免阻塞主线程或其他关键内核线程。<code>kworker</code> 线程通常不与用户空间交互，而是专注于内核级别的任务。</p>\n<p>主要特点和用途：</p>\n<ol>\n<li><p><strong>后台任务处理</strong>：<code>kworker</code> 线程主要用于处理一些后台任务，如延迟的工作队列、定时器、中断处理等。</p>\n</li>\n<li><p><strong>异步执行</strong>：它们允许内核在不同的上下文中执行一些工作，而不会干扰到主线程或其他关键的内核线程。</p>\n</li>\n<li><p><strong>并发性能优化</strong>：在多核系统中，<code>kworker</code> 线程可以并行执行，从而提高系统的并发性能。</p>\n</li>\n<li><p><strong>避免阻塞</strong>：<code>kworker</code> 线程通常用于处理一些可能会阻塞主线程的工作，以确保内核的响应性不受影响。</p>\n</li>\n<li><p><strong>调度策略</strong>：它们可以使用不同的调度策略，以便在不同的上下文中执行任务，而不会竞争其他关键任务的资源。</p>\n</li>\n</ol>\n<p><code>kworker</code> 线程是一种在内核中用于执行后台任务的机制，有助于提高系统的性能和响应性。这些线程的设计允许内核在不同的上下文中执行任务，从而保持系统的平稳运行。不同的内核版本和配置可能会有不同数量的 <code>kworker</code> 线程，以适应系统的需求。</p>\n<h1 id=\"kworker源码\"><a href=\"#kworker源码\" class=\"headerlink\" title=\"kworker源码\"></a>kworker源码</h1><p>kernel/workqueue.c：init_workqueues()—&gt;create_worker()—&gt;kthread_create_on_node()&lt;—kthread进程</p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token comment\" spellcheck=\"true\">/**\n * init_workqueues - 初始化工作队列\n *\n * 这个函数在内核启动过程中被调用，用于初始化工作队列相关的数据结构和参数。\n * 工作队列是内核中用于处理异步任务的机制，它允许后台任务在不阻塞主要线程的情况下执行。\n */</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> __init <span class=\"token function\">init_workqueues</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 各个工作队列池的标准优先级设置</span>\n    <span class=\"token keyword\">int</span> std_nice<span class=\"token punctuation\">[</span>NR_STD_WORKER_POOLS<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> HIGHPRI_NICE_LEVEL <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">,</span> cpu<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 检查结构体对齐，确保池子工作队列和 long long 类型对齐</span>\n    <span class=\"token function\">WARN_ON</span><span class=\"token punctuation\">(</span><span class=\"token function\">__alignof__</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> pool_workqueue<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token function\">__alignof__</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 初始化工作队列池缓存</span>\n    pwq_cache <span class=\"token operator\">=</span> <span class=\"token function\">KMEM_CACHE</span><span class=\"token punctuation\">(</span>pool_workqueue<span class=\"token punctuation\">,</span> SLAB_PANIC<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 注册 CPU 通知回调，用于处理 CPU 的上线事件</span>\n    <span class=\"token function\">cpu_notifier</span><span class=\"token punctuation\">(</span>workqueue_cpu_up_callback<span class=\"token punctuation\">,</span> CPU_PRI_WORKQUEUE_UP<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 注册 CPU 热移除通知回调，用于处理 CPU 的下线事件</span>\n    <span class=\"token function\">hotcpu_notifier</span><span class=\"token punctuation\">(</span>workqueue_cpu_down_callback<span class=\"token punctuation\">,</span> CPU_PRI_WORKQUEUE_DOWN<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 初始化 NUMA 相关设置</span>\n    <span class=\"token function\">wq_numa_init</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 初始化 CPU 池子</span>\n    <span class=\"token function\">for_each_possible_cpu</span><span class=\"token punctuation\">(</span>cpu<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">struct</span> worker_pool <span class=\"token operator\">*</span>pool<span class=\"token punctuation\">;</span>\n\n        i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">for_each_cpu_worker_pool</span><span class=\"token punctuation\">(</span>pool<span class=\"token punctuation\">,</span> cpu<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 初始化池子工作队列</span>\n            <span class=\"token function\">BUG_ON</span><span class=\"token punctuation\">(</span><span class=\"token function\">init_worker_pool</span><span class=\"token punctuation\">(</span>pool<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            pool<span class=\"token operator\">-></span>cpu <span class=\"token operator\">=</span> cpu<span class=\"token punctuation\">;</span>\n            <span class=\"token function\">cpumask_copy</span><span class=\"token punctuation\">(</span>pool<span class=\"token operator\">-></span>attrs<span class=\"token operator\">-></span>cpumask<span class=\"token punctuation\">,</span> <span class=\"token function\">cpumask_of</span><span class=\"token punctuation\">(</span>cpu<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            pool<span class=\"token operator\">-></span>attrs<span class=\"token operator\">-></span>nice <span class=\"token operator\">=</span> std_nice<span class=\"token punctuation\">[</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            pool<span class=\"token operator\">-></span>node <span class=\"token operator\">=</span> <span class=\"token function\">cpu_to_node</span><span class=\"token punctuation\">(</span>cpu<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">/* 分配池子 ID */</span>\n            <span class=\"token function\">mutex_lock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>wq_pool_mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">BUG_ON</span><span class=\"token punctuation\">(</span><span class=\"token function\">worker_pool_assign_id</span><span class=\"token punctuation\">(</span>pool<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">mutex_unlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>wq_pool_mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 创建初始工作者</span>\n    <span class=\"token function\">for_each_online_cpu</span><span class=\"token punctuation\">(</span>cpu<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">struct</span> worker_pool <span class=\"token operator\">*</span>pool<span class=\"token punctuation\">;</span>\n\n        <span class=\"token function\">for_each_cpu_worker_pool</span><span class=\"token punctuation\">(</span>pool<span class=\"token punctuation\">,</span> cpu<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            pool<span class=\"token operator\">-></span>flags <span class=\"token operator\">&amp;</span><span class=\"token operator\">=</span> <span class=\"token operator\">~</span>POOL_DISASSOCIATED<span class=\"token punctuation\">;</span>\n            <span class=\"token function\">BUG_ON</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">create_worker</span><span class=\"token punctuation\">(</span>pool<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 创建默认的 unbound 和 ordered 工作队列属性</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> NR_STD_WORKER_POOLS<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">struct</span> workqueue_attrs <span class=\"token operator\">*</span>attrs<span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 分配工作队列属性</span>\n        <span class=\"token function\">BUG_ON</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>attrs <span class=\"token operator\">=</span> <span class=\"token function\">alloc_workqueue_attrs</span><span class=\"token punctuation\">(</span>GFP_KERNEL<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        attrs<span class=\"token operator\">-></span>nice <span class=\"token operator\">=</span> std_nice<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        unbound_std_wq_attrs<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> attrs<span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">/*\n         * 有序工作队列只应有一个 pwq，由 pwqs 强制执行排序。\n         * 关闭 NUMA 以便 dfl_pwq 用于所有节点。\n         */</span>\n        <span class=\"token function\">BUG_ON</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>attrs <span class=\"token operator\">=</span> <span class=\"token function\">alloc_workqueue_attrs</span><span class=\"token punctuation\">(</span>GFP_KERNEL<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        attrs<span class=\"token operator\">-></span>nice <span class=\"token operator\">=</span> std_nice<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        attrs<span class=\"token operator\">-></span>no_numa <span class=\"token operator\">=</span> true<span class=\"token punctuation\">;</span>\n        ordered_wq_attrs<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> attrs<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 创建系统工作队列</span>\n    system_wq <span class=\"token operator\">=</span> <span class=\"token function\">alloc_workqueue</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"events\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    system_highpri_wq <span class=\"token operator\">=</span> <span class=\"token function\">alloc_workqueue</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"events_highpri\"</span><span class=\"token punctuation\">,</span> WQ_HIGHPRI<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    system_long_wq <span class=\"token operator\">=</span> <span class=\"token function\">alloc_workqueue</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"events_long\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    system_unbound_wq <span class=\"token operator\">=</span> <span class=\"token function\">alloc_workqueue</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"events_unbound\"</span><span class=\"token punctuation\">,</span> WQ_UNBOUND<span class=\"token punctuation\">,</span>\n                                        WQ_UNBOUND_MAX_ACTIVE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    system_freezable_wq <span class=\"token operator\">=</span> <span class=\"token function\">alloc_workqueue</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"events_freezable\"</span><span class=\"token punctuation\">,</span>\n                                          WQ_FREEZABLE<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    system_power_efficient_wq <span class=\"token operator\">=</span> <span class=\"token function\">alloc_workqueue</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"events_power_efficient\"</span><span class=\"token punctuation\">,</span>\n                                                WQ_POWER_EFFICIENT<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    system_freezable_power_efficient_wq <span class=\"token operator\">=</span> <span class=\"token function\">alloc_workqueue</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"events_freezable_power_efficient\"</span><span class=\"token punctuation\">,</span>\n                                                          WQ_FREEZABLE <span class=\"token operator\">|</span> WQ_POWER_EFFICIENT<span class=\"token punctuation\">,</span>\n                                                          <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 检查系统工作队列是否成功创建</span>\n    <span class=\"token function\">BUG_ON</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>system_wq <span class=\"token operator\">||</span> <span class=\"token operator\">!</span>system_highpri_wq <span class=\"token operator\">||</span> <span class=\"token operator\">!</span>system_long_wq <span class=\"token operator\">||</span>\n           <span class=\"token operator\">!</span>system_unbound_wq <span class=\"token operator\">||</span> <span class=\"token operator\">!</span>system_freezable_wq <span class=\"token operator\">||</span>\n           <span class=\"token operator\">!</span>system_power_efficient_wq <span class=\"token operator\">||</span>\n           <span class=\"token operator\">!</span>system_freezable_power_efficient_wq<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">// 在内核初始化阶段调用 init_workqueues 函数</span>\n<span class=\"token function\">early_initcall</span><span class=\"token punctuation\">(</span>init_workqueues<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token comment\" spellcheck=\"true\">/**\n * create_worker - 创建一个新的工作队列工作者\n * @pool: 新工作者将属于的池子\n *\n * 这个函数用于创建并启动一个新的工作队列工作者，该工作者将附属于指定的池子 @pool。\n *\n * 上下文：\n * 这个函数可能会进行休眠操作（可能会分配内存，可能会导致调度器切换）。\n *\n * 返回：\n * 返回指向新创建的工作者的指针，如果创建失败则返回 NULL。\n */</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">struct</span> worker <span class=\"token operator\">*</span><span class=\"token function\">create_worker</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> worker_pool <span class=\"token operator\">*</span>pool<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">struct</span> worker <span class=\"token operator\">*</span>worker <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 初始化工作者指针</span>\n    <span class=\"token keyword\">int</span> id <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 初始化工作者的 ID</span>\n    <span class=\"token keyword\">char</span> id_buf<span class=\"token punctuation\">[</span><span class=\"token number\">16</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 用于存储 ID 的字符缓冲区</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 获取一个唯一的工作者 ID</span>\n    id <span class=\"token operator\">=</span> <span class=\"token function\">ida_simple_get</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>pool<span class=\"token operator\">-></span>worker_ida<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> GFP_KERNEL<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>id <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">goto</span> fail<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 分配工作者的内存</span>\n    worker <span class=\"token operator\">=</span> <span class=\"token function\">alloc_worker</span><span class=\"token punctuation\">(</span>pool<span class=\"token operator\">-></span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>worker<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">goto</span> fail<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 初始化工作者的属性</span>\n    worker<span class=\"token operator\">-></span>pool <span class=\"token operator\">=</span> pool<span class=\"token punctuation\">;</span>\n    worker<span class=\"token operator\">-></span>id <span class=\"token operator\">=</span> id<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 创建工作者的线程名</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pool<span class=\"token operator\">-></span>cpu <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">snprintf</span><span class=\"token punctuation\">(</span>id_buf<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>id_buf<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"%d:%d%s\"</span><span class=\"token punctuation\">,</span> pool<span class=\"token operator\">-></span>cpu<span class=\"token punctuation\">,</span> id<span class=\"token punctuation\">,</span>\n                 pool<span class=\"token operator\">-></span>attrs<span class=\"token operator\">-></span>nice <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span>  <span class=\"token operator\">?</span> <span class=\"token string\">\"H\"</span> <span class=\"token punctuation\">:</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span>\n        <span class=\"token function\">snprintf</span><span class=\"token punctuation\">(</span>id_buf<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>id_buf<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"u%d:%d\"</span><span class=\"token punctuation\">,</span> pool<span class=\"token operator\">-></span>id<span class=\"token punctuation\">,</span> id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 在指定的 NUMA 节点上创建工作者线程</span>\n    worker<span class=\"token operator\">-></span>task <span class=\"token operator\">=</span> <span class=\"token function\">kthread_create_on_node</span><span class=\"token punctuation\">(</span>worker_thread<span class=\"token punctuation\">,</span> worker<span class=\"token punctuation\">,</span> pool<span class=\"token operator\">-></span>node<span class=\"token punctuation\">,</span>\n                                          <span class=\"token string\">\"kworker/%s\"</span><span class=\"token punctuation\">,</span> id_buf<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">IS_ERR</span><span class=\"token punctuation\">(</span>worker<span class=\"token operator\">-></span>task<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">goto</span> fail<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 设置工作者线程的优先级</span>\n    <span class=\"token function\">set_user_nice</span><span class=\"token punctuation\">(</span>worker<span class=\"token operator\">-></span>task<span class=\"token punctuation\">,</span> pool<span class=\"token operator\">-></span>attrs<span class=\"token operator\">-></span>nice<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 防止用户干扰工作者线程的 CPU 亲和性设置</span>\n    worker<span class=\"token operator\">-></span>task<span class=\"token operator\">-></span>flags <span class=\"token operator\">|</span><span class=\"token operator\">=</span> PF_NO_SETAFFINITY<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 将工作者附加到池子</span>\n    <span class=\"token function\">worker_attach_to_pool</span><span class=\"token punctuation\">(</span>worker<span class=\"token punctuation\">,</span> pool<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 启动新创建的工作者线程</span>\n    <span class=\"token function\">spin_lock_irq</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>pool<span class=\"token operator\">-></span>lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    worker<span class=\"token operator\">-></span>pool<span class=\"token operator\">-></span>nr_workers<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">worker_enter_idle</span><span class=\"token punctuation\">(</span>worker<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">wake_up_process</span><span class=\"token punctuation\">(</span>worker<span class=\"token operator\">-></span>task<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">spin_unlock_irq</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>pool<span class=\"token operator\">-></span>lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> worker<span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 返回新创建的工作者指针</span>\n\nfail<span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>id <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">ida_simple_remove</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>pool<span class=\"token operator\">-></span>worker_ida<span class=\"token punctuation\">,</span> id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 清理 ID 分配</span>\n    <span class=\"token function\">kfree</span><span class=\"token punctuation\">(</span>worker<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 释放工作者内存</span>\n    <span class=\"token keyword\">return</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 返回 NULL 表示创建失败</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>根据工作者所属的池子属性来为工作者线程生成一个名称。生成的名称将包含一些池子和工作者的信息，以便在内核中识别工作者线程的用途。具体的命名方式如下：</p>\n<ul>\n<li><p>如果 <code>pool-&gt;cpu &gt;= 0</code>，即工作者线程分配到了特定的 CPU，则名称将按以下格式生成：</p>\n<ul>\n<li><code>%d:%d</code> 用于表示池子所在的 CPU 编号和工作者的 ID</li>\n<li><code>%s</code> 根据池子的属性 <code>pool-&gt;attrs-&gt;nice</code>，如果优先级小于 0（HIGHPRI_NICE_LEVEL），则附加 “H”，表示高优先级</li>\n</ul>\n</li>\n<li><p>如果 <code>pool-&gt;cpu</code> 小于 0，即工作者线程是无绑定到特定 CPU 的，则名称将按以下格式生成：</p>\n<ul>\n<li><code>u%d:%d</code> 用于表示池子的 ID 和工作者的 ID</li>\n</ul>\n</li>\n</ul>\n<p>例如，如果 <code>pool-&gt;cpu</code> 是 2，<code>id</code> 是 5，并且 <code>pool-&gt;attrs-&gt;nice</code> 为正值，则生成的名称可能是 “2:5”。如果 <code>pool-&gt;cpu</code> 是 -1，<code>pool-&gt;id</code> 是 1，<code>id</code> 是 3，则生成的名称可能是 “u1:3”。</p>\n<p>这个命名方式是为了在内核中更好地识别不同的工作者线程以及它们所属的池子和属性。这对于调试和监控工作者线程的活动非常有帮助。</p>\n<h1 id=\"kworker函数\"><a href=\"#kworker函数\" class=\"headerlink\" title=\"kworker函数\"></a>kworker函数</h1><p>worker_thread()—&gt;process_scheduled_works()—&gt;process_one_work()</p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token comment\" spellcheck=\"true\">/**\n * worker_thread - 工作者线程函数\n * @__worker: 自身工作者\n *\n * 工作者线程函数。所有工作者都属于一个工作者池（worker_pool） - 可能是每个 CPU 的一个或动态的无绑定池。这些工作者处理所有工作项，不管它们的特定目标工作队列。唯一的例外是属于具有救援者（rescuer）的工作队列的工作项，这将在 rescuer_thread() 中解释。\n\n * 返回值：0\n */</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">worker_thread</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>__worker<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">struct</span> worker <span class=\"token operator\">*</span>worker <span class=\"token operator\">=</span> __worker<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">struct</span> worker_pool <span class=\"token operator\">*</span>pool <span class=\"token operator\">=</span> worker<span class=\"token operator\">-></span>pool<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 告诉调度器这是一个工作队列工作者</span>\n    worker<span class=\"token operator\">-></span>task<span class=\"token operator\">-></span>flags <span class=\"token operator\">|</span><span class=\"token operator\">=</span> PF_WQ_WORKER<span class=\"token punctuation\">;</span>\n\nwoke_up<span class=\"token punctuation\">:</span>\n    <span class=\"token function\">spin_lock_irq</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>pool<span class=\"token operator\">-></span>lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 是否应该终止？</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">unlikely</span><span class=\"token punctuation\">(</span>worker<span class=\"token operator\">-></span>flags <span class=\"token operator\">&amp;</span> WORKER_DIE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">spin_unlock_irq</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>pool<span class=\"token operator\">-></span>lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 确保 worker 不在任何列表中</span>\n        <span class=\"token function\">WARN_ON_ONCE</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">list_empty</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>worker<span class=\"token operator\">-></span>entry<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 清除工作者标志</span>\n        worker<span class=\"token operator\">-></span>task<span class=\"token operator\">-></span>flags <span class=\"token operator\">&amp;</span><span class=\"token operator\">=</span> <span class=\"token operator\">~</span>PF_WQ_WORKER<span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 设置任务的名称为 \"kworker/dying\"</span>\n        <span class=\"token function\">set_task_comm</span><span class=\"token punctuation\">(</span>worker<span class=\"token operator\">-></span>task<span class=\"token punctuation\">,</span> <span class=\"token string\">\"kworker/dying\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 从工作者池的 worker_ida 中移除工作者 ID</span>\n        <span class=\"token function\">ida_simple_remove</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>pool<span class=\"token operator\">-></span>worker_ida<span class=\"token punctuation\">,</span> worker<span class=\"token operator\">-></span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 从工作者池中分离工作者</span>\n        <span class=\"token function\">worker_detach_from_pool</span><span class=\"token punctuation\">(</span>worker<span class=\"token punctuation\">,</span> pool<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 释放工作者内存</span>\n        <span class=\"token function\">kfree</span><span class=\"token punctuation\">(</span>worker<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 让工作者离开空闲状态，准备处理工作</span>\n    <span class=\"token function\">worker_leave_idle</span><span class=\"token punctuation\">(</span>worker<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nrecheck<span class=\"token punctuation\">:</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 是否不再需要更多工作者？</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">need_more_worker</span><span class=\"token punctuation\">(</span>pool<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">goto</span> sleep<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 是否需要进行管理？</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">unlikely</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">may_start_working</span><span class=\"token punctuation\">(</span>pool<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">manage_workers</span><span class=\"token punctuation\">(</span>worker<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">goto</span> recheck<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/*\n     * ->scheduled 列表只能在工作者准备处理工作或实际处理工作时填充。\n     * 确保在休眠时没有人干扰它。\n     */</span>\n    <span class=\"token function\">WARN_ON_ONCE</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">list_empty</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>worker<span class=\"token operator\">-></span>scheduled<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/*\n     * 完成 PREP 阶段。我们保证至少有一个空闲工作者或其他人已经承担了管理者角色。\n     * 如果适用，这是 @worker 开始参与并发管理的地方，并在重新绑定后恢复并发管理。\n     * 有关详细信息，请参阅 rebind_workers()。\n     */</span>\n    <span class=\"token function\">worker_clr_flags</span><span class=\"token punctuation\">(</span>worker<span class=\"token punctuation\">,</span> WORKER_PREP <span class=\"token operator\">|</span> WORKER_REBOUND<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">do</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">struct</span> work_struct <span class=\"token operator\">*</span>work <span class=\"token operator\">=</span>\n            <span class=\"token function\">list_first_entry</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>pool<span class=\"token operator\">-></span>worklist<span class=\"token punctuation\">,</span>\n                     <span class=\"token keyword\">struct</span> work_struct<span class=\"token punctuation\">,</span> entry<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">likely</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token function\">work_data_bits</span><span class=\"token punctuation\">(</span>work<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;</span> WORK_STRUCT_LINKED<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">/* 优化路径，不是严格必需的 */</span>\n            <span class=\"token function\">process_one_work</span><span class=\"token punctuation\">(</span>worker<span class=\"token punctuation\">,</span> work<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">unlikely</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">list_empty</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>worker<span class=\"token operator\">-></span>scheduled<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                <span class=\"token function\">process_scheduled_works</span><span class=\"token punctuation\">(</span>worker<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">move_linked_works</span><span class=\"token punctuation\">(</span>work<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>worker<span class=\"token operator\">-></span>scheduled<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">process_scheduled_works</span><span class=\"token punctuation\">(</span>worker<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token function\">keep_working</span><span class=\"token punctuation\">(</span>pool<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 设置工作者为准备状态</span>\n    <span class=\"token function\">worker_set_flags</span><span class=\"token punctuation\">(</span>worker<span class=\"token punctuation\">,</span> WORKER_PREP<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nsleep<span class=\"token punctuation\">:</span>\n    <span class=\"token comment\" spellcheck=\"true\">/*\n     * 池->lock 已经持有，没有要处理的工作也没有必要管理，进入休眠。\n     * 工作者只在持有池->lock 或从本地 CPU 中唤醒时被唤醒，因此在释放池->lock 之前设置当前状态足以防止丢失任何事件。\n     */</span>\n    <span class=\"token function\">worker_enter_idle</span><span class=\"token punctuation\">(</span>worker<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 设置当前线程状态为可中断睡眠</span>\n    <span class=\"token function\">__set_current_state</span><span class=\"token punctuation\">(</span>TASK_INTERRUPTIBLE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">spin_unlock_irq</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>pool<span class=\"token operator\">-></span>lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 进入调度器，等待被唤醒</span>\n    <span class=\"token function\">schedule</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">goto</span> woke_up<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token comment\" spellcheck=\"true\">/**\n * process_scheduled_works - 处理预定的工作项\n * @worker: 自身工作者\n *\n * 处理所有预定的工作项。请注意，预定的工作项列表在处理工作项时可能会发生变化，因此此函数反复从顶部获取工作项并执行它们。\n\n * 上下文：\n * 在 spin_lock_irq(pool->lock) 下，可能会多次释放和重新获取锁。\n */</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">process_scheduled_works</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> worker <span class=\"token operator\">*</span>worker<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">list_empty</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>worker<span class=\"token operator\">-></span>scheduled<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">struct</span> work_struct <span class=\"token operator\">*</span>work <span class=\"token operator\">=</span> <span class=\"token function\">list_first_entry</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>worker<span class=\"token operator\">-></span>scheduled<span class=\"token punctuation\">,</span>\n                        <span class=\"token keyword\">struct</span> work_struct<span class=\"token punctuation\">,</span> entry<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">process_one_work</span><span class=\"token punctuation\">(</span>worker<span class=\"token punctuation\">,</span> work<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token comment\" spellcheck=\"true\">/**\n * process_one_work - 处理单个工作项\n * @worker: 自身工作者\n * @work: 要处理的工作项\n *\n * 处理 @work。此函数包含处理单个工作项所需的所有逻辑，包括与同一 CPU 上的其他工作者的同步和交互、排队和刷新。只要满足上下文要求，任何工作者都可以调用此函数来处理工作项。\n\n * 上下文：\n * 在 spin_lock_irq(pool->lock) 下，会释放并重新获取锁。\n */</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">process_one_work</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> worker <span class=\"token operator\">*</span>worker<span class=\"token punctuation\">,</span> <span class=\"token keyword\">struct</span> work_struct <span class=\"token operator\">*</span>work<span class=\"token punctuation\">)</span>\n<span class=\"token function\">__releases</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>pool<span class=\"token operator\">-></span>lock<span class=\"token punctuation\">)</span>\n<span class=\"token function\">__acquires</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>pool<span class=\"token operator\">-></span>lock<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">struct</span> pool_workqueue <span class=\"token operator\">*</span>pwq <span class=\"token operator\">=</span> <span class=\"token function\">get_work_pwq</span><span class=\"token punctuation\">(</span>work<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">struct</span> worker_pool <span class=\"token operator\">*</span>pool <span class=\"token operator\">=</span> worker<span class=\"token operator\">-></span>pool<span class=\"token punctuation\">;</span>\n    bool cpu_intensive <span class=\"token operator\">=</span> pwq<span class=\"token operator\">-></span>wq<span class=\"token operator\">-></span>flags <span class=\"token operator\">&amp;</span> WQ_CPU_INTENSIVE<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> work_color<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">struct</span> worker <span class=\"token operator\">*</span>collision<span class=\"token punctuation\">;</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">ifdef</span> CONFIG_LOCKDEP</span>\n    <span class=\"token comment\" spellcheck=\"true\">/*\n     * 可以在从工作项调用的函数内部释放 struct work_struct，因此我们也需要在 lockdep 中考虑这一点。为了避免虚假的“已持有的锁被释放”警告，\n     * 以及在查看 work->lockdep_map 时出现问题，我们在这里创建一个副本并使用它。\n     */</span>\n    <span class=\"token keyword\">struct</span> lockdep_map lockdep_map<span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">lockdep_copy_map</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>lockdep_map<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>work<span class=\"token operator\">-></span>lockdep_map<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">endif</span></span>\n    <span class=\"token comment\" spellcheck=\"true\">/* 确保我们在正确的 CPU 上 */</span>\n    <span class=\"token function\">WARN_ON_ONCE</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>pool<span class=\"token operator\">-></span>flags <span class=\"token operator\">&amp;</span> POOL_DISASSOCIATED<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span>\n             <span class=\"token function\">raw_smp_processor_id</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> pool<span class=\"token operator\">-></span>cpu<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/*\n     * 一个工作项不应在单个 CPU 上的多个工作者之间并发执行。\n     * 检查是否有其他工作者已经在处理这个工作项。如果是这样，则将工作项推迟到当前正在执行的工作者。\n     */</span>\n    collision <span class=\"token operator\">=</span> <span class=\"token function\">find_worker_executing_work</span><span class=\"token punctuation\">(</span>pool<span class=\"token punctuation\">,</span> work<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">unlikely</span><span class=\"token punctuation\">(</span>collision<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">move_linked_works</span><span class=\"token punctuation\">(</span>work<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>collision<span class=\"token operator\">-></span>scheduled<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/* 认领并出队 */</span>\n    <span class=\"token function\">debug_work_deactivate</span><span class=\"token punctuation\">(</span>work<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">hash_add</span><span class=\"token punctuation\">(</span>pool<span class=\"token operator\">-></span>busy_hash<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>worker<span class=\"token operator\">-></span>hentry<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">)</span>work<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    worker<span class=\"token operator\">-></span>current_work <span class=\"token operator\">=</span> work<span class=\"token punctuation\">;</span>\n    worker<span class=\"token operator\">-></span>current_func <span class=\"token operator\">=</span> work<span class=\"token operator\">-></span>func<span class=\"token punctuation\">;</span>\n    worker<span class=\"token operator\">-></span>current_pwq <span class=\"token operator\">=</span> pwq<span class=\"token punctuation\">;</span>\n    work_color <span class=\"token operator\">=</span> <span class=\"token function\">get_work_color</span><span class=\"token punctuation\">(</span>work<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">list_del_init</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>work<span class=\"token operator\">-></span>entry<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/*\n     * CPU 密集型的工作项不参与并发管理。它们由调度器负责。\n     * 这将把 @worker 从并发管理中移出，并且下一个代码块将链接执行挂起的工作项。\n     */</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">unlikely</span><span class=\"token punctuation\">(</span>cpu_intensive<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">worker_set_flags</span><span class=\"token punctuation\">(</span>worker<span class=\"token punctuation\">,</span> WORKER_CPU_INTENSIVE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/*\n     * 如果需要的话唤醒另一个工作者。对于正常的每个 CPU 工作者，条件始终为 false，因为 nr_running 在此时总是 >= 1。\n     * 这用于链接执行挂起的工作项，对于 WORKER_NOT_RUNNING 工作者（如 UNBOUND 和 CPU_INTENSIVE）。\n     */</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">need_more_worker</span><span class=\"token punctuation\">(</span>pool<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">wake_up_worker</span><span class=\"token punctuation\">(</span>pool<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/*\n     * 记录最后一个工作池并清除 PENDING，这应该是对 @work 的最后一次更新。\n     * 同时，这在 @pool->lock 中完成，以便在禁用 IRQ 时同时发生 PENDING 和队列状态的变化。\n     */</span>\n    <span class=\"token function\">set_work_pool_and_clear_pending</span><span class=\"token punctuation\">(</span>work<span class=\"token punctuation\">,</span> pool<span class=\"token operator\">-></span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">spin_unlock_irq</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>pool<span class=\"token operator\">-></span>lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">lock_map_acquire_read</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>pwq<span class=\"token operator\">-></span>wq<span class=\"token operator\">-></span>lockdep_map<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">lock_map_acquire</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>lockdep_map<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">trace_workqueue_execute_start</span><span class=\"token punctuation\">(</span>work<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    worker<span class=\"token operator\">-></span><span class=\"token function\">current_func</span><span class=\"token punctuation\">(</span>work<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">/*\n     * 虽然我们必须小心，以免在此之后使用“work”，但跟踪点只会记录其地址。\n     */</span>\n    <span class=\"token function\">trace_workqueue_execute_end</span><span class=\"token punctuation\">(</span>work<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">lock_map_release</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>lockdep_map<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">lock_map_release</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>pwq<span class=\"token operator\">-></span>wq<span class=\"token operator\">-></span>lockdep_map<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">unlikely</span><span class=\"token punctuation\">(</span><span class=\"token function\">in_atomic</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> <span class=\"token function\">lockdep_depth</span><span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">pr_err</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"BUG: workqueue leaked lock or atomic: %s/0x%08x/%d\\n\"</span>\n               <span class=\"token string\">\"     last function: %pf\\n\"</span><span class=\"token punctuation\">,</span>\n               current<span class=\"token operator\">-></span>comm<span class=\"token punctuation\">,</span> <span class=\"token function\">preempt_count</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">task_pid_nr</span><span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n               worker<span class=\"token operator\">-></span>current_func<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">debug_show_held_locks</span><span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">dump_stack</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/*\n     * 以下内容可以防止 kworker 在没有 PREEMPT 的内核上占用 CPU，\n     * 在这种情况下，等待重新排队的工作项等待某些事情发生可能会与 stop_machine 死锁，\n     * 因为这种工作项可以无限期地重新排队自己，而所有其他 CPU 都被困在 stop_machine 中。\n     * 同时，报告一个静止的 RCU 状态，以便相同的条件不会冻结 RCU。\n     */</span>\n    <span class=\"token function\">cond_resched_rcu_qs</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">spin_lock_irq</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>pool<span class=\"token operator\">-></span>lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/* 清除 CPU 密集状态 */</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">unlikely</span><span class=\"token punctuation\">(</span>cpu_intensive<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">worker_clr_flags</span><span class=\"token punctuation\">(</span>worker<span class=\"token punctuation\">,</span> WORKER_CPU_INTENSIVE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/* 我们已经完成了它，释放 */</span>\n    <span class=\"token function\">hash_del</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>worker<span class=\"token operator\">-></span>hentry<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    worker<span class=\"token operator\">-></span>current_work <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n    worker<span class=\"token operator\">-></span>current_func <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n    worker<span class=\"token operator\">-></span>current_pwq <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n    worker<span class=\"token operator\">-></span>desc_valid <span class=\"token operator\">=</span> false<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">pwq_dec_nr_in_flight</span><span class=\"token punctuation\">(</span>pwq<span class=\"token punctuation\">,</span> work_color<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"ps-A-–forest\"><a href=\"#ps-A-–forest\" class=\"headerlink\" title=\"ps -A –forest\"></a>ps -A –forest</h1><pre class=\" language-c\"><code class=\"language-c\">ps <span class=\"token operator\">-</span>A <span class=\"token operator\">--</span>forest\n  PID TTY          TIME CMD\n    <span class=\"token number\">2</span> <span class=\"token operator\">?</span>        <span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span> kthreadd\n    <span class=\"token number\">3</span> <span class=\"token operator\">?</span>        <span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">01</span>  \\_ ksoftirqd<span class=\"token operator\">/</span><span class=\"token number\">0</span>\n    <span class=\"token number\">5</span> <span class=\"token operator\">?</span>        <span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span>  \\_ kworker<span class=\"token operator\">/</span><span class=\"token number\">0</span><span class=\"token punctuation\">:</span>0H\n    <span class=\"token number\">7</span> <span class=\"token operator\">?</span>        <span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">06</span>  \\_ rcu_preempt\n    <span class=\"token number\">8</span> <span class=\"token operator\">?</span>        <span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span>  \\_ rcu_sched\n    <span class=\"token number\">9</span> <span class=\"token operator\">?</span>        <span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span>  \\_ rcu_bh\n   <span class=\"token number\">10</span> <span class=\"token operator\">?</span>        <span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span>  \\_ migration<span class=\"token operator\">/</span><span class=\"token number\">0</span>\n   <span class=\"token number\">11</span> <span class=\"token operator\">?</span>        <span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span>  \\_ khelper\n   <span class=\"token number\">12</span> <span class=\"token operator\">?</span>        <span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span>  \\_ kdevtmpfs\n   <span class=\"token number\">13</span> <span class=\"token operator\">?</span>        <span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span>  \\_ perf\n   <span class=\"token number\">14</span> <span class=\"token operator\">?</span>        <span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span>  \\_ writeback\n   <span class=\"token number\">15</span> <span class=\"token operator\">?</span>        <span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span>  \\_ crypto\n   <span class=\"token number\">16</span> <span class=\"token operator\">?</span>        <span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span>  \\_ bioset\n   <span class=\"token number\">17</span> <span class=\"token operator\">?</span>        <span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span>  \\_ kblockd\n   <span class=\"token number\">18</span> <span class=\"token operator\">?</span>        <span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span>  \\_ ata_sff\n   <span class=\"token number\">20</span> <span class=\"token operator\">?</span>        <span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span>  \\_ cfg80211\n   <span class=\"token number\">21</span> <span class=\"token operator\">?</span>        <span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span>  \\_ rpciod\n   <span class=\"token number\">22</span> <span class=\"token operator\">?</span>        <span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span>  \\_ kswapd0\n   <span class=\"token number\">23</span> <span class=\"token operator\">?</span>        <span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span>  \\_ fsnotify_mark\n   <span class=\"token number\">24</span> <span class=\"token operator\">?</span>        <span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span>  \\_ nfsiod\n   <span class=\"token number\">61</span> <span class=\"token operator\">?</span>        <span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span>  \\_ kapmd\n   <span class=\"token number\">62</span> <span class=\"token operator\">?</span>        <span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span>  \\_ spi2\n   <span class=\"token number\">63</span> <span class=\"token operator\">?</span>        <span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span>  \\_ kworker<span class=\"token operator\">/</span>u2<span class=\"token punctuation\">:</span><span class=\"token number\">1</span>\n   <span class=\"token number\">68</span> <span class=\"token operator\">?</span>        <span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span>  \\_ ci_otg\n   <span class=\"token number\">70</span> <span class=\"token operator\">?</span>        <span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span>  \\_ goodix_wq\n   <span class=\"token number\">71</span> <span class=\"token operator\">?</span>        <span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span>  \\_ cfinteractive\n   <span class=\"token number\">72</span> <span class=\"token operator\">?</span>        <span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span>  \\_ irq<span class=\"token operator\">/</span><span class=\"token number\">224</span><span class=\"token operator\">-</span>mmc0\n   <span class=\"token number\">73</span> <span class=\"token operator\">?</span>        <span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span>  \\_ irq<span class=\"token operator\">/</span><span class=\"token number\">49</span><span class=\"token operator\">-</span><span class=\"token number\">2190000</span><span class=\"token punctuation\">.</span>\n   <span class=\"token number\">74</span> <span class=\"token operator\">?</span>        <span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span>  \\_ mxs_dcp_chan<span class=\"token operator\">/</span>sh\n   <span class=\"token number\">75</span> <span class=\"token operator\">?</span>        <span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span>  \\_ mxs_dcp_chan<span class=\"token operator\">/</span>ae\n   <span class=\"token number\">81</span> <span class=\"token operator\">?</span>        <span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span>  \\_ kworker<span class=\"token operator\">/</span>u2<span class=\"token punctuation\">:</span><span class=\"token number\">3</span>\n   <span class=\"token number\">82</span> <span class=\"token operator\">?</span>        <span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span>  \\_ ipv6_addrconf\n   <span class=\"token number\">83</span> <span class=\"token operator\">?</span>        <span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span>  \\_ krfcommd\n   <span class=\"token number\">84</span> <span class=\"token operator\">?</span>        <span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span>  \\_ pxp_dispatch\n   <span class=\"token number\">85</span> <span class=\"token operator\">?</span>        <span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span>  \\_ deferwq\n   <span class=\"token number\">86</span> <span class=\"token operator\">?</span>        <span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span>  \\_ irq<span class=\"token operator\">/</span><span class=\"token number\">204</span><span class=\"token operator\">-</span>imx_the\n   <span class=\"token number\">87</span> <span class=\"token operator\">?</span>        <span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span>  \\_ ubi_bgt0d\n  <span class=\"token number\">140</span> <span class=\"token operator\">?</span>        <span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span>  \\_ ubifs_bgt0_0\n <span class=\"token number\">1037</span> <span class=\"token operator\">?</span>        <span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span>  \\_ kworker<span class=\"token operator\">/</span><span class=\"token number\">0</span><span class=\"token punctuation\">:</span><span class=\"token number\">0</span>\n <span class=\"token number\">1041</span> <span class=\"token operator\">?</span>        <span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span>  \\_ kworker<span class=\"token operator\">/</span><span class=\"token number\">0</span><span class=\"token punctuation\">:</span><span class=\"token number\">2</span>\n <span class=\"token number\">1042</span> <span class=\"token operator\">?</span>        <span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span>  \\_ kworker<span class=\"token operator\">/</span><span class=\"token number\">0</span><span class=\"token punctuation\">:</span><span class=\"token number\">1</span></code></pre>\n<p>kworker/x_x即是你的工作线程</p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<h1 id=\"kworker线程\"><a href=\"#kworker线程\" class=\"headerlink\" title=\"kworker线程\"></a>kworker线程</h1><p><code>kworker</code> 是一类内核线程，用于执行一些与内核相关的后台任务。这些线程被用于处理一些异步工作，以避免阻塞主线程或其他关键内核线程。<code>kworker</code> 线程通常不与用户空间交互，而是专注于内核级别的任务。</p>\n<p>主要特点和用途：</p>\n<ol>\n<li><p><strong>后台任务处理</strong>：<code>kworker</code> 线程主要用于处理一些后台任务，如延迟的工作队列、定时器、中断处理等。</p>\n</li>\n<li><p><strong>异步执行</strong>：它们允许内核在不同的上下文中执行一些工作，而不会干扰到主线程或其他关键的内核线程。</p>\n</li>\n<li><p><strong>并发性能优化</strong>：在多核系统中，<code>kworker</code> 线程可以并行执行，从而提高系统的并发性能。</p>\n</li>\n<li><p><strong>避免阻塞</strong>：<code>kworker</code> 线程通常用于处理一些可能会阻塞主线程的工作，以确保内核的响应性不受影响。</p>\n</li>\n<li><p><strong>调度策略</strong>：它们可以使用不同的调度策略，以便在不同的上下文中执行任务，而不会竞争其他关键任务的资源。</p>\n</li>\n</ol>\n<p><code>kworker</code> 线程是一种在内核中用于执行后台任务的机制，有助于提高系统的性能和响应性。这些线程的设计允许内核在不同的上下文中执行任务，从而保持系统的平稳运行。不同的内核版本和配置可能会有不同数量的 <code>kworker</code> 线程，以适应系统的需求。</p>\n<h1 id=\"kworker源码\"><a href=\"#kworker源码\" class=\"headerlink\" title=\"kworker源码\"></a>kworker源码</h1><p>kernel/workqueue.c：init_workqueues()—&gt;create_worker()—&gt;kthread_create_on_node()&lt;—kthread进程</p>\n<pre><code class=\"c\">/**\n * init_workqueues - 初始化工作队列\n *\n * 这个函数在内核启动过程中被调用，用于初始化工作队列相关的数据结构和参数。\n * 工作队列是内核中用于处理异步任务的机制，它允许后台任务在不阻塞主要线程的情况下执行。\n */\nstatic int __init init_workqueues(void)\n{\n    // 各个工作队列池的标准优先级设置\n    int std_nice[NR_STD_WORKER_POOLS] = { 0, HIGHPRI_NICE_LEVEL };\n    int i, cpu;\n\n    // 检查结构体对齐，确保池子工作队列和 long long 类型对齐\n    WARN_ON(__alignof__(struct pool_workqueue) &lt; __alignof__(long long));\n\n    // 初始化工作队列池缓存\n    pwq_cache = KMEM_CACHE(pool_workqueue, SLAB_PANIC);\n\n    // 注册 CPU 通知回调，用于处理 CPU 的上线事件\n    cpu_notifier(workqueue_cpu_up_callback, CPU_PRI_WORKQUEUE_UP);\n    // 注册 CPU 热移除通知回调，用于处理 CPU 的下线事件\n    hotcpu_notifier(workqueue_cpu_down_callback, CPU_PRI_WORKQUEUE_DOWN);\n\n    // 初始化 NUMA 相关设置\n    wq_numa_init();\n\n    // 初始化 CPU 池子\n    for_each_possible_cpu(cpu) {\n        struct worker_pool *pool;\n\n        i = 0;\n        for_each_cpu_worker_pool(pool, cpu) {\n            // 初始化池子工作队列\n            BUG_ON(init_worker_pool(pool));\n            pool-&gt;cpu = cpu;\n            cpumask_copy(pool-&gt;attrs-&gt;cpumask, cpumask_of(cpu));\n            pool-&gt;attrs-&gt;nice = std_nice[i++];\n            pool-&gt;node = cpu_to_node(cpu);\n\n            /* 分配池子 ID */\n            mutex_lock(&amp;wq_pool_mutex);\n            BUG_ON(worker_pool_assign_id(pool));\n            mutex_unlock(&amp;wq_pool_mutex);\n        }\n    }\n\n    // 创建初始工作者\n    for_each_online_cpu(cpu) {\n        struct worker_pool *pool;\n\n        for_each_cpu_worker_pool(pool, cpu) {\n            pool-&gt;flags &amp;= ~POOL_DISASSOCIATED;\n            BUG_ON(!create_worker(pool));\n        }\n    }\n\n    // 创建默认的 unbound 和 ordered 工作队列属性\n    for (i = 0; i &lt; NR_STD_WORKER_POOLS; i++) {\n        struct workqueue_attrs *attrs;\n\n        // 分配工作队列属性\n        BUG_ON(!(attrs = alloc_workqueue_attrs(GFP_KERNEL)));\n        attrs-&gt;nice = std_nice[i];\n        unbound_std_wq_attrs[i] = attrs;\n\n        /*\n         * 有序工作队列只应有一个 pwq，由 pwqs 强制执行排序。\n         * 关闭 NUMA 以便 dfl_pwq 用于所有节点。\n         */\n        BUG_ON(!(attrs = alloc_workqueue_attrs(GFP_KERNEL)));\n        attrs-&gt;nice = std_nice[i];\n        attrs-&gt;no_numa = true;\n        ordered_wq_attrs[i] = attrs;\n    }\n\n    // 创建系统工作队列\n    system_wq = alloc_workqueue(&quot;events&quot;, 0, 0);\n    system_highpri_wq = alloc_workqueue(&quot;events_highpri&quot;, WQ_HIGHPRI, 0);\n    system_long_wq = alloc_workqueue(&quot;events_long&quot;, 0, 0);\n    system_unbound_wq = alloc_workqueue(&quot;events_unbound&quot;, WQ_UNBOUND,\n                                        WQ_UNBOUND_MAX_ACTIVE);\n    system_freezable_wq = alloc_workqueue(&quot;events_freezable&quot;,\n                                          WQ_FREEZABLE, 0);\n    system_power_efficient_wq = alloc_workqueue(&quot;events_power_efficient&quot;,\n                                                WQ_POWER_EFFICIENT, 0);\n    system_freezable_power_efficient_wq = alloc_workqueue(&quot;events_freezable_power_efficient&quot;,\n                                                          WQ_FREEZABLE | WQ_POWER_EFFICIENT,\n                                                          0);\n    // 检查系统工作队列是否成功创建\n    BUG_ON(!system_wq || !system_highpri_wq || !system_long_wq ||\n           !system_unbound_wq || !system_freezable_wq ||\n           !system_power_efficient_wq ||\n           !system_freezable_power_efficient_wq);\n    return 0;\n}\n// 在内核初始化阶段调用 init_workqueues 函数\nearly_initcall(init_workqueues);</code></pre>\n<pre><code class=\"c\">/**\n * create_worker - 创建一个新的工作队列工作者\n * @pool: 新工作者将属于的池子\n *\n * 这个函数用于创建并启动一个新的工作队列工作者，该工作者将附属于指定的池子 @pool。\n *\n * 上下文：\n * 这个函数可能会进行休眠操作（可能会分配内存，可能会导致调度器切换）。\n *\n * 返回：\n * 返回指向新创建的工作者的指针，如果创建失败则返回 NULL。\n */\nstatic struct worker *create_worker(struct worker_pool *pool)\n{\n    struct worker *worker = NULL;  // 初始化工作者指针\n    int id = -1;  // 初始化工作者的 ID\n    char id_buf[16];  // 用于存储 ID 的字符缓冲区\n\n    // 获取一个唯一的工作者 ID\n    id = ida_simple_get(&amp;pool-&gt;worker_ida, 0, 0, GFP_KERNEL);\n    if (id &lt; 0)\n        goto fail;\n\n    // 分配工作者的内存\n    worker = alloc_worker(pool-&gt;node);\n    if (!worker)\n        goto fail;\n\n    // 初始化工作者的属性\n    worker-&gt;pool = pool;\n    worker-&gt;id = id;\n\n    // 创建工作者的线程名\n    if (pool-&gt;cpu &gt;= 0)\n        snprintf(id_buf, sizeof(id_buf), &quot;%d:%d%s&quot;, pool-&gt;cpu, id,\n                 pool-&gt;attrs-&gt;nice &lt; 0  ? &quot;H&quot; : &quot;&quot;);\n    else\n        snprintf(id_buf, sizeof(id_buf), &quot;u%d:%d&quot;, pool-&gt;id, id);\n\n    // 在指定的 NUMA 节点上创建工作者线程\n    worker-&gt;task = kthread_create_on_node(worker_thread, worker, pool-&gt;node,\n                                          &quot;kworker/%s&quot;, id_buf);\n    if (IS_ERR(worker-&gt;task))\n        goto fail;\n\n    // 设置工作者线程的优先级\n    set_user_nice(worker-&gt;task, pool-&gt;attrs-&gt;nice);\n\n    // 防止用户干扰工作者线程的 CPU 亲和性设置\n    worker-&gt;task-&gt;flags |= PF_NO_SETAFFINITY;\n\n    // 将工作者附加到池子\n    worker_attach_to_pool(worker, pool);\n\n    // 启动新创建的工作者线程\n    spin_lock_irq(&amp;pool-&gt;lock);\n    worker-&gt;pool-&gt;nr_workers++;\n    worker_enter_idle(worker);\n    wake_up_process(worker-&gt;task);\n    spin_unlock_irq(&amp;pool-&gt;lock);\n\n    return worker;  // 返回新创建的工作者指针\n\nfail:\n    if (id &gt;= 0)\n        ida_simple_remove(&amp;pool-&gt;worker_ida, id);  // 清理 ID 分配\n    kfree(worker);  // 释放工作者内存\n    return NULL;  // 返回 NULL 表示创建失败\n}</code></pre>\n<p>根据工作者所属的池子属性来为工作者线程生成一个名称。生成的名称将包含一些池子和工作者的信息，以便在内核中识别工作者线程的用途。具体的命名方式如下：</p>\n<ul>\n<li><p>如果 <code>pool-&gt;cpu &gt;= 0</code>，即工作者线程分配到了特定的 CPU，则名称将按以下格式生成：</p>\n<ul>\n<li><code>%d:%d</code> 用于表示池子所在的 CPU 编号和工作者的 ID</li>\n<li><code>%s</code> 根据池子的属性 <code>pool-&gt;attrs-&gt;nice</code>，如果优先级小于 0（HIGHPRI_NICE_LEVEL），则附加 “H”，表示高优先级</li>\n</ul>\n</li>\n<li><p>如果 <code>pool-&gt;cpu</code> 小于 0，即工作者线程是无绑定到特定 CPU 的，则名称将按以下格式生成：</p>\n<ul>\n<li><code>u%d:%d</code> 用于表示池子的 ID 和工作者的 ID</li>\n</ul>\n</li>\n</ul>\n<p>例如，如果 <code>pool-&gt;cpu</code> 是 2，<code>id</code> 是 5，并且 <code>pool-&gt;attrs-&gt;nice</code> 为正值，则生成的名称可能是 “2:5”。如果 <code>pool-&gt;cpu</code> 是 -1，<code>pool-&gt;id</code> 是 1，<code>id</code> 是 3，则生成的名称可能是 “u1:3”。</p>\n<p>这个命名方式是为了在内核中更好地识别不同的工作者线程以及它们所属的池子和属性。这对于调试和监控工作者线程的活动非常有帮助。</p>\n<h1 id=\"kworker函数\"><a href=\"#kworker函数\" class=\"headerlink\" title=\"kworker函数\"></a>kworker函数</h1><p>worker_thread()—&gt;process_scheduled_works()—&gt;process_one_work()</p>\n<pre><code class=\"c\">/**\n * worker_thread - 工作者线程函数\n * @__worker: 自身工作者\n *\n * 工作者线程函数。所有工作者都属于一个工作者池（worker_pool） - 可能是每个 CPU 的一个或动态的无绑定池。这些工作者处理所有工作项，不管它们的特定目标工作队列。唯一的例外是属于具有救援者（rescuer）的工作队列的工作项，这将在 rescuer_thread() 中解释。\n\n * 返回值：0\n */\nstatic int worker_thread(void *__worker)\n{\n    struct worker *worker = __worker;\n    struct worker_pool *pool = worker-&gt;pool;\n\n    // 告诉调度器这是一个工作队列工作者\n    worker-&gt;task-&gt;flags |= PF_WQ_WORKER;\n\nwoke_up:\n    spin_lock_irq(&amp;pool-&gt;lock);\n\n    // 是否应该终止？\n    if (unlikely(worker-&gt;flags &amp; WORKER_DIE)) {\n        spin_unlock_irq(&amp;pool-&gt;lock);\n\n        // 确保 worker 不在任何列表中\n        WARN_ON_ONCE(!list_empty(&amp;worker-&gt;entry));\n\n        // 清除工作者标志\n        worker-&gt;task-&gt;flags &amp;= ~PF_WQ_WORKER;\n\n        // 设置任务的名称为 &quot;kworker/dying&quot;\n        set_task_comm(worker-&gt;task, &quot;kworker/dying&quot;);\n\n        // 从工作者池的 worker_ida 中移除工作者 ID\n        ida_simple_remove(&amp;pool-&gt;worker_ida, worker-&gt;id);\n\n        // 从工作者池中分离工作者\n        worker_detach_from_pool(worker, pool);\n\n        // 释放工作者内存\n        kfree(worker);\n        return 0;\n    }\n\n    // 让工作者离开空闲状态，准备处理工作\n    worker_leave_idle(worker);\n\nrecheck:\n    // 是否不再需要更多工作者？\n    if (!need_more_worker(pool))\n        goto sleep;\n\n    // 是否需要进行管理？\n    if (unlikely(!may_start_working(pool)) &amp;&amp; manage_workers(worker))\n        goto recheck;\n\n    /*\n     * -&gt;scheduled 列表只能在工作者准备处理工作或实际处理工作时填充。\n     * 确保在休眠时没有人干扰它。\n     */\n    WARN_ON_ONCE(!list_empty(&amp;worker-&gt;scheduled));\n\n    /*\n     * 完成 PREP 阶段。我们保证至少有一个空闲工作者或其他人已经承担了管理者角色。\n     * 如果适用，这是 @worker 开始参与并发管理的地方，并在重新绑定后恢复并发管理。\n     * 有关详细信息，请参阅 rebind_workers()。\n     */\n    worker_clr_flags(worker, WORKER_PREP | WORKER_REBOUND);\n\n    do {\n        struct work_struct *work =\n            list_first_entry(&amp;pool-&gt;worklist,\n                     struct work_struct, entry);\n\n        if (likely(!(*work_data_bits(work) &amp; WORK_STRUCT_LINKED))) {\n            /* 优化路径，不是严格必需的 */\n            process_one_work(worker, work);\n            if (unlikely(!list_empty(&amp;worker-&gt;scheduled)))\n                process_scheduled_works(worker);\n        } else {\n            move_linked_works(work, &amp;worker-&gt;scheduled, NULL);\n            process_scheduled_works(worker);\n        }\n    } while (keep_working(pool));\n\n    // 设置工作者为准备状态\n    worker_set_flags(worker, WORKER_PREP);\n\nsleep:\n    /*\n     * 池-&gt;lock 已经持有，没有要处理的工作也没有必要管理，进入休眠。\n     * 工作者只在持有池-&gt;lock 或从本地 CPU 中唤醒时被唤醒，因此在释放池-&gt;lock 之前设置当前状态足以防止丢失任何事件。\n     */\n    worker_enter_idle(worker);\n\n    // 设置当前线程状态为可中断睡眠\n    __set_current_state(TASK_INTERRUPTIBLE);\n    spin_unlock_irq(&amp;pool-&gt;lock);\n\n    // 进入调度器，等待被唤醒\n    schedule();\n    goto woke_up;\n}</code></pre>\n<pre><code class=\"c\">/**\n * process_scheduled_works - 处理预定的工作项\n * @worker: 自身工作者\n *\n * 处理所有预定的工作项。请注意，预定的工作项列表在处理工作项时可能会发生变化，因此此函数反复从顶部获取工作项并执行它们。\n\n * 上下文：\n * 在 spin_lock_irq(pool-&gt;lock) 下，可能会多次释放和重新获取锁。\n */\nstatic void process_scheduled_works(struct worker *worker)\n{\n    while (!list_empty(&amp;worker-&gt;scheduled)) {\n        struct work_struct *work = list_first_entry(&amp;worker-&gt;scheduled,\n                        struct work_struct, entry);\n        process_one_work(worker, work);\n    }\n}</code></pre>\n<pre><code class=\"c\">/**\n * process_one_work - 处理单个工作项\n * @worker: 自身工作者\n * @work: 要处理的工作项\n *\n * 处理 @work。此函数包含处理单个工作项所需的所有逻辑，包括与同一 CPU 上的其他工作者的同步和交互、排队和刷新。只要满足上下文要求，任何工作者都可以调用此函数来处理工作项。\n\n * 上下文：\n * 在 spin_lock_irq(pool-&gt;lock) 下，会释放并重新获取锁。\n */\nstatic void process_one_work(struct worker *worker, struct work_struct *work)\n__releases(&amp;pool-&gt;lock)\n__acquires(&amp;pool-&gt;lock)\n{\n    struct pool_workqueue *pwq = get_work_pwq(work);\n    struct worker_pool *pool = worker-&gt;pool;\n    bool cpu_intensive = pwq-&gt;wq-&gt;flags &amp; WQ_CPU_INTENSIVE;\n    int work_color;\n    struct worker *collision;\n#ifdef CONFIG_LOCKDEP\n    /*\n     * 可以在从工作项调用的函数内部释放 struct work_struct，因此我们也需要在 lockdep 中考虑这一点。为了避免虚假的“已持有的锁被释放”警告，\n     * 以及在查看 work-&gt;lockdep_map 时出现问题，我们在这里创建一个副本并使用它。\n     */\n    struct lockdep_map lockdep_map;\n\n    lockdep_copy_map(&amp;lockdep_map, &amp;work-&gt;lockdep_map);\n#endif\n    /* 确保我们在正确的 CPU 上 */\n    WARN_ON_ONCE(!(pool-&gt;flags &amp; POOL_DISASSOCIATED) &amp;&amp;\n             raw_smp_processor_id() != pool-&gt;cpu);\n\n    /*\n     * 一个工作项不应在单个 CPU 上的多个工作者之间并发执行。\n     * 检查是否有其他工作者已经在处理这个工作项。如果是这样，则将工作项推迟到当前正在执行的工作者。\n     */\n    collision = find_worker_executing_work(pool, work);\n    if (unlikely(collision)) {\n        move_linked_works(work, &amp;collision-&gt;scheduled, NULL);\n        return;\n    }\n\n    /* 认领并出队 */\n    debug_work_deactivate(work);\n    hash_add(pool-&gt;busy_hash, &amp;worker-&gt;hentry, (unsigned long)work);\n    worker-&gt;current_work = work;\n    worker-&gt;current_func = work-&gt;func;\n    worker-&gt;current_pwq = pwq;\n    work_color = get_work_color(work);\n\n    list_del_init(&amp;work-&gt;entry);\n\n    /*\n     * CPU 密集型的工作项不参与并发管理。它们由调度器负责。\n     * 这将把 @worker 从并发管理中移出，并且下一个代码块将链接执行挂起的工作项。\n     */\n    if (unlikely(cpu_intensive))\n        worker_set_flags(worker, WORKER_CPU_INTENSIVE);\n\n    /*\n     * 如果需要的话唤醒另一个工作者。对于正常的每个 CPU 工作者，条件始终为 false，因为 nr_running 在此时总是 &gt;= 1。\n     * 这用于链接执行挂起的工作项，对于 WORKER_NOT_RUNNING 工作者（如 UNBOUND 和 CPU_INTENSIVE）。\n     */\n    if (need_more_worker(pool))\n        wake_up_worker(pool);\n\n    /*\n     * 记录最后一个工作池并清除 PENDING，这应该是对 @work 的最后一次更新。\n     * 同时，这在 @pool-&gt;lock 中完成，以便在禁用 IRQ 时同时发生 PENDING 和队列状态的变化。\n     */\n    set_work_pool_and_clear_pending(work, pool-&gt;id);\n\n    spin_unlock_irq(&amp;pool-&gt;lock);\n\n    lock_map_acquire_read(&amp;pwq-&gt;wq-&gt;lockdep_map);\n    lock_map_acquire(&amp;lockdep_map);\n    trace_workqueue_execute_start(work);\n    worker-&gt;current_func(work);\n    /*\n     * 虽然我们必须小心，以免在此之后使用“work”，但跟踪点只会记录其地址。\n     */\n    trace_workqueue_execute_end(work);\n    lock_map_release(&amp;lockdep_map);\n    lock_map_release(&amp;pwq-&gt;wq-&gt;lockdep_map);\n\n    if (unlikely(in_atomic() || lockdep_depth(current) &gt; 0)) {\n        pr_err(&quot;BUG: workqueue leaked lock or atomic: %s/0x%08x/%d\\n&quot;\n               &quot;     last function: %pf\\n&quot;,\n               current-&gt;comm, preempt_count(), task_pid_nr(current),\n               worker-&gt;current_func);\n        debug_show_held_locks(current);\n        dump_stack();\n    }\n\n    /*\n     * 以下内容可以防止 kworker 在没有 PREEMPT 的内核上占用 CPU，\n     * 在这种情况下，等待重新排队的工作项等待某些事情发生可能会与 stop_machine 死锁，\n     * 因为这种工作项可以无限期地重新排队自己，而所有其他 CPU 都被困在 stop_machine 中。\n     * 同时，报告一个静止的 RCU 状态，以便相同的条件不会冻结 RCU。\n     */\n    cond_resched_rcu_qs();\n\n    spin_lock_irq(&amp;pool-&gt;lock);\n\n    /* 清除 CPU 密集状态 */\n    if (unlikely(cpu_intensive))\n        worker_clr_flags(worker, WORKER_CPU_INTENSIVE);\n\n    /* 我们已经完成了它，释放 */\n    hash_del(&amp;worker-&gt;hentry);\n    worker-&gt;current_work = NULL;\n    worker-&gt;current_func = NULL;\n    worker-&gt;current_pwq = NULL;\n    worker-&gt;desc_valid = false;\n    pwq_dec_nr_in_flight(pwq, work_color);\n}</code></pre>\n<h1 id=\"ps-A-–forest\"><a href=\"#ps-A-–forest\" class=\"headerlink\" title=\"ps -A –forest\"></a>ps -A –forest</h1><pre><code class=\"c\">ps -A --forest\n  PID TTY          TIME CMD\n    2 ?        00:00:00 kthreadd\n    3 ?        00:00:01  \\_ ksoftirqd/0\n    5 ?        00:00:00  \\_ kworker/0:0H\n    7 ?        00:00:06  \\_ rcu_preempt\n    8 ?        00:00:00  \\_ rcu_sched\n    9 ?        00:00:00  \\_ rcu_bh\n   10 ?        00:00:00  \\_ migration/0\n   11 ?        00:00:00  \\_ khelper\n   12 ?        00:00:00  \\_ kdevtmpfs\n   13 ?        00:00:00  \\_ perf\n   14 ?        00:00:00  \\_ writeback\n   15 ?        00:00:00  \\_ crypto\n   16 ?        00:00:00  \\_ bioset\n   17 ?        00:00:00  \\_ kblockd\n   18 ?        00:00:00  \\_ ata_sff\n   20 ?        00:00:00  \\_ cfg80211\n   21 ?        00:00:00  \\_ rpciod\n   22 ?        00:00:00  \\_ kswapd0\n   23 ?        00:00:00  \\_ fsnotify_mark\n   24 ?        00:00:00  \\_ nfsiod\n   61 ?        00:00:00  \\_ kapmd\n   62 ?        00:00:00  \\_ spi2\n   63 ?        00:00:00  \\_ kworker/u2:1\n   68 ?        00:00:00  \\_ ci_otg\n   70 ?        00:00:00  \\_ goodix_wq\n   71 ?        00:00:00  \\_ cfinteractive\n   72 ?        00:00:00  \\_ irq/224-mmc0\n   73 ?        00:00:00  \\_ irq/49-2190000.\n   74 ?        00:00:00  \\_ mxs_dcp_chan/sh\n   75 ?        00:00:00  \\_ mxs_dcp_chan/ae\n   81 ?        00:00:00  \\_ kworker/u2:3\n   82 ?        00:00:00  \\_ ipv6_addrconf\n   83 ?        00:00:00  \\_ krfcommd\n   84 ?        00:00:00  \\_ pxp_dispatch\n   85 ?        00:00:00  \\_ deferwq\n   86 ?        00:00:00  \\_ irq/204-imx_the\n   87 ?        00:00:00  \\_ ubi_bgt0d\n  140 ?        00:00:00  \\_ ubifs_bgt0_0\n 1037 ?        00:00:00  \\_ kworker/0:0\n 1041 ?        00:00:00  \\_ kworker/0:2\n 1042 ?        00:00:00  \\_ kworker/0:1</code></pre>\n<p>kworker/x_x即是你的工作线程</p>\n"},{"title":"process-syslogd-klogd","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-08-31T03:32:30.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"\n# syslog\n\"syslog\" 是一个用于系统日志的标准化方法和系统，用于收集、存储和管理操作系统和应用程序的日志信息。在很多操作系统中，包括类Unix系统（如Linux），syslog是一个重要的组件，用于日志管理和故障排除。\n\n关于 \"syslog 线程\" 的具体用途，这可能会因上下文和特定系统的设置而有所不同。一般来说，\"syslog 线程\" 可能指的是一个在系统中运行的线程，专门用于处理和管理日志消息。以下是一些可能的用途：\n\n1. **日志收集和处理：** \"syslog 线程\" 可能会收集来自不同应用程序、服务和系统组件的日志消息。它可以对这些消息进行处理、分类和过滤，以确保将有关系统状态、故障和事件的相关信息记录下来。\n\n2. **日志存储：** \"syslog 线程\" 可能会将日志消息存储到适当的位置，通常是日志文件。这些日志文件可能位于系统的标准位置，如 `/var/log` 目录下，或者根据系统管理员的配置而定。\n\n3. **日志转发：** \"syslog 线程\" 通常还能够将日志消息转发到远程的日志服务器，以便集中管理和分析。这在大规模系统中特别有用，可以将日志从多个服务器和设备中集中处理。\n\n4. **日志分析和监控：** \"syslog 线程\" 可能会涉及将日志消息传递给分析工具或监控系统，以便实时监视系统的健康状态、故障和异常情况。\n\n总之，\"syslog 线程\" 在系统中起着重要作用，有助于捕获、管理和分析系统的日志信息，从而帮助管理员进行故障排除、安全监控和系统维护。\n\n# syslog源码\n/etc/rc5.d/S20syslog -> etc/init.d/syslog -> /etc/init.d/syslog.sysklogd\n```shell\n#! /bin/sh\n# /etc/init.d/sysklogd: start the system log daemon.\n\n### BEGIN INIT INFO\n# Provides:             sysklogd\n# Required-Start:       $remote_fs $time\n# Required-Stop:        $remote_fs $time\n# Should-Start:         $network\n# Should-Stop:          $network\n# Default-Start:        2 3 4 5\n# Default-Stop:         0 1 6\n# Short-Description:    System logger\n### END INIT INFO\n\n# Source function library.\n. /etc/init.d/functions\n\nPATH=/bin:/usr/bin:/sbin:/usr/sbin\n\npidfile_syslogd=/var/run/syslogd.pid\npidfile_klogd=/var/run/klogd.pid\nbinpath_syslogd=/sbin/syslogd\nbinpath_klogd=/sbin/klogd\n\ntest -x $binpath || exit 0\n\ntest ! -r /etc/default/syslogd || . /etc/default/syslogd\n\ncreate_xconsole()\n{\n    # Only proceed if /dev/xconsole is used at all\n    if ! grep -q '^[^#].*/dev/xconsole' /etc/syslog.conf\n    then\n\treturn\n    fi\n\n    if [ ! -e /dev/xconsole ]; then\n\tmknod -m 640 /dev/xconsole p\n    else\n\tchmod 0640 /dev/xconsole\n    fi\n    chown root:adm /dev/xconsole\n    test ! -x /sbin/restorecon || /sbin/restorecon /dev/xconsole\n}\n\nlog_begin_msg () {\n    echo -n $1\n}\n\nlog_end_msg () {\n    echo $1\n}\n\nlog_success_msg () {\n    echo $1\n}\n\nrunning()\n{\n    # No pidfile, probably no daemon present\n    #\n    if [ ! -f $pidfile ]\n    then\n\treturn 1\n    fi\n\n    pid=`cat $pidfile_syslogd`\n\n    # No pid, probably no daemon present\n    #\n    if [ -z \"$pid\" ]\n    then\n\treturn 1\n    fi\n\n    if [ ! -d /proc/$pid ]\n    then\n\treturn 1\n    fi\n\n    cmd=`cat /proc/$pid/cmdline | tr \"\\000\" \"\\n\"|head -n 1`\n\n    # No syslogd?\n    #\n    if [ \"$cmd\" != \"$binpath\" ]\n    then\n\treturn 1\n    fi\n\n    return 0\n}\n\ncase \"$1\" in\n  start)\n    log_begin_msg \"Starting system log daemon...\"\n    create_xconsole\n    start-stop-daemon --start --quiet --pidfile $pidfile_syslogd --name syslogd --startas $binpath_syslogd -- $SYSLOGD\n    log_end_msg $?\n    log_begin_msg \"Starting kernel log daemon...\"\n    start-stop-daemon --start --quiet --pidfile $pidfile_klogd --name klogd --startas $binpath_klogd -- $KLOGD\n    log_end_msg $?\n    ;;\n  stop)\n    log_begin_msg \"Stopping system log daemon...\"\n    start-stop-daemon --stop --quiet --pidfile $pidfile_syslogd --name syslogd\n    log_end_msg $?\n    log_begin_msg \"Stopping kernel log daemon...\"\n    start-stop-daemon --stop --quiet --retry 3 --exec $binpath_klogd --pidfile $pidfile_klogd\n    log_end_msg $?\n    ;;\n  reload|force-reload)\n    log_begin_msg \"Reloading system log daemon...\"\n    start-stop-daemon --stop --quiet --signal 1 --pidfile $pidfile_syslogd --name syslogd\n    log_end_msg $?\n    log_begin_msg \"Reloading kernel log daemon...\"\n    start-stop-daemon --stop --quiet --retry 3 --exec $binpath_klogd --pidfile $pidfile_klogd\n    start-stop-daemon --start --quiet --pidfile $pidfile_klogd --name klogd --startas $binpath_klogd -- $KLOGD\n    log_end_msg $?\n    ;;\n  restart)\n    log_begin_msg \"Restarting system log daemon...\"\n    start-stop-daemon --stop --retry 5 --quiet --pidfile $pidfile_syslogd --name syslogd\n    start-stop-daemon --start --quiet --pidfile $pidfile_syslogd --name syslogd --startas $binpath_syslogd -- $SYSLOGD\n    log_end_msg $?\n    log_begin_msg \"Reloading kernel log daemon...\"\n    start-stop-daemon --stop --quiet --retry 3 --exec $binpath_klogd --pidfile $pidfile_klogd\n    start-stop-daemon --start --quiet --pidfile $pidfile_klogd --name klogd --startas $binpath_klogd -- $KLOGD\n    log_end_msg $?\n    ;;\n  reload-or-restart)\n    if running\n    then\n\t$0 reload\n    else\n\t$0 start\n    fi\n    ;;\n  status)\n    status syslogd\n    RETVAL=$?\n    status klogd\n    rval=$?\n    [ $RETVAL -eq 0 ] && exit $rval\n    exit $RETVAL\n    ;;\n  *)\n    log_success_msg \"Usage: /etc/init.d/sysklogd {start|stop|reload|restart|force-reload|reload-or-restart|status}\"\n    exit 1\nesac\n\nexit 0\n```\n显而易见运行/sbin/syslogd和/sbin/klogd\n\n# linux系统日志简介\n\nLinux 日志系统是用于记录、存储和管理操作系统和应用程序的日志消息的机制和工具集合。日志是记录系统运行状态、事件、错误和其他相关信息的关键工具，对于故障排除、性能监控、安全审计和系统维护至关重要。以下是 Linux 日志系统的主要组成部分和概述：\n\n1. **syslog：** Syslog 是一个标准化的日志消息传输协议和系统，用于将系统和应用程序的日志消息发送到集中的日志服务器或存储位置。Syslog 能够将日志消息分类、过滤和转发，并支持不同的日志级别，如调试、信息、警告和错误。\n\n2. **日志消息级别：** Linux 日志消息通常分为几个不同的级别，例如：调试（debug）、信息（info）、警告（warning）、错误（error）和严重（critical）。这些级别帮助管理员快速了解日志的重要性。\n\n3. **日志位置：** 在 Linux 系统中，日志消息通常存储在 `/var/log` 目录下。不同的服务和应用程序可能会有自己的日志文件，例如 `/var/log/messages`、`/var/log/syslog`、`/var/log/auth.log` 等。\n\n4. **日志旋转：** 为了防止日志文件过大，Linux 系统通常使用日志旋转工具来定期归档、压缩或删除旧的日志文件，并创建新的日志文件。常见的日志旋转工具包括 `logrotate`。\n\n5. **日志分析工具：** Linux 提供了各种用于分析和查看日志的工具，例如 `grep` 用于搜索、`tail` 用于实时查看、`less` 用于分页查看等。此外，还有更高级的工具如 `journalctl` 用于查看 Systemd Journal 日志。\n\n6. **Systemd Journal：** Systemd 是现代 Linux 系统的初始化系统，它引入了 Systemd Journal，一个用于收集和管理系统日志的机制。`journalctl` 命令用于访问和查询 Systemd Journal 中的日志。\n\n7. **远程日志：** Linux 日志系统支持将日志消息发送到远程的日志服务器，以便集中存储和分析。这对于大规模系统和分布式环境非常有用。\n\n# 如何使用syslog和klog\n[syslog官网](https://en.wikipedia.org/wiki/Syslog)\n[klog官网](https://linux.die.net/man/8/klogd)\n","source":"_posts/2023/08/process-syslogd-klogd.md","raw":"---\ntitle: process-syslogd-klogd\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-08-31 11:32:30\npassword:\nsummary:\ntags:\n- linux\n- process\ncategories:\n- process\n- linux\nkeywords:\ndescription:\n---\n\n# syslog\n\"syslog\" 是一个用于系统日志的标准化方法和系统，用于收集、存储和管理操作系统和应用程序的日志信息。在很多操作系统中，包括类Unix系统（如Linux），syslog是一个重要的组件，用于日志管理和故障排除。\n\n关于 \"syslog 线程\" 的具体用途，这可能会因上下文和特定系统的设置而有所不同。一般来说，\"syslog 线程\" 可能指的是一个在系统中运行的线程，专门用于处理和管理日志消息。以下是一些可能的用途：\n\n1. **日志收集和处理：** \"syslog 线程\" 可能会收集来自不同应用程序、服务和系统组件的日志消息。它可以对这些消息进行处理、分类和过滤，以确保将有关系统状态、故障和事件的相关信息记录下来。\n\n2. **日志存储：** \"syslog 线程\" 可能会将日志消息存储到适当的位置，通常是日志文件。这些日志文件可能位于系统的标准位置，如 `/var/log` 目录下，或者根据系统管理员的配置而定。\n\n3. **日志转发：** \"syslog 线程\" 通常还能够将日志消息转发到远程的日志服务器，以便集中管理和分析。这在大规模系统中特别有用，可以将日志从多个服务器和设备中集中处理。\n\n4. **日志分析和监控：** \"syslog 线程\" 可能会涉及将日志消息传递给分析工具或监控系统，以便实时监视系统的健康状态、故障和异常情况。\n\n总之，\"syslog 线程\" 在系统中起着重要作用，有助于捕获、管理和分析系统的日志信息，从而帮助管理员进行故障排除、安全监控和系统维护。\n\n# syslog源码\n/etc/rc5.d/S20syslog -> etc/init.d/syslog -> /etc/init.d/syslog.sysklogd\n```shell\n#! /bin/sh\n# /etc/init.d/sysklogd: start the system log daemon.\n\n### BEGIN INIT INFO\n# Provides:             sysklogd\n# Required-Start:       $remote_fs $time\n# Required-Stop:        $remote_fs $time\n# Should-Start:         $network\n# Should-Stop:          $network\n# Default-Start:        2 3 4 5\n# Default-Stop:         0 1 6\n# Short-Description:    System logger\n### END INIT INFO\n\n# Source function library.\n. /etc/init.d/functions\n\nPATH=/bin:/usr/bin:/sbin:/usr/sbin\n\npidfile_syslogd=/var/run/syslogd.pid\npidfile_klogd=/var/run/klogd.pid\nbinpath_syslogd=/sbin/syslogd\nbinpath_klogd=/sbin/klogd\n\ntest -x $binpath || exit 0\n\ntest ! -r /etc/default/syslogd || . /etc/default/syslogd\n\ncreate_xconsole()\n{\n    # Only proceed if /dev/xconsole is used at all\n    if ! grep -q '^[^#].*/dev/xconsole' /etc/syslog.conf\n    then\n\treturn\n    fi\n\n    if [ ! -e /dev/xconsole ]; then\n\tmknod -m 640 /dev/xconsole p\n    else\n\tchmod 0640 /dev/xconsole\n    fi\n    chown root:adm /dev/xconsole\n    test ! -x /sbin/restorecon || /sbin/restorecon /dev/xconsole\n}\n\nlog_begin_msg () {\n    echo -n $1\n}\n\nlog_end_msg () {\n    echo $1\n}\n\nlog_success_msg () {\n    echo $1\n}\n\nrunning()\n{\n    # No pidfile, probably no daemon present\n    #\n    if [ ! -f $pidfile ]\n    then\n\treturn 1\n    fi\n\n    pid=`cat $pidfile_syslogd`\n\n    # No pid, probably no daemon present\n    #\n    if [ -z \"$pid\" ]\n    then\n\treturn 1\n    fi\n\n    if [ ! -d /proc/$pid ]\n    then\n\treturn 1\n    fi\n\n    cmd=`cat /proc/$pid/cmdline | tr \"\\000\" \"\\n\"|head -n 1`\n\n    # No syslogd?\n    #\n    if [ \"$cmd\" != \"$binpath\" ]\n    then\n\treturn 1\n    fi\n\n    return 0\n}\n\ncase \"$1\" in\n  start)\n    log_begin_msg \"Starting system log daemon...\"\n    create_xconsole\n    start-stop-daemon --start --quiet --pidfile $pidfile_syslogd --name syslogd --startas $binpath_syslogd -- $SYSLOGD\n    log_end_msg $?\n    log_begin_msg \"Starting kernel log daemon...\"\n    start-stop-daemon --start --quiet --pidfile $pidfile_klogd --name klogd --startas $binpath_klogd -- $KLOGD\n    log_end_msg $?\n    ;;\n  stop)\n    log_begin_msg \"Stopping system log daemon...\"\n    start-stop-daemon --stop --quiet --pidfile $pidfile_syslogd --name syslogd\n    log_end_msg $?\n    log_begin_msg \"Stopping kernel log daemon...\"\n    start-stop-daemon --stop --quiet --retry 3 --exec $binpath_klogd --pidfile $pidfile_klogd\n    log_end_msg $?\n    ;;\n  reload|force-reload)\n    log_begin_msg \"Reloading system log daemon...\"\n    start-stop-daemon --stop --quiet --signal 1 --pidfile $pidfile_syslogd --name syslogd\n    log_end_msg $?\n    log_begin_msg \"Reloading kernel log daemon...\"\n    start-stop-daemon --stop --quiet --retry 3 --exec $binpath_klogd --pidfile $pidfile_klogd\n    start-stop-daemon --start --quiet --pidfile $pidfile_klogd --name klogd --startas $binpath_klogd -- $KLOGD\n    log_end_msg $?\n    ;;\n  restart)\n    log_begin_msg \"Restarting system log daemon...\"\n    start-stop-daemon --stop --retry 5 --quiet --pidfile $pidfile_syslogd --name syslogd\n    start-stop-daemon --start --quiet --pidfile $pidfile_syslogd --name syslogd --startas $binpath_syslogd -- $SYSLOGD\n    log_end_msg $?\n    log_begin_msg \"Reloading kernel log daemon...\"\n    start-stop-daemon --stop --quiet --retry 3 --exec $binpath_klogd --pidfile $pidfile_klogd\n    start-stop-daemon --start --quiet --pidfile $pidfile_klogd --name klogd --startas $binpath_klogd -- $KLOGD\n    log_end_msg $?\n    ;;\n  reload-or-restart)\n    if running\n    then\n\t$0 reload\n    else\n\t$0 start\n    fi\n    ;;\n  status)\n    status syslogd\n    RETVAL=$?\n    status klogd\n    rval=$?\n    [ $RETVAL -eq 0 ] && exit $rval\n    exit $RETVAL\n    ;;\n  *)\n    log_success_msg \"Usage: /etc/init.d/sysklogd {start|stop|reload|restart|force-reload|reload-or-restart|status}\"\n    exit 1\nesac\n\nexit 0\n```\n显而易见运行/sbin/syslogd和/sbin/klogd\n\n# linux系统日志简介\n\nLinux 日志系统是用于记录、存储和管理操作系统和应用程序的日志消息的机制和工具集合。日志是记录系统运行状态、事件、错误和其他相关信息的关键工具，对于故障排除、性能监控、安全审计和系统维护至关重要。以下是 Linux 日志系统的主要组成部分和概述：\n\n1. **syslog：** Syslog 是一个标准化的日志消息传输协议和系统，用于将系统和应用程序的日志消息发送到集中的日志服务器或存储位置。Syslog 能够将日志消息分类、过滤和转发，并支持不同的日志级别，如调试、信息、警告和错误。\n\n2. **日志消息级别：** Linux 日志消息通常分为几个不同的级别，例如：调试（debug）、信息（info）、警告（warning）、错误（error）和严重（critical）。这些级别帮助管理员快速了解日志的重要性。\n\n3. **日志位置：** 在 Linux 系统中，日志消息通常存储在 `/var/log` 目录下。不同的服务和应用程序可能会有自己的日志文件，例如 `/var/log/messages`、`/var/log/syslog`、`/var/log/auth.log` 等。\n\n4. **日志旋转：** 为了防止日志文件过大，Linux 系统通常使用日志旋转工具来定期归档、压缩或删除旧的日志文件，并创建新的日志文件。常见的日志旋转工具包括 `logrotate`。\n\n5. **日志分析工具：** Linux 提供了各种用于分析和查看日志的工具，例如 `grep` 用于搜索、`tail` 用于实时查看、`less` 用于分页查看等。此外，还有更高级的工具如 `journalctl` 用于查看 Systemd Journal 日志。\n\n6. **Systemd Journal：** Systemd 是现代 Linux 系统的初始化系统，它引入了 Systemd Journal，一个用于收集和管理系统日志的机制。`journalctl` 命令用于访问和查询 Systemd Journal 中的日志。\n\n7. **远程日志：** Linux 日志系统支持将日志消息发送到远程的日志服务器，以便集中存储和分析。这对于大规模系统和分布式环境非常有用。\n\n# 如何使用syslog和klog\n[syslog官网](https://en.wikipedia.org/wiki/Syslog)\n[klog官网](https://linux.die.net/man/8/klogd)\n","slug":"process-syslogd-klogd","published":1,"updated":"2024-01-05T08:12:19.809Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clru1g21z002qs4fuajeqh8sg","content":"<h1 id=\"syslog\"><a href=\"#syslog\" class=\"headerlink\" title=\"syslog\"></a>syslog</h1><p>“syslog” 是一个用于系统日志的标准化方法和系统，用于收集、存储和管理操作系统和应用程序的日志信息。在很多操作系统中，包括类Unix系统（如Linux），syslog是一个重要的组件，用于日志管理和故障排除。</p>\n<p>关于 “syslog 线程” 的具体用途，这可能会因上下文和特定系统的设置而有所不同。一般来说，”syslog 线程” 可能指的是一个在系统中运行的线程，专门用于处理和管理日志消息。以下是一些可能的用途：</p>\n<ol>\n<li><p><strong>日志收集和处理：</strong> “syslog 线程” 可能会收集来自不同应用程序、服务和系统组件的日志消息。它可以对这些消息进行处理、分类和过滤，以确保将有关系统状态、故障和事件的相关信息记录下来。</p>\n</li>\n<li><p><strong>日志存储：</strong> “syslog 线程” 可能会将日志消息存储到适当的位置，通常是日志文件。这些日志文件可能位于系统的标准位置，如 <code>/var/log</code> 目录下，或者根据系统管理员的配置而定。</p>\n</li>\n<li><p><strong>日志转发：</strong> “syslog 线程” 通常还能够将日志消息转发到远程的日志服务器，以便集中管理和分析。这在大规模系统中特别有用，可以将日志从多个服务器和设备中集中处理。</p>\n</li>\n<li><p><strong>日志分析和监控：</strong> “syslog 线程” 可能会涉及将日志消息传递给分析工具或监控系统，以便实时监视系统的健康状态、故障和异常情况。</p>\n</li>\n</ol>\n<p>总之，”syslog 线程” 在系统中起着重要作用，有助于捕获、管理和分析系统的日志信息，从而帮助管理员进行故障排除、安全监控和系统维护。</p>\n<h1 id=\"syslog源码\"><a href=\"#syslog源码\" class=\"headerlink\" title=\"syslog源码\"></a>syslog源码</h1><p>/etc/rc5.d/S20syslog -&gt; etc/init.d/syslog -&gt; /etc/init.d/syslog.sysklogd</p>\n<pre class=\" language-shell\"><code class=\"language-shell\">#! /bin/sh\n# /etc/init.d/sysklogd: start the system log daemon.\n\n### BEGIN INIT INFO\n# Provides:             sysklogd\n# Required-Start:       $remote_fs $time\n# Required-Stop:        $remote_fs $time\n# Should-Start:         $network\n# Should-Stop:          $network\n# Default-Start:        2 3 4 5\n# Default-Stop:         0 1 6\n# Short-Description:    System logger\n### END INIT INFO\n\n# Source function library.\n. /etc/init.d/functions\n\nPATH=/bin:/usr/bin:/sbin:/usr/sbin\n\npidfile_syslogd=/var/run/syslogd.pid\npidfile_klogd=/var/run/klogd.pid\nbinpath_syslogd=/sbin/syslogd\nbinpath_klogd=/sbin/klogd\n\ntest -x $binpath || exit 0\n\ntest ! -r /etc/default/syslogd || . /etc/default/syslogd\n\ncreate_xconsole()\n{\n    # Only proceed if /dev/xconsole is used at all\n    if ! grep -q '^[^#].*/dev/xconsole' /etc/syslog.conf\n    then\n    return\n    fi\n\n    if [ ! -e /dev/xconsole ]; then\n    mknod -m 640 /dev/xconsole p\n    else\n    chmod 0640 /dev/xconsole\n    fi\n    chown root:adm /dev/xconsole\n    test ! -x /sbin/restorecon || /sbin/restorecon /dev/xconsole\n}\n\nlog_begin_msg () {\n    echo -n $1\n}\n\nlog_end_msg () {\n    echo $1\n}\n\nlog_success_msg () {\n    echo $1\n}\n\nrunning()\n{\n    # No pidfile, probably no daemon present\n    #\n    if [ ! -f $pidfile ]\n    then\n    return 1\n    fi\n\n    pid=`cat $pidfile_syslogd`\n\n    # No pid, probably no daemon present\n    #\n    if [ -z \"$pid\" ]\n    then\n    return 1\n    fi\n\n    if [ ! -d /proc/$pid ]\n    then\n    return 1\n    fi\n\n    cmd=`cat /proc/$pid/cmdline | tr \"\\000\" \"\\n\"|head -n 1`\n\n    # No syslogd?\n    #\n    if [ \"$cmd\" != \"$binpath\" ]\n    then\n    return 1\n    fi\n\n    return 0\n}\n\ncase \"$1\" in\n  start)\n    log_begin_msg \"Starting system log daemon...\"\n    create_xconsole\n    start-stop-daemon --start --quiet --pidfile $pidfile_syslogd --name syslogd --startas $binpath_syslogd -- $SYSLOGD\n    log_end_msg $?\n    log_begin_msg \"Starting kernel log daemon...\"\n    start-stop-daemon --start --quiet --pidfile $pidfile_klogd --name klogd --startas $binpath_klogd -- $KLOGD\n    log_end_msg $?\n    ;;\n  stop)\n    log_begin_msg \"Stopping system log daemon...\"\n    start-stop-daemon --stop --quiet --pidfile $pidfile_syslogd --name syslogd\n    log_end_msg $?\n    log_begin_msg \"Stopping kernel log daemon...\"\n    start-stop-daemon --stop --quiet --retry 3 --exec $binpath_klogd --pidfile $pidfile_klogd\n    log_end_msg $?\n    ;;\n  reload|force-reload)\n    log_begin_msg \"Reloading system log daemon...\"\n    start-stop-daemon --stop --quiet --signal 1 --pidfile $pidfile_syslogd --name syslogd\n    log_end_msg $?\n    log_begin_msg \"Reloading kernel log daemon...\"\n    start-stop-daemon --stop --quiet --retry 3 --exec $binpath_klogd --pidfile $pidfile_klogd\n    start-stop-daemon --start --quiet --pidfile $pidfile_klogd --name klogd --startas $binpath_klogd -- $KLOGD\n    log_end_msg $?\n    ;;\n  restart)\n    log_begin_msg \"Restarting system log daemon...\"\n    start-stop-daemon --stop --retry 5 --quiet --pidfile $pidfile_syslogd --name syslogd\n    start-stop-daemon --start --quiet --pidfile $pidfile_syslogd --name syslogd --startas $binpath_syslogd -- $SYSLOGD\n    log_end_msg $?\n    log_begin_msg \"Reloading kernel log daemon...\"\n    start-stop-daemon --stop --quiet --retry 3 --exec $binpath_klogd --pidfile $pidfile_klogd\n    start-stop-daemon --start --quiet --pidfile $pidfile_klogd --name klogd --startas $binpath_klogd -- $KLOGD\n    log_end_msg $?\n    ;;\n  reload-or-restart)\n    if running\n    then\n    $0 reload\n    else\n    $0 start\n    fi\n    ;;\n  status)\n    status syslogd\n    RETVAL=$?\n    status klogd\n    rval=$?\n    [ $RETVAL -eq 0 ] && exit $rval\n    exit $RETVAL\n    ;;\n  *)\n    log_success_msg \"Usage: /etc/init.d/sysklogd {start|stop|reload|restart|force-reload|reload-or-restart|status}\"\n    exit 1\nesac\n\nexit 0</code></pre>\n<p>显而易见运行/sbin/syslogd和/sbin/klogd</p>\n<h1 id=\"linux系统日志简介\"><a href=\"#linux系统日志简介\" class=\"headerlink\" title=\"linux系统日志简介\"></a>linux系统日志简介</h1><p>Linux 日志系统是用于记录、存储和管理操作系统和应用程序的日志消息的机制和工具集合。日志是记录系统运行状态、事件、错误和其他相关信息的关键工具，对于故障排除、性能监控、安全审计和系统维护至关重要。以下是 Linux 日志系统的主要组成部分和概述：</p>\n<ol>\n<li><p><strong>syslog：</strong> Syslog 是一个标准化的日志消息传输协议和系统，用于将系统和应用程序的日志消息发送到集中的日志服务器或存储位置。Syslog 能够将日志消息分类、过滤和转发，并支持不同的日志级别，如调试、信息、警告和错误。</p>\n</li>\n<li><p><strong>日志消息级别：</strong> Linux 日志消息通常分为几个不同的级别，例如：调试（debug）、信息（info）、警告（warning）、错误（error）和严重（critical）。这些级别帮助管理员快速了解日志的重要性。</p>\n</li>\n<li><p><strong>日志位置：</strong> 在 Linux 系统中，日志消息通常存储在 <code>/var/log</code> 目录下。不同的服务和应用程序可能会有自己的日志文件，例如 <code>/var/log/messages</code>、<code>/var/log/syslog</code>、<code>/var/log/auth.log</code> 等。</p>\n</li>\n<li><p><strong>日志旋转：</strong> 为了防止日志文件过大，Linux 系统通常使用日志旋转工具来定期归档、压缩或删除旧的日志文件，并创建新的日志文件。常见的日志旋转工具包括 <code>logrotate</code>。</p>\n</li>\n<li><p><strong>日志分析工具：</strong> Linux 提供了各种用于分析和查看日志的工具，例如 <code>grep</code> 用于搜索、<code>tail</code> 用于实时查看、<code>less</code> 用于分页查看等。此外，还有更高级的工具如 <code>journalctl</code> 用于查看 Systemd Journal 日志。</p>\n</li>\n<li><p><strong>Systemd Journal：</strong> Systemd 是现代 Linux 系统的初始化系统，它引入了 Systemd Journal，一个用于收集和管理系统日志的机制。<code>journalctl</code> 命令用于访问和查询 Systemd Journal 中的日志。</p>\n</li>\n<li><p><strong>远程日志：</strong> Linux 日志系统支持将日志消息发送到远程的日志服务器，以便集中存储和分析。这对于大规模系统和分布式环境非常有用。</p>\n</li>\n</ol>\n<h1 id=\"如何使用syslog和klog\"><a href=\"#如何使用syslog和klog\" class=\"headerlink\" title=\"如何使用syslog和klog\"></a>如何使用syslog和klog</h1><p><a href=\"https://en.wikipedia.org/wiki/Syslog\" target=\"_blank\" rel=\"noopener\">syslog官网</a><br><a href=\"https://linux.die.net/man/8/klogd\" target=\"_blank\" rel=\"noopener\">klog官网</a></p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<h1 id=\"syslog\"><a href=\"#syslog\" class=\"headerlink\" title=\"syslog\"></a>syslog</h1><p>“syslog” 是一个用于系统日志的标准化方法和系统，用于收集、存储和管理操作系统和应用程序的日志信息。在很多操作系统中，包括类Unix系统（如Linux），syslog是一个重要的组件，用于日志管理和故障排除。</p>\n<p>关于 “syslog 线程” 的具体用途，这可能会因上下文和特定系统的设置而有所不同。一般来说，”syslog 线程” 可能指的是一个在系统中运行的线程，专门用于处理和管理日志消息。以下是一些可能的用途：</p>\n<ol>\n<li><p><strong>日志收集和处理：</strong> “syslog 线程” 可能会收集来自不同应用程序、服务和系统组件的日志消息。它可以对这些消息进行处理、分类和过滤，以确保将有关系统状态、故障和事件的相关信息记录下来。</p>\n</li>\n<li><p><strong>日志存储：</strong> “syslog 线程” 可能会将日志消息存储到适当的位置，通常是日志文件。这些日志文件可能位于系统的标准位置，如 <code>/var/log</code> 目录下，或者根据系统管理员的配置而定。</p>\n</li>\n<li><p><strong>日志转发：</strong> “syslog 线程” 通常还能够将日志消息转发到远程的日志服务器，以便集中管理和分析。这在大规模系统中特别有用，可以将日志从多个服务器和设备中集中处理。</p>\n</li>\n<li><p><strong>日志分析和监控：</strong> “syslog 线程” 可能会涉及将日志消息传递给分析工具或监控系统，以便实时监视系统的健康状态、故障和异常情况。</p>\n</li>\n</ol>\n<p>总之，”syslog 线程” 在系统中起着重要作用，有助于捕获、管理和分析系统的日志信息，从而帮助管理员进行故障排除、安全监控和系统维护。</p>\n<h1 id=\"syslog源码\"><a href=\"#syslog源码\" class=\"headerlink\" title=\"syslog源码\"></a>syslog源码</h1><p>/etc/rc5.d/S20syslog -&gt; etc/init.d/syslog -&gt; /etc/init.d/syslog.sysklogd</p>\n<pre><code class=\"shell\">#! /bin/sh\n# /etc/init.d/sysklogd: start the system log daemon.\n\n### BEGIN INIT INFO\n# Provides:             sysklogd\n# Required-Start:       $remote_fs $time\n# Required-Stop:        $remote_fs $time\n# Should-Start:         $network\n# Should-Stop:          $network\n# Default-Start:        2 3 4 5\n# Default-Stop:         0 1 6\n# Short-Description:    System logger\n### END INIT INFO\n\n# Source function library.\n. /etc/init.d/functions\n\nPATH=/bin:/usr/bin:/sbin:/usr/sbin\n\npidfile_syslogd=/var/run/syslogd.pid\npidfile_klogd=/var/run/klogd.pid\nbinpath_syslogd=/sbin/syslogd\nbinpath_klogd=/sbin/klogd\n\ntest -x $binpath || exit 0\n\ntest ! -r /etc/default/syslogd || . /etc/default/syslogd\n\ncreate_xconsole()\n{\n    # Only proceed if /dev/xconsole is used at all\n    if ! grep -q &#39;^[^#].*/dev/xconsole&#39; /etc/syslog.conf\n    then\n    return\n    fi\n\n    if [ ! -e /dev/xconsole ]; then\n    mknod -m 640 /dev/xconsole p\n    else\n    chmod 0640 /dev/xconsole\n    fi\n    chown root:adm /dev/xconsole\n    test ! -x /sbin/restorecon || /sbin/restorecon /dev/xconsole\n}\n\nlog_begin_msg () {\n    echo -n $1\n}\n\nlog_end_msg () {\n    echo $1\n}\n\nlog_success_msg () {\n    echo $1\n}\n\nrunning()\n{\n    # No pidfile, probably no daemon present\n    #\n    if [ ! -f $pidfile ]\n    then\n    return 1\n    fi\n\n    pid=`cat $pidfile_syslogd`\n\n    # No pid, probably no daemon present\n    #\n    if [ -z &quot;$pid&quot; ]\n    then\n    return 1\n    fi\n\n    if [ ! -d /proc/$pid ]\n    then\n    return 1\n    fi\n\n    cmd=`cat /proc/$pid/cmdline | tr &quot;\\000&quot; &quot;\\n&quot;|head -n 1`\n\n    # No syslogd?\n    #\n    if [ &quot;$cmd&quot; != &quot;$binpath&quot; ]\n    then\n    return 1\n    fi\n\n    return 0\n}\n\ncase &quot;$1&quot; in\n  start)\n    log_begin_msg &quot;Starting system log daemon...&quot;\n    create_xconsole\n    start-stop-daemon --start --quiet --pidfile $pidfile_syslogd --name syslogd --startas $binpath_syslogd -- $SYSLOGD\n    log_end_msg $?\n    log_begin_msg &quot;Starting kernel log daemon...&quot;\n    start-stop-daemon --start --quiet --pidfile $pidfile_klogd --name klogd --startas $binpath_klogd -- $KLOGD\n    log_end_msg $?\n    ;;\n  stop)\n    log_begin_msg &quot;Stopping system log daemon...&quot;\n    start-stop-daemon --stop --quiet --pidfile $pidfile_syslogd --name syslogd\n    log_end_msg $?\n    log_begin_msg &quot;Stopping kernel log daemon...&quot;\n    start-stop-daemon --stop --quiet --retry 3 --exec $binpath_klogd --pidfile $pidfile_klogd\n    log_end_msg $?\n    ;;\n  reload|force-reload)\n    log_begin_msg &quot;Reloading system log daemon...&quot;\n    start-stop-daemon --stop --quiet --signal 1 --pidfile $pidfile_syslogd --name syslogd\n    log_end_msg $?\n    log_begin_msg &quot;Reloading kernel log daemon...&quot;\n    start-stop-daemon --stop --quiet --retry 3 --exec $binpath_klogd --pidfile $pidfile_klogd\n    start-stop-daemon --start --quiet --pidfile $pidfile_klogd --name klogd --startas $binpath_klogd -- $KLOGD\n    log_end_msg $?\n    ;;\n  restart)\n    log_begin_msg &quot;Restarting system log daemon...&quot;\n    start-stop-daemon --stop --retry 5 --quiet --pidfile $pidfile_syslogd --name syslogd\n    start-stop-daemon --start --quiet --pidfile $pidfile_syslogd --name syslogd --startas $binpath_syslogd -- $SYSLOGD\n    log_end_msg $?\n    log_begin_msg &quot;Reloading kernel log daemon...&quot;\n    start-stop-daemon --stop --quiet --retry 3 --exec $binpath_klogd --pidfile $pidfile_klogd\n    start-stop-daemon --start --quiet --pidfile $pidfile_klogd --name klogd --startas $binpath_klogd -- $KLOGD\n    log_end_msg $?\n    ;;\n  reload-or-restart)\n    if running\n    then\n    $0 reload\n    else\n    $0 start\n    fi\n    ;;\n  status)\n    status syslogd\n    RETVAL=$?\n    status klogd\n    rval=$?\n    [ $RETVAL -eq 0 ] &amp;&amp; exit $rval\n    exit $RETVAL\n    ;;\n  *)\n    log_success_msg &quot;Usage: /etc/init.d/sysklogd {start|stop|reload|restart|force-reload|reload-or-restart|status}&quot;\n    exit 1\nesac\n\nexit 0</code></pre>\n<p>显而易见运行/sbin/syslogd和/sbin/klogd</p>\n<h1 id=\"linux系统日志简介\"><a href=\"#linux系统日志简介\" class=\"headerlink\" title=\"linux系统日志简介\"></a>linux系统日志简介</h1><p>Linux 日志系统是用于记录、存储和管理操作系统和应用程序的日志消息的机制和工具集合。日志是记录系统运行状态、事件、错误和其他相关信息的关键工具，对于故障排除、性能监控、安全审计和系统维护至关重要。以下是 Linux 日志系统的主要组成部分和概述：</p>\n<ol>\n<li><p><strong>syslog：</strong> Syslog 是一个标准化的日志消息传输协议和系统，用于将系统和应用程序的日志消息发送到集中的日志服务器或存储位置。Syslog 能够将日志消息分类、过滤和转发，并支持不同的日志级别，如调试、信息、警告和错误。</p>\n</li>\n<li><p><strong>日志消息级别：</strong> Linux 日志消息通常分为几个不同的级别，例如：调试（debug）、信息（info）、警告（warning）、错误（error）和严重（critical）。这些级别帮助管理员快速了解日志的重要性。</p>\n</li>\n<li><p><strong>日志位置：</strong> 在 Linux 系统中，日志消息通常存储在 <code>/var/log</code> 目录下。不同的服务和应用程序可能会有自己的日志文件，例如 <code>/var/log/messages</code>、<code>/var/log/syslog</code>、<code>/var/log/auth.log</code> 等。</p>\n</li>\n<li><p><strong>日志旋转：</strong> 为了防止日志文件过大，Linux 系统通常使用日志旋转工具来定期归档、压缩或删除旧的日志文件，并创建新的日志文件。常见的日志旋转工具包括 <code>logrotate</code>。</p>\n</li>\n<li><p><strong>日志分析工具：</strong> Linux 提供了各种用于分析和查看日志的工具，例如 <code>grep</code> 用于搜索、<code>tail</code> 用于实时查看、<code>less</code> 用于分页查看等。此外，还有更高级的工具如 <code>journalctl</code> 用于查看 Systemd Journal 日志。</p>\n</li>\n<li><p><strong>Systemd Journal：</strong> Systemd 是现代 Linux 系统的初始化系统，它引入了 Systemd Journal，一个用于收集和管理系统日志的机制。<code>journalctl</code> 命令用于访问和查询 Systemd Journal 中的日志。</p>\n</li>\n<li><p><strong>远程日志：</strong> Linux 日志系统支持将日志消息发送到远程的日志服务器，以便集中存储和分析。这对于大规模系统和分布式环境非常有用。</p>\n</li>\n</ol>\n<h1 id=\"如何使用syslog和klog\"><a href=\"#如何使用syslog和klog\" class=\"headerlink\" title=\"如何使用syslog和klog\"></a>如何使用syslog和klog</h1><p><a href=\"https://en.wikipedia.org/wiki/Syslog\" target=\"_blank\" rel=\"noopener\">syslog官网</a><br><a href=\"https://linux.die.net/man/8/klogd\" target=\"_blank\" rel=\"noopener\">klog官网</a></p>\n"},{"title":"process-kthreadd","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-08-25T00:51:44.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"\n# kthread进程\n`kthread` 是 Linux 内核中的一种线程类型，它用于执行内核空间的工作。这些线程通常用于处理一些需要在内核中运行的任务，而不会阻塞整个系统。以下是一些 `kthread` 线程的主要用途：\n\n1. **后台工作：** `kthread` 线程通常用于执行与系统管理和维护相关的后台任务。例如，定期执行清理操作、处理未完成的任务、回收资源等。\n\n2. **异步处理：** 内核中的一些操作可能需要在后台执行，而不阻塞主要执行路径。使用 `kthread` 可以在后台进行这些操作，以确保主要执行路径的响应性。\n\n3. **延迟操作：** 某些操作可能需要在某些条件满足后才能执行，例如在资源可用时才进行操作。`kthread` 可以用于定期检查这些条件，并在满足时执行操作。\n\n4. **并发处理：** 内核可能需要同时执行多个任务，例如处理多个网络连接或设备请求。使用 `kthread` 可以实现这种并发处理。\n\n5. **设备驱动程序：** 设备驱动程序可能需要在后台执行某些操作，如处理中断、清理资源、维护设备状态等。\n\n6. **事件通知：** `kthread` 线程可以用于监听特定事件，一旦事件发生，线程可以处理相应的操作。\n\n总之，`kthread` 线程在内核中为开发者提供了一种执行后台任务、异步操作、并发处理等操作的方式，同时不会阻塞整个系统。这对于确保系统的响应性、资源管理和后台任务的执行非常有用。\n\n# kthread源码\n```c\n\nstatic noinline void __init_refok rest_init(void)\n{\n\tint pid;\n\n\trcu_scheduler_starting();\n\tsmpboot_thread_init();\n\t/*\n\t * We need to spawn init first so that it obtains pid 1, however\n\t * the init task will end up wanting to create kthreads, which, if\n\t * we schedule it before we create kthreadd, will OOPS.\n\t */\n\tkernel_thread(kernel_init, NULL, CLONE_FS);\n\tnuma_default_policy();\n\tpid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES);\n\trcu_read_lock();\n\tkthreadd_task = find_task_by_pid_ns(pid, &init_pid_ns);\n\trcu_read_unlock();\n\tcomplete(&kthreadd_done);\n\n\t/*\n\t * The boot idle thread must execute schedule()\n\t * at least once to get things moving:\n\t */\n\tinit_idle_bootup_task(current);\n\tschedule_preempt_disabled();\n\t/* Call into cpu_idle with preempt disabled */\n\tcpu_startup_entry(CPUHP_ONLINE);\n}\n```\n\n```c\n/**\n * kthreadd - 内核线程创建和管理函数\n * @unused: 未使用的指针（内核线程函数签名所需）\n *\n * 此函数作为内核线程创建和管理的入口点。\n * 它负责为子线程设置干净的上下文以继承，管理其调度，并根据需要创建新的内核线程。\n */\nint kthreadd(void *unused)\n{\n    struct task_struct *tsk = current;\n\n    /* 为子线程设置一个干净的上下文。 */\n    set_task_comm(tsk, \"kthreadd\");  // 设置线程的名称为 \"kthreadd\"\n    ignore_signals(tsk);  // 忽略信号，确保线程不受外部信号的干扰\n    set_cpus_allowed_ptr(tsk, cpu_all_mask);  // 允许线程在所有 CPU 上运行\n    set_mems_allowed(node_states[N_MEMORY]);  // 允许线程在特定内存节点上运行\n\n    current->flags |= PF_NOFREEZE;  // 设置标志，防止线程被冻结（挂起）\n\n    for (;;) {  // 无限循环，管理线程的创建和调度\n        set_current_state(TASK_INTERRUPTIBLE);  // 将线程状态设置为可中断睡眠状态\n        \n        /* 如果 kthread 创建请求列表为空，则等待事件。 */\n        if (list_empty(&kthread_create_list))\n            schedule();  // 调度其他任务，等待新的线程创建请求\n        \n        __set_current_state(TASK_RUNNING);  // 将线程状态设置回运行状态\n\n        spin_lock(&kthread_create_lock);  // 获取 kthread 创建请求列表的自旋锁\n        \n        /* 处理待处理的 kthread 创建请求 */\n        while (!list_empty(&kthread_create_list)) {\n            struct kthread_create_info *create;\n\n            /* 获取下一个待处理的 kthread 创建请求 */\n            create = list_entry(kthread_create_list.next,\n                                struct kthread_create_info, list);\n            list_del_init(&create->list);  // 从列表中移除该请求并初始化其链接\n            \n            spin_unlock(&kthread_create_lock);  // 解锁，允许其他线程访问创建请求列表\n\n            /* 根据请求创建并初始化新的 kthread */\n            create_kthread(create);\n\n            spin_lock(&kthread_create_lock);  // 获取锁，以处理下一个创建请求\n        }\n        spin_unlock(&kthread_create_lock);  // 解锁 kthread 创建请求列表\n        \n        // 回到循环的开头，继续等待和处理线程创建请求\n    }\n\n    return 0;  // 实际上永远不会到达这里，因为此循环会无限运行\n}\n```\n这个函数主要干两件事：\n    1：schedule();调度线程\n    2：create_kthread(create);根据kthread_create_list创建新的线程\n\n","source":"_posts/2023/08/process-kthreadd.md","raw":"---\ntitle: process-kthreadd\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-08-25 08:51:44\npassword:\nsummary:\ntags:\n- linux\n- process\ncategories:\n- process\n- linux\nkeywords:\ndescription:\n---\n\n# kthread进程\n`kthread` 是 Linux 内核中的一种线程类型，它用于执行内核空间的工作。这些线程通常用于处理一些需要在内核中运行的任务，而不会阻塞整个系统。以下是一些 `kthread` 线程的主要用途：\n\n1. **后台工作：** `kthread` 线程通常用于执行与系统管理和维护相关的后台任务。例如，定期执行清理操作、处理未完成的任务、回收资源等。\n\n2. **异步处理：** 内核中的一些操作可能需要在后台执行，而不阻塞主要执行路径。使用 `kthread` 可以在后台进行这些操作，以确保主要执行路径的响应性。\n\n3. **延迟操作：** 某些操作可能需要在某些条件满足后才能执行，例如在资源可用时才进行操作。`kthread` 可以用于定期检查这些条件，并在满足时执行操作。\n\n4. **并发处理：** 内核可能需要同时执行多个任务，例如处理多个网络连接或设备请求。使用 `kthread` 可以实现这种并发处理。\n\n5. **设备驱动程序：** 设备驱动程序可能需要在后台执行某些操作，如处理中断、清理资源、维护设备状态等。\n\n6. **事件通知：** `kthread` 线程可以用于监听特定事件，一旦事件发生，线程可以处理相应的操作。\n\n总之，`kthread` 线程在内核中为开发者提供了一种执行后台任务、异步操作、并发处理等操作的方式，同时不会阻塞整个系统。这对于确保系统的响应性、资源管理和后台任务的执行非常有用。\n\n# kthread源码\n```c\n\nstatic noinline void __init_refok rest_init(void)\n{\n\tint pid;\n\n\trcu_scheduler_starting();\n\tsmpboot_thread_init();\n\t/*\n\t * We need to spawn init first so that it obtains pid 1, however\n\t * the init task will end up wanting to create kthreads, which, if\n\t * we schedule it before we create kthreadd, will OOPS.\n\t */\n\tkernel_thread(kernel_init, NULL, CLONE_FS);\n\tnuma_default_policy();\n\tpid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES);\n\trcu_read_lock();\n\tkthreadd_task = find_task_by_pid_ns(pid, &init_pid_ns);\n\trcu_read_unlock();\n\tcomplete(&kthreadd_done);\n\n\t/*\n\t * The boot idle thread must execute schedule()\n\t * at least once to get things moving:\n\t */\n\tinit_idle_bootup_task(current);\n\tschedule_preempt_disabled();\n\t/* Call into cpu_idle with preempt disabled */\n\tcpu_startup_entry(CPUHP_ONLINE);\n}\n```\n\n```c\n/**\n * kthreadd - 内核线程创建和管理函数\n * @unused: 未使用的指针（内核线程函数签名所需）\n *\n * 此函数作为内核线程创建和管理的入口点。\n * 它负责为子线程设置干净的上下文以继承，管理其调度，并根据需要创建新的内核线程。\n */\nint kthreadd(void *unused)\n{\n    struct task_struct *tsk = current;\n\n    /* 为子线程设置一个干净的上下文。 */\n    set_task_comm(tsk, \"kthreadd\");  // 设置线程的名称为 \"kthreadd\"\n    ignore_signals(tsk);  // 忽略信号，确保线程不受外部信号的干扰\n    set_cpus_allowed_ptr(tsk, cpu_all_mask);  // 允许线程在所有 CPU 上运行\n    set_mems_allowed(node_states[N_MEMORY]);  // 允许线程在特定内存节点上运行\n\n    current->flags |= PF_NOFREEZE;  // 设置标志，防止线程被冻结（挂起）\n\n    for (;;) {  // 无限循环，管理线程的创建和调度\n        set_current_state(TASK_INTERRUPTIBLE);  // 将线程状态设置为可中断睡眠状态\n        \n        /* 如果 kthread 创建请求列表为空，则等待事件。 */\n        if (list_empty(&kthread_create_list))\n            schedule();  // 调度其他任务，等待新的线程创建请求\n        \n        __set_current_state(TASK_RUNNING);  // 将线程状态设置回运行状态\n\n        spin_lock(&kthread_create_lock);  // 获取 kthread 创建请求列表的自旋锁\n        \n        /* 处理待处理的 kthread 创建请求 */\n        while (!list_empty(&kthread_create_list)) {\n            struct kthread_create_info *create;\n\n            /* 获取下一个待处理的 kthread 创建请求 */\n            create = list_entry(kthread_create_list.next,\n                                struct kthread_create_info, list);\n            list_del_init(&create->list);  // 从列表中移除该请求并初始化其链接\n            \n            spin_unlock(&kthread_create_lock);  // 解锁，允许其他线程访问创建请求列表\n\n            /* 根据请求创建并初始化新的 kthread */\n            create_kthread(create);\n\n            spin_lock(&kthread_create_lock);  // 获取锁，以处理下一个创建请求\n        }\n        spin_unlock(&kthread_create_lock);  // 解锁 kthread 创建请求列表\n        \n        // 回到循环的开头，继续等待和处理线程创建请求\n    }\n\n    return 0;  // 实际上永远不会到达这里，因为此循环会无限运行\n}\n```\n这个函数主要干两件事：\n    1：schedule();调度线程\n    2：create_kthread(create);根据kthread_create_list创建新的线程\n\n","slug":"process-kthreadd","published":1,"updated":"2024-01-05T08:12:19.808Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clru1g220002us4fu627r0x4y","content":"<h1 id=\"kthread进程\"><a href=\"#kthread进程\" class=\"headerlink\" title=\"kthread进程\"></a>kthread进程</h1><p><code>kthread</code> 是 Linux 内核中的一种线程类型，它用于执行内核空间的工作。这些线程通常用于处理一些需要在内核中运行的任务，而不会阻塞整个系统。以下是一些 <code>kthread</code> 线程的主要用途：</p>\n<ol>\n<li><p><strong>后台工作：</strong> <code>kthread</code> 线程通常用于执行与系统管理和维护相关的后台任务。例如，定期执行清理操作、处理未完成的任务、回收资源等。</p>\n</li>\n<li><p><strong>异步处理：</strong> 内核中的一些操作可能需要在后台执行，而不阻塞主要执行路径。使用 <code>kthread</code> 可以在后台进行这些操作，以确保主要执行路径的响应性。</p>\n</li>\n<li><p><strong>延迟操作：</strong> 某些操作可能需要在某些条件满足后才能执行，例如在资源可用时才进行操作。<code>kthread</code> 可以用于定期检查这些条件，并在满足时执行操作。</p>\n</li>\n<li><p><strong>并发处理：</strong> 内核可能需要同时执行多个任务，例如处理多个网络连接或设备请求。使用 <code>kthread</code> 可以实现这种并发处理。</p>\n</li>\n<li><p><strong>设备驱动程序：</strong> 设备驱动程序可能需要在后台执行某些操作，如处理中断、清理资源、维护设备状态等。</p>\n</li>\n<li><p><strong>事件通知：</strong> <code>kthread</code> 线程可以用于监听特定事件，一旦事件发生，线程可以处理相应的操作。</p>\n</li>\n</ol>\n<p>总之，<code>kthread</code> 线程在内核中为开发者提供了一种执行后台任务、异步操作、并发处理等操作的方式，同时不会阻塞整个系统。这对于确保系统的响应性、资源管理和后台任务的执行非常有用。</p>\n<h1 id=\"kthread源码\"><a href=\"#kthread源码\" class=\"headerlink\" title=\"kthread源码\"></a>kthread源码</h1><pre class=\" language-c\"><code class=\"language-c\">\n<span class=\"token keyword\">static</span> noinline <span class=\"token keyword\">void</span> __init_refok <span class=\"token function\">rest_init</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> pid<span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">rcu_scheduler_starting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">smpboot_thread_init</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">/*\n     * We need to spawn init first so that it obtains pid 1, however\n     * the init task will end up wanting to create kthreads, which, if\n     * we schedule it before we create kthreadd, will OOPS.\n     */</span>\n    <span class=\"token function\">kernel_thread</span><span class=\"token punctuation\">(</span>kernel_init<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> CLONE_FS<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">numa_default_policy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    pid <span class=\"token operator\">=</span> <span class=\"token function\">kernel_thread</span><span class=\"token punctuation\">(</span>kthreadd<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> CLONE_FS <span class=\"token operator\">|</span> CLONE_FILES<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">rcu_read_lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    kthreadd_task <span class=\"token operator\">=</span> <span class=\"token function\">find_task_by_pid_ns</span><span class=\"token punctuation\">(</span>pid<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>init_pid_ns<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">rcu_read_unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">complete</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>kthreadd_done<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/*\n     * The boot idle thread must execute schedule()\n     * at least once to get things moving:\n     */</span>\n    <span class=\"token function\">init_idle_bootup_task</span><span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">schedule_preempt_disabled</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">/* Call into cpu_idle with preempt disabled */</span>\n    <span class=\"token function\">cpu_startup_entry</span><span class=\"token punctuation\">(</span>CPUHP_ONLINE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token comment\" spellcheck=\"true\">/**\n * kthreadd - 内核线程创建和管理函数\n * @unused: 未使用的指针（内核线程函数签名所需）\n *\n * 此函数作为内核线程创建和管理的入口点。\n * 它负责为子线程设置干净的上下文以继承，管理其调度，并根据需要创建新的内核线程。\n */</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">kthreadd</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>unused<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">struct</span> task_struct <span class=\"token operator\">*</span>tsk <span class=\"token operator\">=</span> current<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/* 为子线程设置一个干净的上下文。 */</span>\n    <span class=\"token function\">set_task_comm</span><span class=\"token punctuation\">(</span>tsk<span class=\"token punctuation\">,</span> <span class=\"token string\">\"kthreadd\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 设置线程的名称为 \"kthreadd\"</span>\n    <span class=\"token function\">ignore_signals</span><span class=\"token punctuation\">(</span>tsk<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 忽略信号，确保线程不受外部信号的干扰</span>\n    <span class=\"token function\">set_cpus_allowed_ptr</span><span class=\"token punctuation\">(</span>tsk<span class=\"token punctuation\">,</span> cpu_all_mask<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 允许线程在所有 CPU 上运行</span>\n    <span class=\"token function\">set_mems_allowed</span><span class=\"token punctuation\">(</span>node_states<span class=\"token punctuation\">[</span>N_MEMORY<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 允许线程在特定内存节点上运行</span>\n\n    current<span class=\"token operator\">-></span>flags <span class=\"token operator\">|</span><span class=\"token operator\">=</span> PF_NOFREEZE<span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 设置标志，防止线程被冻结（挂起）</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  <span class=\"token comment\" spellcheck=\"true\">// 无限循环，管理线程的创建和调度</span>\n        <span class=\"token function\">set_current_state</span><span class=\"token punctuation\">(</span>TASK_INTERRUPTIBLE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 将线程状态设置为可中断睡眠状态</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">/* 如果 kthread 创建请求列表为空，则等待事件。 */</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">list_empty</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>kthread_create_list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token function\">schedule</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 调度其他任务，等待新的线程创建请求</span>\n\n        <span class=\"token function\">__set_current_state</span><span class=\"token punctuation\">(</span>TASK_RUNNING<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 将线程状态设置回运行状态</span>\n\n        <span class=\"token function\">spin_lock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>kthread_create_lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 获取 kthread 创建请求列表的自旋锁</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">/* 处理待处理的 kthread 创建请求 */</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">list_empty</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>kthread_create_list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">struct</span> kthread_create_info <span class=\"token operator\">*</span>create<span class=\"token punctuation\">;</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">/* 获取下一个待处理的 kthread 创建请求 */</span>\n            create <span class=\"token operator\">=</span> <span class=\"token function\">list_entry</span><span class=\"token punctuation\">(</span>kthread_create_list<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">,</span>\n                                <span class=\"token keyword\">struct</span> kthread_create_info<span class=\"token punctuation\">,</span> list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">list_del_init</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>create<span class=\"token operator\">-></span>list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 从列表中移除该请求并初始化其链接</span>\n\n            <span class=\"token function\">spin_unlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>kthread_create_lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 解锁，允许其他线程访问创建请求列表</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">/* 根据请求创建并初始化新的 kthread */</span>\n            <span class=\"token function\">create_kthread</span><span class=\"token punctuation\">(</span>create<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token function\">spin_lock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>kthread_create_lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 获取锁，以处理下一个创建请求</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token function\">spin_unlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>kthread_create_lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 解锁 kthread 创建请求列表</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 回到循环的开头，继续等待和处理线程创建请求</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 实际上永远不会到达这里，因为此循环会无限运行</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>这个函数主要干两件事：<br>    1：schedule();调度线程<br>    2：create_kthread(create);根据kthread_create_list创建新的线程</p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<h1 id=\"kthread进程\"><a href=\"#kthread进程\" class=\"headerlink\" title=\"kthread进程\"></a>kthread进程</h1><p><code>kthread</code> 是 Linux 内核中的一种线程类型，它用于执行内核空间的工作。这些线程通常用于处理一些需要在内核中运行的任务，而不会阻塞整个系统。以下是一些 <code>kthread</code> 线程的主要用途：</p>\n<ol>\n<li><p><strong>后台工作：</strong> <code>kthread</code> 线程通常用于执行与系统管理和维护相关的后台任务。例如，定期执行清理操作、处理未完成的任务、回收资源等。</p>\n</li>\n<li><p><strong>异步处理：</strong> 内核中的一些操作可能需要在后台执行，而不阻塞主要执行路径。使用 <code>kthread</code> 可以在后台进行这些操作，以确保主要执行路径的响应性。</p>\n</li>\n<li><p><strong>延迟操作：</strong> 某些操作可能需要在某些条件满足后才能执行，例如在资源可用时才进行操作。<code>kthread</code> 可以用于定期检查这些条件，并在满足时执行操作。</p>\n</li>\n<li><p><strong>并发处理：</strong> 内核可能需要同时执行多个任务，例如处理多个网络连接或设备请求。使用 <code>kthread</code> 可以实现这种并发处理。</p>\n</li>\n<li><p><strong>设备驱动程序：</strong> 设备驱动程序可能需要在后台执行某些操作，如处理中断、清理资源、维护设备状态等。</p>\n</li>\n<li><p><strong>事件通知：</strong> <code>kthread</code> 线程可以用于监听特定事件，一旦事件发生，线程可以处理相应的操作。</p>\n</li>\n</ol>\n<p>总之，<code>kthread</code> 线程在内核中为开发者提供了一种执行后台任务、异步操作、并发处理等操作的方式，同时不会阻塞整个系统。这对于确保系统的响应性、资源管理和后台任务的执行非常有用。</p>\n<h1 id=\"kthread源码\"><a href=\"#kthread源码\" class=\"headerlink\" title=\"kthread源码\"></a>kthread源码</h1><pre><code class=\"c\">\nstatic noinline void __init_refok rest_init(void)\n{\n    int pid;\n\n    rcu_scheduler_starting();\n    smpboot_thread_init();\n    /*\n     * We need to spawn init first so that it obtains pid 1, however\n     * the init task will end up wanting to create kthreads, which, if\n     * we schedule it before we create kthreadd, will OOPS.\n     */\n    kernel_thread(kernel_init, NULL, CLONE_FS);\n    numa_default_policy();\n    pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES);\n    rcu_read_lock();\n    kthreadd_task = find_task_by_pid_ns(pid, &amp;init_pid_ns);\n    rcu_read_unlock();\n    complete(&amp;kthreadd_done);\n\n    /*\n     * The boot idle thread must execute schedule()\n     * at least once to get things moving:\n     */\n    init_idle_bootup_task(current);\n    schedule_preempt_disabled();\n    /* Call into cpu_idle with preempt disabled */\n    cpu_startup_entry(CPUHP_ONLINE);\n}</code></pre>\n<pre><code class=\"c\">/**\n * kthreadd - 内核线程创建和管理函数\n * @unused: 未使用的指针（内核线程函数签名所需）\n *\n * 此函数作为内核线程创建和管理的入口点。\n * 它负责为子线程设置干净的上下文以继承，管理其调度，并根据需要创建新的内核线程。\n */\nint kthreadd(void *unused)\n{\n    struct task_struct *tsk = current;\n\n    /* 为子线程设置一个干净的上下文。 */\n    set_task_comm(tsk, &quot;kthreadd&quot;);  // 设置线程的名称为 &quot;kthreadd&quot;\n    ignore_signals(tsk);  // 忽略信号，确保线程不受外部信号的干扰\n    set_cpus_allowed_ptr(tsk, cpu_all_mask);  // 允许线程在所有 CPU 上运行\n    set_mems_allowed(node_states[N_MEMORY]);  // 允许线程在特定内存节点上运行\n\n    current-&gt;flags |= PF_NOFREEZE;  // 设置标志，防止线程被冻结（挂起）\n\n    for (;;) {  // 无限循环，管理线程的创建和调度\n        set_current_state(TASK_INTERRUPTIBLE);  // 将线程状态设置为可中断睡眠状态\n\n        /* 如果 kthread 创建请求列表为空，则等待事件。 */\n        if (list_empty(&amp;kthread_create_list))\n            schedule();  // 调度其他任务，等待新的线程创建请求\n\n        __set_current_state(TASK_RUNNING);  // 将线程状态设置回运行状态\n\n        spin_lock(&amp;kthread_create_lock);  // 获取 kthread 创建请求列表的自旋锁\n\n        /* 处理待处理的 kthread 创建请求 */\n        while (!list_empty(&amp;kthread_create_list)) {\n            struct kthread_create_info *create;\n\n            /* 获取下一个待处理的 kthread 创建请求 */\n            create = list_entry(kthread_create_list.next,\n                                struct kthread_create_info, list);\n            list_del_init(&amp;create-&gt;list);  // 从列表中移除该请求并初始化其链接\n\n            spin_unlock(&amp;kthread_create_lock);  // 解锁，允许其他线程访问创建请求列表\n\n            /* 根据请求创建并初始化新的 kthread */\n            create_kthread(create);\n\n            spin_lock(&amp;kthread_create_lock);  // 获取锁，以处理下一个创建请求\n        }\n        spin_unlock(&amp;kthread_create_lock);  // 解锁 kthread 创建请求列表\n\n        // 回到循环的开头，继续等待和处理线程创建请求\n    }\n\n    return 0;  // 实际上永远不会到达这里，因为此循环会无限运行\n}</code></pre>\n<p>这个函数主要干两件事：<br>    1：schedule();调度线程<br>    2：create_kthread(create);根据kthread_create_list创建新的线程</p>\n"},{"title":"process-watchdog","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-08-31T07:19:48.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"\n# watchdog作用\n看门狗（Watchdog）是一种硬件或软件机制，旨在监视计算机系统或设备的运行状态，并在系统出现故障、死锁或异常情况时采取措施以防止系统长时间无响应或停滞。看门狗在嵌入式系统、服务器、网络设备等各种场景中都有广泛应用。\n\n看门狗的主要作用包括：\n\n1. **保证系统稳定性和可用性：** 看门狗能够监视系统的运行状态。如果系统在一段时间内没有及时响应看门狗的喂狗操作，看门狗会触发特定的操作，如系统重启或其他预定义的操作，以恢复系统的稳定性和可用性。\n\n2. **防止死锁和异常状态：** 死锁是指系统中的进程或资源无法继续执行或释放，导致系统无法正常运行。看门狗能够监控这种异常情况，并在死锁发生时进行干预，防止系统长时间无响应。\n\n3. **检测程序错误：** 看门狗还可以用于检测程序错误，比如内存泄漏、异常崩溃等。如果程序出现了无法处理的错误，可能无法执行喂狗操作，从而触发看门狗超时操作。\n\n4. **恢复系统正常状态：** 当系统出现异常情况时，看门狗可以自动采取措施，如重启系统或执行预定的恢复操作，以使系统重新进入正常状态。\n\n5. **预防设备故障：** 在一些嵌入式系统中，看门狗还可以监控硬件设备的状态。如果硬件设备发生故障或停滞，看门狗可以采取措施避免系统长时间受到影响。\n\n总之，看门狗是一种用于提高系统稳定性、可靠性和可用性的重要机制。它能够在系统遇到异常情况时自动采取措施，保障系统能够快速恢复正常运行。\n\n# watchdog源码\n设备树节点:\n```c\n   wdog1: wdog@020bc000 {\n    compatible = \"fsl,imx6ul-wdt\", \"fsl,imx21-wdt\";\n    reg = <0x020bc000 0x4000>;\n    interrupts = <0 80 4>;\n    clocks = <&clks 208>;\n   };\n\n   wdog2: wdog@020c0000 {\n    compatible = \"fsl,imx6ul-wdt\", \"fsl,imx21-wdt\";\n    reg = <0x020c0000 0x4000>;\n    interrupts = <0 81 4>;\n    clocks = <&clks 209>;\n    status = \"disabled\";\n   };\n```\n这段代码片段是设备树（Device Tree）中的一个节点，描述了一个 i.MX6 UltraLite 系列处理器上的看门狗设备（Watchdog Device）的属性和配置。让我为你解释其中的内容：\n\n- `wdog1: wdog@020bc000 { ... };`：这是一个设备节点的定义，其中 `wdog1` 是节点的名称，`wdog@020bc000` 是看门狗设备在设备树中的标识，`020bc000` 是设备的寄存器基地址。\n\n- `compatible = \"fsl,imx6ul-wdt\", \"fsl,imx21-wdt\";`：这是设备兼容性属性，表示这个设备与两种类型的看门狗兼容，即 i.MX6 UltraLite 系列看门狗和 i.MX21 系列看门狗。\n\n- `reg = <0x020bc000 0x4000>;`：这是设备的寄存器属性，指定设备的寄存器基地址和大小。在这里，寄存器基地址是 `0x020bc000`，大小是 `0x4000`（16KB）。\n\n- `interrupts = <0 80 4>;`：这是中断属性，指定中断的描述信息。在这里，`0` 表示中断控制器编号，`80` 表示中断号，`4` 表示中断触发类型（边缘触发）。\n\n- `clocks = <&clks 208>;`：这是时钟属性，指定看门狗设备所使用的时钟源。`&clks` 是时钟源的引用，`208` 是时钟源的索引或标识。\n\n这个设备树节点描述了 i.MX6 UltraLite 系列处理器上的一个看门狗设备的属性，包括设备类型、寄存器地址、中断配置和时钟源等信息。设备树在嵌入式系统中用于描述硬件设备和资源配置，使得内核能够根据这些信息正确初始化和管理设备。\n\ndrivers/watchdog/imx2_wdt.c:imx2_wdt_probe()\n```c\nstatic int __init imx2_wdt_probe(struct platform_device *pdev)\n{\n\tstruct imx2_wdt_device *wdev;\n\tstruct watchdog_device *wdog;\n\tstruct resource *res;\n\tvoid __iomem *base;\n\tint ret;\n\tint irq;\n\tu32 val;\n\tstruct device_node *of_node = pdev->dev.of_node;\n\n\twdev = devm_kzalloc(&pdev->dev, sizeof(*wdev), GFP_KERNEL);\n\tif (!wdev)\n\t\treturn -ENOMEM;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tbase = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\twdev->regmap = devm_regmap_init_mmio_clk(&pdev->dev, NULL, base,\n\t\t\t\t\t\t &imx2_wdt_regmap_config);\n\tif (IS_ERR(wdev->regmap)) {\n\t\tdev_err(&pdev->dev, \"regmap init failed\\n\");\n\t\treturn PTR_ERR(wdev->regmap);\n\t}\n\n\twdev->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(wdev->clk)) {\n\t\tdev_err(&pdev->dev, \"can't get Watchdog clock\\n\");\n\t\treturn PTR_ERR(wdev->clk);\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tret = devm_request_irq(&pdev->dev, irq, imx2_wdt_isr, 0,\n\t\t\t       dev_name(&pdev->dev), pdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"can't get irq %d\\n\", irq);\n\t\treturn ret;\n\t}\n\n\tif (of_get_property(of_node, \"fsl,wdog_b\", NULL)) {\n\t\twdev->wdog_b = true;\n\t\tdev_info(&pdev->dev, \"use WDOG_B to reboot.\\n\");\n\t}\n\n\twdog\t\t\t= &wdev->wdog;\n\twdog->info\t\t= &imx2_wdt_info;\n\twdog->ops\t\t= &imx2_wdt_ops;\n\twdog->min_timeout\t= 1;\n\twdog->max_timeout\t= IMX2_WDT_MAX_TIME;\n\n\tclk_prepare_enable(wdev->clk);\n\n\tregmap_read(wdev->regmap, IMX2_WDT_WRSR, &val);\n\twdog->bootstatus = val & IMX2_WDT_WRSR_TOUT ? WDIOF_CARDRESET : 0;\n\n\twdog->timeout = clamp_t(unsigned, timeout, 1, IMX2_WDT_MAX_TIME);\n\tif (wdog->timeout != timeout)\n\t\tdev_warn(&pdev->dev, \"Initial timeout out of range! Clamped from %u to %u\\n\",\n\t\t\t timeout, wdog->timeout);\n\n\tplatform_set_drvdata(pdev, wdog);\n\twatchdog_set_drvdata(wdog, wdev);\n\twatchdog_set_nowayout(wdog, nowayout);\n\twatchdog_init_timeout(wdog, timeout, &pdev->dev);\n    //开启定时器定时喂狗\n\tsetup_timer(&wdev->timer, imx2_wdt_timer_ping, (unsigned long)wdog);\n\n\timx2_wdt_ping_if_active(wdog);\n\n\t/*\n\t * Disable the watchdog power down counter at boot. Otherwise the power\n\t * down counter will pull down the #WDOG interrupt line for one clock\n\t * cycle.\n\t */\n\tregmap_write(wdev->regmap, IMX2_WDT_WMCR, 0);\n\n\tret = watchdog_register_device(wdog);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"cannot register watchdog device\\n\");\n\t\treturn ret;\n\t}\n\n\twdev->restart_handler.notifier_call = imx2_restart_handler;\n\twdev->restart_handler.priority = 128;\n\tret = register_restart_handler(&wdev->restart_handler);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"cannot register restart handler\\n\");\n\n\tdev_info(&pdev->dev, \"timeout %d sec (nowayout=%d)\\n\",\n\t\t wdog->timeout, nowayout);\n\n\treturn 0;\n}\n```\n```shell\nroot@ATK-IMX6U:/proc# cat interrupts \n           CPU0       \n 16:      39397       GPC  55 Level     i.MX Timer Tick\n 17:      56353       GPC  13 Level     mxs-dma\n 18:      18539       GPC  15 Level     bch\n 19:          0       GPC  33 Level     2010000.ecspi\n 20:       2871       GPC  26 Level     2020000.serial\n 21:          0       GPC  98 Level     sai\n 22:          0       GPC  50 Level     2034000.asrc\n 48:          0  gpio-mxc  18 Edge      USER-KEY1\n 49:          0  gpio-mxc  19 Edge      2190000.usdhc cd\n198:          0       GPC   4 Level     20cc000.snvs:snvs-powerkey\n199:      22953       GPC 120 Level     20b4000.ethernet\n200:          0       GPC 121 Level     20b4000.ethernet\n201:          0       GPC  80 Level     20bc000.wdog\n204:          0       GPC  49 Level     imx_thermal\n209:          0       GPC  19 Level     rtc alarm\n215:          0       GPC   2 Level     sdma\n220:          0       GPC  43 Level     2184000.usb\n221:         35       GPC  42 Level     2184200.usb\n222:       1342       GPC 118 Level     2188000.ethernet\n223:          0       GPC 119 Level     2188000.ethernet\n224:         52       GPC  22 Level     mmc0\n225:         10       GPC  36 Level     21a0000.i2c\n226:         34       GPC  37 Level     21a4000.i2c\n229:          3       GPC   5 Level     21c8000.lcdif\n232:          0       GPC  28 Level     21ec000.serial\nIPI0:          0  CPU wakeup interrupts\nIPI1:          0  Timer broadcast interrupts\nIPI2:          0  Rescheduling interrupts\nIPI3:          0  Function call interrupts\nIPI4:          0  Single function call interrupts\nIPI5:          0  CPU stop interrupts\nIPI6:          0  IRQ work interrupts\nIPI7:          0  completion interrupts\nErr:          0\n```\n看门狗的中断就是80,81的看门狗设备树中没有开.\n\n# 控制watchdog\n`/dev/watchdog` 文件通常用于控制和管理看门狗设备。通过对这个文件执行特定的操作，你可以喂狗、配置超时时间、重启系统等。以下是一些常见的操作方法：\n\n1. **喂狗：** 对 `/dev/watchdog` 文件写入任意数据可以喂狗，即重置看门狗的计时器，防止看门狗超时。这通常用于告诉看门狗设备：“我还活着，不要触发超时”。\n\n   ```sh\n   echo 1 > /dev/watchdog\n   ```\n\n2. **设置超时时间：** 有些系统允许你设置 `/dev/watchdog` 文件的内容来改变看门狗的超时时间。这取决于系统和硬件平台的支持。例如，要设置超时时间为 10 秒：\n\n   ```sh\n   echo 10 > /dev/watchdog\n   ```\n\n   请注意，不是所有系统都支持通过写入 `/dev/watchdog` 来设置超时时间。\n\n3. **关闭看门狗：** 关闭看门狗通常是通过停止对 `/dev/watchdog` 文件的写入操作来实现的。不再写入数据，看门狗计时器会在超时后触发。\n\n   ```sh\n   echo 0 > /dev/watchdog\n   ```\n\n4. **重启系统：** 在某些情况下，写入特定的数据到 `/dev/watchdog` 可以触发系统重启。这通常用于告诉看门狗设备：“我要重启系统”。\n\n   ```sh\n   echo \"reboot\" > /dev/watchdog\n   ```\n\n请注意，使用 `/dev/watchdog` 文件操作可能会需要足够的权限，通常需要以超级用户权限（使用 `sudo`）执行操作。此外，不同的系统和硬件平台可能会有不同的支持和行为，因此在执行任何操作之前，最好查阅相关文档以确保你了解正确的操作方法和效果。误操作可能会导致系统重启或其他不可预料的问题。\n","source":"_posts/2023/08/process-watchdog.md","raw":"---\ntitle: process-watchdog\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-08-31 15:19:48\npassword:\nsummary:\ntags:\n- linux\n- process\ncategories:\n- process\n- linux\nkeywords:\ndescription:\n---\n\n# watchdog作用\n看门狗（Watchdog）是一种硬件或软件机制，旨在监视计算机系统或设备的运行状态，并在系统出现故障、死锁或异常情况时采取措施以防止系统长时间无响应或停滞。看门狗在嵌入式系统、服务器、网络设备等各种场景中都有广泛应用。\n\n看门狗的主要作用包括：\n\n1. **保证系统稳定性和可用性：** 看门狗能够监视系统的运行状态。如果系统在一段时间内没有及时响应看门狗的喂狗操作，看门狗会触发特定的操作，如系统重启或其他预定义的操作，以恢复系统的稳定性和可用性。\n\n2. **防止死锁和异常状态：** 死锁是指系统中的进程或资源无法继续执行或释放，导致系统无法正常运行。看门狗能够监控这种异常情况，并在死锁发生时进行干预，防止系统长时间无响应。\n\n3. **检测程序错误：** 看门狗还可以用于检测程序错误，比如内存泄漏、异常崩溃等。如果程序出现了无法处理的错误，可能无法执行喂狗操作，从而触发看门狗超时操作。\n\n4. **恢复系统正常状态：** 当系统出现异常情况时，看门狗可以自动采取措施，如重启系统或执行预定的恢复操作，以使系统重新进入正常状态。\n\n5. **预防设备故障：** 在一些嵌入式系统中，看门狗还可以监控硬件设备的状态。如果硬件设备发生故障或停滞，看门狗可以采取措施避免系统长时间受到影响。\n\n总之，看门狗是一种用于提高系统稳定性、可靠性和可用性的重要机制。它能够在系统遇到异常情况时自动采取措施，保障系统能够快速恢复正常运行。\n\n# watchdog源码\n设备树节点:\n```c\n   wdog1: wdog@020bc000 {\n    compatible = \"fsl,imx6ul-wdt\", \"fsl,imx21-wdt\";\n    reg = <0x020bc000 0x4000>;\n    interrupts = <0 80 4>;\n    clocks = <&clks 208>;\n   };\n\n   wdog2: wdog@020c0000 {\n    compatible = \"fsl,imx6ul-wdt\", \"fsl,imx21-wdt\";\n    reg = <0x020c0000 0x4000>;\n    interrupts = <0 81 4>;\n    clocks = <&clks 209>;\n    status = \"disabled\";\n   };\n```\n这段代码片段是设备树（Device Tree）中的一个节点，描述了一个 i.MX6 UltraLite 系列处理器上的看门狗设备（Watchdog Device）的属性和配置。让我为你解释其中的内容：\n\n- `wdog1: wdog@020bc000 { ... };`：这是一个设备节点的定义，其中 `wdog1` 是节点的名称，`wdog@020bc000` 是看门狗设备在设备树中的标识，`020bc000` 是设备的寄存器基地址。\n\n- `compatible = \"fsl,imx6ul-wdt\", \"fsl,imx21-wdt\";`：这是设备兼容性属性，表示这个设备与两种类型的看门狗兼容，即 i.MX6 UltraLite 系列看门狗和 i.MX21 系列看门狗。\n\n- `reg = <0x020bc000 0x4000>;`：这是设备的寄存器属性，指定设备的寄存器基地址和大小。在这里，寄存器基地址是 `0x020bc000`，大小是 `0x4000`（16KB）。\n\n- `interrupts = <0 80 4>;`：这是中断属性，指定中断的描述信息。在这里，`0` 表示中断控制器编号，`80` 表示中断号，`4` 表示中断触发类型（边缘触发）。\n\n- `clocks = <&clks 208>;`：这是时钟属性，指定看门狗设备所使用的时钟源。`&clks` 是时钟源的引用，`208` 是时钟源的索引或标识。\n\n这个设备树节点描述了 i.MX6 UltraLite 系列处理器上的一个看门狗设备的属性，包括设备类型、寄存器地址、中断配置和时钟源等信息。设备树在嵌入式系统中用于描述硬件设备和资源配置，使得内核能够根据这些信息正确初始化和管理设备。\n\ndrivers/watchdog/imx2_wdt.c:imx2_wdt_probe()\n```c\nstatic int __init imx2_wdt_probe(struct platform_device *pdev)\n{\n\tstruct imx2_wdt_device *wdev;\n\tstruct watchdog_device *wdog;\n\tstruct resource *res;\n\tvoid __iomem *base;\n\tint ret;\n\tint irq;\n\tu32 val;\n\tstruct device_node *of_node = pdev->dev.of_node;\n\n\twdev = devm_kzalloc(&pdev->dev, sizeof(*wdev), GFP_KERNEL);\n\tif (!wdev)\n\t\treturn -ENOMEM;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tbase = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\twdev->regmap = devm_regmap_init_mmio_clk(&pdev->dev, NULL, base,\n\t\t\t\t\t\t &imx2_wdt_regmap_config);\n\tif (IS_ERR(wdev->regmap)) {\n\t\tdev_err(&pdev->dev, \"regmap init failed\\n\");\n\t\treturn PTR_ERR(wdev->regmap);\n\t}\n\n\twdev->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(wdev->clk)) {\n\t\tdev_err(&pdev->dev, \"can't get Watchdog clock\\n\");\n\t\treturn PTR_ERR(wdev->clk);\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tret = devm_request_irq(&pdev->dev, irq, imx2_wdt_isr, 0,\n\t\t\t       dev_name(&pdev->dev), pdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"can't get irq %d\\n\", irq);\n\t\treturn ret;\n\t}\n\n\tif (of_get_property(of_node, \"fsl,wdog_b\", NULL)) {\n\t\twdev->wdog_b = true;\n\t\tdev_info(&pdev->dev, \"use WDOG_B to reboot.\\n\");\n\t}\n\n\twdog\t\t\t= &wdev->wdog;\n\twdog->info\t\t= &imx2_wdt_info;\n\twdog->ops\t\t= &imx2_wdt_ops;\n\twdog->min_timeout\t= 1;\n\twdog->max_timeout\t= IMX2_WDT_MAX_TIME;\n\n\tclk_prepare_enable(wdev->clk);\n\n\tregmap_read(wdev->regmap, IMX2_WDT_WRSR, &val);\n\twdog->bootstatus = val & IMX2_WDT_WRSR_TOUT ? WDIOF_CARDRESET : 0;\n\n\twdog->timeout = clamp_t(unsigned, timeout, 1, IMX2_WDT_MAX_TIME);\n\tif (wdog->timeout != timeout)\n\t\tdev_warn(&pdev->dev, \"Initial timeout out of range! Clamped from %u to %u\\n\",\n\t\t\t timeout, wdog->timeout);\n\n\tplatform_set_drvdata(pdev, wdog);\n\twatchdog_set_drvdata(wdog, wdev);\n\twatchdog_set_nowayout(wdog, nowayout);\n\twatchdog_init_timeout(wdog, timeout, &pdev->dev);\n    //开启定时器定时喂狗\n\tsetup_timer(&wdev->timer, imx2_wdt_timer_ping, (unsigned long)wdog);\n\n\timx2_wdt_ping_if_active(wdog);\n\n\t/*\n\t * Disable the watchdog power down counter at boot. Otherwise the power\n\t * down counter will pull down the #WDOG interrupt line for one clock\n\t * cycle.\n\t */\n\tregmap_write(wdev->regmap, IMX2_WDT_WMCR, 0);\n\n\tret = watchdog_register_device(wdog);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"cannot register watchdog device\\n\");\n\t\treturn ret;\n\t}\n\n\twdev->restart_handler.notifier_call = imx2_restart_handler;\n\twdev->restart_handler.priority = 128;\n\tret = register_restart_handler(&wdev->restart_handler);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"cannot register restart handler\\n\");\n\n\tdev_info(&pdev->dev, \"timeout %d sec (nowayout=%d)\\n\",\n\t\t wdog->timeout, nowayout);\n\n\treturn 0;\n}\n```\n```shell\nroot@ATK-IMX6U:/proc# cat interrupts \n           CPU0       \n 16:      39397       GPC  55 Level     i.MX Timer Tick\n 17:      56353       GPC  13 Level     mxs-dma\n 18:      18539       GPC  15 Level     bch\n 19:          0       GPC  33 Level     2010000.ecspi\n 20:       2871       GPC  26 Level     2020000.serial\n 21:          0       GPC  98 Level     sai\n 22:          0       GPC  50 Level     2034000.asrc\n 48:          0  gpio-mxc  18 Edge      USER-KEY1\n 49:          0  gpio-mxc  19 Edge      2190000.usdhc cd\n198:          0       GPC   4 Level     20cc000.snvs:snvs-powerkey\n199:      22953       GPC 120 Level     20b4000.ethernet\n200:          0       GPC 121 Level     20b4000.ethernet\n201:          0       GPC  80 Level     20bc000.wdog\n204:          0       GPC  49 Level     imx_thermal\n209:          0       GPC  19 Level     rtc alarm\n215:          0       GPC   2 Level     sdma\n220:          0       GPC  43 Level     2184000.usb\n221:         35       GPC  42 Level     2184200.usb\n222:       1342       GPC 118 Level     2188000.ethernet\n223:          0       GPC 119 Level     2188000.ethernet\n224:         52       GPC  22 Level     mmc0\n225:         10       GPC  36 Level     21a0000.i2c\n226:         34       GPC  37 Level     21a4000.i2c\n229:          3       GPC   5 Level     21c8000.lcdif\n232:          0       GPC  28 Level     21ec000.serial\nIPI0:          0  CPU wakeup interrupts\nIPI1:          0  Timer broadcast interrupts\nIPI2:          0  Rescheduling interrupts\nIPI3:          0  Function call interrupts\nIPI4:          0  Single function call interrupts\nIPI5:          0  CPU stop interrupts\nIPI6:          0  IRQ work interrupts\nIPI7:          0  completion interrupts\nErr:          0\n```\n看门狗的中断就是80,81的看门狗设备树中没有开.\n\n# 控制watchdog\n`/dev/watchdog` 文件通常用于控制和管理看门狗设备。通过对这个文件执行特定的操作，你可以喂狗、配置超时时间、重启系统等。以下是一些常见的操作方法：\n\n1. **喂狗：** 对 `/dev/watchdog` 文件写入任意数据可以喂狗，即重置看门狗的计时器，防止看门狗超时。这通常用于告诉看门狗设备：“我还活着，不要触发超时”。\n\n   ```sh\n   echo 1 > /dev/watchdog\n   ```\n\n2. **设置超时时间：** 有些系统允许你设置 `/dev/watchdog` 文件的内容来改变看门狗的超时时间。这取决于系统和硬件平台的支持。例如，要设置超时时间为 10 秒：\n\n   ```sh\n   echo 10 > /dev/watchdog\n   ```\n\n   请注意，不是所有系统都支持通过写入 `/dev/watchdog` 来设置超时时间。\n\n3. **关闭看门狗：** 关闭看门狗通常是通过停止对 `/dev/watchdog` 文件的写入操作来实现的。不再写入数据，看门狗计时器会在超时后触发。\n\n   ```sh\n   echo 0 > /dev/watchdog\n   ```\n\n4. **重启系统：** 在某些情况下，写入特定的数据到 `/dev/watchdog` 可以触发系统重启。这通常用于告诉看门狗设备：“我要重启系统”。\n\n   ```sh\n   echo \"reboot\" > /dev/watchdog\n   ```\n\n请注意，使用 `/dev/watchdog` 文件操作可能会需要足够的权限，通常需要以超级用户权限（使用 `sudo`）执行操作。此外，不同的系统和硬件平台可能会有不同的支持和行为，因此在执行任何操作之前，最好查阅相关文档以确保你了解正确的操作方法和效果。误操作可能会导致系统重启或其他不可预料的问题。\n","slug":"process-watchdog","published":1,"updated":"2024-01-05T08:12:19.810Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clru1g222002ys4fu67ptqf4d","content":"<h1 id=\"watchdog作用\"><a href=\"#watchdog作用\" class=\"headerlink\" title=\"watchdog作用\"></a>watchdog作用</h1><p>看门狗（Watchdog）是一种硬件或软件机制，旨在监视计算机系统或设备的运行状态，并在系统出现故障、死锁或异常情况时采取措施以防止系统长时间无响应或停滞。看门狗在嵌入式系统、服务器、网络设备等各种场景中都有广泛应用。</p>\n<p>看门狗的主要作用包括：</p>\n<ol>\n<li><p><strong>保证系统稳定性和可用性：</strong> 看门狗能够监视系统的运行状态。如果系统在一段时间内没有及时响应看门狗的喂狗操作，看门狗会触发特定的操作，如系统重启或其他预定义的操作，以恢复系统的稳定性和可用性。</p>\n</li>\n<li><p><strong>防止死锁和异常状态：</strong> 死锁是指系统中的进程或资源无法继续执行或释放，导致系统无法正常运行。看门狗能够监控这种异常情况，并在死锁发生时进行干预，防止系统长时间无响应。</p>\n</li>\n<li><p><strong>检测程序错误：</strong> 看门狗还可以用于检测程序错误，比如内存泄漏、异常崩溃等。如果程序出现了无法处理的错误，可能无法执行喂狗操作，从而触发看门狗超时操作。</p>\n</li>\n<li><p><strong>恢复系统正常状态：</strong> 当系统出现异常情况时，看门狗可以自动采取措施，如重启系统或执行预定的恢复操作，以使系统重新进入正常状态。</p>\n</li>\n<li><p><strong>预防设备故障：</strong> 在一些嵌入式系统中，看门狗还可以监控硬件设备的状态。如果硬件设备发生故障或停滞，看门狗可以采取措施避免系统长时间受到影响。</p>\n</li>\n</ol>\n<p>总之，看门狗是一种用于提高系统稳定性、可靠性和可用性的重要机制。它能够在系统遇到异常情况时自动采取措施，保障系统能够快速恢复正常运行。</p>\n<h1 id=\"watchdog源码\"><a href=\"#watchdog源码\" class=\"headerlink\" title=\"watchdog源码\"></a>watchdog源码</h1><p>设备树节点:</p>\n<pre class=\" language-c\"><code class=\"language-c\">   wdog1<span class=\"token punctuation\">:</span> wdog@020bc000 <span class=\"token punctuation\">{</span>\n    compatible <span class=\"token operator\">=</span> <span class=\"token string\">\"fsl,imx6ul-wdt\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"fsl,imx21-wdt\"</span><span class=\"token punctuation\">;</span>\n    reg <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span><span class=\"token number\">0x020bc000</span> <span class=\"token number\">0x4000</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n    interrupts <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span><span class=\"token number\">0</span> <span class=\"token number\">80</span> <span class=\"token number\">4</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n    clocks <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span><span class=\"token operator\">&amp;</span>clks <span class=\"token number\">208</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n   wdog2<span class=\"token punctuation\">:</span> wdog@020c0000 <span class=\"token punctuation\">{</span>\n    compatible <span class=\"token operator\">=</span> <span class=\"token string\">\"fsl,imx6ul-wdt\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"fsl,imx21-wdt\"</span><span class=\"token punctuation\">;</span>\n    reg <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span><span class=\"token number\">0x020c0000</span> <span class=\"token number\">0x4000</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n    interrupts <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span><span class=\"token number\">0</span> <span class=\"token number\">81</span> <span class=\"token number\">4</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n    clocks <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span><span class=\"token operator\">&amp;</span>clks <span class=\"token number\">209</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n    status <span class=\"token operator\">=</span> <span class=\"token string\">\"disabled\"</span><span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre>\n<p>这段代码片段是设备树（Device Tree）中的一个节点，描述了一个 i.MX6 UltraLite 系列处理器上的看门狗设备（Watchdog Device）的属性和配置。让我为你解释其中的内容：</p>\n<ul>\n<li><p><code>wdog1: wdog@020bc000 { ... };</code>：这是一个设备节点的定义，其中 <code>wdog1</code> 是节点的名称，<code>wdog@020bc000</code> 是看门狗设备在设备树中的标识，<code>020bc000</code> 是设备的寄存器基地址。</p>\n</li>\n<li><p><code>compatible = &quot;fsl,imx6ul-wdt&quot;, &quot;fsl,imx21-wdt&quot;;</code>：这是设备兼容性属性，表示这个设备与两种类型的看门狗兼容，即 i.MX6 UltraLite 系列看门狗和 i.MX21 系列看门狗。</p>\n</li>\n<li><p><code>reg = &lt;0x020bc000 0x4000&gt;;</code>：这是设备的寄存器属性，指定设备的寄存器基地址和大小。在这里，寄存器基地址是 <code>0x020bc000</code>，大小是 <code>0x4000</code>（16KB）。</p>\n</li>\n<li><p><code>interrupts = &lt;0 80 4&gt;;</code>：这是中断属性，指定中断的描述信息。在这里，<code>0</code> 表示中断控制器编号，<code>80</code> 表示中断号，<code>4</code> 表示中断触发类型（边缘触发）。</p>\n</li>\n<li><p><code>clocks = &lt;&amp;clks 208&gt;;</code>：这是时钟属性，指定看门狗设备所使用的时钟源。<code>&amp;clks</code> 是时钟源的引用，<code>208</code> 是时钟源的索引或标识。</p>\n</li>\n</ul>\n<p>这个设备树节点描述了 i.MX6 UltraLite 系列处理器上的一个看门狗设备的属性，包括设备类型、寄存器地址、中断配置和时钟源等信息。设备树在嵌入式系统中用于描述硬件设备和资源配置，使得内核能够根据这些信息正确初始化和管理设备。</p>\n<p>drivers/watchdog/imx2_wdt.c:imx2_wdt_probe()</p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> __init <span class=\"token function\">imx2_wdt_probe</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> platform_device <span class=\"token operator\">*</span>pdev<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">struct</span> imx2_wdt_device <span class=\"token operator\">*</span>wdev<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">struct</span> watchdog_device <span class=\"token operator\">*</span>wdog<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">struct</span> resource <span class=\"token operator\">*</span>res<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">void</span> __iomem <span class=\"token operator\">*</span>base<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> ret<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> irq<span class=\"token punctuation\">;</span>\n    u32 val<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">struct</span> device_node <span class=\"token operator\">*</span>of_node <span class=\"token operator\">=</span> pdev<span class=\"token operator\">-></span>dev<span class=\"token punctuation\">.</span>of_node<span class=\"token punctuation\">;</span>\n\n    wdev <span class=\"token operator\">=</span> <span class=\"token function\">devm_kzalloc</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>pdev<span class=\"token operator\">-></span>dev<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>wdev<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> GFP_KERNEL<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>wdev<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span>ENOMEM<span class=\"token punctuation\">;</span>\n\n    res <span class=\"token operator\">=</span> <span class=\"token function\">platform_get_resource</span><span class=\"token punctuation\">(</span>pdev<span class=\"token punctuation\">,</span> IORESOURCE_MEM<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    base <span class=\"token operator\">=</span> <span class=\"token function\">devm_ioremap_resource</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>pdev<span class=\"token operator\">-></span>dev<span class=\"token punctuation\">,</span> res<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">IS_ERR</span><span class=\"token punctuation\">(</span>base<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">PTR_ERR</span><span class=\"token punctuation\">(</span>base<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    wdev<span class=\"token operator\">-></span>regmap <span class=\"token operator\">=</span> <span class=\"token function\">devm_regmap_init_mmio_clk</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>pdev<span class=\"token operator\">-></span>dev<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> base<span class=\"token punctuation\">,</span>\n                         <span class=\"token operator\">&amp;</span>imx2_wdt_regmap_config<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">IS_ERR</span><span class=\"token punctuation\">(</span>wdev<span class=\"token operator\">-></span>regmap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">dev_err</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>pdev<span class=\"token operator\">-></span>dev<span class=\"token punctuation\">,</span> <span class=\"token string\">\"regmap init failed\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">PTR_ERR</span><span class=\"token punctuation\">(</span>wdev<span class=\"token operator\">-></span>regmap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    wdev<span class=\"token operator\">-></span>clk <span class=\"token operator\">=</span> <span class=\"token function\">devm_clk_get</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>pdev<span class=\"token operator\">-></span>dev<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">IS_ERR</span><span class=\"token punctuation\">(</span>wdev<span class=\"token operator\">-></span>clk<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">dev_err</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>pdev<span class=\"token operator\">-></span>dev<span class=\"token punctuation\">,</span> <span class=\"token string\">\"can't get Watchdog clock\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">PTR_ERR</span><span class=\"token punctuation\">(</span>wdev<span class=\"token operator\">-></span>clk<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    irq <span class=\"token operator\">=</span> <span class=\"token function\">platform_get_irq</span><span class=\"token punctuation\">(</span>pdev<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    ret <span class=\"token operator\">=</span> <span class=\"token function\">devm_request_irq</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>pdev<span class=\"token operator\">-></span>dev<span class=\"token punctuation\">,</span> irq<span class=\"token punctuation\">,</span> imx2_wdt_isr<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n                   <span class=\"token function\">dev_name</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>pdev<span class=\"token operator\">-></span>dev<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> pdev<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ret<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">dev_err</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>pdev<span class=\"token operator\">-></span>dev<span class=\"token punctuation\">,</span> <span class=\"token string\">\"can't get irq %d\\n\"</span><span class=\"token punctuation\">,</span> irq<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> ret<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">of_get_property</span><span class=\"token punctuation\">(</span>of_node<span class=\"token punctuation\">,</span> <span class=\"token string\">\"fsl,wdog_b\"</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        wdev<span class=\"token operator\">-></span>wdog_b <span class=\"token operator\">=</span> true<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">dev_info</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>pdev<span class=\"token operator\">-></span>dev<span class=\"token punctuation\">,</span> <span class=\"token string\">\"use WDOG_B to reboot.\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    wdog            <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>wdev<span class=\"token operator\">-></span>wdog<span class=\"token punctuation\">;</span>\n    wdog<span class=\"token operator\">-></span>info        <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>imx2_wdt_info<span class=\"token punctuation\">;</span>\n    wdog<span class=\"token operator\">-></span>ops        <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>imx2_wdt_ops<span class=\"token punctuation\">;</span>\n    wdog<span class=\"token operator\">-></span>min_timeout    <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    wdog<span class=\"token operator\">-></span>max_timeout    <span class=\"token operator\">=</span> IMX2_WDT_MAX_TIME<span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">clk_prepare_enable</span><span class=\"token punctuation\">(</span>wdev<span class=\"token operator\">-></span>clk<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">regmap_read</span><span class=\"token punctuation\">(</span>wdev<span class=\"token operator\">-></span>regmap<span class=\"token punctuation\">,</span> IMX2_WDT_WRSR<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    wdog<span class=\"token operator\">-></span>bootstatus <span class=\"token operator\">=</span> val <span class=\"token operator\">&amp;</span> IMX2_WDT_WRSR_TOUT <span class=\"token operator\">?</span> WDIOF_CARDRESET <span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    wdog<span class=\"token operator\">-></span>timeout <span class=\"token operator\">=</span> <span class=\"token function\">clamp_t</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span><span class=\"token punctuation\">,</span> timeout<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> IMX2_WDT_MAX_TIME<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>wdog<span class=\"token operator\">-></span>timeout <span class=\"token operator\">!=</span> timeout<span class=\"token punctuation\">)</span>\n        <span class=\"token function\">dev_warn</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>pdev<span class=\"token operator\">-></span>dev<span class=\"token punctuation\">,</span> <span class=\"token string\">\"Initial timeout out of range! Clamped from %u to %u\\n\"</span><span class=\"token punctuation\">,</span>\n             timeout<span class=\"token punctuation\">,</span> wdog<span class=\"token operator\">-></span>timeout<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">platform_set_drvdata</span><span class=\"token punctuation\">(</span>pdev<span class=\"token punctuation\">,</span> wdog<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">watchdog_set_drvdata</span><span class=\"token punctuation\">(</span>wdog<span class=\"token punctuation\">,</span> wdev<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">watchdog_set_nowayout</span><span class=\"token punctuation\">(</span>wdog<span class=\"token punctuation\">,</span> nowayout<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">watchdog_init_timeout</span><span class=\"token punctuation\">(</span>wdog<span class=\"token punctuation\">,</span> timeout<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>pdev<span class=\"token operator\">-></span>dev<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//开启定时器定时喂狗</span>\n    <span class=\"token function\">setup_timer</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>wdev<span class=\"token operator\">-></span>timer<span class=\"token punctuation\">,</span> imx2_wdt_timer_ping<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">)</span>wdog<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">imx2_wdt_ping_if_active</span><span class=\"token punctuation\">(</span>wdog<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/*\n     * Disable the watchdog power down counter at boot. Otherwise the power\n     * down counter will pull down the #WDOG interrupt line for one clock\n     * cycle.\n     */</span>\n    <span class=\"token function\">regmap_write</span><span class=\"token punctuation\">(</span>wdev<span class=\"token operator\">-></span>regmap<span class=\"token punctuation\">,</span> IMX2_WDT_WMCR<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    ret <span class=\"token operator\">=</span> <span class=\"token function\">watchdog_register_device</span><span class=\"token punctuation\">(</span>wdog<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ret<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">dev_err</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>pdev<span class=\"token operator\">-></span>dev<span class=\"token punctuation\">,</span> <span class=\"token string\">\"cannot register watchdog device\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> ret<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    wdev<span class=\"token operator\">-></span>restart_handler<span class=\"token punctuation\">.</span>notifier_call <span class=\"token operator\">=</span> imx2_restart_handler<span class=\"token punctuation\">;</span>\n    wdev<span class=\"token operator\">-></span>restart_handler<span class=\"token punctuation\">.</span>priority <span class=\"token operator\">=</span> <span class=\"token number\">128</span><span class=\"token punctuation\">;</span>\n    ret <span class=\"token operator\">=</span> <span class=\"token function\">register_restart_handler</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>wdev<span class=\"token operator\">-></span>restart_handler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ret<span class=\"token punctuation\">)</span>\n        <span class=\"token function\">dev_err</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>pdev<span class=\"token operator\">-></span>dev<span class=\"token punctuation\">,</span> <span class=\"token string\">\"cannot register restart handler\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">dev_info</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>pdev<span class=\"token operator\">-></span>dev<span class=\"token punctuation\">,</span> <span class=\"token string\">\"timeout %d sec (nowayout=%d)\\n\"</span><span class=\"token punctuation\">,</span>\n         wdog<span class=\"token operator\">-></span>timeout<span class=\"token punctuation\">,</span> nowayout<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-shell\"><code class=\"language-shell\">root@ATK-IMX6U:/proc# cat interrupts \n           CPU0       \n 16:      39397       GPC  55 Level     i.MX Timer Tick\n 17:      56353       GPC  13 Level     mxs-dma\n 18:      18539       GPC  15 Level     bch\n 19:          0       GPC  33 Level     2010000.ecspi\n 20:       2871       GPC  26 Level     2020000.serial\n 21:          0       GPC  98 Level     sai\n 22:          0       GPC  50 Level     2034000.asrc\n 48:          0  gpio-mxc  18 Edge      USER-KEY1\n 49:          0  gpio-mxc  19 Edge      2190000.usdhc cd\n198:          0       GPC   4 Level     20cc000.snvs:snvs-powerkey\n199:      22953       GPC 120 Level     20b4000.ethernet\n200:          0       GPC 121 Level     20b4000.ethernet\n201:          0       GPC  80 Level     20bc000.wdog\n204:          0       GPC  49 Level     imx_thermal\n209:          0       GPC  19 Level     rtc alarm\n215:          0       GPC   2 Level     sdma\n220:          0       GPC  43 Level     2184000.usb\n221:         35       GPC  42 Level     2184200.usb\n222:       1342       GPC 118 Level     2188000.ethernet\n223:          0       GPC 119 Level     2188000.ethernet\n224:         52       GPC  22 Level     mmc0\n225:         10       GPC  36 Level     21a0000.i2c\n226:         34       GPC  37 Level     21a4000.i2c\n229:          3       GPC   5 Level     21c8000.lcdif\n232:          0       GPC  28 Level     21ec000.serial\nIPI0:          0  CPU wakeup interrupts\nIPI1:          0  Timer broadcast interrupts\nIPI2:          0  Rescheduling interrupts\nIPI3:          0  Function call interrupts\nIPI4:          0  Single function call interrupts\nIPI5:          0  CPU stop interrupts\nIPI6:          0  IRQ work interrupts\nIPI7:          0  completion interrupts\nErr:          0</code></pre>\n<p>看门狗的中断就是80,81的看门狗设备树中没有开.</p>\n<h1 id=\"控制watchdog\"><a href=\"#控制watchdog\" class=\"headerlink\" title=\"控制watchdog\"></a>控制watchdog</h1><p><code>/dev/watchdog</code> 文件通常用于控制和管理看门狗设备。通过对这个文件执行特定的操作，你可以喂狗、配置超时时间、重启系统等。以下是一些常见的操作方法：</p>\n<ol>\n<li><p><strong>喂狗：</strong> 对 <code>/dev/watchdog</code> 文件写入任意数据可以喂狗，即重置看门狗的计时器，防止看门狗超时。这通常用于告诉看门狗设备：“我还活着，不要触发超时”。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">echo 1 > /dev/watchdog</code></pre>\n</li>\n<li><p><strong>设置超时时间：</strong> 有些系统允许你设置 <code>/dev/watchdog</code> 文件的内容来改变看门狗的超时时间。这取决于系统和硬件平台的支持。例如，要设置超时时间为 10 秒：</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">echo 10 > /dev/watchdog</code></pre>\n<p>请注意，不是所有系统都支持通过写入 <code>/dev/watchdog</code> 来设置超时时间。</p>\n</li>\n<li><p><strong>关闭看门狗：</strong> 关闭看门狗通常是通过停止对 <code>/dev/watchdog</code> 文件的写入操作来实现的。不再写入数据，看门狗计时器会在超时后触发。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">echo 0 > /dev/watchdog</code></pre>\n</li>\n<li><p><strong>重启系统：</strong> 在某些情况下，写入特定的数据到 <code>/dev/watchdog</code> 可以触发系统重启。这通常用于告诉看门狗设备：“我要重启系统”。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">echo \"reboot\" > /dev/watchdog</code></pre>\n</li>\n</ol>\n<p>请注意，使用 <code>/dev/watchdog</code> 文件操作可能会需要足够的权限，通常需要以超级用户权限（使用 <code>sudo</code>）执行操作。此外，不同的系统和硬件平台可能会有不同的支持和行为，因此在执行任何操作之前，最好查阅相关文档以确保你了解正确的操作方法和效果。误操作可能会导致系统重启或其他不可预料的问题。</p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<h1 id=\"watchdog作用\"><a href=\"#watchdog作用\" class=\"headerlink\" title=\"watchdog作用\"></a>watchdog作用</h1><p>看门狗（Watchdog）是一种硬件或软件机制，旨在监视计算机系统或设备的运行状态，并在系统出现故障、死锁或异常情况时采取措施以防止系统长时间无响应或停滞。看门狗在嵌入式系统、服务器、网络设备等各种场景中都有广泛应用。</p>\n<p>看门狗的主要作用包括：</p>\n<ol>\n<li><p><strong>保证系统稳定性和可用性：</strong> 看门狗能够监视系统的运行状态。如果系统在一段时间内没有及时响应看门狗的喂狗操作，看门狗会触发特定的操作，如系统重启或其他预定义的操作，以恢复系统的稳定性和可用性。</p>\n</li>\n<li><p><strong>防止死锁和异常状态：</strong> 死锁是指系统中的进程或资源无法继续执行或释放，导致系统无法正常运行。看门狗能够监控这种异常情况，并在死锁发生时进行干预，防止系统长时间无响应。</p>\n</li>\n<li><p><strong>检测程序错误：</strong> 看门狗还可以用于检测程序错误，比如内存泄漏、异常崩溃等。如果程序出现了无法处理的错误，可能无法执行喂狗操作，从而触发看门狗超时操作。</p>\n</li>\n<li><p><strong>恢复系统正常状态：</strong> 当系统出现异常情况时，看门狗可以自动采取措施，如重启系统或执行预定的恢复操作，以使系统重新进入正常状态。</p>\n</li>\n<li><p><strong>预防设备故障：</strong> 在一些嵌入式系统中，看门狗还可以监控硬件设备的状态。如果硬件设备发生故障或停滞，看门狗可以采取措施避免系统长时间受到影响。</p>\n</li>\n</ol>\n<p>总之，看门狗是一种用于提高系统稳定性、可靠性和可用性的重要机制。它能够在系统遇到异常情况时自动采取措施，保障系统能够快速恢复正常运行。</p>\n<h1 id=\"watchdog源码\"><a href=\"#watchdog源码\" class=\"headerlink\" title=\"watchdog源码\"></a>watchdog源码</h1><p>设备树节点:</p>\n<pre><code class=\"c\">   wdog1: wdog@020bc000 {\n    compatible = &quot;fsl,imx6ul-wdt&quot;, &quot;fsl,imx21-wdt&quot;;\n    reg = &lt;0x020bc000 0x4000&gt;;\n    interrupts = &lt;0 80 4&gt;;\n    clocks = &lt;&amp;clks 208&gt;;\n   };\n\n   wdog2: wdog@020c0000 {\n    compatible = &quot;fsl,imx6ul-wdt&quot;, &quot;fsl,imx21-wdt&quot;;\n    reg = &lt;0x020c0000 0x4000&gt;;\n    interrupts = &lt;0 81 4&gt;;\n    clocks = &lt;&amp;clks 209&gt;;\n    status = &quot;disabled&quot;;\n   };</code></pre>\n<p>这段代码片段是设备树（Device Tree）中的一个节点，描述了一个 i.MX6 UltraLite 系列处理器上的看门狗设备（Watchdog Device）的属性和配置。让我为你解释其中的内容：</p>\n<ul>\n<li><p><code>wdog1: wdog@020bc000 { ... };</code>：这是一个设备节点的定义，其中 <code>wdog1</code> 是节点的名称，<code>wdog@020bc000</code> 是看门狗设备在设备树中的标识，<code>020bc000</code> 是设备的寄存器基地址。</p>\n</li>\n<li><p><code>compatible = &quot;fsl,imx6ul-wdt&quot;, &quot;fsl,imx21-wdt&quot;;</code>：这是设备兼容性属性，表示这个设备与两种类型的看门狗兼容，即 i.MX6 UltraLite 系列看门狗和 i.MX21 系列看门狗。</p>\n</li>\n<li><p><code>reg = &lt;0x020bc000 0x4000&gt;;</code>：这是设备的寄存器属性，指定设备的寄存器基地址和大小。在这里，寄存器基地址是 <code>0x020bc000</code>，大小是 <code>0x4000</code>（16KB）。</p>\n</li>\n<li><p><code>interrupts = &lt;0 80 4&gt;;</code>：这是中断属性，指定中断的描述信息。在这里，<code>0</code> 表示中断控制器编号，<code>80</code> 表示中断号，<code>4</code> 表示中断触发类型（边缘触发）。</p>\n</li>\n<li><p><code>clocks = &lt;&amp;clks 208&gt;;</code>：这是时钟属性，指定看门狗设备所使用的时钟源。<code>&amp;clks</code> 是时钟源的引用，<code>208</code> 是时钟源的索引或标识。</p>\n</li>\n</ul>\n<p>这个设备树节点描述了 i.MX6 UltraLite 系列处理器上的一个看门狗设备的属性，包括设备类型、寄存器地址、中断配置和时钟源等信息。设备树在嵌入式系统中用于描述硬件设备和资源配置，使得内核能够根据这些信息正确初始化和管理设备。</p>\n<p>drivers/watchdog/imx2_wdt.c:imx2_wdt_probe()</p>\n<pre><code class=\"c\">static int __init imx2_wdt_probe(struct platform_device *pdev)\n{\n    struct imx2_wdt_device *wdev;\n    struct watchdog_device *wdog;\n    struct resource *res;\n    void __iomem *base;\n    int ret;\n    int irq;\n    u32 val;\n    struct device_node *of_node = pdev-&gt;dev.of_node;\n\n    wdev = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(*wdev), GFP_KERNEL);\n    if (!wdev)\n        return -ENOMEM;\n\n    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n    base = devm_ioremap_resource(&amp;pdev-&gt;dev, res);\n    if (IS_ERR(base))\n        return PTR_ERR(base);\n\n    wdev-&gt;regmap = devm_regmap_init_mmio_clk(&amp;pdev-&gt;dev, NULL, base,\n                         &amp;imx2_wdt_regmap_config);\n    if (IS_ERR(wdev-&gt;regmap)) {\n        dev_err(&amp;pdev-&gt;dev, &quot;regmap init failed\\n&quot;);\n        return PTR_ERR(wdev-&gt;regmap);\n    }\n\n    wdev-&gt;clk = devm_clk_get(&amp;pdev-&gt;dev, NULL);\n    if (IS_ERR(wdev-&gt;clk)) {\n        dev_err(&amp;pdev-&gt;dev, &quot;can&#39;t get Watchdog clock\\n&quot;);\n        return PTR_ERR(wdev-&gt;clk);\n    }\n\n    irq = platform_get_irq(pdev, 0);\n    ret = devm_request_irq(&amp;pdev-&gt;dev, irq, imx2_wdt_isr, 0,\n                   dev_name(&amp;pdev-&gt;dev), pdev);\n    if (ret) {\n        dev_err(&amp;pdev-&gt;dev, &quot;can&#39;t get irq %d\\n&quot;, irq);\n        return ret;\n    }\n\n    if (of_get_property(of_node, &quot;fsl,wdog_b&quot;, NULL)) {\n        wdev-&gt;wdog_b = true;\n        dev_info(&amp;pdev-&gt;dev, &quot;use WDOG_B to reboot.\\n&quot;);\n    }\n\n    wdog            = &amp;wdev-&gt;wdog;\n    wdog-&gt;info        = &amp;imx2_wdt_info;\n    wdog-&gt;ops        = &amp;imx2_wdt_ops;\n    wdog-&gt;min_timeout    = 1;\n    wdog-&gt;max_timeout    = IMX2_WDT_MAX_TIME;\n\n    clk_prepare_enable(wdev-&gt;clk);\n\n    regmap_read(wdev-&gt;regmap, IMX2_WDT_WRSR, &amp;val);\n    wdog-&gt;bootstatus = val &amp; IMX2_WDT_WRSR_TOUT ? WDIOF_CARDRESET : 0;\n\n    wdog-&gt;timeout = clamp_t(unsigned, timeout, 1, IMX2_WDT_MAX_TIME);\n    if (wdog-&gt;timeout != timeout)\n        dev_warn(&amp;pdev-&gt;dev, &quot;Initial timeout out of range! Clamped from %u to %u\\n&quot;,\n             timeout, wdog-&gt;timeout);\n\n    platform_set_drvdata(pdev, wdog);\n    watchdog_set_drvdata(wdog, wdev);\n    watchdog_set_nowayout(wdog, nowayout);\n    watchdog_init_timeout(wdog, timeout, &amp;pdev-&gt;dev);\n    //开启定时器定时喂狗\n    setup_timer(&amp;wdev-&gt;timer, imx2_wdt_timer_ping, (unsigned long)wdog);\n\n    imx2_wdt_ping_if_active(wdog);\n\n    /*\n     * Disable the watchdog power down counter at boot. Otherwise the power\n     * down counter will pull down the #WDOG interrupt line for one clock\n     * cycle.\n     */\n    regmap_write(wdev-&gt;regmap, IMX2_WDT_WMCR, 0);\n\n    ret = watchdog_register_device(wdog);\n    if (ret) {\n        dev_err(&amp;pdev-&gt;dev, &quot;cannot register watchdog device\\n&quot;);\n        return ret;\n    }\n\n    wdev-&gt;restart_handler.notifier_call = imx2_restart_handler;\n    wdev-&gt;restart_handler.priority = 128;\n    ret = register_restart_handler(&amp;wdev-&gt;restart_handler);\n    if (ret)\n        dev_err(&amp;pdev-&gt;dev, &quot;cannot register restart handler\\n&quot;);\n\n    dev_info(&amp;pdev-&gt;dev, &quot;timeout %d sec (nowayout=%d)\\n&quot;,\n         wdog-&gt;timeout, nowayout);\n\n    return 0;\n}</code></pre>\n<pre><code class=\"shell\">root@ATK-IMX6U:/proc# cat interrupts \n           CPU0       \n 16:      39397       GPC  55 Level     i.MX Timer Tick\n 17:      56353       GPC  13 Level     mxs-dma\n 18:      18539       GPC  15 Level     bch\n 19:          0       GPC  33 Level     2010000.ecspi\n 20:       2871       GPC  26 Level     2020000.serial\n 21:          0       GPC  98 Level     sai\n 22:          0       GPC  50 Level     2034000.asrc\n 48:          0  gpio-mxc  18 Edge      USER-KEY1\n 49:          0  gpio-mxc  19 Edge      2190000.usdhc cd\n198:          0       GPC   4 Level     20cc000.snvs:snvs-powerkey\n199:      22953       GPC 120 Level     20b4000.ethernet\n200:          0       GPC 121 Level     20b4000.ethernet\n201:          0       GPC  80 Level     20bc000.wdog\n204:          0       GPC  49 Level     imx_thermal\n209:          0       GPC  19 Level     rtc alarm\n215:          0       GPC   2 Level     sdma\n220:          0       GPC  43 Level     2184000.usb\n221:         35       GPC  42 Level     2184200.usb\n222:       1342       GPC 118 Level     2188000.ethernet\n223:          0       GPC 119 Level     2188000.ethernet\n224:         52       GPC  22 Level     mmc0\n225:         10       GPC  36 Level     21a0000.i2c\n226:         34       GPC  37 Level     21a4000.i2c\n229:          3       GPC   5 Level     21c8000.lcdif\n232:          0       GPC  28 Level     21ec000.serial\nIPI0:          0  CPU wakeup interrupts\nIPI1:          0  Timer broadcast interrupts\nIPI2:          0  Rescheduling interrupts\nIPI3:          0  Function call interrupts\nIPI4:          0  Single function call interrupts\nIPI5:          0  CPU stop interrupts\nIPI6:          0  IRQ work interrupts\nIPI7:          0  completion interrupts\nErr:          0</code></pre>\n<p>看门狗的中断就是80,81的看门狗设备树中没有开.</p>\n<h1 id=\"控制watchdog\"><a href=\"#控制watchdog\" class=\"headerlink\" title=\"控制watchdog\"></a>控制watchdog</h1><p><code>/dev/watchdog</code> 文件通常用于控制和管理看门狗设备。通过对这个文件执行特定的操作，你可以喂狗、配置超时时间、重启系统等。以下是一些常见的操作方法：</p>\n<ol>\n<li><p><strong>喂狗：</strong> 对 <code>/dev/watchdog</code> 文件写入任意数据可以喂狗，即重置看门狗的计时器，防止看门狗超时。这通常用于告诉看门狗设备：“我还活着，不要触发超时”。</p>\n<pre><code class=\"sh\">echo 1 &gt; /dev/watchdog</code></pre>\n</li>\n<li><p><strong>设置超时时间：</strong> 有些系统允许你设置 <code>/dev/watchdog</code> 文件的内容来改变看门狗的超时时间。这取决于系统和硬件平台的支持。例如，要设置超时时间为 10 秒：</p>\n<pre><code class=\"sh\">echo 10 &gt; /dev/watchdog</code></pre>\n<p>请注意，不是所有系统都支持通过写入 <code>/dev/watchdog</code> 来设置超时时间。</p>\n</li>\n<li><p><strong>关闭看门狗：</strong> 关闭看门狗通常是通过停止对 <code>/dev/watchdog</code> 文件的写入操作来实现的。不再写入数据，看门狗计时器会在超时后触发。</p>\n<pre><code class=\"sh\">echo 0 &gt; /dev/watchdog</code></pre>\n</li>\n<li><p><strong>重启系统：</strong> 在某些情况下，写入特定的数据到 <code>/dev/watchdog</code> 可以触发系统重启。这通常用于告诉看门狗设备：“我要重启系统”。</p>\n<pre><code class=\"sh\">echo &quot;reboot&quot; &gt; /dev/watchdog</code></pre>\n</li>\n</ol>\n<p>请注意，使用 <code>/dev/watchdog</code> 文件操作可能会需要足够的权限，通常需要以超级用户权限（使用 <code>sudo</code>）执行操作。此外，不同的系统和硬件平台可能会有不同的支持和行为，因此在执行任何操作之前，最好查阅相关文档以确保你了解正确的操作方法和效果。误操作可能会导致系统重启或其他不可预料的问题。</p>\n"},{"title":"语法指导翻译器","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-08-16T03:31:23.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"\n# 上下文无关文法\n\n![文法定义](语法指导翻译器/文法定义.png)\n![语法定义](语法指导翻译器/语法定义.png)\n**文法是用来描述语法的**\n举个例子：\n产生式：  Sent -> S V O\n        S -> 人 | 天\n        V -> 吃 | 下\n        O -> 雨 | 雪 | 饭 | 肉\n其中英文字母都是非终结符（SVO 分别表示主谓宾），汉字都是终结符。这个文法可以生成如下句子（共 2*2*4=16 种组合，懒得写全了，简单写 7 种意思意思）：｛人吃饭，天下雨，人吃肉，天下雪，人下雪，天下饭，天吃肉，……｝可以看到，其中有一些搭配在语义上是不恰当的，例如“天吃肉”。其（最左）推导过程为：Sent -> SVO -> 天VO -> 天吃O -> 天吃肉\n但是上下文无关文法里，因为有“V -> 吃 | 下”这样一条产生式，V 就永远都可以推出“吃”这个词，它并不在乎应用“V -> 吃 | 下”这个产生式进行推导时 V 所在的上下文（在这个例子里，就是”天VO“中 V 左右两边的字符串”天“和”O“）。事实上，在 V 推出“吃”这一步，它的左边是“天”这个词，而”天“和”吃“不搭配，导致最后的句子读起来很奇怪。\n**上下文无关语法就是每段代码都是可以独立解析的，和上下文无关，C语言的语法是上下文相关**\n\n# 语法分析树\n![语语法分析树](语法指导翻译器/语法分析树.png)\n**文语法分析树是用来辅助推导文法到语法的**\n\n# 语法制导翻译\n![语法制导翻译](语法指导翻译器/语法制导翻译.png)\n语法指导翻译是通过向一个文法的产生式附加一些规则或程序片段而得到的\n为了翻译程序设计语言的某个结构，除了为该结构生成的代码以外，编译器还需要保存许多信息。例如：编译器可能需要知道这个结构的类型、目标代码中第1条指令的位置、生成的指令的个数。\n属性可以表示任意的信息，如类型、串、内存位置等。\n\n将语义规则和语法规则（产生式）联系起来涉及两个概念：\n    语法制导定义（Syntax-directed definitions，SDD）\n    语法制导翻译方案（Syntax-directed Translation Scheme，SDT）（语义）\n## 后缀表示\n表达式E的后缀形式可以归纳地定义如下：\n\n如果E是一个变量或者常量，则E的后缀表示是E本身\n如果E是形如E1 op E2的表达式，其中op是一个二元操作符，则E的后缀表示是E1'E2'op，这里E1'和E2'分别是E1和E2的后缀表示\n如果E是形如(E1)的表达式，则E1的后缀表示是E的后缀表示。\n因为一个表达式的操作符的位置和每个操作符的操作个数(参数数量)只允许后缀表达式的一种解码方式，所以在后缀表示中不需要括号。例如,(9 - 5) + 2的后缀表示是95-2+, 9 - (5 + 2)的后缀表示是952+-\n\n一个数字记号的后缀形式是该数字本身。\n## 综合属性\n分析树的某个节点的属性值是由其子节点的属性值确定的。一棵分析树的所有综合属性值的计算只需要分析树的一次自底向上遍历。\n\n## 继承属性\n分析树的某个节点的属性值是由其夫节点或则兄弟节点的属性值确定的。\n\n## 简单的语法指导定义\n![简单语法指导定义](语法指导翻译器/简单语法制导定义.png)\n\n## 树的遍历\n\n## 翻译方案\n\n# 语法分析\n\n## 自顶向下分析方法\n为了解释什么是自顶向下分析方法，首先来看一个简单的例子，语法为：\n\nS -> aS | bS | c\n需要解析的句子为abac，解析过程如下：\n\nWorking-string\t \tProduction\nS\t \t            S -> aS\naS\t \t            S -> bS\nabS\t \t            S -> aS\nabaS\t \t        S -> c\nabac\t \t        ACCEPT\n下面，一步一步跟踪这个解析过程，查看每一步是如何选择出需要的产生式的。首先，我们的目标是将起始符号 S 展开到 最终句子 abac 。把它们写在同一行来进行比较，如下：\n\nWorking-string\t \tFinal-string\t \tProduction\nS\t \t            a bac\t \t \n假设有一个 strcmp 函数来比较符号串 “S” 和 “abac” ，从左向右一个符号一个符号的比较，找到第一个不匹配的符号，也就是 “S” 和 “a”。\n\n因此，此时必须将中间句子中的 “S” 展开，才能得到最终句子。那如何展开呢？将最终句子中不匹配的这个 “a” ，和 S 的三个产生式的右边 aS 、 bS 和 c 相比，可以看出，只能选择 S -> aS 展开，才可以和 “a” 匹配上，展开后得到中间句子 aS ：\n\nWorking-string\t \tFinal-string\t \tProduction\nS\t \t            a bac\t \t        S -> aS\na S\t \t            a b ac\t \t \n再次比较此时的中间句子 “aS” 和最终句子 “abac” ，找到的第一个不匹配的符号分别为 “S” 和 “b” ，将 “b” 和 S 的三个产生式比较，发现只能选择 S -> bS ，展开后得到中间句子 abS ：\n\nWorking-string\t \tFinal-string\t \tProduction\nS\t \t            a bac\t \t        S -> aS\na S\t \t            a b ac\t \t        S -> bS\nab S\t \t        ab a c\t \t \n按以上原则，每次都对中间句子和最终句子进行比较，找到第一个不匹配的符号，然后利用不匹配的符号挑选出需要的产生式，最终展开到最终句子：\n\nWorking-string\t \tFinal-string\t \tProduction\nS\t \t            a bac\t \t        S -> aS\na S\t \t            a b ac\t \t        S -> bS\nab S\t \t        ab a c\t \t        S -> aS\naba S\t \t        aba c\t \t        S -> c\nabac\t \t        abac\t \t        ACCEPT\n因此自顶向下分析方法的基本思路为：\n\n每个推导步中，从左向右比较中间句子和最终句子，找到第一个不匹配的符号，如：中间句子为 u X v 、最终句子为 u a w 。显然，a 一定是终结符， X 则可能为非终结符，也可能为终结符，有以下 4 种情况：\n\n情况 A ： X 为终结符，这种情况表明无论怎么展开都不可能展开到最终句子，即最终句子不合语法，此时终止推导。\n\n情况 B ： X 为非终结符，假设它的所有产生式为 X -> u1 | u2 | ... | un ，将 a 和这些产生式的右边 u1, u2, ... , un 相比较，找出可以和 a 匹配的 ui ，将 ui 代替中间句子 u X v 中的 X ，得到下一个中间句子 u ui v，然后开始下一轮展开。\n\n情况 C ： X 为非终结符，但它的所有产生式的右边 u1, u2, ... , un 中，没有一个可以和 “a” 匹配上，这种情况表明最终句子不合语法，此时终止推导。\n\n情况 D ： X 为非终结符，但它的所有产生式的右边 u1, u2, ... , un 中，有两个或以上的 ui 可以和 “a” 匹配上，这种情况表明此语法不适于用自顶向下分析方法，需要修改语法。\n\n## 预测性分析法\n### 文法\n### 消除左递归\n### FIRST集\n### FOLLOW集\n### 预测表\n### 分析句子\n\n## 何时使用E产生式\n\n## 设计一个预分析器\n\n## 左递归\n\n参考链接：\n[自己动手写编译器](https://pandolia.net/tinyc/index.html)\n[LL1预测分析法代码](https://blog.csdn.net/m0_54759841/article/details/124001965)\n[LL1预测分析法-first-follow-select集](https://blog.csdn.net/CooperNiu/article/details/78524688)\n","source":"_posts/2023/08/语法指导翻译器.md","raw":"---\ntitle: 语法指导翻译器\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-08-16 11:31:23\npassword:\nsummary:\ntags:\n- 编译原理\ncategories:\n- 编译原理\nkeywords:\ndescription:\n---\n\n# 上下文无关文法\n\n![文法定义](语法指导翻译器/文法定义.png)\n![语法定义](语法指导翻译器/语法定义.png)\n**文法是用来描述语法的**\n举个例子：\n产生式：  Sent -> S V O\n        S -> 人 | 天\n        V -> 吃 | 下\n        O -> 雨 | 雪 | 饭 | 肉\n其中英文字母都是非终结符（SVO 分别表示主谓宾），汉字都是终结符。这个文法可以生成如下句子（共 2*2*4=16 种组合，懒得写全了，简单写 7 种意思意思）：｛人吃饭，天下雨，人吃肉，天下雪，人下雪，天下饭，天吃肉，……｝可以看到，其中有一些搭配在语义上是不恰当的，例如“天吃肉”。其（最左）推导过程为：Sent -> SVO -> 天VO -> 天吃O -> 天吃肉\n但是上下文无关文法里，因为有“V -> 吃 | 下”这样一条产生式，V 就永远都可以推出“吃”这个词，它并不在乎应用“V -> 吃 | 下”这个产生式进行推导时 V 所在的上下文（在这个例子里，就是”天VO“中 V 左右两边的字符串”天“和”O“）。事实上，在 V 推出“吃”这一步，它的左边是“天”这个词，而”天“和”吃“不搭配，导致最后的句子读起来很奇怪。\n**上下文无关语法就是每段代码都是可以独立解析的，和上下文无关，C语言的语法是上下文相关**\n\n# 语法分析树\n![语语法分析树](语法指导翻译器/语法分析树.png)\n**文语法分析树是用来辅助推导文法到语法的**\n\n# 语法制导翻译\n![语法制导翻译](语法指导翻译器/语法制导翻译.png)\n语法指导翻译是通过向一个文法的产生式附加一些规则或程序片段而得到的\n为了翻译程序设计语言的某个结构，除了为该结构生成的代码以外，编译器还需要保存许多信息。例如：编译器可能需要知道这个结构的类型、目标代码中第1条指令的位置、生成的指令的个数。\n属性可以表示任意的信息，如类型、串、内存位置等。\n\n将语义规则和语法规则（产生式）联系起来涉及两个概念：\n    语法制导定义（Syntax-directed definitions，SDD）\n    语法制导翻译方案（Syntax-directed Translation Scheme，SDT）（语义）\n## 后缀表示\n表达式E的后缀形式可以归纳地定义如下：\n\n如果E是一个变量或者常量，则E的后缀表示是E本身\n如果E是形如E1 op E2的表达式，其中op是一个二元操作符，则E的后缀表示是E1'E2'op，这里E1'和E2'分别是E1和E2的后缀表示\n如果E是形如(E1)的表达式，则E1的后缀表示是E的后缀表示。\n因为一个表达式的操作符的位置和每个操作符的操作个数(参数数量)只允许后缀表达式的一种解码方式，所以在后缀表示中不需要括号。例如,(9 - 5) + 2的后缀表示是95-2+, 9 - (5 + 2)的后缀表示是952+-\n\n一个数字记号的后缀形式是该数字本身。\n## 综合属性\n分析树的某个节点的属性值是由其子节点的属性值确定的。一棵分析树的所有综合属性值的计算只需要分析树的一次自底向上遍历。\n\n## 继承属性\n分析树的某个节点的属性值是由其夫节点或则兄弟节点的属性值确定的。\n\n## 简单的语法指导定义\n![简单语法指导定义](语法指导翻译器/简单语法制导定义.png)\n\n## 树的遍历\n\n## 翻译方案\n\n# 语法分析\n\n## 自顶向下分析方法\n为了解释什么是自顶向下分析方法，首先来看一个简单的例子，语法为：\n\nS -> aS | bS | c\n需要解析的句子为abac，解析过程如下：\n\nWorking-string\t \tProduction\nS\t \t            S -> aS\naS\t \t            S -> bS\nabS\t \t            S -> aS\nabaS\t \t        S -> c\nabac\t \t        ACCEPT\n下面，一步一步跟踪这个解析过程，查看每一步是如何选择出需要的产生式的。首先，我们的目标是将起始符号 S 展开到 最终句子 abac 。把它们写在同一行来进行比较，如下：\n\nWorking-string\t \tFinal-string\t \tProduction\nS\t \t            a bac\t \t \n假设有一个 strcmp 函数来比较符号串 “S” 和 “abac” ，从左向右一个符号一个符号的比较，找到第一个不匹配的符号，也就是 “S” 和 “a”。\n\n因此，此时必须将中间句子中的 “S” 展开，才能得到最终句子。那如何展开呢？将最终句子中不匹配的这个 “a” ，和 S 的三个产生式的右边 aS 、 bS 和 c 相比，可以看出，只能选择 S -> aS 展开，才可以和 “a” 匹配上，展开后得到中间句子 aS ：\n\nWorking-string\t \tFinal-string\t \tProduction\nS\t \t            a bac\t \t        S -> aS\na S\t \t            a b ac\t \t \n再次比较此时的中间句子 “aS” 和最终句子 “abac” ，找到的第一个不匹配的符号分别为 “S” 和 “b” ，将 “b” 和 S 的三个产生式比较，发现只能选择 S -> bS ，展开后得到中间句子 abS ：\n\nWorking-string\t \tFinal-string\t \tProduction\nS\t \t            a bac\t \t        S -> aS\na S\t \t            a b ac\t \t        S -> bS\nab S\t \t        ab a c\t \t \n按以上原则，每次都对中间句子和最终句子进行比较，找到第一个不匹配的符号，然后利用不匹配的符号挑选出需要的产生式，最终展开到最终句子：\n\nWorking-string\t \tFinal-string\t \tProduction\nS\t \t            a bac\t \t        S -> aS\na S\t \t            a b ac\t \t        S -> bS\nab S\t \t        ab a c\t \t        S -> aS\naba S\t \t        aba c\t \t        S -> c\nabac\t \t        abac\t \t        ACCEPT\n因此自顶向下分析方法的基本思路为：\n\n每个推导步中，从左向右比较中间句子和最终句子，找到第一个不匹配的符号，如：中间句子为 u X v 、最终句子为 u a w 。显然，a 一定是终结符， X 则可能为非终结符，也可能为终结符，有以下 4 种情况：\n\n情况 A ： X 为终结符，这种情况表明无论怎么展开都不可能展开到最终句子，即最终句子不合语法，此时终止推导。\n\n情况 B ： X 为非终结符，假设它的所有产生式为 X -> u1 | u2 | ... | un ，将 a 和这些产生式的右边 u1, u2, ... , un 相比较，找出可以和 a 匹配的 ui ，将 ui 代替中间句子 u X v 中的 X ，得到下一个中间句子 u ui v，然后开始下一轮展开。\n\n情况 C ： X 为非终结符，但它的所有产生式的右边 u1, u2, ... , un 中，没有一个可以和 “a” 匹配上，这种情况表明最终句子不合语法，此时终止推导。\n\n情况 D ： X 为非终结符，但它的所有产生式的右边 u1, u2, ... , un 中，有两个或以上的 ui 可以和 “a” 匹配上，这种情况表明此语法不适于用自顶向下分析方法，需要修改语法。\n\n## 预测性分析法\n### 文法\n### 消除左递归\n### FIRST集\n### FOLLOW集\n### 预测表\n### 分析句子\n\n## 何时使用E产生式\n\n## 设计一个预分析器\n\n## 左递归\n\n参考链接：\n[自己动手写编译器](https://pandolia.net/tinyc/index.html)\n[LL1预测分析法代码](https://blog.csdn.net/m0_54759841/article/details/124001965)\n[LL1预测分析法-first-follow-select集](https://blog.csdn.net/CooperNiu/article/details/78524688)\n","slug":"语法指导翻译器","published":1,"updated":"2024-01-05T08:12:19.810Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clru1g2240032s4ful7gth935","content":"<h1 id=\"上下文无关文法\"><a href=\"#上下文无关文法\" class=\"headerlink\" title=\"上下文无关文法\"></a>上下文无关文法</h1><p><img src=\"/2023/08/yu-fa-zhi-dao-fan-yi-qi/%E6%96%87%E6%B3%95%E5%AE%9A%E4%B9%89.png\" alt=\"文法定义\"><br><img src=\"/2023/08/yu-fa-zhi-dao-fan-yi-qi/%E8%AF%AD%E6%B3%95%E5%AE%9A%E4%B9%89.png\" alt=\"语法定义\"><br><strong>文法是用来描述语法的</strong><br>举个例子：<br>产生式：  Sent -&gt; S V O<br>        S -&gt; 人 | 天<br>        V -&gt; 吃 | 下<br>        O -&gt; 雨 | 雪 | 饭 | 肉<br>其中英文字母都是非终结符（SVO 分别表示主谓宾），汉字都是终结符。这个文法可以生成如下句子（共 2<em>2</em>4=16 种组合，懒得写全了，简单写 7 种意思意思）：｛人吃饭，天下雨，人吃肉，天下雪，人下雪，天下饭，天吃肉，……｝可以看到，其中有一些搭配在语义上是不恰当的，例如“天吃肉”。其（最左）推导过程为：Sent -&gt; SVO -&gt; 天VO -&gt; 天吃O -&gt; 天吃肉<br>但是上下文无关文法里，因为有“V -&gt; 吃 | 下”这样一条产生式，V 就永远都可以推出“吃”这个词，它并不在乎应用“V -&gt; 吃 | 下”这个产生式进行推导时 V 所在的上下文（在这个例子里，就是”天VO“中 V 左右两边的字符串”天“和”O“）。事实上，在 V 推出“吃”这一步，它的左边是“天”这个词，而”天“和”吃“不搭配，导致最后的句子读起来很奇怪。<br><strong>上下文无关语法就是每段代码都是可以独立解析的，和上下文无关，C语言的语法是上下文相关</strong></p>\n<h1 id=\"语法分析树\"><a href=\"#语法分析树\" class=\"headerlink\" title=\"语法分析树\"></a>语法分析树</h1><p><img src=\"/2023/08/yu-fa-zhi-dao-fan-yi-qi/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%A0%91.png\" alt=\"语语法分析树\"><br><strong>文语法分析树是用来辅助推导文法到语法的</strong></p>\n<h1 id=\"语法制导翻译\"><a href=\"#语法制导翻译\" class=\"headerlink\" title=\"语法制导翻译\"></a>语法制导翻译</h1><p><img src=\"/2023/08/yu-fa-zhi-dao-fan-yi-qi/%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91.png\" alt=\"语法制导翻译\"><br>语法指导翻译是通过向一个文法的产生式附加一些规则或程序片段而得到的<br>为了翻译程序设计语言的某个结构，除了为该结构生成的代码以外，编译器还需要保存许多信息。例如：编译器可能需要知道这个结构的类型、目标代码中第1条指令的位置、生成的指令的个数。<br>属性可以表示任意的信息，如类型、串、内存位置等。</p>\n<p>将语义规则和语法规则（产生式）联系起来涉及两个概念：<br>    语法制导定义（Syntax-directed definitions，SDD）<br>    语法制导翻译方案（Syntax-directed Translation Scheme，SDT）（语义）</p>\n<h2 id=\"后缀表示\"><a href=\"#后缀表示\" class=\"headerlink\" title=\"后缀表示\"></a>后缀表示</h2><p>表达式E的后缀形式可以归纳地定义如下：</p>\n<p>如果E是一个变量或者常量，则E的后缀表示是E本身<br>如果E是形如E1 op E2的表达式，其中op是一个二元操作符，则E的后缀表示是E1’E2’op，这里E1’和E2’分别是E1和E2的后缀表示<br>如果E是形如(E1)的表达式，则E1的后缀表示是E的后缀表示。<br>因为一个表达式的操作符的位置和每个操作符的操作个数(参数数量)只允许后缀表达式的一种解码方式，所以在后缀表示中不需要括号。例如,(9 - 5) + 2的后缀表示是95-2+, 9 - (5 + 2)的后缀表示是952+-</p>\n<p>一个数字记号的后缀形式是该数字本身。</p>\n<h2 id=\"综合属性\"><a href=\"#综合属性\" class=\"headerlink\" title=\"综合属性\"></a>综合属性</h2><p>分析树的某个节点的属性值是由其子节点的属性值确定的。一棵分析树的所有综合属性值的计算只需要分析树的一次自底向上遍历。</p>\n<h2 id=\"继承属性\"><a href=\"#继承属性\" class=\"headerlink\" title=\"继承属性\"></a>继承属性</h2><p>分析树的某个节点的属性值是由其夫节点或则兄弟节点的属性值确定的。</p>\n<h2 id=\"简单的语法指导定义\"><a href=\"#简单的语法指导定义\" class=\"headerlink\" title=\"简单的语法指导定义\"></a>简单的语法指导定义</h2><p><img src=\"/2023/08/yu-fa-zhi-dao-fan-yi-qi/%E7%AE%80%E5%8D%95%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E5%AE%9A%E4%B9%89.png\" alt=\"简单语法指导定义\"></p>\n<h2 id=\"树的遍历\"><a href=\"#树的遍历\" class=\"headerlink\" title=\"树的遍历\"></a>树的遍历</h2><h2 id=\"翻译方案\"><a href=\"#翻译方案\" class=\"headerlink\" title=\"翻译方案\"></a>翻译方案</h2><h1 id=\"语法分析\"><a href=\"#语法分析\" class=\"headerlink\" title=\"语法分析\"></a>语法分析</h1><h2 id=\"自顶向下分析方法\"><a href=\"#自顶向下分析方法\" class=\"headerlink\" title=\"自顶向下分析方法\"></a>自顶向下分析方法</h2><p>为了解释什么是自顶向下分析方法，首先来看一个简单的例子，语法为：</p>\n<p>S -&gt; aS | bS | c<br>需要解析的句子为abac，解析过程如下：</p>\n<p>Working-string         Production<br>S                     S -&gt; aS<br>aS                     S -&gt; bS<br>abS                     S -&gt; aS<br>abaS                 S -&gt; c<br>abac                 ACCEPT<br>下面，一步一步跟踪这个解析过程，查看每一步是如何选择出需要的产生式的。首先，我们的目标是将起始符号 S 展开到 最终句子 abac 。把它们写在同一行来进行比较，如下：</p>\n<p>Working-string         Final-string         Production<br>S                     a bac<br>假设有一个 strcmp 函数来比较符号串 “S” 和 “abac” ，从左向右一个符号一个符号的比较，找到第一个不匹配的符号，也就是 “S” 和 “a”。</p>\n<p>因此，此时必须将中间句子中的 “S” 展开，才能得到最终句子。那如何展开呢？将最终句子中不匹配的这个 “a” ，和 S 的三个产生式的右边 aS 、 bS 和 c 相比，可以看出，只能选择 S -&gt; aS 展开，才可以和 “a” 匹配上，展开后得到中间句子 aS ：</p>\n<p>Working-string         Final-string         Production<br>S                     a bac                 S -&gt; aS<br>a S                     a b ac<br>再次比较此时的中间句子 “aS” 和最终句子 “abac” ，找到的第一个不匹配的符号分别为 “S” 和 “b” ，将 “b” 和 S 的三个产生式比较，发现只能选择 S -&gt; bS ，展开后得到中间句子 abS ：</p>\n<p>Working-string         Final-string         Production<br>S                     a bac                 S -&gt; aS<br>a S                     a b ac                 S -&gt; bS<br>ab S                 ab a c<br>按以上原则，每次都对中间句子和最终句子进行比较，找到第一个不匹配的符号，然后利用不匹配的符号挑选出需要的产生式，最终展开到最终句子：</p>\n<p>Working-string         Final-string         Production<br>S                     a bac                 S -&gt; aS<br>a S                     a b ac                 S -&gt; bS<br>ab S                 ab a c                 S -&gt; aS<br>aba S                 aba c                 S -&gt; c<br>abac                 abac                 ACCEPT<br>因此自顶向下分析方法的基本思路为：</p>\n<p>每个推导步中，从左向右比较中间句子和最终句子，找到第一个不匹配的符号，如：中间句子为 u X v 、最终句子为 u a w 。显然，a 一定是终结符， X 则可能为非终结符，也可能为终结符，有以下 4 种情况：</p>\n<p>情况 A ： X 为终结符，这种情况表明无论怎么展开都不可能展开到最终句子，即最终句子不合语法，此时终止推导。</p>\n<p>情况 B ： X 为非终结符，假设它的所有产生式为 X -&gt; u1 | u2 | … | un ，将 a 和这些产生式的右边 u1, u2, … , un 相比较，找出可以和 a 匹配的 ui ，将 ui 代替中间句子 u X v 中的 X ，得到下一个中间句子 u ui v，然后开始下一轮展开。</p>\n<p>情况 C ： X 为非终结符，但它的所有产生式的右边 u1, u2, … , un 中，没有一个可以和 “a” 匹配上，这种情况表明最终句子不合语法，此时终止推导。</p>\n<p>情况 D ： X 为非终结符，但它的所有产生式的右边 u1, u2, … , un 中，有两个或以上的 ui 可以和 “a” 匹配上，这种情况表明此语法不适于用自顶向下分析方法，需要修改语法。</p>\n<h2 id=\"预测性分析法\"><a href=\"#预测性分析法\" class=\"headerlink\" title=\"预测性分析法\"></a>预测性分析法</h2><h3 id=\"文法\"><a href=\"#文法\" class=\"headerlink\" title=\"文法\"></a>文法</h3><h3 id=\"消除左递归\"><a href=\"#消除左递归\" class=\"headerlink\" title=\"消除左递归\"></a>消除左递归</h3><h3 id=\"FIRST集\"><a href=\"#FIRST集\" class=\"headerlink\" title=\"FIRST集\"></a>FIRST集</h3><h3 id=\"FOLLOW集\"><a href=\"#FOLLOW集\" class=\"headerlink\" title=\"FOLLOW集\"></a>FOLLOW集</h3><h3 id=\"预测表\"><a href=\"#预测表\" class=\"headerlink\" title=\"预测表\"></a>预测表</h3><h3 id=\"分析句子\"><a href=\"#分析句子\" class=\"headerlink\" title=\"分析句子\"></a>分析句子</h3><h2 id=\"何时使用E产生式\"><a href=\"#何时使用E产生式\" class=\"headerlink\" title=\"何时使用E产生式\"></a>何时使用E产生式</h2><h2 id=\"设计一个预分析器\"><a href=\"#设计一个预分析器\" class=\"headerlink\" title=\"设计一个预分析器\"></a>设计一个预分析器</h2><h2 id=\"左递归\"><a href=\"#左递归\" class=\"headerlink\" title=\"左递归\"></a>左递归</h2><p>参考链接：<br><a href=\"https://pandolia.net/tinyc/index.html\" target=\"_blank\" rel=\"noopener\">自己动手写编译器</a><br><a href=\"https://blog.csdn.net/m0_54759841/article/details/124001965\" target=\"_blank\" rel=\"noopener\">LL1预测分析法代码</a><br><a href=\"https://blog.csdn.net/CooperNiu/article/details/78524688\" target=\"_blank\" rel=\"noopener\">LL1预测分析法-first-follow-select集</a></p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<h1 id=\"上下文无关文法\"><a href=\"#上下文无关文法\" class=\"headerlink\" title=\"上下文无关文法\"></a>上下文无关文法</h1><p><img src=\"/2023/08/yu-fa-zhi-dao-fan-yi-qi/%E6%96%87%E6%B3%95%E5%AE%9A%E4%B9%89.png\" alt=\"文法定义\"><br><img src=\"/2023/08/yu-fa-zhi-dao-fan-yi-qi/%E8%AF%AD%E6%B3%95%E5%AE%9A%E4%B9%89.png\" alt=\"语法定义\"><br><strong>文法是用来描述语法的</strong><br>举个例子：<br>产生式：  Sent -&gt; S V O<br>        S -&gt; 人 | 天<br>        V -&gt; 吃 | 下<br>        O -&gt; 雨 | 雪 | 饭 | 肉<br>其中英文字母都是非终结符（SVO 分别表示主谓宾），汉字都是终结符。这个文法可以生成如下句子（共 2<em>2</em>4=16 种组合，懒得写全了，简单写 7 种意思意思）：｛人吃饭，天下雨，人吃肉，天下雪，人下雪，天下饭，天吃肉，……｝可以看到，其中有一些搭配在语义上是不恰当的，例如“天吃肉”。其（最左）推导过程为：Sent -&gt; SVO -&gt; 天VO -&gt; 天吃O -&gt; 天吃肉<br>但是上下文无关文法里，因为有“V -&gt; 吃 | 下”这样一条产生式，V 就永远都可以推出“吃”这个词，它并不在乎应用“V -&gt; 吃 | 下”这个产生式进行推导时 V 所在的上下文（在这个例子里，就是”天VO“中 V 左右两边的字符串”天“和”O“）。事实上，在 V 推出“吃”这一步，它的左边是“天”这个词，而”天“和”吃“不搭配，导致最后的句子读起来很奇怪。<br><strong>上下文无关语法就是每段代码都是可以独立解析的，和上下文无关，C语言的语法是上下文相关</strong></p>\n<h1 id=\"语法分析树\"><a href=\"#语法分析树\" class=\"headerlink\" title=\"语法分析树\"></a>语法分析树</h1><p><img src=\"/2023/08/yu-fa-zhi-dao-fan-yi-qi/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%A0%91.png\" alt=\"语语法分析树\"><br><strong>文语法分析树是用来辅助推导文法到语法的</strong></p>\n<h1 id=\"语法制导翻译\"><a href=\"#语法制导翻译\" class=\"headerlink\" title=\"语法制导翻译\"></a>语法制导翻译</h1><p><img src=\"/2023/08/yu-fa-zhi-dao-fan-yi-qi/%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91.png\" alt=\"语法制导翻译\"><br>语法指导翻译是通过向一个文法的产生式附加一些规则或程序片段而得到的<br>为了翻译程序设计语言的某个结构，除了为该结构生成的代码以外，编译器还需要保存许多信息。例如：编译器可能需要知道这个结构的类型、目标代码中第1条指令的位置、生成的指令的个数。<br>属性可以表示任意的信息，如类型、串、内存位置等。</p>\n<p>将语义规则和语法规则（产生式）联系起来涉及两个概念：<br>    语法制导定义（Syntax-directed definitions，SDD）<br>    语法制导翻译方案（Syntax-directed Translation Scheme，SDT）（语义）</p>\n<h2 id=\"后缀表示\"><a href=\"#后缀表示\" class=\"headerlink\" title=\"后缀表示\"></a>后缀表示</h2><p>表达式E的后缀形式可以归纳地定义如下：</p>\n<p>如果E是一个变量或者常量，则E的后缀表示是E本身<br>如果E是形如E1 op E2的表达式，其中op是一个二元操作符，则E的后缀表示是E1’E2’op，这里E1’和E2’分别是E1和E2的后缀表示<br>如果E是形如(E1)的表达式，则E1的后缀表示是E的后缀表示。<br>因为一个表达式的操作符的位置和每个操作符的操作个数(参数数量)只允许后缀表达式的一种解码方式，所以在后缀表示中不需要括号。例如,(9 - 5) + 2的后缀表示是95-2+, 9 - (5 + 2)的后缀表示是952+-</p>\n<p>一个数字记号的后缀形式是该数字本身。</p>\n<h2 id=\"综合属性\"><a href=\"#综合属性\" class=\"headerlink\" title=\"综合属性\"></a>综合属性</h2><p>分析树的某个节点的属性值是由其子节点的属性值确定的。一棵分析树的所有综合属性值的计算只需要分析树的一次自底向上遍历。</p>\n<h2 id=\"继承属性\"><a href=\"#继承属性\" class=\"headerlink\" title=\"继承属性\"></a>继承属性</h2><p>分析树的某个节点的属性值是由其夫节点或则兄弟节点的属性值确定的。</p>\n<h2 id=\"简单的语法指导定义\"><a href=\"#简单的语法指导定义\" class=\"headerlink\" title=\"简单的语法指导定义\"></a>简单的语法指导定义</h2><p><img src=\"/2023/08/yu-fa-zhi-dao-fan-yi-qi/%E7%AE%80%E5%8D%95%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E5%AE%9A%E4%B9%89.png\" alt=\"简单语法指导定义\"></p>\n<h2 id=\"树的遍历\"><a href=\"#树的遍历\" class=\"headerlink\" title=\"树的遍历\"></a>树的遍历</h2><h2 id=\"翻译方案\"><a href=\"#翻译方案\" class=\"headerlink\" title=\"翻译方案\"></a>翻译方案</h2><h1 id=\"语法分析\"><a href=\"#语法分析\" class=\"headerlink\" title=\"语法分析\"></a>语法分析</h1><h2 id=\"自顶向下分析方法\"><a href=\"#自顶向下分析方法\" class=\"headerlink\" title=\"自顶向下分析方法\"></a>自顶向下分析方法</h2><p>为了解释什么是自顶向下分析方法，首先来看一个简单的例子，语法为：</p>\n<p>S -&gt; aS | bS | c<br>需要解析的句子为abac，解析过程如下：</p>\n<p>Working-string         Production<br>S                     S -&gt; aS<br>aS                     S -&gt; bS<br>abS                     S -&gt; aS<br>abaS                 S -&gt; c<br>abac                 ACCEPT<br>下面，一步一步跟踪这个解析过程，查看每一步是如何选择出需要的产生式的。首先，我们的目标是将起始符号 S 展开到 最终句子 abac 。把它们写在同一行来进行比较，如下：</p>\n<p>Working-string         Final-string         Production<br>S                     a bac<br>假设有一个 strcmp 函数来比较符号串 “S” 和 “abac” ，从左向右一个符号一个符号的比较，找到第一个不匹配的符号，也就是 “S” 和 “a”。</p>\n<p>因此，此时必须将中间句子中的 “S” 展开，才能得到最终句子。那如何展开呢？将最终句子中不匹配的这个 “a” ，和 S 的三个产生式的右边 aS 、 bS 和 c 相比，可以看出，只能选择 S -&gt; aS 展开，才可以和 “a” 匹配上，展开后得到中间句子 aS ：</p>\n<p>Working-string         Final-string         Production<br>S                     a bac                 S -&gt; aS<br>a S                     a b ac<br>再次比较此时的中间句子 “aS” 和最终句子 “abac” ，找到的第一个不匹配的符号分别为 “S” 和 “b” ，将 “b” 和 S 的三个产生式比较，发现只能选择 S -&gt; bS ，展开后得到中间句子 abS ：</p>\n<p>Working-string         Final-string         Production<br>S                     a bac                 S -&gt; aS<br>a S                     a b ac                 S -&gt; bS<br>ab S                 ab a c<br>按以上原则，每次都对中间句子和最终句子进行比较，找到第一个不匹配的符号，然后利用不匹配的符号挑选出需要的产生式，最终展开到最终句子：</p>\n<p>Working-string         Final-string         Production<br>S                     a bac                 S -&gt; aS<br>a S                     a b ac                 S -&gt; bS<br>ab S                 ab a c                 S -&gt; aS<br>aba S                 aba c                 S -&gt; c<br>abac                 abac                 ACCEPT<br>因此自顶向下分析方法的基本思路为：</p>\n<p>每个推导步中，从左向右比较中间句子和最终句子，找到第一个不匹配的符号，如：中间句子为 u X v 、最终句子为 u a w 。显然，a 一定是终结符， X 则可能为非终结符，也可能为终结符，有以下 4 种情况：</p>\n<p>情况 A ： X 为终结符，这种情况表明无论怎么展开都不可能展开到最终句子，即最终句子不合语法，此时终止推导。</p>\n<p>情况 B ： X 为非终结符，假设它的所有产生式为 X -&gt; u1 | u2 | … | un ，将 a 和这些产生式的右边 u1, u2, … , un 相比较，找出可以和 a 匹配的 ui ，将 ui 代替中间句子 u X v 中的 X ，得到下一个中间句子 u ui v，然后开始下一轮展开。</p>\n<p>情况 C ： X 为非终结符，但它的所有产生式的右边 u1, u2, … , un 中，没有一个可以和 “a” 匹配上，这种情况表明最终句子不合语法，此时终止推导。</p>\n<p>情况 D ： X 为非终结符，但它的所有产生式的右边 u1, u2, … , un 中，有两个或以上的 ui 可以和 “a” 匹配上，这种情况表明此语法不适于用自顶向下分析方法，需要修改语法。</p>\n<h2 id=\"预测性分析法\"><a href=\"#预测性分析法\" class=\"headerlink\" title=\"预测性分析法\"></a>预测性分析法</h2><h3 id=\"文法\"><a href=\"#文法\" class=\"headerlink\" title=\"文法\"></a>文法</h3><h3 id=\"消除左递归\"><a href=\"#消除左递归\" class=\"headerlink\" title=\"消除左递归\"></a>消除左递归</h3><h3 id=\"FIRST集\"><a href=\"#FIRST集\" class=\"headerlink\" title=\"FIRST集\"></a>FIRST集</h3><h3 id=\"FOLLOW集\"><a href=\"#FOLLOW集\" class=\"headerlink\" title=\"FOLLOW集\"></a>FOLLOW集</h3><h3 id=\"预测表\"><a href=\"#预测表\" class=\"headerlink\" title=\"预测表\"></a>预测表</h3><h3 id=\"分析句子\"><a href=\"#分析句子\" class=\"headerlink\" title=\"分析句子\"></a>分析句子</h3><h2 id=\"何时使用E产生式\"><a href=\"#何时使用E产生式\" class=\"headerlink\" title=\"何时使用E产生式\"></a>何时使用E产生式</h2><h2 id=\"设计一个预分析器\"><a href=\"#设计一个预分析器\" class=\"headerlink\" title=\"设计一个预分析器\"></a>设计一个预分析器</h2><h2 id=\"左递归\"><a href=\"#左递归\" class=\"headerlink\" title=\"左递归\"></a>左递归</h2><p>参考链接：<br><a href=\"https://pandolia.net/tinyc/index.html\" target=\"_blank\" rel=\"noopener\">自己动手写编译器</a><br><a href=\"https://blog.csdn.net/m0_54759841/article/details/124001965\" target=\"_blank\" rel=\"noopener\">LL1预测分析法代码</a><br><a href=\"https://blog.csdn.net/CooperNiu/article/details/78524688\" target=\"_blank\" rel=\"noopener\">LL1预测分析法-first-follow-select集</a></p>\n"},{"title":"process-dropbear","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-09-12T02:27:12.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"\n# dropbear线程\nDropbear是一个轻量级的SSH服务器和客户端程序，用于安全地远程访问和管理计算机系统。它被设计成非常小巧和高效，适用于资源受限的环境，如嵌入式系统和嵌入式设备。Dropbear是一个自由开源软件项目，通常在类似于Linux的操作系统中使用。\n\n以下是Dropbear的一些主要特点和信息：\n\n1. **轻量级和高效性能：** Dropbear的代码基础相对较小，这使得它在资源有限的系统上运行速度快，并占用较少的内存。\n\n2. **SSH功能：** Dropbear提供了SSH服务器和客户端功能。SSH（Secure Shell）是一种加密的网络协议，用于在网络上安全地远程登录到其他计算机系统并执行命令。\n\n3. **安全性：** Dropbear致力于提供强大的安全性。它支持现代的SSH协议，包括加密、认证和密钥管理，以确保通信的机密性和完整性。\n\n4. **简化配置：** Dropbear的配置文件相对简单，易于管理。它通常具有类似于OpenSSH的配置选项，但具有更小的配置文件和更少的依赖项。\n\n5. **适用于嵌入式系统：** Dropbear经常用于嵌入式系统、路由器和其他嵌入式设备，因为它占用的系统资源较少，且易于集成。\n\n总的来说，Dropbear是一个小巧、高效且安全的SSH实现，适用于各种嵌入式和资源有限的环境，以提供安全的远程访问和管理功能。它与其他SSH服务器（如OpenSSH）功能相似，但更适合于需要小型、快速、低资源占用的用例。\n\n# 移植\n[dropbear官网](https://matt.ucc.asn.au/dropbear/dropbear.html)\n\n## 软件下载\n\n[zlib](http://www.zlib.net/)\n[dropbear](http://matt.ucc.asn.au/dropbear/releases/)\n\n## 软件编译\n### zlib编译\n1). 解压zlib：\n\n    tar -zxvf zlib1.2.8.tar.gz -C /usr/local/zlib/src   (此处目录根据自己情况定义)\n\n2). 进入zlib的解压目录\n\n    cd /usr/local/zlib/src\n\n3). 配置zlib\n\n    ./configure --prefix=/usr/local/zlib  (即将zlib的库生成到该目录下)  \n\n4). 上面步骤做完，将会生成Makefile，vim进去，修改Makefile\n\n    CC=/home/qq/toolchain/bin/arm-openwrt-linux-gcc  //你交叉编译工具的绝对路径  \n    AR=/home/qq/toolchain/bin/arm-openwrt-linux-gcc-ar  \n    RANLIB=/home/qq/toolchain/bin/arm-openwrt-linux-gcc-ranlib    \n    LDSHARED=/home/qq/toolchain/bin/arm-openwrt-linux-gcc -shared   -Wl,-soname,libz.so.1,--version-script,zlib.map   //(我只是将原来的gcc改成了我自己的编译工具，后面的参数没动过)\n\n5). 执行make\n6). 执行make install\n\n完成以上步骤，你去/usr/local/zlib目录下看，会发现多了几个目录，代表zlib交叉编译成功！！\n\n### dropbear编译\n1). 解压dropbear：\n\n    tar -jxvf dropbear-2016.74.tar.bz2 -C /usr/local/dropbear/src   //(此处目录根据自己情况定义)\n\n2). 进入dropbear的解压目录\n\n    cd /usr/local/dropbear/src\n\n3). 配置dropbear\n\n./configure --prefix=/usr/local/dropbear  --with-zlib=/usr/local/zlib/ CC=/home/qq/toolchain/bin/arm-openwrt-linux-gcc --host=arm  //(根据自己的情况修改)\n\n4). 上面步骤做完，Makefile内的CC会自动修改掉，不用再人为修改Makefile了\n5). 执行make\n\n    make PROGRAMS=\"dropbear dbclient dropbearkey dropbearconvert scp\" \n\n6). 执行make install\n\n    make PROGRAMS=\"dropbear dbclient dropbearkey dropbearconvert scp\" install\n\n7). 注意，因为默认不编译scp，PROGRAMS=xxx是强制编译出scp来，不这样干也可以，但是需要自己生成scp：\n\n    make scp  \n    cp scp /usr/local/dropbear\n\n完成以上步骤，你去/usr/local/dropbear目录下看，会发现多了几个目录，代表dropbear交叉编译成功！！\n\n# 移植文件到开发板上\n\n    将/usr/local/dropbear/bin/移植到板卡的/usr/bin/下；\n    将/usr/local/dropbear/sbin/下的文件都复制到板卡的/usr/sbin/目录下\n\n```shell\nroot@ATK-IMX6U:/usr/sbin# ls -l | grep drop*\nBinary file dropbearconvert matches\nBinary file dropbearkey matches\nBinary file dropbearmulti matches\n\nroot@ATK-IMX6U:/usr/bin# ls -l | grep drop*\n-rwxr-xr-x   1 root root  19K Jul 20 10:22 apt-cdrom\nlrwxrwxrwx   1 root root   23 Jan  1  1970 dbclient -> /usr/sbin/dropbearmulti\nlrwxrwxrwx   1 root root   23 Jan  1  1970 scp -> /usr/sbin/dropbearmulti\nlrwxrwxrwx   1 root root   23 Jan  1  1970 ssh -> /usr/sbin/dropbearmulti\n```\n\n# 配置开机启动\n在etc/rc5.d中创建链接文件指向../init.d/dropbear\n```shell\nln -s /etc/init.d/dropbear /etc/rc5.d/S10dropbear\n```\n```shell\nroot@ATK-IMX6U:/etc/rc5.d# ls -l | grep dro*\nlrwxrwxrwx 1 root root 18 Jan  1  1970 S10dropbear -> ../init.d/dropbear\n```\n在etc/init.d中创建dropbear文件\n```shell\n#!/bin/sh\n### BEGIN INIT INFO\n# Provides:           sshd\n# Required-Start:     $remote_fs $syslog $networking\n# Required-Stop:      $remote_fs $syslog\n# Default-Start:      2 3 4 5\n# Default-Stop:       1\n# Short-Description:  Dropbear Secure Shell server\n### END INIT INFO\n#\n# Do not configure this file. Edit /etc/default/dropbear instead!\n# 请不要直接编辑此文件，请编辑 /etc/default/dropbear 文件来配置Dropbear服务。\n\n# 设置PATH环境变量，指定脚本执行时可执行文件的搜索路径\nPATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin\n\n# Dropbear可执行文件的路径\nDAEMON=/usr/sbin/dropbear\n\n# 服务的名称\nNAME=dropbear\n\n# 服务的描述\nDESC=\"Dropbear SSH server\"\n\n# 保存Dropbear进程的PID的文件路径\nPIDFILE=/var/run/dropbear.pid\n\n# Dropbear监听的SSH端口，默认是22\nDROPBEAR_PORT=22\n\n# Dropbear附加参数，默认为空\nDROPBEAR_EXTRA_ARGS=\n\n# 是否禁止启动Dropbear服务的标志，0表示不禁止\nNO_START=0\n\nset -e\n\ntest ! -r /etc/default/dropbear || . /etc/default/dropbear\ntest \"$NO_START\" = \"0\" || exit 0\ntest -x \"$DAEMON\" || exit 0\ntest ! -h /var/service/dropbear || exit 0\n\n# 设置一个标志，用于检测文件系统是否为只读（readonly_rootfs=0表示不是只读）\nreadonly_rootfs=0\nfor flag in `awk '{ if ($2 == \"/\") { split($4,FLAGS,\",\") } }; END { for (f in FLAGS) print FLAGS[f] }' </proc/mounts`; do\n  case $flag in\n   ro)\n     readonly_rootfs=1\n     ;;\n  esac\ndone\n\n# 根据文件系统是否只读，设置Dropbear的密钥文件路径\nif [ $readonly_rootfs = \"1\" ]; then\n  mkdir -p /var/lib/dropbear\n  DROPBEAR_RSAKEY_DEFAULT=\"/var/lib/dropbear/dropbear_rsa_host_key\"\n  DROPBEAR_DSSKEY_DEFAULT=\"/var/lib/dropbear/dropbear_dss_host_key\"\nelse\n  DROPBEAR_RSAKEY_DEFAULT=\"/etc/dropbear/dropbear_rsa_host_key\"\n  DROPBEAR_DSSKEY_DEFAULT=\"/etc/dropbear/dropbear_dss_host_key\"\nfi\n\n# 如果用户配置了DROPBEAR_BANNER，将其添加到Dropbear附加参数中\ntest -z \"$DROPBEAR_BANNER\" || \\\n  DROPBEAR_EXTRA_ARGS=\"$DROPBEAR_EXTRA_ARGS -b $DROPBEAR_BANNER\"\n\n# 如果用户没有配置DROPBEAR_RSAKEY，默认使用DROPBEAR_RSAKEY_DEFAULT\ntest -n \"$DROPBEAR_RSAKEY\" || \\\n  DROPBEAR_RSAKEY=$DROPBEAR_RSAKEY_DEFAULT\n\n# 如果用户没有配置DROPBEAR_DSSKEY，默认使用DROPBEAR_DSSKEY_DEFAULT\ntest -n \"$DROPBEAR_DSSKEY\" || \\\n  DROPBEAR_DSSKEY=$DROPBEAR_DSSKEY_DEFAULT\n\n# 如果用户没有配置DROPBEAR_KEYTYPES，默认使用\"rsa\"作为密钥类型\ntest -n \"$DROPBEAR_KEYTYPES\" || \\\n  DROPBEAR_KEYTYPES=\"rsa\"\n\n# 生成Dropbear密钥\ngen_keys() {\nfor t in $DROPBEAR_KEYTYPES; do\n  case $t in\n    rsa)\n        if [ -f \"$DROPBEAR_RSAKEY\" -a ! -s \"$DROPBEAR_RSAKEY\" ]; then\n                rm $DROPBEAR_RSAKEY || true\n        fi\n        test -f $DROPBEAR_RSAKEY || dropbearkey -t rsa -f $DROPBEAR_RSAKEY\n\t;;\n    dsa)\n        if [ -f \"$DROPBEAR_DSSKEY\" -a ! -s \"$DROPBEAR_DSSKEY\" ]; then\n                rm $DROPBEAR_DSSKEY || true\n        fi\n        test -f $DROPBEAR_DSSKEY || dropbearkey -t dss -f $DROPBEAR_DSSKEY\n\t;;\n  esac\ndone\n}\n\n# 根据启动参数执行不同的操作\ncase \"$1\" in\n  start)\n    echo -n \"Starting $DESC: \"\n    gen_keys\n    KEY_ARGS=\"\"\n    test -f $DROPBEAR_DSSKEY && KEY_ARGS=\"$KEY_ARGS -d $DROPBEAR_DSSKEY\"\n    test -f $DROPBEAR_RSAKEY && KEY_ARGS=\"$KEY_ARGS -r $DROPBEAR_RSAKEY\"\n    start-stop-daemon -S -p $PIDFILE \\\n      -x \"$DAEMON\" -- $KEY_ARGS \\\n        -p \"$DROPBEAR_PORT\" $DROPBEAR_EXTRA_ARGS\n    echo \"$NAME.\"\n    ;;\n  stop)\n    echo -n \"Stopping $DESC: \"\n    start-stop-daemon -K -x \"$DAEMON\" -p $PIDFILE\n    echo \"$NAME.\"\n    ;;\n  restart|force-reload)\n    echo -n \"Restarting $DESC: \"\n    start-stop-daemon -K -x \"$DAEMON\" -p $PIDFILE\n    sleep 1\n    KEY_ARGS=\"\"\n    test -f $DROPBEAR_DSSKEY && KEY_ARGS=\"$KEY_ARGS -d $DROPBEAR_DSSKEY\"\n    test -f $DROPBEAR_RSAKEY && KEY_ARGS=\"$KEY_ARGS -r $DROPBEAR_RSAKEY\"\n    start-stop-daemon -S -p $PIDFILE \\\n      -x \"$DAEMON\" -- $KEY_ARGS \\\n        -p \"$DROPBEAR_PORT\" $DROPBEAR_EXTRA_ARGS\n    echo \"$NAME.\"\n    ;;\n  *)\n    N=/etc/init.d/$NAME\n    echo \"Usage: $N {start|stop|restart|force-reload}\" >&2\n    exit 1\n    ;;\nesac\n\nexit 0\n\n```\n\n# dropbear使用\n[dhclient命令](https://linux265.com/course/linux-command-dhclient.html)\n[scp命令](https://linux265.com/course/linux-command-scp.html)\n[SSH命令](https://linux265.com/news/2283.html)\n这三命令都是dropbearmulti参数\n/usr/sbin中有 `dropbearmulti`、`dropbearkey` 和 `dropbearconvert` 是与 Dropbear 相关的辅助工具，用于不同的任务, 都是由dropbear编译生成的.\n\n1. **dropbearmulti**：\n\n   `dropbearmulti` 是 Dropbear 的多实例执行工具。它允许在同一系统上运行多个 Dropbear SSH 服务器实例，每个实例可以监听不同的端口、使用不同的密钥等配置。这对于需要同时提供多个 SSH 服务的情况很有用，例如，一个服务器可以监听默认的 SSH 端口 22，而另一个实例可以监听另一个自定义的端口，以提供额外的安全性。\n\n2. **dropbearkey**：\n\n   `dropbearkey` 是 Dropbear 的密钥生成工具。它用于生成 SSH 密钥对，包括 RSA 和 DSA 密钥。这些密钥对用于身份验证和数据加密，是建立安全 SSH 连接所必需的组成部分。`dropbearkey` 可以用于生成服务器的主机密钥和用户的身份验证密钥。\n\n3. **dropbearconvert**：\n\n   `dropbearconvert` 是 Dropbear 的密钥格式转换工具。它用于将不同格式的 SSH 密钥（如 OpenSSH 格式）转换为 Dropbear 可以识别的格式。这对于在不同 SSH 服务器之间迁移密钥或在不同格式的密钥之间进行转换很有用。例如，如果你有一个 OpenSSH 格式的密钥，但想在 Dropbear 上使用，你可以使用 `dropbearconvert` 来转换它。\n\n这些工具通常与 Dropbear 一起提供，并在配置和管理 SSH 服务器时非常有用。它们使用户能够生成、管理和迁移 SSH 密钥，以及配置多个 Dropbear SSH 服务器实例，以满足不同的需求。\n","source":"_posts/2023/09/process-dropbear.md","raw":"---\ntitle: process-dropbear\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-09-12 10:27:12\npassword:\nsummary:\ntags:\n- linux\n- process\ncategories:\n- process\n- linux\nkeywords:\ndescription:\n---\n\n# dropbear线程\nDropbear是一个轻量级的SSH服务器和客户端程序，用于安全地远程访问和管理计算机系统。它被设计成非常小巧和高效，适用于资源受限的环境，如嵌入式系统和嵌入式设备。Dropbear是一个自由开源软件项目，通常在类似于Linux的操作系统中使用。\n\n以下是Dropbear的一些主要特点和信息：\n\n1. **轻量级和高效性能：** Dropbear的代码基础相对较小，这使得它在资源有限的系统上运行速度快，并占用较少的内存。\n\n2. **SSH功能：** Dropbear提供了SSH服务器和客户端功能。SSH（Secure Shell）是一种加密的网络协议，用于在网络上安全地远程登录到其他计算机系统并执行命令。\n\n3. **安全性：** Dropbear致力于提供强大的安全性。它支持现代的SSH协议，包括加密、认证和密钥管理，以确保通信的机密性和完整性。\n\n4. **简化配置：** Dropbear的配置文件相对简单，易于管理。它通常具有类似于OpenSSH的配置选项，但具有更小的配置文件和更少的依赖项。\n\n5. **适用于嵌入式系统：** Dropbear经常用于嵌入式系统、路由器和其他嵌入式设备，因为它占用的系统资源较少，且易于集成。\n\n总的来说，Dropbear是一个小巧、高效且安全的SSH实现，适用于各种嵌入式和资源有限的环境，以提供安全的远程访问和管理功能。它与其他SSH服务器（如OpenSSH）功能相似，但更适合于需要小型、快速、低资源占用的用例。\n\n# 移植\n[dropbear官网](https://matt.ucc.asn.au/dropbear/dropbear.html)\n\n## 软件下载\n\n[zlib](http://www.zlib.net/)\n[dropbear](http://matt.ucc.asn.au/dropbear/releases/)\n\n## 软件编译\n### zlib编译\n1). 解压zlib：\n\n    tar -zxvf zlib1.2.8.tar.gz -C /usr/local/zlib/src   (此处目录根据自己情况定义)\n\n2). 进入zlib的解压目录\n\n    cd /usr/local/zlib/src\n\n3). 配置zlib\n\n    ./configure --prefix=/usr/local/zlib  (即将zlib的库生成到该目录下)  \n\n4). 上面步骤做完，将会生成Makefile，vim进去，修改Makefile\n\n    CC=/home/qq/toolchain/bin/arm-openwrt-linux-gcc  //你交叉编译工具的绝对路径  \n    AR=/home/qq/toolchain/bin/arm-openwrt-linux-gcc-ar  \n    RANLIB=/home/qq/toolchain/bin/arm-openwrt-linux-gcc-ranlib    \n    LDSHARED=/home/qq/toolchain/bin/arm-openwrt-linux-gcc -shared   -Wl,-soname,libz.so.1,--version-script,zlib.map   //(我只是将原来的gcc改成了我自己的编译工具，后面的参数没动过)\n\n5). 执行make\n6). 执行make install\n\n完成以上步骤，你去/usr/local/zlib目录下看，会发现多了几个目录，代表zlib交叉编译成功！！\n\n### dropbear编译\n1). 解压dropbear：\n\n    tar -jxvf dropbear-2016.74.tar.bz2 -C /usr/local/dropbear/src   //(此处目录根据自己情况定义)\n\n2). 进入dropbear的解压目录\n\n    cd /usr/local/dropbear/src\n\n3). 配置dropbear\n\n./configure --prefix=/usr/local/dropbear  --with-zlib=/usr/local/zlib/ CC=/home/qq/toolchain/bin/arm-openwrt-linux-gcc --host=arm  //(根据自己的情况修改)\n\n4). 上面步骤做完，Makefile内的CC会自动修改掉，不用再人为修改Makefile了\n5). 执行make\n\n    make PROGRAMS=\"dropbear dbclient dropbearkey dropbearconvert scp\" \n\n6). 执行make install\n\n    make PROGRAMS=\"dropbear dbclient dropbearkey dropbearconvert scp\" install\n\n7). 注意，因为默认不编译scp，PROGRAMS=xxx是强制编译出scp来，不这样干也可以，但是需要自己生成scp：\n\n    make scp  \n    cp scp /usr/local/dropbear\n\n完成以上步骤，你去/usr/local/dropbear目录下看，会发现多了几个目录，代表dropbear交叉编译成功！！\n\n# 移植文件到开发板上\n\n    将/usr/local/dropbear/bin/移植到板卡的/usr/bin/下；\n    将/usr/local/dropbear/sbin/下的文件都复制到板卡的/usr/sbin/目录下\n\n```shell\nroot@ATK-IMX6U:/usr/sbin# ls -l | grep drop*\nBinary file dropbearconvert matches\nBinary file dropbearkey matches\nBinary file dropbearmulti matches\n\nroot@ATK-IMX6U:/usr/bin# ls -l | grep drop*\n-rwxr-xr-x   1 root root  19K Jul 20 10:22 apt-cdrom\nlrwxrwxrwx   1 root root   23 Jan  1  1970 dbclient -> /usr/sbin/dropbearmulti\nlrwxrwxrwx   1 root root   23 Jan  1  1970 scp -> /usr/sbin/dropbearmulti\nlrwxrwxrwx   1 root root   23 Jan  1  1970 ssh -> /usr/sbin/dropbearmulti\n```\n\n# 配置开机启动\n在etc/rc5.d中创建链接文件指向../init.d/dropbear\n```shell\nln -s /etc/init.d/dropbear /etc/rc5.d/S10dropbear\n```\n```shell\nroot@ATK-IMX6U:/etc/rc5.d# ls -l | grep dro*\nlrwxrwxrwx 1 root root 18 Jan  1  1970 S10dropbear -> ../init.d/dropbear\n```\n在etc/init.d中创建dropbear文件\n```shell\n#!/bin/sh\n### BEGIN INIT INFO\n# Provides:           sshd\n# Required-Start:     $remote_fs $syslog $networking\n# Required-Stop:      $remote_fs $syslog\n# Default-Start:      2 3 4 5\n# Default-Stop:       1\n# Short-Description:  Dropbear Secure Shell server\n### END INIT INFO\n#\n# Do not configure this file. Edit /etc/default/dropbear instead!\n# 请不要直接编辑此文件，请编辑 /etc/default/dropbear 文件来配置Dropbear服务。\n\n# 设置PATH环境变量，指定脚本执行时可执行文件的搜索路径\nPATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin\n\n# Dropbear可执行文件的路径\nDAEMON=/usr/sbin/dropbear\n\n# 服务的名称\nNAME=dropbear\n\n# 服务的描述\nDESC=\"Dropbear SSH server\"\n\n# 保存Dropbear进程的PID的文件路径\nPIDFILE=/var/run/dropbear.pid\n\n# Dropbear监听的SSH端口，默认是22\nDROPBEAR_PORT=22\n\n# Dropbear附加参数，默认为空\nDROPBEAR_EXTRA_ARGS=\n\n# 是否禁止启动Dropbear服务的标志，0表示不禁止\nNO_START=0\n\nset -e\n\ntest ! -r /etc/default/dropbear || . /etc/default/dropbear\ntest \"$NO_START\" = \"0\" || exit 0\ntest -x \"$DAEMON\" || exit 0\ntest ! -h /var/service/dropbear || exit 0\n\n# 设置一个标志，用于检测文件系统是否为只读（readonly_rootfs=0表示不是只读）\nreadonly_rootfs=0\nfor flag in `awk '{ if ($2 == \"/\") { split($4,FLAGS,\",\") } }; END { for (f in FLAGS) print FLAGS[f] }' </proc/mounts`; do\n  case $flag in\n   ro)\n     readonly_rootfs=1\n     ;;\n  esac\ndone\n\n# 根据文件系统是否只读，设置Dropbear的密钥文件路径\nif [ $readonly_rootfs = \"1\" ]; then\n  mkdir -p /var/lib/dropbear\n  DROPBEAR_RSAKEY_DEFAULT=\"/var/lib/dropbear/dropbear_rsa_host_key\"\n  DROPBEAR_DSSKEY_DEFAULT=\"/var/lib/dropbear/dropbear_dss_host_key\"\nelse\n  DROPBEAR_RSAKEY_DEFAULT=\"/etc/dropbear/dropbear_rsa_host_key\"\n  DROPBEAR_DSSKEY_DEFAULT=\"/etc/dropbear/dropbear_dss_host_key\"\nfi\n\n# 如果用户配置了DROPBEAR_BANNER，将其添加到Dropbear附加参数中\ntest -z \"$DROPBEAR_BANNER\" || \\\n  DROPBEAR_EXTRA_ARGS=\"$DROPBEAR_EXTRA_ARGS -b $DROPBEAR_BANNER\"\n\n# 如果用户没有配置DROPBEAR_RSAKEY，默认使用DROPBEAR_RSAKEY_DEFAULT\ntest -n \"$DROPBEAR_RSAKEY\" || \\\n  DROPBEAR_RSAKEY=$DROPBEAR_RSAKEY_DEFAULT\n\n# 如果用户没有配置DROPBEAR_DSSKEY，默认使用DROPBEAR_DSSKEY_DEFAULT\ntest -n \"$DROPBEAR_DSSKEY\" || \\\n  DROPBEAR_DSSKEY=$DROPBEAR_DSSKEY_DEFAULT\n\n# 如果用户没有配置DROPBEAR_KEYTYPES，默认使用\"rsa\"作为密钥类型\ntest -n \"$DROPBEAR_KEYTYPES\" || \\\n  DROPBEAR_KEYTYPES=\"rsa\"\n\n# 生成Dropbear密钥\ngen_keys() {\nfor t in $DROPBEAR_KEYTYPES; do\n  case $t in\n    rsa)\n        if [ -f \"$DROPBEAR_RSAKEY\" -a ! -s \"$DROPBEAR_RSAKEY\" ]; then\n                rm $DROPBEAR_RSAKEY || true\n        fi\n        test -f $DROPBEAR_RSAKEY || dropbearkey -t rsa -f $DROPBEAR_RSAKEY\n\t;;\n    dsa)\n        if [ -f \"$DROPBEAR_DSSKEY\" -a ! -s \"$DROPBEAR_DSSKEY\" ]; then\n                rm $DROPBEAR_DSSKEY || true\n        fi\n        test -f $DROPBEAR_DSSKEY || dropbearkey -t dss -f $DROPBEAR_DSSKEY\n\t;;\n  esac\ndone\n}\n\n# 根据启动参数执行不同的操作\ncase \"$1\" in\n  start)\n    echo -n \"Starting $DESC: \"\n    gen_keys\n    KEY_ARGS=\"\"\n    test -f $DROPBEAR_DSSKEY && KEY_ARGS=\"$KEY_ARGS -d $DROPBEAR_DSSKEY\"\n    test -f $DROPBEAR_RSAKEY && KEY_ARGS=\"$KEY_ARGS -r $DROPBEAR_RSAKEY\"\n    start-stop-daemon -S -p $PIDFILE \\\n      -x \"$DAEMON\" -- $KEY_ARGS \\\n        -p \"$DROPBEAR_PORT\" $DROPBEAR_EXTRA_ARGS\n    echo \"$NAME.\"\n    ;;\n  stop)\n    echo -n \"Stopping $DESC: \"\n    start-stop-daemon -K -x \"$DAEMON\" -p $PIDFILE\n    echo \"$NAME.\"\n    ;;\n  restart|force-reload)\n    echo -n \"Restarting $DESC: \"\n    start-stop-daemon -K -x \"$DAEMON\" -p $PIDFILE\n    sleep 1\n    KEY_ARGS=\"\"\n    test -f $DROPBEAR_DSSKEY && KEY_ARGS=\"$KEY_ARGS -d $DROPBEAR_DSSKEY\"\n    test -f $DROPBEAR_RSAKEY && KEY_ARGS=\"$KEY_ARGS -r $DROPBEAR_RSAKEY\"\n    start-stop-daemon -S -p $PIDFILE \\\n      -x \"$DAEMON\" -- $KEY_ARGS \\\n        -p \"$DROPBEAR_PORT\" $DROPBEAR_EXTRA_ARGS\n    echo \"$NAME.\"\n    ;;\n  *)\n    N=/etc/init.d/$NAME\n    echo \"Usage: $N {start|stop|restart|force-reload}\" >&2\n    exit 1\n    ;;\nesac\n\nexit 0\n\n```\n\n# dropbear使用\n[dhclient命令](https://linux265.com/course/linux-command-dhclient.html)\n[scp命令](https://linux265.com/course/linux-command-scp.html)\n[SSH命令](https://linux265.com/news/2283.html)\n这三命令都是dropbearmulti参数\n/usr/sbin中有 `dropbearmulti`、`dropbearkey` 和 `dropbearconvert` 是与 Dropbear 相关的辅助工具，用于不同的任务, 都是由dropbear编译生成的.\n\n1. **dropbearmulti**：\n\n   `dropbearmulti` 是 Dropbear 的多实例执行工具。它允许在同一系统上运行多个 Dropbear SSH 服务器实例，每个实例可以监听不同的端口、使用不同的密钥等配置。这对于需要同时提供多个 SSH 服务的情况很有用，例如，一个服务器可以监听默认的 SSH 端口 22，而另一个实例可以监听另一个自定义的端口，以提供额外的安全性。\n\n2. **dropbearkey**：\n\n   `dropbearkey` 是 Dropbear 的密钥生成工具。它用于生成 SSH 密钥对，包括 RSA 和 DSA 密钥。这些密钥对用于身份验证和数据加密，是建立安全 SSH 连接所必需的组成部分。`dropbearkey` 可以用于生成服务器的主机密钥和用户的身份验证密钥。\n\n3. **dropbearconvert**：\n\n   `dropbearconvert` 是 Dropbear 的密钥格式转换工具。它用于将不同格式的 SSH 密钥（如 OpenSSH 格式）转换为 Dropbear 可以识别的格式。这对于在不同 SSH 服务器之间迁移密钥或在不同格式的密钥之间进行转换很有用。例如，如果你有一个 OpenSSH 格式的密钥，但想在 Dropbear 上使用，你可以使用 `dropbearconvert` 来转换它。\n\n这些工具通常与 Dropbear 一起提供，并在配置和管理 SSH 服务器时非常有用。它们使用户能够生成、管理和迁移 SSH 密钥，以及配置多个 Dropbear SSH 服务器实例，以满足不同的需求。\n","slug":"process-dropbear","published":1,"updated":"2024-01-05T08:12:19.869Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clru1g2250036s4fuukfseg7s","content":"<h1 id=\"dropbear线程\"><a href=\"#dropbear线程\" class=\"headerlink\" title=\"dropbear线程\"></a>dropbear线程</h1><p>Dropbear是一个轻量级的SSH服务器和客户端程序，用于安全地远程访问和管理计算机系统。它被设计成非常小巧和高效，适用于资源受限的环境，如嵌入式系统和嵌入式设备。Dropbear是一个自由开源软件项目，通常在类似于Linux的操作系统中使用。</p>\n<p>以下是Dropbear的一些主要特点和信息：</p>\n<ol>\n<li><p><strong>轻量级和高效性能：</strong> Dropbear的代码基础相对较小，这使得它在资源有限的系统上运行速度快，并占用较少的内存。</p>\n</li>\n<li><p><strong>SSH功能：</strong> Dropbear提供了SSH服务器和客户端功能。SSH（Secure Shell）是一种加密的网络协议，用于在网络上安全地远程登录到其他计算机系统并执行命令。</p>\n</li>\n<li><p><strong>安全性：</strong> Dropbear致力于提供强大的安全性。它支持现代的SSH协议，包括加密、认证和密钥管理，以确保通信的机密性和完整性。</p>\n</li>\n<li><p><strong>简化配置：</strong> Dropbear的配置文件相对简单，易于管理。它通常具有类似于OpenSSH的配置选项，但具有更小的配置文件和更少的依赖项。</p>\n</li>\n<li><p><strong>适用于嵌入式系统：</strong> Dropbear经常用于嵌入式系统、路由器和其他嵌入式设备，因为它占用的系统资源较少，且易于集成。</p>\n</li>\n</ol>\n<p>总的来说，Dropbear是一个小巧、高效且安全的SSH实现，适用于各种嵌入式和资源有限的环境，以提供安全的远程访问和管理功能。它与其他SSH服务器（如OpenSSH）功能相似，但更适合于需要小型、快速、低资源占用的用例。</p>\n<h1 id=\"移植\"><a href=\"#移植\" class=\"headerlink\" title=\"移植\"></a>移植</h1><p><a href=\"https://matt.ucc.asn.au/dropbear/dropbear.html\" target=\"_blank\" rel=\"noopener\">dropbear官网</a></p>\n<h2 id=\"软件下载\"><a href=\"#软件下载\" class=\"headerlink\" title=\"软件下载\"></a>软件下载</h2><p><a href=\"http://www.zlib.net/\" target=\"_blank\" rel=\"noopener\">zlib</a><br><a href=\"http://matt.ucc.asn.au/dropbear/releases/\" target=\"_blank\" rel=\"noopener\">dropbear</a></p>\n<h2 id=\"软件编译\"><a href=\"#软件编译\" class=\"headerlink\" title=\"软件编译\"></a>软件编译</h2><h3 id=\"zlib编译\"><a href=\"#zlib编译\" class=\"headerlink\" title=\"zlib编译\"></a>zlib编译</h3><p>1). 解压zlib：</p>\n<pre><code>tar -zxvf zlib1.2.8.tar.gz -C /usr/local/zlib/src   (此处目录根据自己情况定义)</code></pre><p>2). 进入zlib的解压目录</p>\n<pre><code>cd /usr/local/zlib/src</code></pre><p>3). 配置zlib</p>\n<pre><code>./configure --prefix=/usr/local/zlib  (即将zlib的库生成到该目录下)  </code></pre><p>4). 上面步骤做完，将会生成Makefile，vim进去，修改Makefile</p>\n<pre><code>CC=/home/qq/toolchain/bin/arm-openwrt-linux-gcc  //你交叉编译工具的绝对路径  \nAR=/home/qq/toolchain/bin/arm-openwrt-linux-gcc-ar  \nRANLIB=/home/qq/toolchain/bin/arm-openwrt-linux-gcc-ranlib    \nLDSHARED=/home/qq/toolchain/bin/arm-openwrt-linux-gcc -shared   -Wl,-soname,libz.so.1,--version-script,zlib.map   //(我只是将原来的gcc改成了我自己的编译工具，后面的参数没动过)</code></pre><p>5). 执行make<br>6). 执行make install</p>\n<p>完成以上步骤，你去/usr/local/zlib目录下看，会发现多了几个目录，代表zlib交叉编译成功！！</p>\n<h3 id=\"dropbear编译\"><a href=\"#dropbear编译\" class=\"headerlink\" title=\"dropbear编译\"></a>dropbear编译</h3><p>1). 解压dropbear：</p>\n<pre><code>tar -jxvf dropbear-2016.74.tar.bz2 -C /usr/local/dropbear/src   //(此处目录根据自己情况定义)</code></pre><p>2). 进入dropbear的解压目录</p>\n<pre><code>cd /usr/local/dropbear/src</code></pre><p>3). 配置dropbear</p>\n<p>./configure –prefix=/usr/local/dropbear  –with-zlib=/usr/local/zlib/ CC=/home/qq/toolchain/bin/arm-openwrt-linux-gcc –host=arm  //(根据自己的情况修改)</p>\n<p>4). 上面步骤做完，Makefile内的CC会自动修改掉，不用再人为修改Makefile了<br>5). 执行make</p>\n<pre><code>make PROGRAMS=&quot;dropbear dbclient dropbearkey dropbearconvert scp&quot; </code></pre><p>6). 执行make install</p>\n<pre><code>make PROGRAMS=&quot;dropbear dbclient dropbearkey dropbearconvert scp&quot; install</code></pre><p>7). 注意，因为默认不编译scp，PROGRAMS=xxx是强制编译出scp来，不这样干也可以，但是需要自己生成scp：</p>\n<pre><code>make scp  \ncp scp /usr/local/dropbear</code></pre><p>完成以上步骤，你去/usr/local/dropbear目录下看，会发现多了几个目录，代表dropbear交叉编译成功！！</p>\n<h1 id=\"移植文件到开发板上\"><a href=\"#移植文件到开发板上\" class=\"headerlink\" title=\"移植文件到开发板上\"></a>移植文件到开发板上</h1><pre><code>将/usr/local/dropbear/bin/移植到板卡的/usr/bin/下；\n将/usr/local/dropbear/sbin/下的文件都复制到板卡的/usr/sbin/目录下</code></pre><pre class=\" language-shell\"><code class=\"language-shell\">root@ATK-IMX6U:/usr/sbin# ls -l | grep drop*\nBinary file dropbearconvert matches\nBinary file dropbearkey matches\nBinary file dropbearmulti matches\n\nroot@ATK-IMX6U:/usr/bin# ls -l | grep drop*\n-rwxr-xr-x   1 root root  19K Jul 20 10:22 apt-cdrom\nlrwxrwxrwx   1 root root   23 Jan  1  1970 dbclient -> /usr/sbin/dropbearmulti\nlrwxrwxrwx   1 root root   23 Jan  1  1970 scp -> /usr/sbin/dropbearmulti\nlrwxrwxrwx   1 root root   23 Jan  1  1970 ssh -> /usr/sbin/dropbearmulti</code></pre>\n<h1 id=\"配置开机启动\"><a href=\"#配置开机启动\" class=\"headerlink\" title=\"配置开机启动\"></a>配置开机启动</h1><p>在etc/rc5.d中创建链接文件指向../init.d/dropbear</p>\n<pre class=\" language-shell\"><code class=\"language-shell\">ln -s /etc/init.d/dropbear /etc/rc5.d/S10dropbear</code></pre>\n<pre class=\" language-shell\"><code class=\"language-shell\">root@ATK-IMX6U:/etc/rc5.d# ls -l | grep dro*\nlrwxrwxrwx 1 root root 18 Jan  1  1970 S10dropbear -> ../init.d/dropbear</code></pre>\n<p>在etc/init.d中创建dropbear文件</p>\n<pre class=\" language-shell\"><code class=\"language-shell\">#!/bin/sh\n### BEGIN INIT INFO\n# Provides:           sshd\n# Required-Start:     $remote_fs $syslog $networking\n# Required-Stop:      $remote_fs $syslog\n# Default-Start:      2 3 4 5\n# Default-Stop:       1\n# Short-Description:  Dropbear Secure Shell server\n### END INIT INFO\n#\n# Do not configure this file. Edit /etc/default/dropbear instead!\n# 请不要直接编辑此文件，请编辑 /etc/default/dropbear 文件来配置Dropbear服务。\n\n# 设置PATH环境变量，指定脚本执行时可执行文件的搜索路径\nPATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin\n\n# Dropbear可执行文件的路径\nDAEMON=/usr/sbin/dropbear\n\n# 服务的名称\nNAME=dropbear\n\n# 服务的描述\nDESC=\"Dropbear SSH server\"\n\n# 保存Dropbear进程的PID的文件路径\nPIDFILE=/var/run/dropbear.pid\n\n# Dropbear监听的SSH端口，默认是22\nDROPBEAR_PORT=22\n\n# Dropbear附加参数，默认为空\nDROPBEAR_EXTRA_ARGS=\n\n# 是否禁止启动Dropbear服务的标志，0表示不禁止\nNO_START=0\n\nset -e\n\ntest ! -r /etc/default/dropbear || . /etc/default/dropbear\ntest \"$NO_START\" = \"0\" || exit 0\ntest -x \"$DAEMON\" || exit 0\ntest ! -h /var/service/dropbear || exit 0\n\n# 设置一个标志，用于检测文件系统是否为只读（readonly_rootfs=0表示不是只读）\nreadonly_rootfs=0\nfor flag in `awk '{ if ($2 == \"/\") { split($4,FLAGS,\",\") } }; END { for (f in FLAGS) print FLAGS[f] }' </proc/mounts`; do\n  case $flag in\n   ro)\n     readonly_rootfs=1\n     ;;\n  esac\ndone\n\n# 根据文件系统是否只读，设置Dropbear的密钥文件路径\nif [ $readonly_rootfs = \"1\" ]; then\n  mkdir -p /var/lib/dropbear\n  DROPBEAR_RSAKEY_DEFAULT=\"/var/lib/dropbear/dropbear_rsa_host_key\"\n  DROPBEAR_DSSKEY_DEFAULT=\"/var/lib/dropbear/dropbear_dss_host_key\"\nelse\n  DROPBEAR_RSAKEY_DEFAULT=\"/etc/dropbear/dropbear_rsa_host_key\"\n  DROPBEAR_DSSKEY_DEFAULT=\"/etc/dropbear/dropbear_dss_host_key\"\nfi\n\n# 如果用户配置了DROPBEAR_BANNER，将其添加到Dropbear附加参数中\ntest -z \"$DROPBEAR_BANNER\" || \\\n  DROPBEAR_EXTRA_ARGS=\"$DROPBEAR_EXTRA_ARGS -b $DROPBEAR_BANNER\"\n\n# 如果用户没有配置DROPBEAR_RSAKEY，默认使用DROPBEAR_RSAKEY_DEFAULT\ntest -n \"$DROPBEAR_RSAKEY\" || \\\n  DROPBEAR_RSAKEY=$DROPBEAR_RSAKEY_DEFAULT\n\n# 如果用户没有配置DROPBEAR_DSSKEY，默认使用DROPBEAR_DSSKEY_DEFAULT\ntest -n \"$DROPBEAR_DSSKEY\" || \\\n  DROPBEAR_DSSKEY=$DROPBEAR_DSSKEY_DEFAULT\n\n# 如果用户没有配置DROPBEAR_KEYTYPES，默认使用\"rsa\"作为密钥类型\ntest -n \"$DROPBEAR_KEYTYPES\" || \\\n  DROPBEAR_KEYTYPES=\"rsa\"\n\n# 生成Dropbear密钥\ngen_keys() {\nfor t in $DROPBEAR_KEYTYPES; do\n  case $t in\n    rsa)\n        if [ -f \"$DROPBEAR_RSAKEY\" -a ! -s \"$DROPBEAR_RSAKEY\" ]; then\n                rm $DROPBEAR_RSAKEY || true\n        fi\n        test -f $DROPBEAR_RSAKEY || dropbearkey -t rsa -f $DROPBEAR_RSAKEY\n    ;;\n    dsa)\n        if [ -f \"$DROPBEAR_DSSKEY\" -a ! -s \"$DROPBEAR_DSSKEY\" ]; then\n                rm $DROPBEAR_DSSKEY || true\n        fi\n        test -f $DROPBEAR_DSSKEY || dropbearkey -t dss -f $DROPBEAR_DSSKEY\n    ;;\n  esac\ndone\n}\n\n# 根据启动参数执行不同的操作\ncase \"$1\" in\n  start)\n    echo -n \"Starting $DESC: \"\n    gen_keys\n    KEY_ARGS=\"\"\n    test -f $DROPBEAR_DSSKEY && KEY_ARGS=\"$KEY_ARGS -d $DROPBEAR_DSSKEY\"\n    test -f $DROPBEAR_RSAKEY && KEY_ARGS=\"$KEY_ARGS -r $DROPBEAR_RSAKEY\"\n    start-stop-daemon -S -p $PIDFILE \\\n      -x \"$DAEMON\" -- $KEY_ARGS \\\n        -p \"$DROPBEAR_PORT\" $DROPBEAR_EXTRA_ARGS\n    echo \"$NAME.\"\n    ;;\n  stop)\n    echo -n \"Stopping $DESC: \"\n    start-stop-daemon -K -x \"$DAEMON\" -p $PIDFILE\n    echo \"$NAME.\"\n    ;;\n  restart|force-reload)\n    echo -n \"Restarting $DESC: \"\n    start-stop-daemon -K -x \"$DAEMON\" -p $PIDFILE\n    sleep 1\n    KEY_ARGS=\"\"\n    test -f $DROPBEAR_DSSKEY && KEY_ARGS=\"$KEY_ARGS -d $DROPBEAR_DSSKEY\"\n    test -f $DROPBEAR_RSAKEY && KEY_ARGS=\"$KEY_ARGS -r $DROPBEAR_RSAKEY\"\n    start-stop-daemon -S -p $PIDFILE \\\n      -x \"$DAEMON\" -- $KEY_ARGS \\\n        -p \"$DROPBEAR_PORT\" $DROPBEAR_EXTRA_ARGS\n    echo \"$NAME.\"\n    ;;\n  *)\n    N=/etc/init.d/$NAME\n    echo \"Usage: $N {start|stop|restart|force-reload}\" >&2\n    exit 1\n    ;;\nesac\n\nexit 0\n</code></pre>\n<h1 id=\"dropbear使用\"><a href=\"#dropbear使用\" class=\"headerlink\" title=\"dropbear使用\"></a>dropbear使用</h1><p><a href=\"https://linux265.com/course/linux-command-dhclient.html\" target=\"_blank\" rel=\"noopener\">dhclient命令</a><br><a href=\"https://linux265.com/course/linux-command-scp.html\" target=\"_blank\" rel=\"noopener\">scp命令</a><br><a href=\"https://linux265.com/news/2283.html\" target=\"_blank\" rel=\"noopener\">SSH命令</a><br>这三命令都是dropbearmulti参数<br>/usr/sbin中有 <code>dropbearmulti</code>、<code>dropbearkey</code> 和 <code>dropbearconvert</code> 是与 Dropbear 相关的辅助工具，用于不同的任务, 都是由dropbear编译生成的.</p>\n<ol>\n<li><p><strong>dropbearmulti</strong>：</p>\n<p><code>dropbearmulti</code> 是 Dropbear 的多实例执行工具。它允许在同一系统上运行多个 Dropbear SSH 服务器实例，每个实例可以监听不同的端口、使用不同的密钥等配置。这对于需要同时提供多个 SSH 服务的情况很有用，例如，一个服务器可以监听默认的 SSH 端口 22，而另一个实例可以监听另一个自定义的端口，以提供额外的安全性。</p>\n</li>\n<li><p><strong>dropbearkey</strong>：</p>\n<p><code>dropbearkey</code> 是 Dropbear 的密钥生成工具。它用于生成 SSH 密钥对，包括 RSA 和 DSA 密钥。这些密钥对用于身份验证和数据加密，是建立安全 SSH 连接所必需的组成部分。<code>dropbearkey</code> 可以用于生成服务器的主机密钥和用户的身份验证密钥。</p>\n</li>\n<li><p><strong>dropbearconvert</strong>：</p>\n<p><code>dropbearconvert</code> 是 Dropbear 的密钥格式转换工具。它用于将不同格式的 SSH 密钥（如 OpenSSH 格式）转换为 Dropbear 可以识别的格式。这对于在不同 SSH 服务器之间迁移密钥或在不同格式的密钥之间进行转换很有用。例如，如果你有一个 OpenSSH 格式的密钥，但想在 Dropbear 上使用，你可以使用 <code>dropbearconvert</code> 来转换它。</p>\n</li>\n</ol>\n<p>这些工具通常与 Dropbear 一起提供，并在配置和管理 SSH 服务器时非常有用。它们使用户能够生成、管理和迁移 SSH 密钥，以及配置多个 Dropbear SSH 服务器实例，以满足不同的需求。</p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<h1 id=\"dropbear线程\"><a href=\"#dropbear线程\" class=\"headerlink\" title=\"dropbear线程\"></a>dropbear线程</h1><p>Dropbear是一个轻量级的SSH服务器和客户端程序，用于安全地远程访问和管理计算机系统。它被设计成非常小巧和高效，适用于资源受限的环境，如嵌入式系统和嵌入式设备。Dropbear是一个自由开源软件项目，通常在类似于Linux的操作系统中使用。</p>\n<p>以下是Dropbear的一些主要特点和信息：</p>\n<ol>\n<li><p><strong>轻量级和高效性能：</strong> Dropbear的代码基础相对较小，这使得它在资源有限的系统上运行速度快，并占用较少的内存。</p>\n</li>\n<li><p><strong>SSH功能：</strong> Dropbear提供了SSH服务器和客户端功能。SSH（Secure Shell）是一种加密的网络协议，用于在网络上安全地远程登录到其他计算机系统并执行命令。</p>\n</li>\n<li><p><strong>安全性：</strong> Dropbear致力于提供强大的安全性。它支持现代的SSH协议，包括加密、认证和密钥管理，以确保通信的机密性和完整性。</p>\n</li>\n<li><p><strong>简化配置：</strong> Dropbear的配置文件相对简单，易于管理。它通常具有类似于OpenSSH的配置选项，但具有更小的配置文件和更少的依赖项。</p>\n</li>\n<li><p><strong>适用于嵌入式系统：</strong> Dropbear经常用于嵌入式系统、路由器和其他嵌入式设备，因为它占用的系统资源较少，且易于集成。</p>\n</li>\n</ol>\n<p>总的来说，Dropbear是一个小巧、高效且安全的SSH实现，适用于各种嵌入式和资源有限的环境，以提供安全的远程访问和管理功能。它与其他SSH服务器（如OpenSSH）功能相似，但更适合于需要小型、快速、低资源占用的用例。</p>\n<h1 id=\"移植\"><a href=\"#移植\" class=\"headerlink\" title=\"移植\"></a>移植</h1><p><a href=\"https://matt.ucc.asn.au/dropbear/dropbear.html\" target=\"_blank\" rel=\"noopener\">dropbear官网</a></p>\n<h2 id=\"软件下载\"><a href=\"#软件下载\" class=\"headerlink\" title=\"软件下载\"></a>软件下载</h2><p><a href=\"http://www.zlib.net/\" target=\"_blank\" rel=\"noopener\">zlib</a><br><a href=\"http://matt.ucc.asn.au/dropbear/releases/\" target=\"_blank\" rel=\"noopener\">dropbear</a></p>\n<h2 id=\"软件编译\"><a href=\"#软件编译\" class=\"headerlink\" title=\"软件编译\"></a>软件编译</h2><h3 id=\"zlib编译\"><a href=\"#zlib编译\" class=\"headerlink\" title=\"zlib编译\"></a>zlib编译</h3><p>1). 解压zlib：</p>\n<pre><code>tar -zxvf zlib1.2.8.tar.gz -C /usr/local/zlib/src   (此处目录根据自己情况定义)</code></pre><p>2). 进入zlib的解压目录</p>\n<pre><code>cd /usr/local/zlib/src</code></pre><p>3). 配置zlib</p>\n<pre><code>./configure --prefix=/usr/local/zlib  (即将zlib的库生成到该目录下)  </code></pre><p>4). 上面步骤做完，将会生成Makefile，vim进去，修改Makefile</p>\n<pre><code>CC=/home/qq/toolchain/bin/arm-openwrt-linux-gcc  //你交叉编译工具的绝对路径  \nAR=/home/qq/toolchain/bin/arm-openwrt-linux-gcc-ar  \nRANLIB=/home/qq/toolchain/bin/arm-openwrt-linux-gcc-ranlib    \nLDSHARED=/home/qq/toolchain/bin/arm-openwrt-linux-gcc -shared   -Wl,-soname,libz.so.1,--version-script,zlib.map   //(我只是将原来的gcc改成了我自己的编译工具，后面的参数没动过)</code></pre><p>5). 执行make<br>6). 执行make install</p>\n<p>完成以上步骤，你去/usr/local/zlib目录下看，会发现多了几个目录，代表zlib交叉编译成功！！</p>\n<h3 id=\"dropbear编译\"><a href=\"#dropbear编译\" class=\"headerlink\" title=\"dropbear编译\"></a>dropbear编译</h3><p>1). 解压dropbear：</p>\n<pre><code>tar -jxvf dropbear-2016.74.tar.bz2 -C /usr/local/dropbear/src   //(此处目录根据自己情况定义)</code></pre><p>2). 进入dropbear的解压目录</p>\n<pre><code>cd /usr/local/dropbear/src</code></pre><p>3). 配置dropbear</p>\n<p>./configure –prefix=/usr/local/dropbear  –with-zlib=/usr/local/zlib/ CC=/home/qq/toolchain/bin/arm-openwrt-linux-gcc –host=arm  //(根据自己的情况修改)</p>\n<p>4). 上面步骤做完，Makefile内的CC会自动修改掉，不用再人为修改Makefile了<br>5). 执行make</p>\n<pre><code>make PROGRAMS=&quot;dropbear dbclient dropbearkey dropbearconvert scp&quot; </code></pre><p>6). 执行make install</p>\n<pre><code>make PROGRAMS=&quot;dropbear dbclient dropbearkey dropbearconvert scp&quot; install</code></pre><p>7). 注意，因为默认不编译scp，PROGRAMS=xxx是强制编译出scp来，不这样干也可以，但是需要自己生成scp：</p>\n<pre><code>make scp  \ncp scp /usr/local/dropbear</code></pre><p>完成以上步骤，你去/usr/local/dropbear目录下看，会发现多了几个目录，代表dropbear交叉编译成功！！</p>\n<h1 id=\"移植文件到开发板上\"><a href=\"#移植文件到开发板上\" class=\"headerlink\" title=\"移植文件到开发板上\"></a>移植文件到开发板上</h1><pre><code>将/usr/local/dropbear/bin/移植到板卡的/usr/bin/下；\n将/usr/local/dropbear/sbin/下的文件都复制到板卡的/usr/sbin/目录下</code></pre><pre><code class=\"shell\">root@ATK-IMX6U:/usr/sbin# ls -l | grep drop*\nBinary file dropbearconvert matches\nBinary file dropbearkey matches\nBinary file dropbearmulti matches\n\nroot@ATK-IMX6U:/usr/bin# ls -l | grep drop*\n-rwxr-xr-x   1 root root  19K Jul 20 10:22 apt-cdrom\nlrwxrwxrwx   1 root root   23 Jan  1  1970 dbclient -&gt; /usr/sbin/dropbearmulti\nlrwxrwxrwx   1 root root   23 Jan  1  1970 scp -&gt; /usr/sbin/dropbearmulti\nlrwxrwxrwx   1 root root   23 Jan  1  1970 ssh -&gt; /usr/sbin/dropbearmulti</code></pre>\n<h1 id=\"配置开机启动\"><a href=\"#配置开机启动\" class=\"headerlink\" title=\"配置开机启动\"></a>配置开机启动</h1><p>在etc/rc5.d中创建链接文件指向../init.d/dropbear</p>\n<pre><code class=\"shell\">ln -s /etc/init.d/dropbear /etc/rc5.d/S10dropbear</code></pre>\n<pre><code class=\"shell\">root@ATK-IMX6U:/etc/rc5.d# ls -l | grep dro*\nlrwxrwxrwx 1 root root 18 Jan  1  1970 S10dropbear -&gt; ../init.d/dropbear</code></pre>\n<p>在etc/init.d中创建dropbear文件</p>\n<pre><code class=\"shell\">#!/bin/sh\n### BEGIN INIT INFO\n# Provides:           sshd\n# Required-Start:     $remote_fs $syslog $networking\n# Required-Stop:      $remote_fs $syslog\n# Default-Start:      2 3 4 5\n# Default-Stop:       1\n# Short-Description:  Dropbear Secure Shell server\n### END INIT INFO\n#\n# Do not configure this file. Edit /etc/default/dropbear instead!\n# 请不要直接编辑此文件，请编辑 /etc/default/dropbear 文件来配置Dropbear服务。\n\n# 设置PATH环境变量，指定脚本执行时可执行文件的搜索路径\nPATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin\n\n# Dropbear可执行文件的路径\nDAEMON=/usr/sbin/dropbear\n\n# 服务的名称\nNAME=dropbear\n\n# 服务的描述\nDESC=&quot;Dropbear SSH server&quot;\n\n# 保存Dropbear进程的PID的文件路径\nPIDFILE=/var/run/dropbear.pid\n\n# Dropbear监听的SSH端口，默认是22\nDROPBEAR_PORT=22\n\n# Dropbear附加参数，默认为空\nDROPBEAR_EXTRA_ARGS=\n\n# 是否禁止启动Dropbear服务的标志，0表示不禁止\nNO_START=0\n\nset -e\n\ntest ! -r /etc/default/dropbear || . /etc/default/dropbear\ntest &quot;$NO_START&quot; = &quot;0&quot; || exit 0\ntest -x &quot;$DAEMON&quot; || exit 0\ntest ! -h /var/service/dropbear || exit 0\n\n# 设置一个标志，用于检测文件系统是否为只读（readonly_rootfs=0表示不是只读）\nreadonly_rootfs=0\nfor flag in `awk &#39;{ if ($2 == &quot;/&quot;) { split($4,FLAGS,&quot;,&quot;) } }; END { for (f in FLAGS) print FLAGS[f] }&#39; &lt;/proc/mounts`; do\n  case $flag in\n   ro)\n     readonly_rootfs=1\n     ;;\n  esac\ndone\n\n# 根据文件系统是否只读，设置Dropbear的密钥文件路径\nif [ $readonly_rootfs = &quot;1&quot; ]; then\n  mkdir -p /var/lib/dropbear\n  DROPBEAR_RSAKEY_DEFAULT=&quot;/var/lib/dropbear/dropbear_rsa_host_key&quot;\n  DROPBEAR_DSSKEY_DEFAULT=&quot;/var/lib/dropbear/dropbear_dss_host_key&quot;\nelse\n  DROPBEAR_RSAKEY_DEFAULT=&quot;/etc/dropbear/dropbear_rsa_host_key&quot;\n  DROPBEAR_DSSKEY_DEFAULT=&quot;/etc/dropbear/dropbear_dss_host_key&quot;\nfi\n\n# 如果用户配置了DROPBEAR_BANNER，将其添加到Dropbear附加参数中\ntest -z &quot;$DROPBEAR_BANNER&quot; || \\\n  DROPBEAR_EXTRA_ARGS=&quot;$DROPBEAR_EXTRA_ARGS -b $DROPBEAR_BANNER&quot;\n\n# 如果用户没有配置DROPBEAR_RSAKEY，默认使用DROPBEAR_RSAKEY_DEFAULT\ntest -n &quot;$DROPBEAR_RSAKEY&quot; || \\\n  DROPBEAR_RSAKEY=$DROPBEAR_RSAKEY_DEFAULT\n\n# 如果用户没有配置DROPBEAR_DSSKEY，默认使用DROPBEAR_DSSKEY_DEFAULT\ntest -n &quot;$DROPBEAR_DSSKEY&quot; || \\\n  DROPBEAR_DSSKEY=$DROPBEAR_DSSKEY_DEFAULT\n\n# 如果用户没有配置DROPBEAR_KEYTYPES，默认使用&quot;rsa&quot;作为密钥类型\ntest -n &quot;$DROPBEAR_KEYTYPES&quot; || \\\n  DROPBEAR_KEYTYPES=&quot;rsa&quot;\n\n# 生成Dropbear密钥\ngen_keys() {\nfor t in $DROPBEAR_KEYTYPES; do\n  case $t in\n    rsa)\n        if [ -f &quot;$DROPBEAR_RSAKEY&quot; -a ! -s &quot;$DROPBEAR_RSAKEY&quot; ]; then\n                rm $DROPBEAR_RSAKEY || true\n        fi\n        test -f $DROPBEAR_RSAKEY || dropbearkey -t rsa -f $DROPBEAR_RSAKEY\n    ;;\n    dsa)\n        if [ -f &quot;$DROPBEAR_DSSKEY&quot; -a ! -s &quot;$DROPBEAR_DSSKEY&quot; ]; then\n                rm $DROPBEAR_DSSKEY || true\n        fi\n        test -f $DROPBEAR_DSSKEY || dropbearkey -t dss -f $DROPBEAR_DSSKEY\n    ;;\n  esac\ndone\n}\n\n# 根据启动参数执行不同的操作\ncase &quot;$1&quot; in\n  start)\n    echo -n &quot;Starting $DESC: &quot;\n    gen_keys\n    KEY_ARGS=&quot;&quot;\n    test -f $DROPBEAR_DSSKEY &amp;&amp; KEY_ARGS=&quot;$KEY_ARGS -d $DROPBEAR_DSSKEY&quot;\n    test -f $DROPBEAR_RSAKEY &amp;&amp; KEY_ARGS=&quot;$KEY_ARGS -r $DROPBEAR_RSAKEY&quot;\n    start-stop-daemon -S -p $PIDFILE \\\n      -x &quot;$DAEMON&quot; -- $KEY_ARGS \\\n        -p &quot;$DROPBEAR_PORT&quot; $DROPBEAR_EXTRA_ARGS\n    echo &quot;$NAME.&quot;\n    ;;\n  stop)\n    echo -n &quot;Stopping $DESC: &quot;\n    start-stop-daemon -K -x &quot;$DAEMON&quot; -p $PIDFILE\n    echo &quot;$NAME.&quot;\n    ;;\n  restart|force-reload)\n    echo -n &quot;Restarting $DESC: &quot;\n    start-stop-daemon -K -x &quot;$DAEMON&quot; -p $PIDFILE\n    sleep 1\n    KEY_ARGS=&quot;&quot;\n    test -f $DROPBEAR_DSSKEY &amp;&amp; KEY_ARGS=&quot;$KEY_ARGS -d $DROPBEAR_DSSKEY&quot;\n    test -f $DROPBEAR_RSAKEY &amp;&amp; KEY_ARGS=&quot;$KEY_ARGS -r $DROPBEAR_RSAKEY&quot;\n    start-stop-daemon -S -p $PIDFILE \\\n      -x &quot;$DAEMON&quot; -- $KEY_ARGS \\\n        -p &quot;$DROPBEAR_PORT&quot; $DROPBEAR_EXTRA_ARGS\n    echo &quot;$NAME.&quot;\n    ;;\n  *)\n    N=/etc/init.d/$NAME\n    echo &quot;Usage: $N {start|stop|restart|force-reload}&quot; &gt;&amp;2\n    exit 1\n    ;;\nesac\n\nexit 0\n</code></pre>\n<h1 id=\"dropbear使用\"><a href=\"#dropbear使用\" class=\"headerlink\" title=\"dropbear使用\"></a>dropbear使用</h1><p><a href=\"https://linux265.com/course/linux-command-dhclient.html\" target=\"_blank\" rel=\"noopener\">dhclient命令</a><br><a href=\"https://linux265.com/course/linux-command-scp.html\" target=\"_blank\" rel=\"noopener\">scp命令</a><br><a href=\"https://linux265.com/news/2283.html\" target=\"_blank\" rel=\"noopener\">SSH命令</a><br>这三命令都是dropbearmulti参数<br>/usr/sbin中有 <code>dropbearmulti</code>、<code>dropbearkey</code> 和 <code>dropbearconvert</code> 是与 Dropbear 相关的辅助工具，用于不同的任务, 都是由dropbear编译生成的.</p>\n<ol>\n<li><p><strong>dropbearmulti</strong>：</p>\n<p><code>dropbearmulti</code> 是 Dropbear 的多实例执行工具。它允许在同一系统上运行多个 Dropbear SSH 服务器实例，每个实例可以监听不同的端口、使用不同的密钥等配置。这对于需要同时提供多个 SSH 服务的情况很有用，例如，一个服务器可以监听默认的 SSH 端口 22，而另一个实例可以监听另一个自定义的端口，以提供额外的安全性。</p>\n</li>\n<li><p><strong>dropbearkey</strong>：</p>\n<p><code>dropbearkey</code> 是 Dropbear 的密钥生成工具。它用于生成 SSH 密钥对，包括 RSA 和 DSA 密钥。这些密钥对用于身份验证和数据加密，是建立安全 SSH 连接所必需的组成部分。<code>dropbearkey</code> 可以用于生成服务器的主机密钥和用户的身份验证密钥。</p>\n</li>\n<li><p><strong>dropbearconvert</strong>：</p>\n<p><code>dropbearconvert</code> 是 Dropbear 的密钥格式转换工具。它用于将不同格式的 SSH 密钥（如 OpenSSH 格式）转换为 Dropbear 可以识别的格式。这对于在不同 SSH 服务器之间迁移密钥或在不同格式的密钥之间进行转换很有用。例如，如果你有一个 OpenSSH 格式的密钥，但想在 Dropbear 上使用，你可以使用 <code>dropbearconvert</code> 来转换它。</p>\n</li>\n</ol>\n<p>这些工具通常与 Dropbear 一起提供，并在配置和管理 SSH 服务器时非常有用。它们使用户能够生成、管理和迁移 SSH 密钥，以及配置多个 Dropbear SSH 服务器实例，以满足不同的需求。</p>\n"},{"title":"Medical device registration standards","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-09-14T01:51:28.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"\n![Medical device registration standards](Medical-device-registration-standards/2023-09-14_10-00-13.png)\n[xmind文件地址](https://gitee.com/qian-qiang/study-notes/tree/master/Medical_Devices)","source":"_posts/2023/09/Medical-device-registration-standards.md","raw":"---\ntitle: Medical device registration standards\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-09-14 09:51:28\npassword:\nsummary:\ntags:\n- 医疗器械软件\ncategories:\n- Embedded system\nkeywords:\ndescription:\n---\n\n![Medical device registration standards](Medical-device-registration-standards/2023-09-14_10-00-13.png)\n[xmind文件地址](https://gitee.com/qian-qiang/study-notes/tree/master/Medical_Devices)","slug":"Medical-device-registration-standards","published":1,"updated":"2024-01-05T08:12:19.847Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clru1g2270039s4fulr5c5f3a","content":"<p><img src=\"/2023/09/medical-device-registration-standards/2023-09-14_10-00-13.png\" alt=\"Medical device registration standards\"><br><a href=\"https://gitee.com/qian-qiang/study-notes/tree/master/Medical_Devices\" target=\"_blank\" rel=\"noopener\">xmind文件地址</a></p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<p><img src=\"/2023/09/medical-device-registration-standards/2023-09-14_10-00-13.png\" alt=\"Medical device registration standards\"><br><a href=\"https://gitee.com/qian-qiang/study-notes/tree/master/Medical_Devices\" target=\"_blank\" rel=\"noopener\">xmind文件地址</a></p>\n"},{"title":"日落","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-09-12T07:06:06.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"\n![微信图片_20230912150619.jpg](微信图片_20230912150619.jpg)\n![微信图片_20230912150614.jpg](微信图片_20230912150614.jpg)\n![微信图片_20230912150606.jpg](微信图片_20230912150606.jpg)\n![微信图片_20230912150554.jpg](微信图片_20230912150554.jpg)\n![微信图片_20230912150602.jpg](微信图片_20230912150602.jpg)\n![微信图片_20230912150536.jpg](微信图片_20230912150536.jpg)\n![微信图片_20230912150622.jpg](微信图片_20230912150622.jpg)\n![微信图片_20230912090924.png](微信图片_20230912090924.png)\n![微信图片_20230912150610.jpg](微信图片_20230912150610.jpg)\n![微信图片_20230912150558.jpg](微信图片_20230912150558.jpg)\n","source":"_posts/2023/09/日落.md","raw":"---\ntitle: 日落\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-09-12 15:06:06\npassword:\nsummary:\ntags:\n- gallery-日落\ncategories:\n- gallery\nkeywords:\ndescription:\n---\n\n![微信图片_20230912150619.jpg](微信图片_20230912150619.jpg)\n![微信图片_20230912150614.jpg](微信图片_20230912150614.jpg)\n![微信图片_20230912150606.jpg](微信图片_20230912150606.jpg)\n![微信图片_20230912150554.jpg](微信图片_20230912150554.jpg)\n![微信图片_20230912150602.jpg](微信图片_20230912150602.jpg)\n![微信图片_20230912150536.jpg](微信图片_20230912150536.jpg)\n![微信图片_20230912150622.jpg](微信图片_20230912150622.jpg)\n![微信图片_20230912090924.png](微信图片_20230912090924.png)\n![微信图片_20230912150610.jpg](微信图片_20230912150610.jpg)\n![微信图片_20230912150558.jpg](微信图片_20230912150558.jpg)\n","slug":"日落","published":1,"updated":"2024-01-05T08:12:19.870Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clru1g229003bs4fuf1z176lp","content":"<p><img src=\"/2023/09/ri-luo/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230912150619.jpg\" alt=\"微信图片_20230912150619.jpg\"><br><img src=\"/2023/09/ri-luo/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230912150614.jpg\" alt=\"微信图片_20230912150614.jpg\"><br><img src=\"/2023/09/ri-luo/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230912150606.jpg\" alt=\"微信图片_20230912150606.jpg\"><br><img src=\"/2023/09/ri-luo/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230912150554.jpg\" alt=\"微信图片_20230912150554.jpg\"><br><img src=\"/2023/09/ri-luo/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230912150602.jpg\" alt=\"微信图片_20230912150602.jpg\"><br><img src=\"/2023/09/ri-luo/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230912150536.jpg\" alt=\"微信图片_20230912150536.jpg\"><br><img src=\"/2023/09/ri-luo/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230912150622.jpg\" alt=\"微信图片_20230912150622.jpg\"><br><img src=\"/2023/09/ri-luo/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230912090924.png\" alt=\"微信图片_20230912090924.png\"><br><img src=\"/2023/09/ri-luo/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230912150610.jpg\" alt=\"微信图片_20230912150610.jpg\"><br><img src=\"/2023/09/ri-luo/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230912150558.jpg\" alt=\"微信图片_20230912150558.jpg\"></p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<p><img src=\"/2023/09/ri-luo/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230912150619.jpg\" alt=\"微信图片_20230912150619.jpg\"><br><img src=\"/2023/09/ri-luo/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230912150614.jpg\" alt=\"微信图片_20230912150614.jpg\"><br><img src=\"/2023/09/ri-luo/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230912150606.jpg\" alt=\"微信图片_20230912150606.jpg\"><br><img src=\"/2023/09/ri-luo/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230912150554.jpg\" alt=\"微信图片_20230912150554.jpg\"><br><img src=\"/2023/09/ri-luo/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230912150602.jpg\" alt=\"微信图片_20230912150602.jpg\"><br><img src=\"/2023/09/ri-luo/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230912150536.jpg\" alt=\"微信图片_20230912150536.jpg\"><br><img src=\"/2023/09/ri-luo/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230912150622.jpg\" alt=\"微信图片_20230912150622.jpg\"><br><img src=\"/2023/09/ri-luo/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230912090924.png\" alt=\"微信图片_20230912090924.png\"><br><img src=\"/2023/09/ri-luo/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230912150610.jpg\" alt=\"微信图片_20230912150610.jpg\"><br><img src=\"/2023/09/ri-luo/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230912150558.jpg\" alt=\"微信图片_20230912150558.jpg\"></p>\n"},{"title":"I2C半高电平","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2024-01-05T08:33:21.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"\n# I2C出现半高电平\n![半高电平](I2C半高电平/picture1.jpg)\n\n# 危害\n![逻辑分析仪](I2C半高电平/picture2.jpg)\n通过逻辑分析仪的分析，上图中的半高电平是write完0XA0之后等待从I2C设备的ACK,逻辑分析仪没有抓取到ACK的低电平导致的解析中断。虽然逻辑分析仪的电平是正常的但是通过示波器采样才能看出细节。\n\n# 分析\n## 硬件结构\n\nIIC的接口是OD/OC结构，因此其本身无法输出高电平。\n坏处：\n1、不接外部上拉就只能输出低电平，所以设计的时候千万记得把上拉电阻给留上；\n\n好处：\n1、外部上拉可以减少IC自身的驱动负担；\n2、实现线与（IIC多主机同步时钟和仲裁总线控制权的时候感受就非常明显）；\n3、改变信号电平（在手册允许的范围内甚至能把信号电平整的比IC供电电压还要高）。\n![硬件结构](I2C半高电平/picture3.jpg)\n\n## 时序波形\n![时序波形](I2C半高电平/picture4.jpg)\n\n## ACK响应位出现半高电平\n![](I2C半高电平/picture5.jpg)\n这种情况说白了就是IIC链路上的器件接口不是纯粹的OD/OC，一般多出在可编程器件上，比如说MCU，CPLD。\n如果IIC总线上挂了多个器件，在ACK位的时候，有器件管脚没有配置为OD或者OC，导致芯片内部将该管脚拉高，此时链路上其他的器件又需响应想拉低总线，如果两边链路上都存在串阻，则通过电阻分压会出现中间电平；\n如果没有串阻，或者串阻过小，则可能烧坏器件（灌电流）。总之非常危险，这个半高电平可能出现在任何位置，只不过ACK位容易被忽视，更容易出问题。\n\n# 解决方法\n在将SDA设置成输入之前不要设置延时，如果传输完数据之后延时一段时间等待ACK的话，这个时候还是输入状态而从设备的ACK已经拉低，就会出现中间电平。一直开漏模式也行，因为SDA引脚是加了上拉电阻的，只要输出你先设为高电平，再去读取该引脚，是能正确读取到的ACK的。\n\n> 如何计算I2C的上拉电阻 https://blog.csdn.net/zhi_Alanwu/article/details/133785325","source":"_posts/2024/01/I2C半高电平.md","raw":"---\ntitle: I2C半高电平\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2024-01-05 16:33:21\npassword:\nsummary:\ntags:\n- Embedded system\ncategories:\n- Embedded system\nkeywords:\ndescription:\n---\n\n# I2C出现半高电平\n![半高电平](I2C半高电平/picture1.jpg)\n\n# 危害\n![逻辑分析仪](I2C半高电平/picture2.jpg)\n通过逻辑分析仪的分析，上图中的半高电平是write完0XA0之后等待从I2C设备的ACK,逻辑分析仪没有抓取到ACK的低电平导致的解析中断。虽然逻辑分析仪的电平是正常的但是通过示波器采样才能看出细节。\n\n# 分析\n## 硬件结构\n\nIIC的接口是OD/OC结构，因此其本身无法输出高电平。\n坏处：\n1、不接外部上拉就只能输出低电平，所以设计的时候千万记得把上拉电阻给留上；\n\n好处：\n1、外部上拉可以减少IC自身的驱动负担；\n2、实现线与（IIC多主机同步时钟和仲裁总线控制权的时候感受就非常明显）；\n3、改变信号电平（在手册允许的范围内甚至能把信号电平整的比IC供电电压还要高）。\n![硬件结构](I2C半高电平/picture3.jpg)\n\n## 时序波形\n![时序波形](I2C半高电平/picture4.jpg)\n\n## ACK响应位出现半高电平\n![](I2C半高电平/picture5.jpg)\n这种情况说白了就是IIC链路上的器件接口不是纯粹的OD/OC，一般多出在可编程器件上，比如说MCU，CPLD。\n如果IIC总线上挂了多个器件，在ACK位的时候，有器件管脚没有配置为OD或者OC，导致芯片内部将该管脚拉高，此时链路上其他的器件又需响应想拉低总线，如果两边链路上都存在串阻，则通过电阻分压会出现中间电平；\n如果没有串阻，或者串阻过小，则可能烧坏器件（灌电流）。总之非常危险，这个半高电平可能出现在任何位置，只不过ACK位容易被忽视，更容易出问题。\n\n# 解决方法\n在将SDA设置成输入之前不要设置延时，如果传输完数据之后延时一段时间等待ACK的话，这个时候还是输入状态而从设备的ACK已经拉低，就会出现中间电平。一直开漏模式也行，因为SDA引脚是加了上拉电阻的，只要输出你先设为高电平，再去读取该引脚，是能正确读取到的ACK的。\n\n> 如何计算I2C的上拉电阻 https://blog.csdn.net/zhi_Alanwu/article/details/133785325","slug":"I2C半高电平","published":1,"updated":"2024-01-06T08:12:40.396Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clru1g22b003fs4fux04bf8tb","content":"<h1 id=\"I2C出现半高电平\"><a href=\"#I2C出现半高电平\" class=\"headerlink\" title=\"I2C出现半高电平\"></a>I2C出现半高电平</h1><p><img src=\"/2024/01/i2c-ban-gao-dian-ping/picture1.jpg\" alt=\"半高电平\"></p>\n<h1 id=\"危害\"><a href=\"#危害\" class=\"headerlink\" title=\"危害\"></a>危害</h1><p><img src=\"/2024/01/i2c-ban-gao-dian-ping/picture2.jpg\" alt=\"逻辑分析仪\"><br>通过逻辑分析仪的分析，上图中的半高电平是write完0XA0之后等待从I2C设备的ACK,逻辑分析仪没有抓取到ACK的低电平导致的解析中断。虽然逻辑分析仪的电平是正常的但是通过示波器采样才能看出细节。</p>\n<h1 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h1><h2 id=\"硬件结构\"><a href=\"#硬件结构\" class=\"headerlink\" title=\"硬件结构\"></a>硬件结构</h2><p>IIC的接口是OD/OC结构，因此其本身无法输出高电平。<br>坏处：<br>1、不接外部上拉就只能输出低电平，所以设计的时候千万记得把上拉电阻给留上；</p>\n<p>好处：<br>1、外部上拉可以减少IC自身的驱动负担；<br>2、实现线与（IIC多主机同步时钟和仲裁总线控制权的时候感受就非常明显）；<br>3、改变信号电平（在手册允许的范围内甚至能把信号电平整的比IC供电电压还要高）。<br><img src=\"/2024/01/i2c-ban-gao-dian-ping/picture3.jpg\" alt=\"硬件结构\"></p>\n<h2 id=\"时序波形\"><a href=\"#时序波形\" class=\"headerlink\" title=\"时序波形\"></a>时序波形</h2><p><img src=\"/2024/01/i2c-ban-gao-dian-ping/picture4.jpg\" alt=\"时序波形\"></p>\n<h2 id=\"ACK响应位出现半高电平\"><a href=\"#ACK响应位出现半高电平\" class=\"headerlink\" title=\"ACK响应位出现半高电平\"></a>ACK响应位出现半高电平</h2><p><img src=\"/2024/01/i2c-ban-gao-dian-ping/picture5.jpg\" alt><br>这种情况说白了就是IIC链路上的器件接口不是纯粹的OD/OC，一般多出在可编程器件上，比如说MCU，CPLD。<br>如果IIC总线上挂了多个器件，在ACK位的时候，有器件管脚没有配置为OD或者OC，导致芯片内部将该管脚拉高，此时链路上其他的器件又需响应想拉低总线，如果两边链路上都存在串阻，则通过电阻分压会出现中间电平；<br>如果没有串阻，或者串阻过小，则可能烧坏器件（灌电流）。总之非常危险，这个半高电平可能出现在任何位置，只不过ACK位容易被忽视，更容易出问题。</p>\n<h1 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h1><p>在将SDA设置成输入之前不要设置延时，如果传输完数据之后延时一段时间等待ACK的话，这个时候还是输入状态而从设备的ACK已经拉低，就会出现中间电平。一直开漏模式也行，因为SDA引脚是加了上拉电阻的，只要输出你先设为高电平，再去读取该引脚，是能正确读取到的ACK的。</p>\n<blockquote>\n<p>如何计算I2C的上拉电阻 <a href=\"https://blog.csdn.net/zhi_Alanwu/article/details/133785325\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/zhi_Alanwu/article/details/133785325</a></p>\n</blockquote>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<h1 id=\"I2C出现半高电平\"><a href=\"#I2C出现半高电平\" class=\"headerlink\" title=\"I2C出现半高电平\"></a>I2C出现半高电平</h1><p><img src=\"/2024/01/i2c-ban-gao-dian-ping/picture1.jpg\" alt=\"半高电平\"></p>\n<h1 id=\"危害\"><a href=\"#危害\" class=\"headerlink\" title=\"危害\"></a>危害</h1><p><img src=\"/2024/01/i2c-ban-gao-dian-ping/picture2.jpg\" alt=\"逻辑分析仪\"><br>通过逻辑分析仪的分析，上图中的半高电平是write完0XA0之后等待从I2C设备的ACK,逻辑分析仪没有抓取到ACK的低电平导致的解析中断。虽然逻辑分析仪的电平是正常的但是通过示波器采样才能看出细节。</p>\n<h1 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h1><h2 id=\"硬件结构\"><a href=\"#硬件结构\" class=\"headerlink\" title=\"硬件结构\"></a>硬件结构</h2><p>IIC的接口是OD/OC结构，因此其本身无法输出高电平。<br>坏处：<br>1、不接外部上拉就只能输出低电平，所以设计的时候千万记得把上拉电阻给留上；</p>\n<p>好处：<br>1、外部上拉可以减少IC自身的驱动负担；<br>2、实现线与（IIC多主机同步时钟和仲裁总线控制权的时候感受就非常明显）；<br>3、改变信号电平（在手册允许的范围内甚至能把信号电平整的比IC供电电压还要高）。<br><img src=\"/2024/01/i2c-ban-gao-dian-ping/picture3.jpg\" alt=\"硬件结构\"></p>\n<h2 id=\"时序波形\"><a href=\"#时序波形\" class=\"headerlink\" title=\"时序波形\"></a>时序波形</h2><p><img src=\"/2024/01/i2c-ban-gao-dian-ping/picture4.jpg\" alt=\"时序波形\"></p>\n<h2 id=\"ACK响应位出现半高电平\"><a href=\"#ACK响应位出现半高电平\" class=\"headerlink\" title=\"ACK响应位出现半高电平\"></a>ACK响应位出现半高电平</h2><p><img src=\"/2024/01/i2c-ban-gao-dian-ping/picture5.jpg\" alt><br>这种情况说白了就是IIC链路上的器件接口不是纯粹的OD/OC，一般多出在可编程器件上，比如说MCU，CPLD。<br>如果IIC总线上挂了多个器件，在ACK位的时候，有器件管脚没有配置为OD或者OC，导致芯片内部将该管脚拉高，此时链路上其他的器件又需响应想拉低总线，如果两边链路上都存在串阻，则通过电阻分压会出现中间电平；<br>如果没有串阻，或者串阻过小，则可能烧坏器件（灌电流）。总之非常危险，这个半高电平可能出现在任何位置，只不过ACK位容易被忽视，更容易出问题。</p>\n<h1 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h1><p>在将SDA设置成输入之前不要设置延时，如果传输完数据之后延时一段时间等待ACK的话，这个时候还是输入状态而从设备的ACK已经拉低，就会出现中间电平。一直开漏模式也行，因为SDA引脚是加了上拉电阻的，只要输出你先设为高电平，再去读取该引脚，是能正确读取到的ACK的。</p>\n<blockquote>\n<p>如何计算I2C的上拉电阻 <a href=\"https://blog.csdn.net/zhi_Alanwu/article/details/133785325\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/zhi_Alanwu/article/details/133785325</a></p>\n</blockquote>\n"},{"title":"医疗器械设计输入","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-09-13T08:53:42.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"\n# 医疗器械的软件设计输入\n设计输入一般有三个来源:\n    1:**用户需求**:每一条用户需求都要对应一条或多条设计输入。用户需求比较笼统时，就要把它分解成容易实施的若干条设计输入。用户需求比较具体时，一条用户需求对应一条设计输入即可。\n    2:**法规和标准的要求**:例如GB9706，強制标准的要求，以及注册指导原则等。比较理想的做法是把这些标准和法规的条款列一个表，逐条判定适不适用于正在开发的产品，如果适用，就导入到设计输入里；如果不适用，说明理由为什么不适用。判定的过程应当存档，因为这也是设计历史文档的一部分，同时对今后类似产品的开发也具有参考价值。\n    3:**风险管理（风险分析）**。通过分析每个危害的严重度，发生频率和可探测度，计算得到每个风险的RPN值，以判断风险是否可以接受。对于高风险和中风险危害，需要制定风险缓解措施。这些缓解措施就要导入到设计输入列表里逐一跟踪落实。\n\n&emsp;&emsp;风险管理标准通常包含一个附录，其中列出了一些危害的示例，这些示例是基于标准制定者的经验而列出的。在使用这种方法时，工程师需要仔细检查这个附录中的危害，并判断它们是否适用于他们正在开发的新产品。如果某些危害适用，那么它们将被纳入风险分析表中进行详细研究和评估。如果某些危害不适用于新产品，工程师需要记录下不适用的理由并进行归档。此外，对于具体要设计的医疗器械，工程师还需要根据该产品的特性添加和考虑其他可能的危害。这个过程高度依赖于工程师的专业经验和知识。\n\n&emsp;&emsp;另一种风险管理方法是将风险管理标准的宏观原则与具体产品的实际使用情况相结合。仔细分析每一个工作步骤，考虑每一步可能存在的危害，并计算每个危害的风险优先级数（RPN值）。这种方法着重于对产品实际使用情境的深入理解，并强调在设计过程中反复思考哪些步骤与已有产品相似，哪些步骤可能不同，以及每一步可能引发的潜在风险。\n\n![](Design-Inputs-Outputs-for-Medical-Device/2023-09-13_17-08-45.png)\n\n\n&emsp;&emsp;现在我们简单模拟一下如何将这三个输入来源导入到设计输入中\n\n&emsp;&emsp;假定用户需求评审已经完成，用户需求列表已经确定。我们用UN#表示第#个用户需求。例如UN2是用户需求表里的第2条。这里的UN表示User Needs，即用户需求。当然，你也可以不用UN，而用汉语拼音，或者其它方式编号。\n![](Design-Inputs-Outputs-for-Medical-Device/2023-09-13_17-14-12.png)\n&emsp;&emsp;   这时法规和标准清单也已经完成，[法规来源于国标例如:GB9706,标准清单来源于注册标准等例如:医疗器械软件注册审查指导原则]并且每一条是否适用于本产品也已经判断完成。假定用R#表示这个清单里的第#条。例如R16表示清单里的第16条。这里R表示Regulatory，即法规。\n![](Design-Inputs-Outputs-for-Medical-Device/2023-09-14_9-14-12.png)\n&emsp;&emsp;把法规和标准的要求生成这个清单，不是必须的。只是如果有这个清单，一是可以避免遗漏，二是可以用这张表承载判断各项要求是否适用于本产品的记录。要不要生成这样的清单，取决于研发管理者的风格和思路。\n\n&emsp;&emsp;这时，初次风险分析也已经完成。类似地，用RMO#表示第#条风险分析。例如RMO7表示第7条风险分析。这里RMO表示Risk Management Output，即风险管理输出。\n\n&emsp;&emsp;现在我们把它们汇集到下面的设计输入输出追踪表中：\n![](Design-Inputs-Outputs-for-Medical-Device/2023-09-14_09-16-16.png)\n&emsp;&emsp;上表第三列表示该条设计输入所对应的输入的来源。有可能同一条设计输入同时来源于法规和风险分析，例如上表的第71条。每一条设计输入都对应各自的设计输出以及设计输出的验证与确认。\n\n&emsp;&emsp;在设计输入评审阶段，只要定义每个输入对应的输出的类型即可。例如只要定义输出是图纸，产品清单，还是实验报告，或者公差堆积分析等即可。在这个阶段，还要制定每一条设计输出的验证计划和确认计划。\n\n&emsp;&emsp;在设计输出和验证评审阶段，通过更新这个表来核实每一行的设计验证的执行情况，要在设计验证一列里填写图纸号，或实验报告号，或者其它验证文件编号，名称，生效日期，也要填写核实人的姓名等。\n\n&emsp;&emsp;在设计输出确认评审阶段，继续更新这个追踪表来核实每一行的设计确认的完成情况，要在设计确认那一列列出确认文件的编号，名称，生效日期，核实人姓名等。\n![](Design-Inputs-Outputs-for-Medical-Device/2023-09-14_09-19-28.png)\n&emsp;&emsp;每次设计评审前，都要评估风险分析是否需要更新。随着项目的进行，可能会发现有些用户需求不合理，需要调整。有些风险没有考虑到，需要补充。当用户需求或者分析分析更新时，设计输入输出追踪表要随之更新。法规或标准更新一般有至少一年的缓冲期，产品开发时要提前将新的法规和标准导入进来。\n\n&emsp;&emsp;在整个设计开发过程中，设计输入输出追踪表是设计历史文档的灵魂。它往前与用户需求，法律法规以及风险管理相关联，往后与设计验证与确认文档相关联。产品开发的主要历史文档都在这个表里被引用。抓住这个追踪表，就可以感受到整个产品开发的脉络。这个追踪表也是设计开发过程可追溯性的记录。有多少个设计输入，最后就有多少个设计输出，一个不多，一个不少，一目了然。\n\n&emsp;&emsp;最后需要说明两点，第一，这种设计模式适合瀑布性/预测性项目,如果是敏捷项目应该更加注重人与人之间的互动,同时文档的记录也是有必要的。第二，应该注重管理项目知识，利用已有的组织知识来创造或改进项目成果，并使当前项目创造的知识可用于支持组织运营和未来的项目或阶段。本过程需要在整个项目期间开展,以上观点只作为参考。\n\n-----------","source":"_posts/2023/09/Design-Inputs-Outputs-for-Medical-Device.md","raw":"---\ntitle: 医疗器械设计输入\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-09-13 16:53:42\npassword:\nsummary:\ntags:\n- 医疗器械软件\ncategories:\n- Embedded system\nkeywords:\ndescription:\n---\n\n# 医疗器械的软件设计输入\n设计输入一般有三个来源:\n    1:**用户需求**:每一条用户需求都要对应一条或多条设计输入。用户需求比较笼统时，就要把它分解成容易实施的若干条设计输入。用户需求比较具体时，一条用户需求对应一条设计输入即可。\n    2:**法规和标准的要求**:例如GB9706，強制标准的要求，以及注册指导原则等。比较理想的做法是把这些标准和法规的条款列一个表，逐条判定适不适用于正在开发的产品，如果适用，就导入到设计输入里；如果不适用，说明理由为什么不适用。判定的过程应当存档，因为这也是设计历史文档的一部分，同时对今后类似产品的开发也具有参考价值。\n    3:**风险管理（风险分析）**。通过分析每个危害的严重度，发生频率和可探测度，计算得到每个风险的RPN值，以判断风险是否可以接受。对于高风险和中风险危害，需要制定风险缓解措施。这些缓解措施就要导入到设计输入列表里逐一跟踪落实。\n\n&emsp;&emsp;风险管理标准通常包含一个附录，其中列出了一些危害的示例，这些示例是基于标准制定者的经验而列出的。在使用这种方法时，工程师需要仔细检查这个附录中的危害，并判断它们是否适用于他们正在开发的新产品。如果某些危害适用，那么它们将被纳入风险分析表中进行详细研究和评估。如果某些危害不适用于新产品，工程师需要记录下不适用的理由并进行归档。此外，对于具体要设计的医疗器械，工程师还需要根据该产品的特性添加和考虑其他可能的危害。这个过程高度依赖于工程师的专业经验和知识。\n\n&emsp;&emsp;另一种风险管理方法是将风险管理标准的宏观原则与具体产品的实际使用情况相结合。仔细分析每一个工作步骤，考虑每一步可能存在的危害，并计算每个危害的风险优先级数（RPN值）。这种方法着重于对产品实际使用情境的深入理解，并强调在设计过程中反复思考哪些步骤与已有产品相似，哪些步骤可能不同，以及每一步可能引发的潜在风险。\n\n![](Design-Inputs-Outputs-for-Medical-Device/2023-09-13_17-08-45.png)\n\n\n&emsp;&emsp;现在我们简单模拟一下如何将这三个输入来源导入到设计输入中\n\n&emsp;&emsp;假定用户需求评审已经完成，用户需求列表已经确定。我们用UN#表示第#个用户需求。例如UN2是用户需求表里的第2条。这里的UN表示User Needs，即用户需求。当然，你也可以不用UN，而用汉语拼音，或者其它方式编号。\n![](Design-Inputs-Outputs-for-Medical-Device/2023-09-13_17-14-12.png)\n&emsp;&emsp;   这时法规和标准清单也已经完成，[法规来源于国标例如:GB9706,标准清单来源于注册标准等例如:医疗器械软件注册审查指导原则]并且每一条是否适用于本产品也已经判断完成。假定用R#表示这个清单里的第#条。例如R16表示清单里的第16条。这里R表示Regulatory，即法规。\n![](Design-Inputs-Outputs-for-Medical-Device/2023-09-14_9-14-12.png)\n&emsp;&emsp;把法规和标准的要求生成这个清单，不是必须的。只是如果有这个清单，一是可以避免遗漏，二是可以用这张表承载判断各项要求是否适用于本产品的记录。要不要生成这样的清单，取决于研发管理者的风格和思路。\n\n&emsp;&emsp;这时，初次风险分析也已经完成。类似地，用RMO#表示第#条风险分析。例如RMO7表示第7条风险分析。这里RMO表示Risk Management Output，即风险管理输出。\n\n&emsp;&emsp;现在我们把它们汇集到下面的设计输入输出追踪表中：\n![](Design-Inputs-Outputs-for-Medical-Device/2023-09-14_09-16-16.png)\n&emsp;&emsp;上表第三列表示该条设计输入所对应的输入的来源。有可能同一条设计输入同时来源于法规和风险分析，例如上表的第71条。每一条设计输入都对应各自的设计输出以及设计输出的验证与确认。\n\n&emsp;&emsp;在设计输入评审阶段，只要定义每个输入对应的输出的类型即可。例如只要定义输出是图纸，产品清单，还是实验报告，或者公差堆积分析等即可。在这个阶段，还要制定每一条设计输出的验证计划和确认计划。\n\n&emsp;&emsp;在设计输出和验证评审阶段，通过更新这个表来核实每一行的设计验证的执行情况，要在设计验证一列里填写图纸号，或实验报告号，或者其它验证文件编号，名称，生效日期，也要填写核实人的姓名等。\n\n&emsp;&emsp;在设计输出确认评审阶段，继续更新这个追踪表来核实每一行的设计确认的完成情况，要在设计确认那一列列出确认文件的编号，名称，生效日期，核实人姓名等。\n![](Design-Inputs-Outputs-for-Medical-Device/2023-09-14_09-19-28.png)\n&emsp;&emsp;每次设计评审前，都要评估风险分析是否需要更新。随着项目的进行，可能会发现有些用户需求不合理，需要调整。有些风险没有考虑到，需要补充。当用户需求或者分析分析更新时，设计输入输出追踪表要随之更新。法规或标准更新一般有至少一年的缓冲期，产品开发时要提前将新的法规和标准导入进来。\n\n&emsp;&emsp;在整个设计开发过程中，设计输入输出追踪表是设计历史文档的灵魂。它往前与用户需求，法律法规以及风险管理相关联，往后与设计验证与确认文档相关联。产品开发的主要历史文档都在这个表里被引用。抓住这个追踪表，就可以感受到整个产品开发的脉络。这个追踪表也是设计开发过程可追溯性的记录。有多少个设计输入，最后就有多少个设计输出，一个不多，一个不少，一目了然。\n\n&emsp;&emsp;最后需要说明两点，第一，这种设计模式适合瀑布性/预测性项目,如果是敏捷项目应该更加注重人与人之间的互动,同时文档的记录也是有必要的。第二，应该注重管理项目知识，利用已有的组织知识来创造或改进项目成果，并使当前项目创造的知识可用于支持组织运营和未来的项目或阶段。本过程需要在整个项目期间开展,以上观点只作为参考。\n\n-----------","slug":"Design-Inputs-Outputs-for-Medical-Device","published":1,"updated":"2024-01-05T08:12:19.837Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clru1g22d003hs4fu2vfcxvib","content":"<h1 id=\"医疗器械的软件设计输入\"><a href=\"#医疗器械的软件设计输入\" class=\"headerlink\" title=\"医疗器械的软件设计输入\"></a>医疗器械的软件设计输入</h1><p>设计输入一般有三个来源:<br>    1:<strong>用户需求</strong>:每一条用户需求都要对应一条或多条设计输入。用户需求比较笼统时，就要把它分解成容易实施的若干条设计输入。用户需求比较具体时，一条用户需求对应一条设计输入即可。<br>    2:<strong>法规和标准的要求</strong>:例如GB9706，強制标准的要求，以及注册指导原则等。比较理想的做法是把这些标准和法规的条款列一个表，逐条判定适不适用于正在开发的产品，如果适用，就导入到设计输入里；如果不适用，说明理由为什么不适用。判定的过程应当存档，因为这也是设计历史文档的一部分，同时对今后类似产品的开发也具有参考价值。<br>    3:<strong>风险管理（风险分析）</strong>。通过分析每个危害的严重度，发生频率和可探测度，计算得到每个风险的RPN值，以判断风险是否可以接受。对于高风险和中风险危害，需要制定风险缓解措施。这些缓解措施就要导入到设计输入列表里逐一跟踪落实。</p>\n<p>&emsp;&emsp;风险管理标准通常包含一个附录，其中列出了一些危害的示例，这些示例是基于标准制定者的经验而列出的。在使用这种方法时，工程师需要仔细检查这个附录中的危害，并判断它们是否适用于他们正在开发的新产品。如果某些危害适用，那么它们将被纳入风险分析表中进行详细研究和评估。如果某些危害不适用于新产品，工程师需要记录下不适用的理由并进行归档。此外，对于具体要设计的医疗器械，工程师还需要根据该产品的特性添加和考虑其他可能的危害。这个过程高度依赖于工程师的专业经验和知识。</p>\n<p>&emsp;&emsp;另一种风险管理方法是将风险管理标准的宏观原则与具体产品的实际使用情况相结合。仔细分析每一个工作步骤，考虑每一步可能存在的危害，并计算每个危害的风险优先级数（RPN值）。这种方法着重于对产品实际使用情境的深入理解，并强调在设计过程中反复思考哪些步骤与已有产品相似，哪些步骤可能不同，以及每一步可能引发的潜在风险。</p>\n<p><img src=\"/2023/09/design-inputs-outputs-for-medical-device/2023-09-13_17-08-45.png\" alt></p>\n<p>&emsp;&emsp;现在我们简单模拟一下如何将这三个输入来源导入到设计输入中</p>\n<p>&emsp;&emsp;假定用户需求评审已经完成，用户需求列表已经确定。我们用UN#表示第#个用户需求。例如UN2是用户需求表里的第2条。这里的UN表示User Needs，即用户需求。当然，你也可以不用UN，而用汉语拼音，或者其它方式编号。<br><img src=\"/2023/09/design-inputs-outputs-for-medical-device/2023-09-13_17-14-12.png\" alt><br>&emsp;&emsp;   这时法规和标准清单也已经完成，[法规来源于国标例如:GB9706,标准清单来源于注册标准等例如:医疗器械软件注册审查指导原则]并且每一条是否适用于本产品也已经判断完成。假定用R#表示这个清单里的第#条。例如R16表示清单里的第16条。这里R表示Regulatory，即法规。<br><img src=\"/2023/09/design-inputs-outputs-for-medical-device/2023-09-14_9-14-12.png\" alt><br>&emsp;&emsp;把法规和标准的要求生成这个清单，不是必须的。只是如果有这个清单，一是可以避免遗漏，二是可以用这张表承载判断各项要求是否适用于本产品的记录。要不要生成这样的清单，取决于研发管理者的风格和思路。</p>\n<p>&emsp;&emsp;这时，初次风险分析也已经完成。类似地，用RMO#表示第#条风险分析。例如RMO7表示第7条风险分析。这里RMO表示Risk Management Output，即风险管理输出。</p>\n<p>&emsp;&emsp;现在我们把它们汇集到下面的设计输入输出追踪表中：<br><img src=\"/2023/09/design-inputs-outputs-for-medical-device/2023-09-14_09-16-16.png\" alt><br>&emsp;&emsp;上表第三列表示该条设计输入所对应的输入的来源。有可能同一条设计输入同时来源于法规和风险分析，例如上表的第71条。每一条设计输入都对应各自的设计输出以及设计输出的验证与确认。</p>\n<p>&emsp;&emsp;在设计输入评审阶段，只要定义每个输入对应的输出的类型即可。例如只要定义输出是图纸，产品清单，还是实验报告，或者公差堆积分析等即可。在这个阶段，还要制定每一条设计输出的验证计划和确认计划。</p>\n<p>&emsp;&emsp;在设计输出和验证评审阶段，通过更新这个表来核实每一行的设计验证的执行情况，要在设计验证一列里填写图纸号，或实验报告号，或者其它验证文件编号，名称，生效日期，也要填写核实人的姓名等。</p>\n<p>&emsp;&emsp;在设计输出确认评审阶段，继续更新这个追踪表来核实每一行的设计确认的完成情况，要在设计确认那一列列出确认文件的编号，名称，生效日期，核实人姓名等。<br><img src=\"/2023/09/design-inputs-outputs-for-medical-device/2023-09-14_09-19-28.png\" alt><br>&emsp;&emsp;每次设计评审前，都要评估风险分析是否需要更新。随着项目的进行，可能会发现有些用户需求不合理，需要调整。有些风险没有考虑到，需要补充。当用户需求或者分析分析更新时，设计输入输出追踪表要随之更新。法规或标准更新一般有至少一年的缓冲期，产品开发时要提前将新的法规和标准导入进来。</p>\n<p>&emsp;&emsp;在整个设计开发过程中，设计输入输出追踪表是设计历史文档的灵魂。它往前与用户需求，法律法规以及风险管理相关联，往后与设计验证与确认文档相关联。产品开发的主要历史文档都在这个表里被引用。抓住这个追踪表，就可以感受到整个产品开发的脉络。这个追踪表也是设计开发过程可追溯性的记录。有多少个设计输入，最后就有多少个设计输出，一个不多，一个不少，一目了然。</p>\n<p>&emsp;&emsp;最后需要说明两点，第一，这种设计模式适合瀑布性/预测性项目,如果是敏捷项目应该更加注重人与人之间的互动,同时文档的记录也是有必要的。第二，应该注重管理项目知识，利用已有的组织知识来创造或改进项目成果，并使当前项目创造的知识可用于支持组织运营和未来的项目或阶段。本过程需要在整个项目期间开展,以上观点只作为参考。</p>\n<hr>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<h1 id=\"医疗器械的软件设计输入\"><a href=\"#医疗器械的软件设计输入\" class=\"headerlink\" title=\"医疗器械的软件设计输入\"></a>医疗器械的软件设计输入</h1><p>设计输入一般有三个来源:<br>    1:<strong>用户需求</strong>:每一条用户需求都要对应一条或多条设计输入。用户需求比较笼统时，就要把它分解成容易实施的若干条设计输入。用户需求比较具体时，一条用户需求对应一条设计输入即可。<br>    2:<strong>法规和标准的要求</strong>:例如GB9706，強制标准的要求，以及注册指导原则等。比较理想的做法是把这些标准和法规的条款列一个表，逐条判定适不适用于正在开发的产品，如果适用，就导入到设计输入里；如果不适用，说明理由为什么不适用。判定的过程应当存档，因为这也是设计历史文档的一部分，同时对今后类似产品的开发也具有参考价值。<br>    3:<strong>风险管理（风险分析）</strong>。通过分析每个危害的严重度，发生频率和可探测度，计算得到每个风险的RPN值，以判断风险是否可以接受。对于高风险和中风险危害，需要制定风险缓解措施。这些缓解措施就要导入到设计输入列表里逐一跟踪落实。</p>\n<p>&emsp;&emsp;风险管理标准通常包含一个附录，其中列出了一些危害的示例，这些示例是基于标准制定者的经验而列出的。在使用这种方法时，工程师需要仔细检查这个附录中的危害，并判断它们是否适用于他们正在开发的新产品。如果某些危害适用，那么它们将被纳入风险分析表中进行详细研究和评估。如果某些危害不适用于新产品，工程师需要记录下不适用的理由并进行归档。此外，对于具体要设计的医疗器械，工程师还需要根据该产品的特性添加和考虑其他可能的危害。这个过程高度依赖于工程师的专业经验和知识。</p>\n<p>&emsp;&emsp;另一种风险管理方法是将风险管理标准的宏观原则与具体产品的实际使用情况相结合。仔细分析每一个工作步骤，考虑每一步可能存在的危害，并计算每个危害的风险优先级数（RPN值）。这种方法着重于对产品实际使用情境的深入理解，并强调在设计过程中反复思考哪些步骤与已有产品相似，哪些步骤可能不同，以及每一步可能引发的潜在风险。</p>\n<p><img src=\"/2023/09/design-inputs-outputs-for-medical-device/2023-09-13_17-08-45.png\" alt></p>\n<p>&emsp;&emsp;现在我们简单模拟一下如何将这三个输入来源导入到设计输入中</p>\n<p>&emsp;&emsp;假定用户需求评审已经完成，用户需求列表已经确定。我们用UN#表示第#个用户需求。例如UN2是用户需求表里的第2条。这里的UN表示User Needs，即用户需求。当然，你也可以不用UN，而用汉语拼音，或者其它方式编号。<br><img src=\"/2023/09/design-inputs-outputs-for-medical-device/2023-09-13_17-14-12.png\" alt><br>&emsp;&emsp;   这时法规和标准清单也已经完成，[法规来源于国标例如:GB9706,标准清单来源于注册标准等例如:医疗器械软件注册审查指导原则]并且每一条是否适用于本产品也已经判断完成。假定用R#表示这个清单里的第#条。例如R16表示清单里的第16条。这里R表示Regulatory，即法规。<br><img src=\"/2023/09/design-inputs-outputs-for-medical-device/2023-09-14_9-14-12.png\" alt><br>&emsp;&emsp;把法规和标准的要求生成这个清单，不是必须的。只是如果有这个清单，一是可以避免遗漏，二是可以用这张表承载判断各项要求是否适用于本产品的记录。要不要生成这样的清单，取决于研发管理者的风格和思路。</p>\n<p>&emsp;&emsp;这时，初次风险分析也已经完成。类似地，用RMO#表示第#条风险分析。例如RMO7表示第7条风险分析。这里RMO表示Risk Management Output，即风险管理输出。</p>\n<p>&emsp;&emsp;现在我们把它们汇集到下面的设计输入输出追踪表中：<br><img src=\"/2023/09/design-inputs-outputs-for-medical-device/2023-09-14_09-16-16.png\" alt><br>&emsp;&emsp;上表第三列表示该条设计输入所对应的输入的来源。有可能同一条设计输入同时来源于法规和风险分析，例如上表的第71条。每一条设计输入都对应各自的设计输出以及设计输出的验证与确认。</p>\n<p>&emsp;&emsp;在设计输入评审阶段，只要定义每个输入对应的输出的类型即可。例如只要定义输出是图纸，产品清单，还是实验报告，或者公差堆积分析等即可。在这个阶段，还要制定每一条设计输出的验证计划和确认计划。</p>\n<p>&emsp;&emsp;在设计输出和验证评审阶段，通过更新这个表来核实每一行的设计验证的执行情况，要在设计验证一列里填写图纸号，或实验报告号，或者其它验证文件编号，名称，生效日期，也要填写核实人的姓名等。</p>\n<p>&emsp;&emsp;在设计输出确认评审阶段，继续更新这个追踪表来核实每一行的设计确认的完成情况，要在设计确认那一列列出确认文件的编号，名称，生效日期，核实人姓名等。<br><img src=\"/2023/09/design-inputs-outputs-for-medical-device/2023-09-14_09-19-28.png\" alt><br>&emsp;&emsp;每次设计评审前，都要评估风险分析是否需要更新。随着项目的进行，可能会发现有些用户需求不合理，需要调整。有些风险没有考虑到，需要补充。当用户需求或者分析分析更新时，设计输入输出追踪表要随之更新。法规或标准更新一般有至少一年的缓冲期，产品开发时要提前将新的法规和标准导入进来。</p>\n<p>&emsp;&emsp;在整个设计开发过程中，设计输入输出追踪表是设计历史文档的灵魂。它往前与用户需求，法律法规以及风险管理相关联，往后与设计验证与确认文档相关联。产品开发的主要历史文档都在这个表里被引用。抓住这个追踪表，就可以感受到整个产品开发的脉络。这个追踪表也是设计开发过程可追溯性的记录。有多少个设计输入，最后就有多少个设计输出，一个不多，一个不少，一目了然。</p>\n<p>&emsp;&emsp;最后需要说明两点，第一，这种设计模式适合瀑布性/预测性项目,如果是敏捷项目应该更加注重人与人之间的互动,同时文档的记录也是有必要的。第二，应该注重管理项目知识，利用已有的组织知识来创造或改进项目成果，并使当前项目创造的知识可用于支持组织运营和未来的项目或阶段。本过程需要在整个项目期间开展,以上观点只作为参考。</p>\n<hr>\n"},{"title":"Quartus FPGA Debug","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2024-01-06T01:35:48.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"# Quartus FPGA Debug\n\n## 系统调试工具比较\n\n| 工具                            | 描述                                                                                                                                                                                                                              | 典型使用                                                                                                                                             |\n| ------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |\n| System Console                  | • 提供实时在系统内调试功能。• 允许您在没有处理器或其他软件的情况下读取和写入系统中的存储器映射(Memory Mapped)组件• 通过 Tcl 解释程序与设计中的硬件模块进行通信。• 允许您利用 Tcl 脚本语言的所有功能。• 支持 JTAG 和 TCP/IP 连接。 | 您需要执行系统级调试。例如，如果您有一个 Avalon® -MM slave 或者Avalon -ST 接口，那么您可以在传输级上调试设计。                                       |\n| Transceiver Toolkit             | • 使您能够通过组合指标测试和调整收发器链路信号质量。• 物理介质附加层(PMA)的 Auto Sweeping 设置可帮助您找到最佳参数值。                                                                                                            | 您需要在完成设计之前调试或优化电路板布局的信号完整性。                                                                                               |\n| Signal Tap Logic Analyzer       | • 使用 FPGA 资源• 对测试节点进行采样，并将信息输出到 Intel Quartus Prime 软件进行显示和分析。                                                                                                                                     | 您有备用的片上存储器，并且希望对硬件中运行的设计进行功能验证。                                                                                       |\n| Signal Probe                    | 以递增方式将内部信号布线到 I/O 管脚，同时保留最后一次进行布局布线的设计结果。                                                                                                                                                     | 您有备用 I/O 管脚，并且想使用外部逻辑分析仪或示波器检查一小组控制管脚脚的操作。                                                                      |\n| Logic Analyzer Interface (LAI)  | • 将较大一组信号多路复用到较少数量的备用 I/O 管脚。• 使您能够选择哪些信号通过 JTAG 连接切换到 I/O 管脚。                                                                                                                          | 您有需要使用外部逻辑分析仪进行验证的有限片上存储器和大量内部数据总线。逻辑分析仪供应商(例如Tektronics*和 Agilent*)提供与此工具的集成，以提高可用性。 |\n| In-System Sources and Probes    | 提供使用 JTAG 接口将逻辑值驱动到内部节点和从内部节点采样逻辑值的简便方法。                                                                                                                                                        | 您想使用带虚拟按钮的前面板对 FPGA 进行原型设计。                                                                                                     |\n| In-System Memory Content Editor | 显示并允许您编辑片上存储器。                                                                                                                                                                                                      | 您想对未连接到 Nios® II 处理器的片上存储器的内容进行查看和编辑。当您不想在系统中有 Nios II 调试内核时，您也可以使用此工具。                          |\n| Virtual JTAG Interface          | 使您能够与 JTAG 接口进行通信，以便开发自定义应用程序。                                                                                                                                                                            | 您想要与设计中的自定义信号进行通信。                                                                                                                 |\n\n\n\n## 对常用调试要求所建议的工具\n\n| 要求                                | Signal Probe | 逻辑分析仪接口(LAI) | Signal Tap 逻辑分析仪 | 描述                                                                                                                                                                                                          |\n| ----------------------------------- | ------------ | ------------------- | --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| More Data Storage                   | N/A          | X                   | —                     | 包含 LAI 工具的外部逻辑分析仪使您能够存储比 Signal TapLogic Analyzer 更多的采集数据，因为外部逻辑分析仪能够提供对更大缓冲器的访问。Signal Probe 工具不采集数据，也不存储数据。                                |\n| Faster Debugging                    | X            | X                   | —                     | 您可以将 LAI 或者 Signal Probe 工具同外部工具一起使用(例如：示波器和混合信号示波器(MSO))。此功能提供对时序模式的访问，允许您调试组合的数据流。                                                                |\n| Minimal Effect on Logic Design      | X            | X (2)               | X (2)                 | Signal Probe 工具以递增方式将节点布线到管脚，而不影响设计逻辑。LAI 将最少的逻辑添加到设计中，从而需要更少的器件资源。Signal Tap Logic Analyzer 对设计的影响不大，因为 Compiler 将调试逻辑视为单独的设计分区。 |\n| Short Compile and Recompile Time    | X            | X (2)               | X (2)                 | Signal Probe 使用递增布线将信号附加到之前保留的管脚上。此特性使您能够在更改源信号选择时快速地重新编译。Signal Tap Logic Analyzer 和 LAI 能够重新整修它们各自的设计分区以缩短重编译时间。                      |\n| Sophisticated Triggering Capability | N/A          | N/A                 | X                     | Signal Tap Logic Analyzer 的触发功能可与商用逻辑分析仪相媲美。                                                                                                                                                |\n| Low I/O Usage                       | —            | —                   | X                     | Signal Tap Logic Analyzer 不需要额外的输出管脚。LAI 和 Signal Probe 都需要 I/O 管脚约束(I/O pin assignments)。                                                                                                |\n| Fast Data Acquisition               | N/A          | —                   | X                     | Signal Tap Logic Analyzer 能够在超过 200 MHz 的速度上采集数据。信号完整性问题限制了使用 LAI 的外部逻辑分析仪的采集速度。                                                                                      |\n| No JTAG Connection Required         | X            | —                   | X                     | Signal Probe 和 Signal Tap 不需要主机进行调试。包含 LAI 的 FPGA 设计需要一个活动的 JTAG 连接到运行 Intel Quartus Prime 软件的主机。                                                                           |\n| No External Equipment Required      | —            | —                   | X                     | Signal Tap Logic Analyzer 仅需要一个从运行 Intel QuartusPrime 软件或者独立的 Signal Tap Logic Analyzer 的主机的 JTAG连接。Signal Probe 和 LAI 需要使用外部调试设备，例如：万用表、示波器或逻辑分析仪。        |\n\n注释：\n\n1. • X 代表对相关功能所建议的工具。\n\n   • —代表相关工具可用于此功能，但此工具可能无法提供最佳结果。\n\n   • N/A 代表此功能不适用于所选工具。\n\n2. 当使用增量编译时有效。\n\n## 调试生态系统\n\n| 调试工具                        | 从设计读取数据 | 在设计中输入值 | 备注                                                                 |\n| ------------------------------- | -------------- | -------------- | -------------------------------------------------------------------- |\n| Signal Tap Logic Analyzer,      | Yes            | No             | 针对探测寄存器传输级(RTL)网表中的信号进行优化的通用故障排除工具      |\n| Logic Analyzer Interface        | ↑              | ↑              | ↑                                                                    |\n| Signal Probe                    | ↑              | ↑              | ↑                                                                    |\n| In-System Sources and Probes    | Yes            | Yes            | 这些工具能够：• 从您定义的断点读取数据• 在运行时期间将值输入到设计中 |\n| Virtual JTAG Interface          | ↑              | ↑              | ↑                                                                    |\n| System Console                  | ↑              | ↑              | ↑                                                                    |\n| Transceiver Toolkit             | ↑              | ↑              | ↑                                                                    |\n| In-System Memory Content Editor | ↑              | ↑              | ↑                                                                    |\n\n> 来源 ： [system-debugging-tools-overview](https:/www.intel.cn/content/www/cn/zh/docs/programmable/683819/19-3/system-debugging-tools-overview.html)","source":"_posts/2024/01/Quartus-FPGA-Debug.md","raw":"---\ntitle: Quartus FPGA Debug\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2024-01-06 09:35:48\npassword:\nsummary:\ntags:\n- FPGA\ncategories:\n- FPGA\nkeywords:\ndescription:\n---\n# Quartus FPGA Debug\n\n## 系统调试工具比较\n\n| 工具                            | 描述                                                                                                                                                                                                                              | 典型使用                                                                                                                                             |\n| ------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |\n| System Console                  | • 提供实时在系统内调试功能。• 允许您在没有处理器或其他软件的情况下读取和写入系统中的存储器映射(Memory Mapped)组件• 通过 Tcl 解释程序与设计中的硬件模块进行通信。• 允许您利用 Tcl 脚本语言的所有功能。• 支持 JTAG 和 TCP/IP 连接。 | 您需要执行系统级调试。例如，如果您有一个 Avalon® -MM slave 或者Avalon -ST 接口，那么您可以在传输级上调试设计。                                       |\n| Transceiver Toolkit             | • 使您能够通过组合指标测试和调整收发器链路信号质量。• 物理介质附加层(PMA)的 Auto Sweeping 设置可帮助您找到最佳参数值。                                                                                                            | 您需要在完成设计之前调试或优化电路板布局的信号完整性。                                                                                               |\n| Signal Tap Logic Analyzer       | • 使用 FPGA 资源• 对测试节点进行采样，并将信息输出到 Intel Quartus Prime 软件进行显示和分析。                                                                                                                                     | 您有备用的片上存储器，并且希望对硬件中运行的设计进行功能验证。                                                                                       |\n| Signal Probe                    | 以递增方式将内部信号布线到 I/O 管脚，同时保留最后一次进行布局布线的设计结果。                                                                                                                                                     | 您有备用 I/O 管脚，并且想使用外部逻辑分析仪或示波器检查一小组控制管脚脚的操作。                                                                      |\n| Logic Analyzer Interface (LAI)  | • 将较大一组信号多路复用到较少数量的备用 I/O 管脚。• 使您能够选择哪些信号通过 JTAG 连接切换到 I/O 管脚。                                                                                                                          | 您有需要使用外部逻辑分析仪进行验证的有限片上存储器和大量内部数据总线。逻辑分析仪供应商(例如Tektronics*和 Agilent*)提供与此工具的集成，以提高可用性。 |\n| In-System Sources and Probes    | 提供使用 JTAG 接口将逻辑值驱动到内部节点和从内部节点采样逻辑值的简便方法。                                                                                                                                                        | 您想使用带虚拟按钮的前面板对 FPGA 进行原型设计。                                                                                                     |\n| In-System Memory Content Editor | 显示并允许您编辑片上存储器。                                                                                                                                                                                                      | 您想对未连接到 Nios® II 处理器的片上存储器的内容进行查看和编辑。当您不想在系统中有 Nios II 调试内核时，您也可以使用此工具。                          |\n| Virtual JTAG Interface          | 使您能够与 JTAG 接口进行通信，以便开发自定义应用程序。                                                                                                                                                                            | 您想要与设计中的自定义信号进行通信。                                                                                                                 |\n\n\n\n## 对常用调试要求所建议的工具\n\n| 要求                                | Signal Probe | 逻辑分析仪接口(LAI) | Signal Tap 逻辑分析仪 | 描述                                                                                                                                                                                                          |\n| ----------------------------------- | ------------ | ------------------- | --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| More Data Storage                   | N/A          | X                   | —                     | 包含 LAI 工具的外部逻辑分析仪使您能够存储比 Signal TapLogic Analyzer 更多的采集数据，因为外部逻辑分析仪能够提供对更大缓冲器的访问。Signal Probe 工具不采集数据，也不存储数据。                                |\n| Faster Debugging                    | X            | X                   | —                     | 您可以将 LAI 或者 Signal Probe 工具同外部工具一起使用(例如：示波器和混合信号示波器(MSO))。此功能提供对时序模式的访问，允许您调试组合的数据流。                                                                |\n| Minimal Effect on Logic Design      | X            | X (2)               | X (2)                 | Signal Probe 工具以递增方式将节点布线到管脚，而不影响设计逻辑。LAI 将最少的逻辑添加到设计中，从而需要更少的器件资源。Signal Tap Logic Analyzer 对设计的影响不大，因为 Compiler 将调试逻辑视为单独的设计分区。 |\n| Short Compile and Recompile Time    | X            | X (2)               | X (2)                 | Signal Probe 使用递增布线将信号附加到之前保留的管脚上。此特性使您能够在更改源信号选择时快速地重新编译。Signal Tap Logic Analyzer 和 LAI 能够重新整修它们各自的设计分区以缩短重编译时间。                      |\n| Sophisticated Triggering Capability | N/A          | N/A                 | X                     | Signal Tap Logic Analyzer 的触发功能可与商用逻辑分析仪相媲美。                                                                                                                                                |\n| Low I/O Usage                       | —            | —                   | X                     | Signal Tap Logic Analyzer 不需要额外的输出管脚。LAI 和 Signal Probe 都需要 I/O 管脚约束(I/O pin assignments)。                                                                                                |\n| Fast Data Acquisition               | N/A          | —                   | X                     | Signal Tap Logic Analyzer 能够在超过 200 MHz 的速度上采集数据。信号完整性问题限制了使用 LAI 的外部逻辑分析仪的采集速度。                                                                                      |\n| No JTAG Connection Required         | X            | —                   | X                     | Signal Probe 和 Signal Tap 不需要主机进行调试。包含 LAI 的 FPGA 设计需要一个活动的 JTAG 连接到运行 Intel Quartus Prime 软件的主机。                                                                           |\n| No External Equipment Required      | —            | —                   | X                     | Signal Tap Logic Analyzer 仅需要一个从运行 Intel QuartusPrime 软件或者独立的 Signal Tap Logic Analyzer 的主机的 JTAG连接。Signal Probe 和 LAI 需要使用外部调试设备，例如：万用表、示波器或逻辑分析仪。        |\n\n注释：\n\n1. • X 代表对相关功能所建议的工具。\n\n   • —代表相关工具可用于此功能，但此工具可能无法提供最佳结果。\n\n   • N/A 代表此功能不适用于所选工具。\n\n2. 当使用增量编译时有效。\n\n## 调试生态系统\n\n| 调试工具                        | 从设计读取数据 | 在设计中输入值 | 备注                                                                 |\n| ------------------------------- | -------------- | -------------- | -------------------------------------------------------------------- |\n| Signal Tap Logic Analyzer,      | Yes            | No             | 针对探测寄存器传输级(RTL)网表中的信号进行优化的通用故障排除工具      |\n| Logic Analyzer Interface        | ↑              | ↑              | ↑                                                                    |\n| Signal Probe                    | ↑              | ↑              | ↑                                                                    |\n| In-System Sources and Probes    | Yes            | Yes            | 这些工具能够：• 从您定义的断点读取数据• 在运行时期间将值输入到设计中 |\n| Virtual JTAG Interface          | ↑              | ↑              | ↑                                                                    |\n| System Console                  | ↑              | ↑              | ↑                                                                    |\n| Transceiver Toolkit             | ↑              | ↑              | ↑                                                                    |\n| In-System Memory Content Editor | ↑              | ↑              | ↑                                                                    |\n\n> 来源 ： [system-debugging-tools-overview](https:/www.intel.cn/content/www/cn/zh/docs/programmable/683819/19-3/system-debugging-tools-overview.html)","slug":"Quartus-FPGA-Debug","published":1,"updated":"2024-01-06T02:12:01.807Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clru1g22e003ls4fuhswam8de","content":"<h1 id=\"Quartus-FPGA-Debug\"><a href=\"#Quartus-FPGA-Debug\" class=\"headerlink\" title=\"Quartus FPGA Debug\"></a>Quartus FPGA Debug</h1><h2 id=\"系统调试工具比较\"><a href=\"#系统调试工具比较\" class=\"headerlink\" title=\"系统调试工具比较\"></a>系统调试工具比较</h2><table>\n<thead>\n<tr>\n<th>工具</th>\n<th>描述</th>\n<th>典型使用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>System Console</td>\n<td>• 提供实时在系统内调试功能。• 允许您在没有处理器或其他软件的情况下读取和写入系统中的存储器映射(Memory Mapped)组件• 通过 Tcl 解释程序与设计中的硬件模块进行通信。• 允许您利用 Tcl 脚本语言的所有功能。• 支持 JTAG 和 TCP/IP 连接。</td>\n<td>您需要执行系统级调试。例如，如果您有一个 Avalon® -MM slave 或者Avalon -ST 接口，那么您可以在传输级上调试设计。</td>\n</tr>\n<tr>\n<td>Transceiver Toolkit</td>\n<td>• 使您能够通过组合指标测试和调整收发器链路信号质量。• 物理介质附加层(PMA)的 Auto Sweeping 设置可帮助您找到最佳参数值。</td>\n<td>您需要在完成设计之前调试或优化电路板布局的信号完整性。</td>\n</tr>\n<tr>\n<td>Signal Tap Logic Analyzer</td>\n<td>• 使用 FPGA 资源• 对测试节点进行采样，并将信息输出到 Intel Quartus Prime 软件进行显示和分析。</td>\n<td>您有备用的片上存储器，并且希望对硬件中运行的设计进行功能验证。</td>\n</tr>\n<tr>\n<td>Signal Probe</td>\n<td>以递增方式将内部信号布线到 I/O 管脚，同时保留最后一次进行布局布线的设计结果。</td>\n<td>您有备用 I/O 管脚，并且想使用外部逻辑分析仪或示波器检查一小组控制管脚脚的操作。</td>\n</tr>\n<tr>\n<td>Logic Analyzer Interface (LAI)</td>\n<td>• 将较大一组信号多路复用到较少数量的备用 I/O 管脚。• 使您能够选择哪些信号通过 JTAG 连接切换到 I/O 管脚。</td>\n<td>您有需要使用外部逻辑分析仪进行验证的有限片上存储器和大量内部数据总线。逻辑分析仪供应商(例如Tektronics<em>和 Agilent</em>)提供与此工具的集成，以提高可用性。</td>\n</tr>\n<tr>\n<td>In-System Sources and Probes</td>\n<td>提供使用 JTAG 接口将逻辑值驱动到内部节点和从内部节点采样逻辑值的简便方法。</td>\n<td>您想使用带虚拟按钮的前面板对 FPGA 进行原型设计。</td>\n</tr>\n<tr>\n<td>In-System Memory Content Editor</td>\n<td>显示并允许您编辑片上存储器。</td>\n<td>您想对未连接到 Nios® II 处理器的片上存储器的内容进行查看和编辑。当您不想在系统中有 Nios II 调试内核时，您也可以使用此工具。</td>\n</tr>\n<tr>\n<td>Virtual JTAG Interface</td>\n<td>使您能够与 JTAG 接口进行通信，以便开发自定义应用程序。</td>\n<td>您想要与设计中的自定义信号进行通信。</td>\n</tr>\n</tbody></table>\n<h2 id=\"对常用调试要求所建议的工具\"><a href=\"#对常用调试要求所建议的工具\" class=\"headerlink\" title=\"对常用调试要求所建议的工具\"></a>对常用调试要求所建议的工具</h2><table>\n<thead>\n<tr>\n<th>要求</th>\n<th>Signal Probe</th>\n<th>逻辑分析仪接口(LAI)</th>\n<th>Signal Tap 逻辑分析仪</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>More Data Storage</td>\n<td>N/A</td>\n<td>X</td>\n<td>—</td>\n<td>包含 LAI 工具的外部逻辑分析仪使您能够存储比 Signal TapLogic Analyzer 更多的采集数据，因为外部逻辑分析仪能够提供对更大缓冲器的访问。Signal Probe 工具不采集数据，也不存储数据。</td>\n</tr>\n<tr>\n<td>Faster Debugging</td>\n<td>X</td>\n<td>X</td>\n<td>—</td>\n<td>您可以将 LAI 或者 Signal Probe 工具同外部工具一起使用(例如：示波器和混合信号示波器(MSO))。此功能提供对时序模式的访问，允许您调试组合的数据流。</td>\n</tr>\n<tr>\n<td>Minimal Effect on Logic Design</td>\n<td>X</td>\n<td>X (2)</td>\n<td>X (2)</td>\n<td>Signal Probe 工具以递增方式将节点布线到管脚，而不影响设计逻辑。LAI 将最少的逻辑添加到设计中，从而需要更少的器件资源。Signal Tap Logic Analyzer 对设计的影响不大，因为 Compiler 将调试逻辑视为单独的设计分区。</td>\n</tr>\n<tr>\n<td>Short Compile and Recompile Time</td>\n<td>X</td>\n<td>X (2)</td>\n<td>X (2)</td>\n<td>Signal Probe 使用递增布线将信号附加到之前保留的管脚上。此特性使您能够在更改源信号选择时快速地重新编译。Signal Tap Logic Analyzer 和 LAI 能够重新整修它们各自的设计分区以缩短重编译时间。</td>\n</tr>\n<tr>\n<td>Sophisticated Triggering Capability</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>X</td>\n<td>Signal Tap Logic Analyzer 的触发功能可与商用逻辑分析仪相媲美。</td>\n</tr>\n<tr>\n<td>Low I/O Usage</td>\n<td>—</td>\n<td>—</td>\n<td>X</td>\n<td>Signal Tap Logic Analyzer 不需要额外的输出管脚。LAI 和 Signal Probe 都需要 I/O 管脚约束(I/O pin assignments)。</td>\n</tr>\n<tr>\n<td>Fast Data Acquisition</td>\n<td>N/A</td>\n<td>—</td>\n<td>X</td>\n<td>Signal Tap Logic Analyzer 能够在超过 200 MHz 的速度上采集数据。信号完整性问题限制了使用 LAI 的外部逻辑分析仪的采集速度。</td>\n</tr>\n<tr>\n<td>No JTAG Connection Required</td>\n<td>X</td>\n<td>—</td>\n<td>X</td>\n<td>Signal Probe 和 Signal Tap 不需要主机进行调试。包含 LAI 的 FPGA 设计需要一个活动的 JTAG 连接到运行 Intel Quartus Prime 软件的主机。</td>\n</tr>\n<tr>\n<td>No External Equipment Required</td>\n<td>—</td>\n<td>—</td>\n<td>X</td>\n<td>Signal Tap Logic Analyzer 仅需要一个从运行 Intel QuartusPrime 软件或者独立的 Signal Tap Logic Analyzer 的主机的 JTAG连接。Signal Probe 和 LAI 需要使用外部调试设备，例如：万用表、示波器或逻辑分析仪。</td>\n</tr>\n</tbody></table>\n<p>注释：</p>\n<ol>\n<li><p>• X 代表对相关功能所建议的工具。</p>\n<p>• —代表相关工具可用于此功能，但此工具可能无法提供最佳结果。</p>\n<p>• N/A 代表此功能不适用于所选工具。</p>\n</li>\n<li><p>当使用增量编译时有效。</p>\n</li>\n</ol>\n<h2 id=\"调试生态系统\"><a href=\"#调试生态系统\" class=\"headerlink\" title=\"调试生态系统\"></a>调试生态系统</h2><table>\n<thead>\n<tr>\n<th>调试工具</th>\n<th>从设计读取数据</th>\n<th>在设计中输入值</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Signal Tap Logic Analyzer,</td>\n<td>Yes</td>\n<td>No</td>\n<td>针对探测寄存器传输级(RTL)网表中的信号进行优化的通用故障排除工具</td>\n</tr>\n<tr>\n<td>Logic Analyzer Interface</td>\n<td>↑</td>\n<td>↑</td>\n<td>↑</td>\n</tr>\n<tr>\n<td>Signal Probe</td>\n<td>↑</td>\n<td>↑</td>\n<td>↑</td>\n</tr>\n<tr>\n<td>In-System Sources and Probes</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>这些工具能够：• 从您定义的断点读取数据• 在运行时期间将值输入到设计中</td>\n</tr>\n<tr>\n<td>Virtual JTAG Interface</td>\n<td>↑</td>\n<td>↑</td>\n<td>↑</td>\n</tr>\n<tr>\n<td>System Console</td>\n<td>↑</td>\n<td>↑</td>\n<td>↑</td>\n</tr>\n<tr>\n<td>Transceiver Toolkit</td>\n<td>↑</td>\n<td>↑</td>\n<td>↑</td>\n</tr>\n<tr>\n<td>In-System Memory Content Editor</td>\n<td>↑</td>\n<td>↑</td>\n<td>↑</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>来源 ： <a href=\"https:/www.intel.cn/content/www/cn/zh/docs/programmable/683819/19-3/system-debugging-tools-overview.html\" target=\"_blank\" rel=\"noopener\">system-debugging-tools-overview</a></p>\n</blockquote>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<h1 id=\"Quartus-FPGA-Debug\"><a href=\"#Quartus-FPGA-Debug\" class=\"headerlink\" title=\"Quartus FPGA Debug\"></a>Quartus FPGA Debug</h1><h2 id=\"系统调试工具比较\"><a href=\"#系统调试工具比较\" class=\"headerlink\" title=\"系统调试工具比较\"></a>系统调试工具比较</h2><table>\n<thead>\n<tr>\n<th>工具</th>\n<th>描述</th>\n<th>典型使用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>System Console</td>\n<td>• 提供实时在系统内调试功能。• 允许您在没有处理器或其他软件的情况下读取和写入系统中的存储器映射(Memory Mapped)组件• 通过 Tcl 解释程序与设计中的硬件模块进行通信。• 允许您利用 Tcl 脚本语言的所有功能。• 支持 JTAG 和 TCP/IP 连接。</td>\n<td>您需要执行系统级调试。例如，如果您有一个 Avalon® -MM slave 或者Avalon -ST 接口，那么您可以在传输级上调试设计。</td>\n</tr>\n<tr>\n<td>Transceiver Toolkit</td>\n<td>• 使您能够通过组合指标测试和调整收发器链路信号质量。• 物理介质附加层(PMA)的 Auto Sweeping 设置可帮助您找到最佳参数值。</td>\n<td>您需要在完成设计之前调试或优化电路板布局的信号完整性。</td>\n</tr>\n<tr>\n<td>Signal Tap Logic Analyzer</td>\n<td>• 使用 FPGA 资源• 对测试节点进行采样，并将信息输出到 Intel Quartus Prime 软件进行显示和分析。</td>\n<td>您有备用的片上存储器，并且希望对硬件中运行的设计进行功能验证。</td>\n</tr>\n<tr>\n<td>Signal Probe</td>\n<td>以递增方式将内部信号布线到 I/O 管脚，同时保留最后一次进行布局布线的设计结果。</td>\n<td>您有备用 I/O 管脚，并且想使用外部逻辑分析仪或示波器检查一小组控制管脚脚的操作。</td>\n</tr>\n<tr>\n<td>Logic Analyzer Interface (LAI)</td>\n<td>• 将较大一组信号多路复用到较少数量的备用 I/O 管脚。• 使您能够选择哪些信号通过 JTAG 连接切换到 I/O 管脚。</td>\n<td>您有需要使用外部逻辑分析仪进行验证的有限片上存储器和大量内部数据总线。逻辑分析仪供应商(例如Tektronics<em>和 Agilent</em>)提供与此工具的集成，以提高可用性。</td>\n</tr>\n<tr>\n<td>In-System Sources and Probes</td>\n<td>提供使用 JTAG 接口将逻辑值驱动到内部节点和从内部节点采样逻辑值的简便方法。</td>\n<td>您想使用带虚拟按钮的前面板对 FPGA 进行原型设计。</td>\n</tr>\n<tr>\n<td>In-System Memory Content Editor</td>\n<td>显示并允许您编辑片上存储器。</td>\n<td>您想对未连接到 Nios® II 处理器的片上存储器的内容进行查看和编辑。当您不想在系统中有 Nios II 调试内核时，您也可以使用此工具。</td>\n</tr>\n<tr>\n<td>Virtual JTAG Interface</td>\n<td>使您能够与 JTAG 接口进行通信，以便开发自定义应用程序。</td>\n<td>您想要与设计中的自定义信号进行通信。</td>\n</tr>\n</tbody></table>\n<h2 id=\"对常用调试要求所建议的工具\"><a href=\"#对常用调试要求所建议的工具\" class=\"headerlink\" title=\"对常用调试要求所建议的工具\"></a>对常用调试要求所建议的工具</h2><table>\n<thead>\n<tr>\n<th>要求</th>\n<th>Signal Probe</th>\n<th>逻辑分析仪接口(LAI)</th>\n<th>Signal Tap 逻辑分析仪</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>More Data Storage</td>\n<td>N/A</td>\n<td>X</td>\n<td>—</td>\n<td>包含 LAI 工具的外部逻辑分析仪使您能够存储比 Signal TapLogic Analyzer 更多的采集数据，因为外部逻辑分析仪能够提供对更大缓冲器的访问。Signal Probe 工具不采集数据，也不存储数据。</td>\n</tr>\n<tr>\n<td>Faster Debugging</td>\n<td>X</td>\n<td>X</td>\n<td>—</td>\n<td>您可以将 LAI 或者 Signal Probe 工具同外部工具一起使用(例如：示波器和混合信号示波器(MSO))。此功能提供对时序模式的访问，允许您调试组合的数据流。</td>\n</tr>\n<tr>\n<td>Minimal Effect on Logic Design</td>\n<td>X</td>\n<td>X (2)</td>\n<td>X (2)</td>\n<td>Signal Probe 工具以递增方式将节点布线到管脚，而不影响设计逻辑。LAI 将最少的逻辑添加到设计中，从而需要更少的器件资源。Signal Tap Logic Analyzer 对设计的影响不大，因为 Compiler 将调试逻辑视为单独的设计分区。</td>\n</tr>\n<tr>\n<td>Short Compile and Recompile Time</td>\n<td>X</td>\n<td>X (2)</td>\n<td>X (2)</td>\n<td>Signal Probe 使用递增布线将信号附加到之前保留的管脚上。此特性使您能够在更改源信号选择时快速地重新编译。Signal Tap Logic Analyzer 和 LAI 能够重新整修它们各自的设计分区以缩短重编译时间。</td>\n</tr>\n<tr>\n<td>Sophisticated Triggering Capability</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>X</td>\n<td>Signal Tap Logic Analyzer 的触发功能可与商用逻辑分析仪相媲美。</td>\n</tr>\n<tr>\n<td>Low I/O Usage</td>\n<td>—</td>\n<td>—</td>\n<td>X</td>\n<td>Signal Tap Logic Analyzer 不需要额外的输出管脚。LAI 和 Signal Probe 都需要 I/O 管脚约束(I/O pin assignments)。</td>\n</tr>\n<tr>\n<td>Fast Data Acquisition</td>\n<td>N/A</td>\n<td>—</td>\n<td>X</td>\n<td>Signal Tap Logic Analyzer 能够在超过 200 MHz 的速度上采集数据。信号完整性问题限制了使用 LAI 的外部逻辑分析仪的采集速度。</td>\n</tr>\n<tr>\n<td>No JTAG Connection Required</td>\n<td>X</td>\n<td>—</td>\n<td>X</td>\n<td>Signal Probe 和 Signal Tap 不需要主机进行调试。包含 LAI 的 FPGA 设计需要一个活动的 JTAG 连接到运行 Intel Quartus Prime 软件的主机。</td>\n</tr>\n<tr>\n<td>No External Equipment Required</td>\n<td>—</td>\n<td>—</td>\n<td>X</td>\n<td>Signal Tap Logic Analyzer 仅需要一个从运行 Intel QuartusPrime 软件或者独立的 Signal Tap Logic Analyzer 的主机的 JTAG连接。Signal Probe 和 LAI 需要使用外部调试设备，例如：万用表、示波器或逻辑分析仪。</td>\n</tr>\n</tbody></table>\n<p>注释：</p>\n<ol>\n<li><p>• X 代表对相关功能所建议的工具。</p>\n<p>• —代表相关工具可用于此功能，但此工具可能无法提供最佳结果。</p>\n<p>• N/A 代表此功能不适用于所选工具。</p>\n</li>\n<li><p>当使用增量编译时有效。</p>\n</li>\n</ol>\n<h2 id=\"调试生态系统\"><a href=\"#调试生态系统\" class=\"headerlink\" title=\"调试生态系统\"></a>调试生态系统</h2><table>\n<thead>\n<tr>\n<th>调试工具</th>\n<th>从设计读取数据</th>\n<th>在设计中输入值</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Signal Tap Logic Analyzer,</td>\n<td>Yes</td>\n<td>No</td>\n<td>针对探测寄存器传输级(RTL)网表中的信号进行优化的通用故障排除工具</td>\n</tr>\n<tr>\n<td>Logic Analyzer Interface</td>\n<td>↑</td>\n<td>↑</td>\n<td>↑</td>\n</tr>\n<tr>\n<td>Signal Probe</td>\n<td>↑</td>\n<td>↑</td>\n<td>↑</td>\n</tr>\n<tr>\n<td>In-System Sources and Probes</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>这些工具能够：• 从您定义的断点读取数据• 在运行时期间将值输入到设计中</td>\n</tr>\n<tr>\n<td>Virtual JTAG Interface</td>\n<td>↑</td>\n<td>↑</td>\n<td>↑</td>\n</tr>\n<tr>\n<td>System Console</td>\n<td>↑</td>\n<td>↑</td>\n<td>↑</td>\n</tr>\n<tr>\n<td>Transceiver Toolkit</td>\n<td>↑</td>\n<td>↑</td>\n<td>↑</td>\n</tr>\n<tr>\n<td>In-System Memory Content Editor</td>\n<td>↑</td>\n<td>↑</td>\n<td>↑</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>来源 ： <a href=\"https:/www.intel.cn/content/www/cn/zh/docs/programmable/683819/19-3/system-debugging-tools-overview.html\" target=\"_blank\" rel=\"noopener\">system-debugging-tools-overview</a></p>\n</blockquote>\n"},{"title":"时序约束整理","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2024-01-16T05:36:52.000Z","password":null,"summary":null,"keywords":["时序约束"],"description":null,"_content":"# <center>时序约束整理</center>\n\n- [时序分析基础知识](#时序分析基础知识)\n- [时序检查](#时序检查)\n    - [Setup 检查](#setup-检查)\n    - [Holdup 检查](#holdup-检查)\n    - [Recovery 检查](#recovery-检查)\n    - [Removal 检查](#removal-检查)\n- [时序约束](#时序约束)\n    - [时钟约束](#时钟约束)\n    - [Input/Output 延时约束](#inputoutput-延时约束)\n    - [Multicycle 约束](#multicycle-约束)\n    - [Falsepath 约束](#falsepath-约束)\n    - [Maxdelay约束](#maxdelay约束)\n\n##  1.时序分析基础知识\n\n#### 什么是时序分析\n\n时序分析本质上就是一种时序检查，目的是检查设计中所有的D触发器是否能够正常工作，也就是检查D触发器的同步端口（数据输入端口）的变化是否满足建立时间要求（Setup）和保持时间要求（Hold）；检查D触发器的异步端口（异步复位端口）的变化是否满足恢复时间要求（Recovery）和移除时间要求（Removal）。\n\n![时序分析](时序约束整理/时序分析.png)\n\n#### 时序分析有哪些类型\n\n时序分析包括静态时序分析（STA）和动态时序分析。\n\n* 动态时序分析：将布局布线生成的布线延迟信息反标注到门级网表中进行仿真，检查是否存在时序违例。此时的仿真包括门延迟和布线延迟信息，能够较好反应芯片的实际工作情况。因为不可能产生完备的测试向量，覆盖门级网表中的每一条路径。因此在动态时序分析中，无法暴露一些路径上可能存在的时序问题。\n* 静态时序分析：采用穷尽分析方法来提取出整个电路存在的所有时序路径，计算信号在这些路径上的传播延时，检查信号的建立和保持时间是否满足时序要求，通过对最大路径延时和最小路径延时的分析，找出违背时序约束的错误。它不需要输入向量就能穷尽所有的路径，且运行速度很快、占用内存较少，不仅可以对芯片设计进行全面的时序功能检查，而且还可利用时序分析的结果来优化设计，因此静态时序分析已经越来越多地被用到数字集成电路设计的验证中。\n\n#### 时序分析使用的工具有哪些\n\n* 静态时序分析使用的工具\n  * Xilinx Vivado Integrated Design Environment Time Engine\n  * Altera Quartus II Timequest\n  * DC等\n* 动态时序分析使用的工具\n  * Mentor Modelsim\n  * Cadence NC-Verilog\n  * Sysnopsys VCS\n\n#### 静态时序分析之前的准备工作\n\n撰写基本的时序约束文件，告知时序引擎一些必要的信息（比如时钟，输入输出延时等）。若没有正确的时序约束，那么时序分析的结果是没有意义的。\n\nD触发器中Tsetup, Thold, Tco的由来\n![D触发器原理图](时序约束整理/TsetupThold的由来.png)\n![Th的由来](时序约束整理/Th的由来.png)\n\n#### 序分析中的常用术语\n\n* 源时钟（Source Clock/Launch Clock，也称发起时钟）\n* 目的时钟（Destination Clock/ Capture Clock, 也称捕获时钟）\n* 发起沿（Launch Edge，源时钟产生数据的有效时钟沿）\n* 捕获沿（Capture Edge，目的时钟捕获数据的有效时钟沿）\n\n发起沿通常在0ns，捕获沿通常在下一个发起沿，发起沿和捕获沿通常相差一个时钟周期。\n\n![img](时序约束整理/LaunchEdgeCaptureEdge.png)\n\n#### 一条普通时序路径的三要素\n\n* 源时钟路径：从源时钟的源节点（通常是FPGA的时钟输入引脚）到源寄存器的时钟端口的路径。当时序路径的起点是FPGA输入端口时，该时序路径是没有源时钟路径的。\n* 数据路径：从时序路径的起点到时序路径的终点之间的数据传播路径。时序路径的起点可以是源寄存器的时钟端口或FPGA的输入端口，时序路径的终点可以是目的寄存器的输入端口或FPGA的输出端口。\n* 目的时钟路径：从目的时钟的源节点（通常是FPGA的时钟输入引脚）到目的寄存器的时钟端口的路径。当时序路径的终点是FPGA的输出端口时，该时序路径是没有目的时钟路径的。\n\n![img](时序约束整理/三要素.png)\n\n#### FPGA中常见的四种时序路径\n\n1. 从FPGA的输入端口到目的寄存器的数据输入端口\n\n   * 数据由Board Clock发起并在FPGA外部产生\n   * 数据经过Input Delay的延迟后到达FPGA的输入端口\n   * 数据经过FPGA的Internal Delay后到达由目的时钟驱动的目的寄存器\n\n   这种路径是没有源时钟路径的，用户需要约束Input Delay和时钟来告知时序引擎必要信息，时序引擎才能正确的分析这种路径\n\n2. 从源寄存器的时钟端口到目的寄存器的数据输入端口\n\n   * 数据由源时钟发起并在FPGA内部产生\n   * 数据经过Data Path Delay后到达由目的时钟驱动的目的寄存器\n\n   这种时序路径是最常见的，用户需要约束源时钟和目的时钟告知时序引擎必要的信息，时序引擎才能正确的分析这种时序路径。\n\n3. 从源寄存器的时钟端口到FPGA的输出端口\n\n   * 数据有源时钟发起并在FPGA内部产生\n   * 数据经过Internal Delay后到达输出端口\n   * 数据经过Output Delay后被Board Clock捕获到\n\n   这种路径是没有目的时钟路径的，用户需要约束Output Delay和时钟来告知时序引擎必要信息，时序引擎才能正确的分析这种路径。\n\n4. 从FPGA的输入端口到FPGA的输出端口\n\n   * 数据横穿FPGA，没有经过任何触发器，这种路径也叫in-to-out path，约束输入和输出延时的参考时钟可以使用虚拟时钟\n\n   这种路径中只有数据路径，用户需要约束Input Delay和Output Delay，告知时序引擎必要的信息，时序引擎才能正确的分析这种时序路径。\n\n![img](时序约束整理/四种路径.png)\n\n## 时序检查\n\n### Setup 检查\n\n#### 时序引擎如何进行Setup检查\n\n1. 确定建立时间要求（建立时间的捕获沿-建立时间的发起沿）\n\n   确定建立时间的捕获沿和建立时间的发起沿。\n\n   时序引擎会找出发起时钟和捕获时钟的最小公共周期，然后在最小公共周期内找到所有发起时钟沿和捕获时钟沿的所有可能情况，并在所有可能的情况中挑选出**最小的建立时间需求**（大于0），从而确定Launch Edge和 Capture Edge。\n\n   ![img](时序约束整理/确定建立时间要求.png)\n\n   ![img](时序约束整理/确定建立时间要求计算.png)\n\n2. 计算数据的需求时间\n\n   ![img](时序约束整理/建立时间计算数据的需求时间.png)\n\n3. 计算数据的到达时间\n\n   ![img](时序约束整理/建立时间计算数据的到达时间.png)\n\n4. 计算Setup的裕量（Slack）\n\n   ![img](时序约束整理/建立时间计算Setup的裕量.png)\n\n#### Setup分析实例\n\n* Data Arrival Time = Launch Edge + Tclka + Tco + Tdata(Tlogic + Tnet)\n\n  ![img](时序约束整理/setup分析data_arrival_time.png)\n\n* Data Require Time = Capture Edge + Tclkb - Tsu\n\n  ![img](时序约束整理/setup分析data_require_time.png)\n\n* Setup Slack = Data Require Time - Data Arrival Time\n\n  ![img](时序约束整理/setup分析setup_slack.png)\n\n#### Setup Slack为负的因素\n\n* Setup Slack = (Capture  Edge - Launch Edge) + (Destination clk delay - source clk delay) - Setup Time - Clk uncertainty - datapath delay\n* Setup Slack = Setup Requirement (一定大于0) + clk skew - Tsu - Tclk uncertainty - Tlogic - Tnet - Tco\n\n1. Setup Requirement与实际情况不符\n\n   建立时间需求过小，这种情况通常会在同步跨时钟域路径中出现，在同步跨时钟域路径中的源时钟频率与目的时钟频率的相位关系虽然是已知的，但是时序引擎默认选择的捕获沿通常都是错误的，需要用户通过多周期路径约束的方式手动修正建立时间需求。比如下图中，两个同频不同相的同步时钟，时序引擎默认选择的捕获沿是目的时钟第二个上升沿，导致建立时间需求非常小，最终肯定会导致时序违例。\n\n   ![img](时序约束整理/SetupRequirement与实际不符.png)\n\n2. Clk Skew为负值，且很大\n\n   通常情况下，同一个时钟下的时钟歪斜不应该超过300ps，同步跨时钟域路径的时钟歪斜不应该超过500ps，异步跨时钟域路径的时钟歪斜一般比较大，因为它们的时钟源不同。\n\n   当出现时钟歪斜大的情况时:\n\n   * 检查源时钟路径和目的时钟路径上是否干净，时钟路径上是否引入了组合逻辑，时钟路径是否使用了过多的BUFGCE，时钟路径上是否级联了多个BUFGCE导致时钟延时变大。\n   * 检查源时钟路径和目的时钟路径所经过的模块是否相同，比如源时钟路径上经过全局缓冲，PMMCM，但是目的时钟路径上只经过了全局缓冲。如下图所示，第一条路径的源时钟路径上有BUFGCE/MMCM/BUFGCE，而目的时钟路径上只有BUFGCE，所以源时钟路径和目的时钟路径的延时不同，导致时钟歪斜较大，应该尽量避免此类路径。第二条路径的源时钟和目的时钟都是来源于MMCM的不同的时钟，所以时钟歪斜较小。\n\n   ![img](时序约束整理/clk_skew很大.png)\n\n3. Tsu/Tco很大\n\n   当设计中使用Block（DSP/Block RAM等）时，应该要注意以下问题。对于以这些Block为时序路径的起点或终点的时序路径，这些**Block的Tsu/Th/Tco都比普通的寄存器大**，而且这些Block的布线延时和时钟歪斜比较大。所以当使用这些Block作为时序路径的终点时，它的起点一定要是触发器，比如说一个Block RAM的写数据信号，输入进Block前最好打一拍。当使用这些Block作为时序路径的起点时，应该使用Block 内部的输出寄存器，比如使用由Block RAM组成的FIFO时，尽量不要使用首字置出的，而使用打一拍后输出的，使用后者可以显著降低Tco。当时序路径为从一个Block到另一个Block时，中间需要进行打拍操作。当使用这些Block的控制端口时，应该保证这些控制信号的低扇出，如使用由Block RAM组成的FIFO时，应该尽量降低读/写能信/地址信号的扇出。\n\n   ![img](时序约束整理/Tco_Th很大.png)\n\n4. Tlogic大\n\n   一般情况下，逻辑延时与时序路径的逻辑层级数息息相关，逻辑层级是指时序路径的起点和终点之间组合逻辑单元（LUT）的个数，而逻辑层级多一级意味着多1个LUT的延时加1条连接LUT的网线延时。通常一级逻辑层级的延时标准是1个LUT加1根网线的总延迟为0.5ns，如果某条路径的逻辑级数大于时钟周期/0.5ns，那么这条路径就被称为长路径。\n\n   常用的处理长路径的方案有两种：\n\n   * 修改rtl代码，在长路径的逻辑中插入流水线，将长路径打破分为多条短路径；\n   * 使用综合工具的retiming优化方式，retiming实际上是寄存器重定向，原理是当某条长路径的相邻路径的建立时间裕量较大，那么它可以调整中间寄存器的位置，来调整布线延迟，通过适当增加相邻路径的布线延迟而减少长路径的布线延迟，使得那些时序违例较小的长路径通过这种微调实现时序收敛。需要强调的是，**这种方式优化的力度非常有限**，它只适合时序违例较小的长路径，对于一些延时特别大的长路径而言，也是无力回天。\n\n   ![img](时序约束整理/Tlogic很大.png)\n\n5. Tnet大\n\n   一般情况下，布线延迟与设计整体或局部模块的资源利用率以及拥塞程度息息相关。\n\n   在正常情况下，一条网线的延时小于1ns，在发生拥塞的区域，网线的延时可能达到若干ns，导致布线延时显著增加。为了解决布线延迟大，需要从降低资源利用率和降低拥塞程度下手，比如某个模块使用了大量的寄存器堆，占用了大量的资源，此时应该考虑使用Block RAM代替这些寄存器堆；某个模块使用了大量的数据选择器，此时应该考虑如何优化这些数据选择器；某个模块的控制信号扇出比较大，与其他模块的互联很重，此时应该考虑如何降低这些信号的扇出；某条时序路径的起点或终点是Block，由于Block的位置比较固定，所以Block的布线延迟会大一些。最后需要强调的是，一定要额外关注高扇出的网线也会对布线延时产生影响。\n\n   ![img](时序约束整理/TimeQuest时序分析Setup1.png)\n\n   TimeQuest时序分析（Setup）\n   \n   ![img](时序约束整理/TimeQuest时序分析Setup2.png)\n\n### Holdup 检查\n\n#### 时序引擎如何进行Holdup检查\n\n1. 确定保持时间要求（确定发起时钟沿和捕获时钟沿）\n\n   **保持时间要求是以建立时间要求为基础的**，保持时间要求有两种：\n\n   * 当前建立时间的发起沿产生的数据不能被当前建立时间的捕获沿的前一个有效沿捕获\n\n   * 当前建立时间的发起沿的下一个有效沿产生的数据不能被当前建立时间的捕获沿捕获\n\n   ![img](时序约束整理/holdTimeRequirement.png)\n\n   根据所有的建立时间需求找到所有的保持时间需求，并从保持时间需求（可正可负）中找到最大的保持时间需求。!\n\n   ![img](时序约束整理/HoldPathRequirement.png)\n\t\n\n   ![img](时序约束整理/DataPathRequirementCalculation.png)\n\n2. 计算数据的需求时间\n\n   ![img](时序约束整理/dataRequiredTimeHold.png)\n\n3. 计算数据的到达时间\n\n   ![img](时序约束整理/DataArrivalTimeHold.png)\n\n4. 计算Hold up的裕量(Slack)\n\n   ![img](时序约束整理/SlackHold.png)\n\n#### Holdup分析实例\n\n* Data Arrival Time (new data) = Launch Edge + Tclka + Tco + Tdata(Tlogic + Tnet)\n* Data Require Time = Capture Edge + Tclkb + Th\n* Hold up Slack = Data Arrival Time - Data Require Time\n\n![img](时序约束整理/HoldupExample.png)\n\n#### Holdup Slack为负的因素\n\n* Holdup Slack = (Launch Edge - Capture Edge) + (Tclka - Tclkb) + Tco + Tdata(Tlogic + Tnet) - Th\n* Holdup Slack = Tco + Tdata(Tlogic + Tnet) - Th - Holdup Requirement - Clk skew\n\nHold up Slack为负的情况比较少见，当Setup Slack有较大裕量时，通常工具会自动插入延时来增加Hold up Slack。\n\n1. 保持时间需求大于0（通常由时序引擎选择错误的捕获沿导致）\n2. 时钟歪斜大于300ps（通常由时钟路径上的组合逻辑导致）\n3. Th过大（通常由时钟路径上的组合逻辑导致）\n\nTimeQuest时序分析（Holdup）\n\n![img](时序约束整理/TimeQuestHoldupSlack.png)\n\n### Recovery 检查\n\n![image-20200806204803965](时序约束整理/复位结构.png)\n\n#### 时序引擎如何进行Recovery检查\n\n![img](时序约束整理/RequireTimeRecovery.png)\n\n![img](时序约束整理/TimeQuestRecovery.png)\n\n### Removal 检查\n\n#### 时序引擎如何进行Removal检查\n\n![img](时序约束整理/RequireTimeRemoval.png)\n\n![img](时序约束整理/TimeQuestRemoval.png)\n\n## 时序约束\n\n时序引擎能够正确分析4钟时序路径的前提是，用户已经进行了正确的时序约束。时序约束本质上就是告知时序引擎一些进行时序分析所必要的信息，这些信息只能由用户主动告知，时序引擎对有些信息可以自动推断，但是推断得到的信息不一定正确。\n\n* 第一种路径需要约束Input_delay\n\n* 第二种路径需要约束时钟\n\n* 第三种路径需要约束Output_delay\n\n* 第四种路径需要约束Max_delay/Min_delay\n\n  ![img](时序约束整理/FourPathConstraints.png)\n\n### 时钟约束\n\n#### 时序约束类型\n\n首先用户必须要正确的约束时钟，时序引擎才能根据时钟信息进行各种时序检查。\n\n用户约束时钟时，一般有两种类型的时钟需要约束。\n\n* 主时钟（Primary Clock）\n\n  主时钟（Primary Clock）有两种类型：第一种是从FPGA的全局时钟输入引脚输入的时钟；第二种是从高速收发器输出给用户的恢复时钟\n\n* 生成时钟（Generated Clock）\n\n  生成时钟（Generated Clock）有两种类型：第一种是由FPGA的专用时钟管理模块（PLL/MMCM）产生的时钟（这种时钟可以由时序引擎自动推断出来）；第二种是由用户通过LUT或寄存器产生的时钟（这种时钟必须由用户手动约束）\n\n1. 主时钟（Primary Clock）约束\n\n   使用`Create_clock`进行约束\n\n   * 第一种是从FPGA的全局时钟输入引脚输入的时钟：\n\n     全局时钟输入引脚是sysclk，时钟周期10ns，占空比50%，相移0度。\n\n     ![img](时序约束整理/PrimaryClockPath.png)\n\n     ![img](时序约束整理/PrimaryClockConstraints.png)\n\n     全局时钟输入引脚是ClkIn，时钟周期10ns，占空比25%，相移90度\n\n     ![img](时序约束整理/PrimaryClockPath2.png)\n\n     ![img](时序约束整理/PrimaryClockConstraints2.png)\n\n   * 第二种是从高速收发器输出给用户的恢复时钟 全局时钟输入引脚是sysclk，时钟周期3.3ns，占空比50%，相移0度\n\n     ![img](时序约束整理/PrimaryClockPathFromSerdes.png)\n\n     ![img](时序约束整理/PrimaryClockConstraintsFromSerdes.png)\n\n2. 生成时钟（Generated Clock）约束\n\n   用`Create_generated_clock`进行时序约束\n\n   每个生成时钟都会对应一个时钟源（Master_clk），这个时钟源可以是Primary Clock或者另一个Generated Clock。\n\n   在约束生成时钟时，用户不需要描述生成时钟的周期和波形，只需要描述由Master_clk经过了怎样的变化而产生的生成时钟即可。比如经过分频（-devide_by），倍频（-multiply_by），反相（-invert），相移（-edge_shift）等等操作。\n\n   ![img](时序约束整理/GeneratedClockSourceClock.png)\n\n   ![img](时序约束整理/GeneratedClcokPath.png)\n\n   ![img](时序约束整理/GeneratedClcokConstraints.png)\n\n   当生成时钟需要进行相移时，使用-edge_shift选项。\n\n   -edge_shift不能与-divide_by/-multiple_by/-invert同时使用。\n\n   ![img](时序约束整理/GeneratedClockEdgeShiftPath.png)\n\n   ![img](时序约束整理/GeneratedClockEdgeShiftConstraints.png)\n\n#### 时钟分组\n\n时序引擎默认情况下会分析所有时钟之间的时序路径，用户可以通过时钟分组`set_clock_group`命令或伪路径`set_false_path`命令来关闭一部分路径的时序分析。\n\n* 使用`set_clock_group`命令，时序引擎会将不同分组的时钟之间的路径分析关闭，相同分组的时钟之间的路径仍然存在。\n* 使用`set_false_path`命令，时序引擎会忽略两个时钟的双向路径，被忽略的路径不一定能够正常工作，需要用户确保该路径使用了两级触发器同步或者按照异步数据传输方式传输数据。用户负责保证这些被忽略的路径可以正常工作。\n\n**两个时钟的关系**\n\n1. 同步时钟（synchronous clock）\n\n   两个时钟之间的相对相位关系是固定的（两个时钟来源于同一个Primary Clock），并且这两个时钟的频率的最小公共周期是个整数。\n\n   比如一个生成时钟（200M）和该生成时钟的Master_clk（100M）之间就属于同步时钟关系，因为这两个时钟的相位关系是确定的，并且可以找到两个时钟的最小公共周期。通常情况下，一个Primary Clock和它产生的生成时钟之间都属于同步时钟关系，除非找不到最小公共周期。**属于同步时钟关系的两个时钟之间的路径是可以进行时序分析的。**\n\n2. 异步时钟（asynchronous clock）\n\n   两个时钟之间的相对相位关系不确定。\n\n   比如FPGA上两个晶振分别产生两个Primary clock（相对相位关系不固定），这两个Primary clock分别从FPGA的两个全局时钟引脚输入给两个MMCM，由两个MMCM分别产生的生成时钟之间属于异步时钟。一般情况下，不同的Primary clock之间都属于异步时钟，这些Primary clock分别产生的生成时钟之间也属于异步时钟关系。\n\n   **属于异步时钟关系的两个时钟之间的路径无法进行正确的时序分析。**\n\n   一般情况下，如果用户不通过时钟分组对时钟之间的关系进行约束，时序引擎会默认所有的时钟之间都属于同步时钟关系\n\n3. 不可扩宽的时钟（unexpandable clock）\n\n   对于这类时钟，时序引擎无法在1000个时钟周期内找到两个时钟的公共周期，时序引擎就会从这1000个时钟中找到建立时间需求最差的情况，并进行时序分析，然而它不一定是FPGA实际运行过程中建立时钟需求最差的情况，因为在1000个时钟周期外可能还会有建立时钟需求更差的情况，这样一来，时序引擎的分析结果就无法保证该路径一定不会出现问题，所以时序引擎的分析结果也就变的毫无意义。\n\n   比如说由同一个Primary Clock驱动的两个MMCM的生成时钟分别是clk0（5.125ns）和clk1（6.666ns），虽然他们的相对相位关系是固定的，但是时序引擎无法保证对两个时钟之间的路径的分析属于最差情况，这种情况和异步时钟之间的时序分析类似，时序分析的结果都看起来正常，但是这个结果是不可信的。所以对这种时钟的处理方式与处理异步时钟是相同的，用户都需要进行跨时钟域的操作。\n\n**总结：异步时钟和不可扩展的时钟之间的路径都无法进行正确的时序分析，所以在时序分析之前，需要使用`set_clock_group`对时钟进行分组，从而将这些无法进行正确时序分析的路径忽略掉。**\n\n**时钟分组实例**\n\n* 第一个Primary clock clk0从FPGA的全局时钟引脚进入了一个MMCM，MMCM生成了两个生成时钟 userclk, itfclk\n\n* 第二个Primary clock clk1是一个高速收发器输出的恢复时钟，将该恢复时钟输入进一个MMCM，MMCM生成了两个生成时钟gtxclk, gtxclktx\n\n  ![img](时序约束整理/set_clock_group_command.png)\n\n  ![img](时序约束整理/set_clock_group_command2.png)\n\n### Input/Output 延时约束\n\n#### 什么是Input delay? 如何计算它？如何约束它？\n\n**Input delay概念**\n\n![img](时序约束整理/input_delay.png)\n\n**Input delay计算**\n\n![img](时序约束整理/input_delay_path1.png)\n\n![img](时序约束整理/input_delay_path2.png)\n\n**Max Input Delay = Tco(Max) + Tpcb(Max) - Clk skew(Min)**\n\n![img](时序约束整理/max_input_delay.png)\n\n**Min Input Delay = Tco(Min) + Tpcb(Min) - Clk skew(Max)**\n\n![img](时序约束整理/Min_Input_Delay.png)\n\n**Input delay约束**\n\n![img](时序约束整理/input_delay_constraints1.png)\n\n![img](时序约束整理/input_delay_constraints2.png)\n\n![img](时序约束整理/input_delay_constraints3.png)\n\n#### 什么是Output delay？如何计算它？如何约束它？\n\n**Output delay概念**\n\n![img](时序约束整理/output_delay.png)\n\n**Output delay计算**\n\n![img](时序约束整理/output_delay_path1.png)\n\n![img](时序约束整理/output_delay_path2.png)\n\n**Max Output Delay = Tpcb(Max) + Tsu - Clk skew(Min)**\n\n![img](时序约束整理/max_output_delay.png)\n\n**Min Output Delay = Tpcb(Min) - Th - Clk skew(Max)**\n\n![img](时序约束整理/min_output_delay.png)\n\n**Output delay约束**\n\n![img](时序约束整理/output_delay_constraints1.png)\n\n![img](时序约束整理/output_delay_constraints2.png)\n\n### Multicycle 约束\n\n#### 为什么要进行Multicycle约束？\n\n* 时序引擎默认情况下会在建立时间需求/保持时间需求最差的情况下进行时序分析，而时序引擎选择的这种需求不一定是用户真正希望的，而且时序引擎默认选择的这种需求是非常严苛的，甚至是根本无法满足的。此时就需要用户进行Multicycle约束，手动修改建立时间需求/保持时间需求。\n* 用户希望放松某些路径的约束力度，就可以通过Multicycle约束调整建立时间需求/保持时间需求。 \n\n使用`set_multicycle_path`命令进行约束\n\n![img](时序约束整理/set_multicycle_path.png)\n\n![img](时序约束整理/set_multicycle_path_start_end.png)\n\n![img](时序约束整理/set_multicycle_path_source_destination_clock.png)\n\n#### 如何进行正确Multicycle约束？\n\n注：使用`set_multicycle_path`命令\n\n1. 在源时钟和目的时钟相同的情况下进行Multicycle约束\n\n   ![img](时序约束整理/multicycle_path_same_clock.png)\n\n   ![img](时序约束整理/multicycle_path_same_clock_timing.png)\n\n   * 每两个时钟发起一次数据，每两个时钟捕获一次数据\n\n     ![img](时序约束整理/multicycle_path_rtl_diagram.png)\n\n     ![img](时序约束整理/set_multicyclye_path_same_clk_command.png)\n\n     ![img](时序约束整理/set_multicycle_path_same_clk_timing.png)\n\n     ![img](时序约束整理/set_multicyclye_path_same_clk_command2.png)\n\n     ![img](时序约束整理/set_multicycle_path_same_clk_timing2.png)\n\n   * 每四个时钟发起一次数据，每四个时钟捕获一次数据\n\n     ![img](时序约束整理/set_multicycle_path_4_timing.png)\n\n   * 只调整setup需求，Holdup需求会发生相应的变化，但是变化结果是错误的\n\n     ![img](时序约束整理/set_multicycle_path_just_setup.png)\n\n     ![img](时序约束整理/set_multicycle_path_just_setup_timing.png)\n\n   * 进一步调整Holdup需求（-start）\n\n     ![img](时序约束整理/set_multicycle_path_holdup_adjust.png)\n\n     ![img](时序约束整理/set_multicycle_path_holdup_timing.png)\n\n   * Set_multicycle_path 4 –hold –end –from [get_pins data0_reg/C] – to [get_pins data1_reg/C]\n\n     ![img](时序约束整理/set_multicycle_hold_4.png)\n\n2. 在源时钟和目的时钟频率相同且有正向偏移的情况下（正向偏移0.3ns）\n\n   ![img](时序约束整理/set_multicycle_path_timeshift0.3.png)\n\n   ![img](时序约束整理/set_multicycle_path_timeshift0.3_timing.png)\n\n   先调整setup需求，holdup需求发生相应的变化，但变化的结果是正确的\n\n   ![img](时序约束整理/set_multicycle_setup_timeshift.png)\n\n   ![img](时序约束整理/set_multicycle_setup_timeshift_timing.png)\n\n3. 在源时钟的目的时钟频率相同且有负向偏移的情况下（负向偏移0.3ns）发生负向偏移时，通常不需要进行Multicycle的约束，除非负向偏移过大\n\n   ![img](时序约束整理/set_multicycle_path_minus_shift.png)\n\n   ![img](时序约束整理/set_multicycle_path_minus_shift_timing.png)\n\n4. 在源时钟和目的时钟频率不同的情况下（源时钟慢，目的时钟快）\n\n   ![img](时序约束整理/set_multicycle_path_slow2fast.png)\n\n   ![img](时序约束整理/set_multicycle_path_slow2fast_timing.png)\n\n   调整setup需求（只能用-end，不能用-start），Holdup需求发生相应的变化，变化的结果是错误的。\n\n   ![img](时序约束整理/set_multicycle_path_slow2fast_just_setup_command.png)\n\n   ![img](时序约束整理/set_multicycle_path_slow2fast_just_setup_timing.png)\n\n   进一步调整Holdup需求（只能用-end，不能用-start）\n\n   ![img](时序约束整理/set_multicycle_path_slow2fast_holdup_command.png)\n\n   ![img](时序约束整理/set_multicycle_path_slow2fast_holdup_timing.png)\n\n5. 在源时钟和目的时钟频率不同的情况下（源时钟快，目的时钟慢）\n\n   ![img](时序约束整理/set_multicycle_path_fast2slow.png)\n\n   ![img](时序约束整理/set_multicycle_path_fast2slow_timing.png)\n\n   同时调整setup需求（只能用-start，不能用-end）和Holdup需求（只能用-start，不能用-end）\n\n   ![img](时序约束整理/set_multicycle_path_fast2slow_setup_hold_command.png)\n\n   ![img](时序约束整理/set_multicycle_path_fast2slow_setup_hold_timing.png)\n\n### Falsepath 约束\n\n#### 什么样的路径属于FalsePath?\n\n注：使用`set_false_path`命令\n\nFalsePath路径是指该路径在拓扑结构中的确存在，但是满足以下任一条件的路径：\n\n* 在实际运行过程中，该路径不工作\n* 该路径不需要进行时序分析\n\n比如：已经做了两级触发器同步的跨时钟域路径\n\n只在上电时工作一次的寄存器\n\n异步复位路径或用于测试的路径\n\n**注意**：如果用户的目的只是放松某条路径的时序约束，可以用`set_multicycle_path`命令进行约束，不要使用`set_false_path`\n\n**设置FalsePath的好处**\n\n1. 减小综合、实现、时序分析的时间\n2. 极大的提升工具对设计的综合、实现、优化的结果\n\n![img](时序约束整理/set_false_path_command.png)\n\n-from/-to的node_list必须是有效的时序路径的起点和终点，或是时钟。-through的node_list可以是ports/pins。\n\n#### FalsePath约束举例\n\n1. 将异步复位信号设置为伪路径\n\n   ![img](时序约束整理/set_false_path_reset.png)\n\n2. 将CLKA到CLKB的单向路径设置为伪路径\n\n   ![img](时序约束整理/set_false_path_a2b_single.png)\n\n3. 将CLKA到CLKB以及CLKB到CLKA的双向路径设置为伪路径\n\n   ![img](时序约束整理/set_false_path_a2b_dual.png)\n\n**注**：当有多个异步时钟之间的路径需要设置为伪路径时，推荐使用`set_clock_group`命令。\n\n![img](时序约束整理/set_false_path_through_diagram.png)\n\n![img](时序约束整理/set_false_path_through_command.png)\n\n凡是经过MUX1/a0，到MUX2/a1的时序路径都会被忽略，采用-through的好处是不需要具体指定时序路径的起点和终点，-through的顺序需要注意，上述命令描述的是先经过MUX1/a0，然后再经过MUX2/a1。\n\n### Maxdelay约束\n\n#### 什么情况下使用Maxdelay约束？\n\n1. 它可以代替Multicycle约束，调整建立时间需求，而且`set_max_delay`约束的优先级比Multicycle约束要高\n2. 对于两个异步时钟域之间的异步信号不需要进行时序分析，但是用户对路径延迟有一定的要求时，可以使用`set_max_delay -datapath only`进行约束。`-datapath only`用于忽略时钟歪斜，只考虑数据路径的延时。\n\n**注**：当用户需要对两个异步时钟域之间的部分/所有路径指定路径的最大延时，用户需要使用`set_max_delay -datapath only`对这些路径的延时进行约束，同时用户不能使用`set_clock_group`约束，因为`set_clock_group`的优先级比`set_maxdelay`高。**两个时钟域之间的剩余路径可以使用`set_false_path`进行约束。**\n\n对于通过set_false_path/set_clock_group命令进行约束的路径，综合器不会对该路径进行优化，很可能导致两个寄存器的位置很远。\n\n1. 单bit信号跨时钟域（两级触发器同步）\n\n   此时只需要使用`set_false_path/set_clock_group`对异步信号的路径约束即可，因为此时两个寄存器之间的延迟不会影响功能，只会影响性能，此时不需要使用Maxdelay约束。\n\n   ![image-20200801212024545](时序约束整理/single_bit_cdc_diagram.png)\n\n2. 多bit信号跨时钟域（格雷码）\n\n   此时若只使用`set_false_path/set_clock_group`对异步信号的路径约束，可能会影响格雷码功能的正确性。所以需要Maxdelay对数据路径的延迟进行约束。\n\n   设计中也常用一种带有格雷码控制的FIFO来实现异步时钟域的隔离。计数器和读写指针等需要用BRAM外部的逻辑搭建，这样的结构就不能简单约束`set_clock_groups`，还要考虑这些外部逻辑如何约束。\n\n   在存储器外部有一些用FPGA逻辑搭建的写指针和读指针控制，分属不同的时钟域，存在跨时钟域的时序路径。\n\n   此时如果仅将读写时钟用`set_clock_goups`约束为异步时钟，想当于设置从A到B和从B到A的路径全部为false path。false path的优先级最高，很显然这么做会导致所有跨读写时钟域的路径全部不做时序分析，读写指针和相关控制逻辑也就失去了存在的意义。\n\n#### 如何进行Maxdelay约束\n\n`set_max_delay -from [get_cells GCB0[*]] -to [get_cells GCB1a[*]] -datapath_only 5`（具体延迟大小一般不超过目的时钟的时钟周期）\n\n`set_false_path -from [get_cells rega] -to [get_cells regb]`\n\n![image-20200801214136797](时序约束整理/set_max_delay_diagram.png)\n","source":"_posts/2024/01/时序约束整理.md","raw":"---\ntitle: 时序约束整理\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2024-01-16 13:36:52\npassword: \nsummary:\ntags:\n- FPGA\ncategories:\n- FPGA\nkeywords:\n- 时序约束\ndescription:\n---\n# <center>时序约束整理</center>\n\n- [时序分析基础知识](#时序分析基础知识)\n- [时序检查](#时序检查)\n    - [Setup 检查](#setup-检查)\n    - [Holdup 检查](#holdup-检查)\n    - [Recovery 检查](#recovery-检查)\n    - [Removal 检查](#removal-检查)\n- [时序约束](#时序约束)\n    - [时钟约束](#时钟约束)\n    - [Input/Output 延时约束](#inputoutput-延时约束)\n    - [Multicycle 约束](#multicycle-约束)\n    - [Falsepath 约束](#falsepath-约束)\n    - [Maxdelay约束](#maxdelay约束)\n\n##  1.时序分析基础知识\n\n#### 什么是时序分析\n\n时序分析本质上就是一种时序检查，目的是检查设计中所有的D触发器是否能够正常工作，也就是检查D触发器的同步端口（数据输入端口）的变化是否满足建立时间要求（Setup）和保持时间要求（Hold）；检查D触发器的异步端口（异步复位端口）的变化是否满足恢复时间要求（Recovery）和移除时间要求（Removal）。\n\n![时序分析](时序约束整理/时序分析.png)\n\n#### 时序分析有哪些类型\n\n时序分析包括静态时序分析（STA）和动态时序分析。\n\n* 动态时序分析：将布局布线生成的布线延迟信息反标注到门级网表中进行仿真，检查是否存在时序违例。此时的仿真包括门延迟和布线延迟信息，能够较好反应芯片的实际工作情况。因为不可能产生完备的测试向量，覆盖门级网表中的每一条路径。因此在动态时序分析中，无法暴露一些路径上可能存在的时序问题。\n* 静态时序分析：采用穷尽分析方法来提取出整个电路存在的所有时序路径，计算信号在这些路径上的传播延时，检查信号的建立和保持时间是否满足时序要求，通过对最大路径延时和最小路径延时的分析，找出违背时序约束的错误。它不需要输入向量就能穷尽所有的路径，且运行速度很快、占用内存较少，不仅可以对芯片设计进行全面的时序功能检查，而且还可利用时序分析的结果来优化设计，因此静态时序分析已经越来越多地被用到数字集成电路设计的验证中。\n\n#### 时序分析使用的工具有哪些\n\n* 静态时序分析使用的工具\n  * Xilinx Vivado Integrated Design Environment Time Engine\n  * Altera Quartus II Timequest\n  * DC等\n* 动态时序分析使用的工具\n  * Mentor Modelsim\n  * Cadence NC-Verilog\n  * Sysnopsys VCS\n\n#### 静态时序分析之前的准备工作\n\n撰写基本的时序约束文件，告知时序引擎一些必要的信息（比如时钟，输入输出延时等）。若没有正确的时序约束，那么时序分析的结果是没有意义的。\n\nD触发器中Tsetup, Thold, Tco的由来\n![D触发器原理图](时序约束整理/TsetupThold的由来.png)\n![Th的由来](时序约束整理/Th的由来.png)\n\n#### 序分析中的常用术语\n\n* 源时钟（Source Clock/Launch Clock，也称发起时钟）\n* 目的时钟（Destination Clock/ Capture Clock, 也称捕获时钟）\n* 发起沿（Launch Edge，源时钟产生数据的有效时钟沿）\n* 捕获沿（Capture Edge，目的时钟捕获数据的有效时钟沿）\n\n发起沿通常在0ns，捕获沿通常在下一个发起沿，发起沿和捕获沿通常相差一个时钟周期。\n\n![img](时序约束整理/LaunchEdgeCaptureEdge.png)\n\n#### 一条普通时序路径的三要素\n\n* 源时钟路径：从源时钟的源节点（通常是FPGA的时钟输入引脚）到源寄存器的时钟端口的路径。当时序路径的起点是FPGA输入端口时，该时序路径是没有源时钟路径的。\n* 数据路径：从时序路径的起点到时序路径的终点之间的数据传播路径。时序路径的起点可以是源寄存器的时钟端口或FPGA的输入端口，时序路径的终点可以是目的寄存器的输入端口或FPGA的输出端口。\n* 目的时钟路径：从目的时钟的源节点（通常是FPGA的时钟输入引脚）到目的寄存器的时钟端口的路径。当时序路径的终点是FPGA的输出端口时，该时序路径是没有目的时钟路径的。\n\n![img](时序约束整理/三要素.png)\n\n#### FPGA中常见的四种时序路径\n\n1. 从FPGA的输入端口到目的寄存器的数据输入端口\n\n   * 数据由Board Clock发起并在FPGA外部产生\n   * 数据经过Input Delay的延迟后到达FPGA的输入端口\n   * 数据经过FPGA的Internal Delay后到达由目的时钟驱动的目的寄存器\n\n   这种路径是没有源时钟路径的，用户需要约束Input Delay和时钟来告知时序引擎必要信息，时序引擎才能正确的分析这种路径\n\n2. 从源寄存器的时钟端口到目的寄存器的数据输入端口\n\n   * 数据由源时钟发起并在FPGA内部产生\n   * 数据经过Data Path Delay后到达由目的时钟驱动的目的寄存器\n\n   这种时序路径是最常见的，用户需要约束源时钟和目的时钟告知时序引擎必要的信息，时序引擎才能正确的分析这种时序路径。\n\n3. 从源寄存器的时钟端口到FPGA的输出端口\n\n   * 数据有源时钟发起并在FPGA内部产生\n   * 数据经过Internal Delay后到达输出端口\n   * 数据经过Output Delay后被Board Clock捕获到\n\n   这种路径是没有目的时钟路径的，用户需要约束Output Delay和时钟来告知时序引擎必要信息，时序引擎才能正确的分析这种路径。\n\n4. 从FPGA的输入端口到FPGA的输出端口\n\n   * 数据横穿FPGA，没有经过任何触发器，这种路径也叫in-to-out path，约束输入和输出延时的参考时钟可以使用虚拟时钟\n\n   这种路径中只有数据路径，用户需要约束Input Delay和Output Delay，告知时序引擎必要的信息，时序引擎才能正确的分析这种时序路径。\n\n![img](时序约束整理/四种路径.png)\n\n## 时序检查\n\n### Setup 检查\n\n#### 时序引擎如何进行Setup检查\n\n1. 确定建立时间要求（建立时间的捕获沿-建立时间的发起沿）\n\n   确定建立时间的捕获沿和建立时间的发起沿。\n\n   时序引擎会找出发起时钟和捕获时钟的最小公共周期，然后在最小公共周期内找到所有发起时钟沿和捕获时钟沿的所有可能情况，并在所有可能的情况中挑选出**最小的建立时间需求**（大于0），从而确定Launch Edge和 Capture Edge。\n\n   ![img](时序约束整理/确定建立时间要求.png)\n\n   ![img](时序约束整理/确定建立时间要求计算.png)\n\n2. 计算数据的需求时间\n\n   ![img](时序约束整理/建立时间计算数据的需求时间.png)\n\n3. 计算数据的到达时间\n\n   ![img](时序约束整理/建立时间计算数据的到达时间.png)\n\n4. 计算Setup的裕量（Slack）\n\n   ![img](时序约束整理/建立时间计算Setup的裕量.png)\n\n#### Setup分析实例\n\n* Data Arrival Time = Launch Edge + Tclka + Tco + Tdata(Tlogic + Tnet)\n\n  ![img](时序约束整理/setup分析data_arrival_time.png)\n\n* Data Require Time = Capture Edge + Tclkb - Tsu\n\n  ![img](时序约束整理/setup分析data_require_time.png)\n\n* Setup Slack = Data Require Time - Data Arrival Time\n\n  ![img](时序约束整理/setup分析setup_slack.png)\n\n#### Setup Slack为负的因素\n\n* Setup Slack = (Capture  Edge - Launch Edge) + (Destination clk delay - source clk delay) - Setup Time - Clk uncertainty - datapath delay\n* Setup Slack = Setup Requirement (一定大于0) + clk skew - Tsu - Tclk uncertainty - Tlogic - Tnet - Tco\n\n1. Setup Requirement与实际情况不符\n\n   建立时间需求过小，这种情况通常会在同步跨时钟域路径中出现，在同步跨时钟域路径中的源时钟频率与目的时钟频率的相位关系虽然是已知的，但是时序引擎默认选择的捕获沿通常都是错误的，需要用户通过多周期路径约束的方式手动修正建立时间需求。比如下图中，两个同频不同相的同步时钟，时序引擎默认选择的捕获沿是目的时钟第二个上升沿，导致建立时间需求非常小，最终肯定会导致时序违例。\n\n   ![img](时序约束整理/SetupRequirement与实际不符.png)\n\n2. Clk Skew为负值，且很大\n\n   通常情况下，同一个时钟下的时钟歪斜不应该超过300ps，同步跨时钟域路径的时钟歪斜不应该超过500ps，异步跨时钟域路径的时钟歪斜一般比较大，因为它们的时钟源不同。\n\n   当出现时钟歪斜大的情况时:\n\n   * 检查源时钟路径和目的时钟路径上是否干净，时钟路径上是否引入了组合逻辑，时钟路径是否使用了过多的BUFGCE，时钟路径上是否级联了多个BUFGCE导致时钟延时变大。\n   * 检查源时钟路径和目的时钟路径所经过的模块是否相同，比如源时钟路径上经过全局缓冲，PMMCM，但是目的时钟路径上只经过了全局缓冲。如下图所示，第一条路径的源时钟路径上有BUFGCE/MMCM/BUFGCE，而目的时钟路径上只有BUFGCE，所以源时钟路径和目的时钟路径的延时不同，导致时钟歪斜较大，应该尽量避免此类路径。第二条路径的源时钟和目的时钟都是来源于MMCM的不同的时钟，所以时钟歪斜较小。\n\n   ![img](时序约束整理/clk_skew很大.png)\n\n3. Tsu/Tco很大\n\n   当设计中使用Block（DSP/Block RAM等）时，应该要注意以下问题。对于以这些Block为时序路径的起点或终点的时序路径，这些**Block的Tsu/Th/Tco都比普通的寄存器大**，而且这些Block的布线延时和时钟歪斜比较大。所以当使用这些Block作为时序路径的终点时，它的起点一定要是触发器，比如说一个Block RAM的写数据信号，输入进Block前最好打一拍。当使用这些Block作为时序路径的起点时，应该使用Block 内部的输出寄存器，比如使用由Block RAM组成的FIFO时，尽量不要使用首字置出的，而使用打一拍后输出的，使用后者可以显著降低Tco。当时序路径为从一个Block到另一个Block时，中间需要进行打拍操作。当使用这些Block的控制端口时，应该保证这些控制信号的低扇出，如使用由Block RAM组成的FIFO时，应该尽量降低读/写能信/地址信号的扇出。\n\n   ![img](时序约束整理/Tco_Th很大.png)\n\n4. Tlogic大\n\n   一般情况下，逻辑延时与时序路径的逻辑层级数息息相关，逻辑层级是指时序路径的起点和终点之间组合逻辑单元（LUT）的个数，而逻辑层级多一级意味着多1个LUT的延时加1条连接LUT的网线延时。通常一级逻辑层级的延时标准是1个LUT加1根网线的总延迟为0.5ns，如果某条路径的逻辑级数大于时钟周期/0.5ns，那么这条路径就被称为长路径。\n\n   常用的处理长路径的方案有两种：\n\n   * 修改rtl代码，在长路径的逻辑中插入流水线，将长路径打破分为多条短路径；\n   * 使用综合工具的retiming优化方式，retiming实际上是寄存器重定向，原理是当某条长路径的相邻路径的建立时间裕量较大，那么它可以调整中间寄存器的位置，来调整布线延迟，通过适当增加相邻路径的布线延迟而减少长路径的布线延迟，使得那些时序违例较小的长路径通过这种微调实现时序收敛。需要强调的是，**这种方式优化的力度非常有限**，它只适合时序违例较小的长路径，对于一些延时特别大的长路径而言，也是无力回天。\n\n   ![img](时序约束整理/Tlogic很大.png)\n\n5. Tnet大\n\n   一般情况下，布线延迟与设计整体或局部模块的资源利用率以及拥塞程度息息相关。\n\n   在正常情况下，一条网线的延时小于1ns，在发生拥塞的区域，网线的延时可能达到若干ns，导致布线延时显著增加。为了解决布线延迟大，需要从降低资源利用率和降低拥塞程度下手，比如某个模块使用了大量的寄存器堆，占用了大量的资源，此时应该考虑使用Block RAM代替这些寄存器堆；某个模块使用了大量的数据选择器，此时应该考虑如何优化这些数据选择器；某个模块的控制信号扇出比较大，与其他模块的互联很重，此时应该考虑如何降低这些信号的扇出；某条时序路径的起点或终点是Block，由于Block的位置比较固定，所以Block的布线延迟会大一些。最后需要强调的是，一定要额外关注高扇出的网线也会对布线延时产生影响。\n\n   ![img](时序约束整理/TimeQuest时序分析Setup1.png)\n\n   TimeQuest时序分析（Setup）\n   \n   ![img](时序约束整理/TimeQuest时序分析Setup2.png)\n\n### Holdup 检查\n\n#### 时序引擎如何进行Holdup检查\n\n1. 确定保持时间要求（确定发起时钟沿和捕获时钟沿）\n\n   **保持时间要求是以建立时间要求为基础的**，保持时间要求有两种：\n\n   * 当前建立时间的发起沿产生的数据不能被当前建立时间的捕获沿的前一个有效沿捕获\n\n   * 当前建立时间的发起沿的下一个有效沿产生的数据不能被当前建立时间的捕获沿捕获\n\n   ![img](时序约束整理/holdTimeRequirement.png)\n\n   根据所有的建立时间需求找到所有的保持时间需求，并从保持时间需求（可正可负）中找到最大的保持时间需求。!\n\n   ![img](时序约束整理/HoldPathRequirement.png)\n\t\n\n   ![img](时序约束整理/DataPathRequirementCalculation.png)\n\n2. 计算数据的需求时间\n\n   ![img](时序约束整理/dataRequiredTimeHold.png)\n\n3. 计算数据的到达时间\n\n   ![img](时序约束整理/DataArrivalTimeHold.png)\n\n4. 计算Hold up的裕量(Slack)\n\n   ![img](时序约束整理/SlackHold.png)\n\n#### Holdup分析实例\n\n* Data Arrival Time (new data) = Launch Edge + Tclka + Tco + Tdata(Tlogic + Tnet)\n* Data Require Time = Capture Edge + Tclkb + Th\n* Hold up Slack = Data Arrival Time - Data Require Time\n\n![img](时序约束整理/HoldupExample.png)\n\n#### Holdup Slack为负的因素\n\n* Holdup Slack = (Launch Edge - Capture Edge) + (Tclka - Tclkb) + Tco + Tdata(Tlogic + Tnet) - Th\n* Holdup Slack = Tco + Tdata(Tlogic + Tnet) - Th - Holdup Requirement - Clk skew\n\nHold up Slack为负的情况比较少见，当Setup Slack有较大裕量时，通常工具会自动插入延时来增加Hold up Slack。\n\n1. 保持时间需求大于0（通常由时序引擎选择错误的捕获沿导致）\n2. 时钟歪斜大于300ps（通常由时钟路径上的组合逻辑导致）\n3. Th过大（通常由时钟路径上的组合逻辑导致）\n\nTimeQuest时序分析（Holdup）\n\n![img](时序约束整理/TimeQuestHoldupSlack.png)\n\n### Recovery 检查\n\n![image-20200806204803965](时序约束整理/复位结构.png)\n\n#### 时序引擎如何进行Recovery检查\n\n![img](时序约束整理/RequireTimeRecovery.png)\n\n![img](时序约束整理/TimeQuestRecovery.png)\n\n### Removal 检查\n\n#### 时序引擎如何进行Removal检查\n\n![img](时序约束整理/RequireTimeRemoval.png)\n\n![img](时序约束整理/TimeQuestRemoval.png)\n\n## 时序约束\n\n时序引擎能够正确分析4钟时序路径的前提是，用户已经进行了正确的时序约束。时序约束本质上就是告知时序引擎一些进行时序分析所必要的信息，这些信息只能由用户主动告知，时序引擎对有些信息可以自动推断，但是推断得到的信息不一定正确。\n\n* 第一种路径需要约束Input_delay\n\n* 第二种路径需要约束时钟\n\n* 第三种路径需要约束Output_delay\n\n* 第四种路径需要约束Max_delay/Min_delay\n\n  ![img](时序约束整理/FourPathConstraints.png)\n\n### 时钟约束\n\n#### 时序约束类型\n\n首先用户必须要正确的约束时钟，时序引擎才能根据时钟信息进行各种时序检查。\n\n用户约束时钟时，一般有两种类型的时钟需要约束。\n\n* 主时钟（Primary Clock）\n\n  主时钟（Primary Clock）有两种类型：第一种是从FPGA的全局时钟输入引脚输入的时钟；第二种是从高速收发器输出给用户的恢复时钟\n\n* 生成时钟（Generated Clock）\n\n  生成时钟（Generated Clock）有两种类型：第一种是由FPGA的专用时钟管理模块（PLL/MMCM）产生的时钟（这种时钟可以由时序引擎自动推断出来）；第二种是由用户通过LUT或寄存器产生的时钟（这种时钟必须由用户手动约束）\n\n1. 主时钟（Primary Clock）约束\n\n   使用`Create_clock`进行约束\n\n   * 第一种是从FPGA的全局时钟输入引脚输入的时钟：\n\n     全局时钟输入引脚是sysclk，时钟周期10ns，占空比50%，相移0度。\n\n     ![img](时序约束整理/PrimaryClockPath.png)\n\n     ![img](时序约束整理/PrimaryClockConstraints.png)\n\n     全局时钟输入引脚是ClkIn，时钟周期10ns，占空比25%，相移90度\n\n     ![img](时序约束整理/PrimaryClockPath2.png)\n\n     ![img](时序约束整理/PrimaryClockConstraints2.png)\n\n   * 第二种是从高速收发器输出给用户的恢复时钟 全局时钟输入引脚是sysclk，时钟周期3.3ns，占空比50%，相移0度\n\n     ![img](时序约束整理/PrimaryClockPathFromSerdes.png)\n\n     ![img](时序约束整理/PrimaryClockConstraintsFromSerdes.png)\n\n2. 生成时钟（Generated Clock）约束\n\n   用`Create_generated_clock`进行时序约束\n\n   每个生成时钟都会对应一个时钟源（Master_clk），这个时钟源可以是Primary Clock或者另一个Generated Clock。\n\n   在约束生成时钟时，用户不需要描述生成时钟的周期和波形，只需要描述由Master_clk经过了怎样的变化而产生的生成时钟即可。比如经过分频（-devide_by），倍频（-multiply_by），反相（-invert），相移（-edge_shift）等等操作。\n\n   ![img](时序约束整理/GeneratedClockSourceClock.png)\n\n   ![img](时序约束整理/GeneratedClcokPath.png)\n\n   ![img](时序约束整理/GeneratedClcokConstraints.png)\n\n   当生成时钟需要进行相移时，使用-edge_shift选项。\n\n   -edge_shift不能与-divide_by/-multiple_by/-invert同时使用。\n\n   ![img](时序约束整理/GeneratedClockEdgeShiftPath.png)\n\n   ![img](时序约束整理/GeneratedClockEdgeShiftConstraints.png)\n\n#### 时钟分组\n\n时序引擎默认情况下会分析所有时钟之间的时序路径，用户可以通过时钟分组`set_clock_group`命令或伪路径`set_false_path`命令来关闭一部分路径的时序分析。\n\n* 使用`set_clock_group`命令，时序引擎会将不同分组的时钟之间的路径分析关闭，相同分组的时钟之间的路径仍然存在。\n* 使用`set_false_path`命令，时序引擎会忽略两个时钟的双向路径，被忽略的路径不一定能够正常工作，需要用户确保该路径使用了两级触发器同步或者按照异步数据传输方式传输数据。用户负责保证这些被忽略的路径可以正常工作。\n\n**两个时钟的关系**\n\n1. 同步时钟（synchronous clock）\n\n   两个时钟之间的相对相位关系是固定的（两个时钟来源于同一个Primary Clock），并且这两个时钟的频率的最小公共周期是个整数。\n\n   比如一个生成时钟（200M）和该生成时钟的Master_clk（100M）之间就属于同步时钟关系，因为这两个时钟的相位关系是确定的，并且可以找到两个时钟的最小公共周期。通常情况下，一个Primary Clock和它产生的生成时钟之间都属于同步时钟关系，除非找不到最小公共周期。**属于同步时钟关系的两个时钟之间的路径是可以进行时序分析的。**\n\n2. 异步时钟（asynchronous clock）\n\n   两个时钟之间的相对相位关系不确定。\n\n   比如FPGA上两个晶振分别产生两个Primary clock（相对相位关系不固定），这两个Primary clock分别从FPGA的两个全局时钟引脚输入给两个MMCM，由两个MMCM分别产生的生成时钟之间属于异步时钟。一般情况下，不同的Primary clock之间都属于异步时钟，这些Primary clock分别产生的生成时钟之间也属于异步时钟关系。\n\n   **属于异步时钟关系的两个时钟之间的路径无法进行正确的时序分析。**\n\n   一般情况下，如果用户不通过时钟分组对时钟之间的关系进行约束，时序引擎会默认所有的时钟之间都属于同步时钟关系\n\n3. 不可扩宽的时钟（unexpandable clock）\n\n   对于这类时钟，时序引擎无法在1000个时钟周期内找到两个时钟的公共周期，时序引擎就会从这1000个时钟中找到建立时间需求最差的情况，并进行时序分析，然而它不一定是FPGA实际运行过程中建立时钟需求最差的情况，因为在1000个时钟周期外可能还会有建立时钟需求更差的情况，这样一来，时序引擎的分析结果就无法保证该路径一定不会出现问题，所以时序引擎的分析结果也就变的毫无意义。\n\n   比如说由同一个Primary Clock驱动的两个MMCM的生成时钟分别是clk0（5.125ns）和clk1（6.666ns），虽然他们的相对相位关系是固定的，但是时序引擎无法保证对两个时钟之间的路径的分析属于最差情况，这种情况和异步时钟之间的时序分析类似，时序分析的结果都看起来正常，但是这个结果是不可信的。所以对这种时钟的处理方式与处理异步时钟是相同的，用户都需要进行跨时钟域的操作。\n\n**总结：异步时钟和不可扩展的时钟之间的路径都无法进行正确的时序分析，所以在时序分析之前，需要使用`set_clock_group`对时钟进行分组，从而将这些无法进行正确时序分析的路径忽略掉。**\n\n**时钟分组实例**\n\n* 第一个Primary clock clk0从FPGA的全局时钟引脚进入了一个MMCM，MMCM生成了两个生成时钟 userclk, itfclk\n\n* 第二个Primary clock clk1是一个高速收发器输出的恢复时钟，将该恢复时钟输入进一个MMCM，MMCM生成了两个生成时钟gtxclk, gtxclktx\n\n  ![img](时序约束整理/set_clock_group_command.png)\n\n  ![img](时序约束整理/set_clock_group_command2.png)\n\n### Input/Output 延时约束\n\n#### 什么是Input delay? 如何计算它？如何约束它？\n\n**Input delay概念**\n\n![img](时序约束整理/input_delay.png)\n\n**Input delay计算**\n\n![img](时序约束整理/input_delay_path1.png)\n\n![img](时序约束整理/input_delay_path2.png)\n\n**Max Input Delay = Tco(Max) + Tpcb(Max) - Clk skew(Min)**\n\n![img](时序约束整理/max_input_delay.png)\n\n**Min Input Delay = Tco(Min) + Tpcb(Min) - Clk skew(Max)**\n\n![img](时序约束整理/Min_Input_Delay.png)\n\n**Input delay约束**\n\n![img](时序约束整理/input_delay_constraints1.png)\n\n![img](时序约束整理/input_delay_constraints2.png)\n\n![img](时序约束整理/input_delay_constraints3.png)\n\n#### 什么是Output delay？如何计算它？如何约束它？\n\n**Output delay概念**\n\n![img](时序约束整理/output_delay.png)\n\n**Output delay计算**\n\n![img](时序约束整理/output_delay_path1.png)\n\n![img](时序约束整理/output_delay_path2.png)\n\n**Max Output Delay = Tpcb(Max) + Tsu - Clk skew(Min)**\n\n![img](时序约束整理/max_output_delay.png)\n\n**Min Output Delay = Tpcb(Min) - Th - Clk skew(Max)**\n\n![img](时序约束整理/min_output_delay.png)\n\n**Output delay约束**\n\n![img](时序约束整理/output_delay_constraints1.png)\n\n![img](时序约束整理/output_delay_constraints2.png)\n\n### Multicycle 约束\n\n#### 为什么要进行Multicycle约束？\n\n* 时序引擎默认情况下会在建立时间需求/保持时间需求最差的情况下进行时序分析，而时序引擎选择的这种需求不一定是用户真正希望的，而且时序引擎默认选择的这种需求是非常严苛的，甚至是根本无法满足的。此时就需要用户进行Multicycle约束，手动修改建立时间需求/保持时间需求。\n* 用户希望放松某些路径的约束力度，就可以通过Multicycle约束调整建立时间需求/保持时间需求。 \n\n使用`set_multicycle_path`命令进行约束\n\n![img](时序约束整理/set_multicycle_path.png)\n\n![img](时序约束整理/set_multicycle_path_start_end.png)\n\n![img](时序约束整理/set_multicycle_path_source_destination_clock.png)\n\n#### 如何进行正确Multicycle约束？\n\n注：使用`set_multicycle_path`命令\n\n1. 在源时钟和目的时钟相同的情况下进行Multicycle约束\n\n   ![img](时序约束整理/multicycle_path_same_clock.png)\n\n   ![img](时序约束整理/multicycle_path_same_clock_timing.png)\n\n   * 每两个时钟发起一次数据，每两个时钟捕获一次数据\n\n     ![img](时序约束整理/multicycle_path_rtl_diagram.png)\n\n     ![img](时序约束整理/set_multicyclye_path_same_clk_command.png)\n\n     ![img](时序约束整理/set_multicycle_path_same_clk_timing.png)\n\n     ![img](时序约束整理/set_multicyclye_path_same_clk_command2.png)\n\n     ![img](时序约束整理/set_multicycle_path_same_clk_timing2.png)\n\n   * 每四个时钟发起一次数据，每四个时钟捕获一次数据\n\n     ![img](时序约束整理/set_multicycle_path_4_timing.png)\n\n   * 只调整setup需求，Holdup需求会发生相应的变化，但是变化结果是错误的\n\n     ![img](时序约束整理/set_multicycle_path_just_setup.png)\n\n     ![img](时序约束整理/set_multicycle_path_just_setup_timing.png)\n\n   * 进一步调整Holdup需求（-start）\n\n     ![img](时序约束整理/set_multicycle_path_holdup_adjust.png)\n\n     ![img](时序约束整理/set_multicycle_path_holdup_timing.png)\n\n   * Set_multicycle_path 4 –hold –end –from [get_pins data0_reg/C] – to [get_pins data1_reg/C]\n\n     ![img](时序约束整理/set_multicycle_hold_4.png)\n\n2. 在源时钟和目的时钟频率相同且有正向偏移的情况下（正向偏移0.3ns）\n\n   ![img](时序约束整理/set_multicycle_path_timeshift0.3.png)\n\n   ![img](时序约束整理/set_multicycle_path_timeshift0.3_timing.png)\n\n   先调整setup需求，holdup需求发生相应的变化，但变化的结果是正确的\n\n   ![img](时序约束整理/set_multicycle_setup_timeshift.png)\n\n   ![img](时序约束整理/set_multicycle_setup_timeshift_timing.png)\n\n3. 在源时钟的目的时钟频率相同且有负向偏移的情况下（负向偏移0.3ns）发生负向偏移时，通常不需要进行Multicycle的约束，除非负向偏移过大\n\n   ![img](时序约束整理/set_multicycle_path_minus_shift.png)\n\n   ![img](时序约束整理/set_multicycle_path_minus_shift_timing.png)\n\n4. 在源时钟和目的时钟频率不同的情况下（源时钟慢，目的时钟快）\n\n   ![img](时序约束整理/set_multicycle_path_slow2fast.png)\n\n   ![img](时序约束整理/set_multicycle_path_slow2fast_timing.png)\n\n   调整setup需求（只能用-end，不能用-start），Holdup需求发生相应的变化，变化的结果是错误的。\n\n   ![img](时序约束整理/set_multicycle_path_slow2fast_just_setup_command.png)\n\n   ![img](时序约束整理/set_multicycle_path_slow2fast_just_setup_timing.png)\n\n   进一步调整Holdup需求（只能用-end，不能用-start）\n\n   ![img](时序约束整理/set_multicycle_path_slow2fast_holdup_command.png)\n\n   ![img](时序约束整理/set_multicycle_path_slow2fast_holdup_timing.png)\n\n5. 在源时钟和目的时钟频率不同的情况下（源时钟快，目的时钟慢）\n\n   ![img](时序约束整理/set_multicycle_path_fast2slow.png)\n\n   ![img](时序约束整理/set_multicycle_path_fast2slow_timing.png)\n\n   同时调整setup需求（只能用-start，不能用-end）和Holdup需求（只能用-start，不能用-end）\n\n   ![img](时序约束整理/set_multicycle_path_fast2slow_setup_hold_command.png)\n\n   ![img](时序约束整理/set_multicycle_path_fast2slow_setup_hold_timing.png)\n\n### Falsepath 约束\n\n#### 什么样的路径属于FalsePath?\n\n注：使用`set_false_path`命令\n\nFalsePath路径是指该路径在拓扑结构中的确存在，但是满足以下任一条件的路径：\n\n* 在实际运行过程中，该路径不工作\n* 该路径不需要进行时序分析\n\n比如：已经做了两级触发器同步的跨时钟域路径\n\n只在上电时工作一次的寄存器\n\n异步复位路径或用于测试的路径\n\n**注意**：如果用户的目的只是放松某条路径的时序约束，可以用`set_multicycle_path`命令进行约束，不要使用`set_false_path`\n\n**设置FalsePath的好处**\n\n1. 减小综合、实现、时序分析的时间\n2. 极大的提升工具对设计的综合、实现、优化的结果\n\n![img](时序约束整理/set_false_path_command.png)\n\n-from/-to的node_list必须是有效的时序路径的起点和终点，或是时钟。-through的node_list可以是ports/pins。\n\n#### FalsePath约束举例\n\n1. 将异步复位信号设置为伪路径\n\n   ![img](时序约束整理/set_false_path_reset.png)\n\n2. 将CLKA到CLKB的单向路径设置为伪路径\n\n   ![img](时序约束整理/set_false_path_a2b_single.png)\n\n3. 将CLKA到CLKB以及CLKB到CLKA的双向路径设置为伪路径\n\n   ![img](时序约束整理/set_false_path_a2b_dual.png)\n\n**注**：当有多个异步时钟之间的路径需要设置为伪路径时，推荐使用`set_clock_group`命令。\n\n![img](时序约束整理/set_false_path_through_diagram.png)\n\n![img](时序约束整理/set_false_path_through_command.png)\n\n凡是经过MUX1/a0，到MUX2/a1的时序路径都会被忽略，采用-through的好处是不需要具体指定时序路径的起点和终点，-through的顺序需要注意，上述命令描述的是先经过MUX1/a0，然后再经过MUX2/a1。\n\n### Maxdelay约束\n\n#### 什么情况下使用Maxdelay约束？\n\n1. 它可以代替Multicycle约束，调整建立时间需求，而且`set_max_delay`约束的优先级比Multicycle约束要高\n2. 对于两个异步时钟域之间的异步信号不需要进行时序分析，但是用户对路径延迟有一定的要求时，可以使用`set_max_delay -datapath only`进行约束。`-datapath only`用于忽略时钟歪斜，只考虑数据路径的延时。\n\n**注**：当用户需要对两个异步时钟域之间的部分/所有路径指定路径的最大延时，用户需要使用`set_max_delay -datapath only`对这些路径的延时进行约束，同时用户不能使用`set_clock_group`约束，因为`set_clock_group`的优先级比`set_maxdelay`高。**两个时钟域之间的剩余路径可以使用`set_false_path`进行约束。**\n\n对于通过set_false_path/set_clock_group命令进行约束的路径，综合器不会对该路径进行优化，很可能导致两个寄存器的位置很远。\n\n1. 单bit信号跨时钟域（两级触发器同步）\n\n   此时只需要使用`set_false_path/set_clock_group`对异步信号的路径约束即可，因为此时两个寄存器之间的延迟不会影响功能，只会影响性能，此时不需要使用Maxdelay约束。\n\n   ![image-20200801212024545](时序约束整理/single_bit_cdc_diagram.png)\n\n2. 多bit信号跨时钟域（格雷码）\n\n   此时若只使用`set_false_path/set_clock_group`对异步信号的路径约束，可能会影响格雷码功能的正确性。所以需要Maxdelay对数据路径的延迟进行约束。\n\n   设计中也常用一种带有格雷码控制的FIFO来实现异步时钟域的隔离。计数器和读写指针等需要用BRAM外部的逻辑搭建，这样的结构就不能简单约束`set_clock_groups`，还要考虑这些外部逻辑如何约束。\n\n   在存储器外部有一些用FPGA逻辑搭建的写指针和读指针控制，分属不同的时钟域，存在跨时钟域的时序路径。\n\n   此时如果仅将读写时钟用`set_clock_goups`约束为异步时钟，想当于设置从A到B和从B到A的路径全部为false path。false path的优先级最高，很显然这么做会导致所有跨读写时钟域的路径全部不做时序分析，读写指针和相关控制逻辑也就失去了存在的意义。\n\n#### 如何进行Maxdelay约束\n\n`set_max_delay -from [get_cells GCB0[*]] -to [get_cells GCB1a[*]] -datapath_only 5`（具体延迟大小一般不超过目的时钟的时钟周期）\n\n`set_false_path -from [get_cells rega] -to [get_cells regb]`\n\n![image-20200801214136797](时序约束整理/set_max_delay_diagram.png)\n","slug":"时序约束整理","published":1,"updated":"2024-01-16T08:32:57.656Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clru1g22f003ps4fuk3inxtki","content":"<h1 id=\"时序约束整理\"><a href=\"#时序约束整理\" class=\"headerlink\" title=\"时序约束整理\"></a><center>时序约束整理</center></h1><ul>\n<li><a href=\"#时序分析基础知识\">时序分析基础知识</a></li>\n<li><a href=\"#时序检查\">时序检查</a><ul>\n<li><a href=\"#setup-检查\">Setup 检查</a></li>\n<li><a href=\"#holdup-检查\">Holdup 检查</a></li>\n<li><a href=\"#recovery-检查\">Recovery 检查</a></li>\n<li><a href=\"#removal-检查\">Removal 检查</a></li>\n</ul>\n</li>\n<li><a href=\"#时序约束\">时序约束</a><ul>\n<li><a href=\"#时钟约束\">时钟约束</a></li>\n<li><a href=\"#inputoutput-延时约束\">Input/Output 延时约束</a></li>\n<li><a href=\"#multicycle-约束\">Multicycle 约束</a></li>\n<li><a href=\"#falsepath-约束\">Falsepath 约束</a></li>\n<li><a href=\"#maxdelay约束\">Maxdelay约束</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"1-时序分析基础知识\"><a href=\"#1-时序分析基础知识\" class=\"headerlink\" title=\"1.时序分析基础知识\"></a>1.时序分析基础知识</h2><h4 id=\"什么是时序分析\"><a href=\"#什么是时序分析\" class=\"headerlink\" title=\"什么是时序分析\"></a>什么是时序分析</h4><p>时序分析本质上就是一种时序检查，目的是检查设计中所有的D触发器是否能够正常工作，也就是检查D触发器的同步端口（数据输入端口）的变化是否满足建立时间要求（Setup）和保持时间要求（Hold）；检查D触发器的异步端口（异步复位端口）的变化是否满足恢复时间要求（Recovery）和移除时间要求（Removal）。</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90.png\" alt=\"时序分析\"></p>\n<h4 id=\"时序分析有哪些类型\"><a href=\"#时序分析有哪些类型\" class=\"headerlink\" title=\"时序分析有哪些类型\"></a>时序分析有哪些类型</h4><p>时序分析包括静态时序分析（STA）和动态时序分析。</p>\n<ul>\n<li>动态时序分析：将布局布线生成的布线延迟信息反标注到门级网表中进行仿真，检查是否存在时序违例。此时的仿真包括门延迟和布线延迟信息，能够较好反应芯片的实际工作情况。因为不可能产生完备的测试向量，覆盖门级网表中的每一条路径。因此在动态时序分析中，无法暴露一些路径上可能存在的时序问题。</li>\n<li>静态时序分析：采用穷尽分析方法来提取出整个电路存在的所有时序路径，计算信号在这些路径上的传播延时，检查信号的建立和保持时间是否满足时序要求，通过对最大路径延时和最小路径延时的分析，找出违背时序约束的错误。它不需要输入向量就能穷尽所有的路径，且运行速度很快、占用内存较少，不仅可以对芯片设计进行全面的时序功能检查，而且还可利用时序分析的结果来优化设计，因此静态时序分析已经越来越多地被用到数字集成电路设计的验证中。</li>\n</ul>\n<h4 id=\"时序分析使用的工具有哪些\"><a href=\"#时序分析使用的工具有哪些\" class=\"headerlink\" title=\"时序分析使用的工具有哪些\"></a>时序分析使用的工具有哪些</h4><ul>\n<li>静态时序分析使用的工具<ul>\n<li>Xilinx Vivado Integrated Design Environment Time Engine</li>\n<li>Altera Quartus II Timequest</li>\n<li>DC等</li>\n</ul>\n</li>\n<li>动态时序分析使用的工具<ul>\n<li>Mentor Modelsim</li>\n<li>Cadence NC-Verilog</li>\n<li>Sysnopsys VCS</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"静态时序分析之前的准备工作\"><a href=\"#静态时序分析之前的准备工作\" class=\"headerlink\" title=\"静态时序分析之前的准备工作\"></a>静态时序分析之前的准备工作</h4><p>撰写基本的时序约束文件，告知时序引擎一些必要的信息（比如时钟，输入输出延时等）。若没有正确的时序约束，那么时序分析的结果是没有意义的。</p>\n<p>D触发器中Tsetup, Thold, Tco的由来<br><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/TsetupThold%E7%9A%84%E7%94%B1%E6%9D%A5.png\" alt=\"D触发器原理图\"><br><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/Th%E7%9A%84%E7%94%B1%E6%9D%A5.png\" alt=\"Th的由来\"></p>\n<h4 id=\"序分析中的常用术语\"><a href=\"#序分析中的常用术语\" class=\"headerlink\" title=\"序分析中的常用术语\"></a>序分析中的常用术语</h4><ul>\n<li>源时钟（Source Clock/Launch Clock，也称发起时钟）</li>\n<li>目的时钟（Destination Clock/ Capture Clock, 也称捕获时钟）</li>\n<li>发起沿（Launch Edge，源时钟产生数据的有效时钟沿）</li>\n<li>捕获沿（Capture Edge，目的时钟捕获数据的有效时钟沿）</li>\n</ul>\n<p>发起沿通常在0ns，捕获沿通常在下一个发起沿，发起沿和捕获沿通常相差一个时钟周期。</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/LaunchEdgeCaptureEdge.png\" alt=\"img\"></p>\n<h4 id=\"一条普通时序路径的三要素\"><a href=\"#一条普通时序路径的三要素\" class=\"headerlink\" title=\"一条普通时序路径的三要素\"></a>一条普通时序路径的三要素</h4><ul>\n<li>源时钟路径：从源时钟的源节点（通常是FPGA的时钟输入引脚）到源寄存器的时钟端口的路径。当时序路径的起点是FPGA输入端口时，该时序路径是没有源时钟路径的。</li>\n<li>数据路径：从时序路径的起点到时序路径的终点之间的数据传播路径。时序路径的起点可以是源寄存器的时钟端口或FPGA的输入端口，时序路径的终点可以是目的寄存器的输入端口或FPGA的输出端口。</li>\n<li>目的时钟路径：从目的时钟的源节点（通常是FPGA的时钟输入引脚）到目的寄存器的时钟端口的路径。当时序路径的终点是FPGA的输出端口时，该时序路径是没有目的时钟路径的。</li>\n</ul>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/%E4%B8%89%E8%A6%81%E7%B4%A0.png\" alt=\"img\"></p>\n<h4 id=\"FPGA中常见的四种时序路径\"><a href=\"#FPGA中常见的四种时序路径\" class=\"headerlink\" title=\"FPGA中常见的四种时序路径\"></a>FPGA中常见的四种时序路径</h4><ol>\n<li><p>从FPGA的输入端口到目的寄存器的数据输入端口</p>\n<ul>\n<li>数据由Board Clock发起并在FPGA外部产生</li>\n<li>数据经过Input Delay的延迟后到达FPGA的输入端口</li>\n<li>数据经过FPGA的Internal Delay后到达由目的时钟驱动的目的寄存器</li>\n</ul>\n<p>这种路径是没有源时钟路径的，用户需要约束Input Delay和时钟来告知时序引擎必要信息，时序引擎才能正确的分析这种路径</p>\n</li>\n<li><p>从源寄存器的时钟端口到目的寄存器的数据输入端口</p>\n<ul>\n<li>数据由源时钟发起并在FPGA内部产生</li>\n<li>数据经过Data Path Delay后到达由目的时钟驱动的目的寄存器</li>\n</ul>\n<p>这种时序路径是最常见的，用户需要约束源时钟和目的时钟告知时序引擎必要的信息，时序引擎才能正确的分析这种时序路径。</p>\n</li>\n<li><p>从源寄存器的时钟端口到FPGA的输出端口</p>\n<ul>\n<li>数据有源时钟发起并在FPGA内部产生</li>\n<li>数据经过Internal Delay后到达输出端口</li>\n<li>数据经过Output Delay后被Board Clock捕获到</li>\n</ul>\n<p>这种路径是没有目的时钟路径的，用户需要约束Output Delay和时钟来告知时序引擎必要信息，时序引擎才能正确的分析这种路径。</p>\n</li>\n<li><p>从FPGA的输入端口到FPGA的输出端口</p>\n<ul>\n<li>数据横穿FPGA，没有经过任何触发器，这种路径也叫in-to-out path，约束输入和输出延时的参考时钟可以使用虚拟时钟</li>\n</ul>\n<p>这种路径中只有数据路径，用户需要约束Input Delay和Output Delay，告知时序引擎必要的信息，时序引擎才能正确的分析这种时序路径。</p>\n</li>\n</ol>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/%E5%9B%9B%E7%A7%8D%E8%B7%AF%E5%BE%84.png\" alt=\"img\"></p>\n<h2 id=\"时序检查\"><a href=\"#时序检查\" class=\"headerlink\" title=\"时序检查\"></a>时序检查</h2><h3 id=\"Setup-检查\"><a href=\"#Setup-检查\" class=\"headerlink\" title=\"Setup 检查\"></a>Setup 检查</h3><h4 id=\"时序引擎如何进行Setup检查\"><a href=\"#时序引擎如何进行Setup检查\" class=\"headerlink\" title=\"时序引擎如何进行Setup检查\"></a>时序引擎如何进行Setup检查</h4><ol>\n<li><p>确定建立时间要求（建立时间的捕获沿-建立时间的发起沿）</p>\n<p>确定建立时间的捕获沿和建立时间的发起沿。</p>\n<p>时序引擎会找出发起时钟和捕获时钟的最小公共周期，然后在最小公共周期内找到所有发起时钟沿和捕获时钟沿的所有可能情况，并在所有可能的情况中挑选出<strong>最小的建立时间需求</strong>（大于0），从而确定Launch Edge和 Capture Edge。</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/%E7%A1%AE%E5%AE%9A%E5%BB%BA%E7%AB%8B%E6%97%B6%E9%97%B4%E8%A6%81%E6%B1%82.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/%E7%A1%AE%E5%AE%9A%E5%BB%BA%E7%AB%8B%E6%97%B6%E9%97%B4%E8%A6%81%E6%B1%82%E8%AE%A1%E7%AE%97.png\" alt=\"img\"></p>\n</li>\n<li><p>计算数据的需求时间</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/%E5%BB%BA%E7%AB%8B%E6%97%B6%E9%97%B4%E8%AE%A1%E7%AE%97%E6%95%B0%E6%8D%AE%E7%9A%84%E9%9C%80%E6%B1%82%E6%97%B6%E9%97%B4.png\" alt=\"img\"></p>\n</li>\n<li><p>计算数据的到达时间</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/%E5%BB%BA%E7%AB%8B%E6%97%B6%E9%97%B4%E8%AE%A1%E7%AE%97%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%B0%E8%BE%BE%E6%97%B6%E9%97%B4.png\" alt=\"img\"></p>\n</li>\n<li><p>计算Setup的裕量（Slack）</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/%E5%BB%BA%E7%AB%8B%E6%97%B6%E9%97%B4%E8%AE%A1%E7%AE%97Setup%E7%9A%84%E8%A3%95%E9%87%8F.png\" alt=\"img\"></p>\n</li>\n</ol>\n<h4 id=\"Setup分析实例\"><a href=\"#Setup分析实例\" class=\"headerlink\" title=\"Setup分析实例\"></a>Setup分析实例</h4><ul>\n<li><p>Data Arrival Time = Launch Edge + Tclka + Tco + Tdata(Tlogic + Tnet)</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/setup%E5%88%86%E6%9E%90data_arrival_time.png\" alt=\"img\"></p>\n</li>\n<li><p>Data Require Time = Capture Edge + Tclkb - Tsu</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/setup%E5%88%86%E6%9E%90data_require_time.png\" alt=\"img\"></p>\n</li>\n<li><p>Setup Slack = Data Require Time - Data Arrival Time</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/setup%E5%88%86%E6%9E%90setup_slack.png\" alt=\"img\"></p>\n</li>\n</ul>\n<h4 id=\"Setup-Slack为负的因素\"><a href=\"#Setup-Slack为负的因素\" class=\"headerlink\" title=\"Setup Slack为负的因素\"></a>Setup Slack为负的因素</h4><ul>\n<li>Setup Slack = (Capture  Edge - Launch Edge) + (Destination clk delay - source clk delay) - Setup Time - Clk uncertainty - datapath delay</li>\n<li>Setup Slack = Setup Requirement (一定大于0) + clk skew - Tsu - Tclk uncertainty - Tlogic - Tnet - Tco</li>\n</ul>\n<ol>\n<li><p>Setup Requirement与实际情况不符</p>\n<p>建立时间需求过小，这种情况通常会在同步跨时钟域路径中出现，在同步跨时钟域路径中的源时钟频率与目的时钟频率的相位关系虽然是已知的，但是时序引擎默认选择的捕获沿通常都是错误的，需要用户通过多周期路径约束的方式手动修正建立时间需求。比如下图中，两个同频不同相的同步时钟，时序引擎默认选择的捕获沿是目的时钟第二个上升沿，导致建立时间需求非常小，最终肯定会导致时序违例。</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/SetupRequirement%E4%B8%8E%E5%AE%9E%E9%99%85%E4%B8%8D%E7%AC%A6.png\" alt=\"img\"></p>\n</li>\n<li><p>Clk Skew为负值，且很大</p>\n<p>通常情况下，同一个时钟下的时钟歪斜不应该超过300ps，同步跨时钟域路径的时钟歪斜不应该超过500ps，异步跨时钟域路径的时钟歪斜一般比较大，因为它们的时钟源不同。</p>\n<p>当出现时钟歪斜大的情况时:</p>\n<ul>\n<li>检查源时钟路径和目的时钟路径上是否干净，时钟路径上是否引入了组合逻辑，时钟路径是否使用了过多的BUFGCE，时钟路径上是否级联了多个BUFGCE导致时钟延时变大。</li>\n<li>检查源时钟路径和目的时钟路径所经过的模块是否相同，比如源时钟路径上经过全局缓冲，PMMCM，但是目的时钟路径上只经过了全局缓冲。如下图所示，第一条路径的源时钟路径上有BUFGCE/MMCM/BUFGCE，而目的时钟路径上只有BUFGCE，所以源时钟路径和目的时钟路径的延时不同，导致时钟歪斜较大，应该尽量避免此类路径。第二条路径的源时钟和目的时钟都是来源于MMCM的不同的时钟，所以时钟歪斜较小。</li>\n</ul>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/clk_skew%E5%BE%88%E5%A4%A7.png\" alt=\"img\"></p>\n</li>\n<li><p>Tsu/Tco很大</p>\n<p>当设计中使用Block（DSP/Block RAM等）时，应该要注意以下问题。对于以这些Block为时序路径的起点或终点的时序路径，这些<strong>Block的Tsu/Th/Tco都比普通的寄存器大</strong>，而且这些Block的布线延时和时钟歪斜比较大。所以当使用这些Block作为时序路径的终点时，它的起点一定要是触发器，比如说一个Block RAM的写数据信号，输入进Block前最好打一拍。当使用这些Block作为时序路径的起点时，应该使用Block 内部的输出寄存器，比如使用由Block RAM组成的FIFO时，尽量不要使用首字置出的，而使用打一拍后输出的，使用后者可以显著降低Tco。当时序路径为从一个Block到另一个Block时，中间需要进行打拍操作。当使用这些Block的控制端口时，应该保证这些控制信号的低扇出，如使用由Block RAM组成的FIFO时，应该尽量降低读/写能信/地址信号的扇出。</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/Tco_Th%E5%BE%88%E5%A4%A7.png\" alt=\"img\"></p>\n</li>\n<li><p>Tlogic大</p>\n<p>一般情况下，逻辑延时与时序路径的逻辑层级数息息相关，逻辑层级是指时序路径的起点和终点之间组合逻辑单元（LUT）的个数，而逻辑层级多一级意味着多1个LUT的延时加1条连接LUT的网线延时。通常一级逻辑层级的延时标准是1个LUT加1根网线的总延迟为0.5ns，如果某条路径的逻辑级数大于时钟周期/0.5ns，那么这条路径就被称为长路径。</p>\n<p>常用的处理长路径的方案有两种：</p>\n<ul>\n<li>修改rtl代码，在长路径的逻辑中插入流水线，将长路径打破分为多条短路径；</li>\n<li>使用综合工具的retiming优化方式，retiming实际上是寄存器重定向，原理是当某条长路径的相邻路径的建立时间裕量较大，那么它可以调整中间寄存器的位置，来调整布线延迟，通过适当增加相邻路径的布线延迟而减少长路径的布线延迟，使得那些时序违例较小的长路径通过这种微调实现时序收敛。需要强调的是，<strong>这种方式优化的力度非常有限</strong>，它只适合时序违例较小的长路径，对于一些延时特别大的长路径而言，也是无力回天。</li>\n</ul>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/Tlogic%E5%BE%88%E5%A4%A7.png\" alt=\"img\"></p>\n</li>\n<li><p>Tnet大</p>\n<p>一般情况下，布线延迟与设计整体或局部模块的资源利用率以及拥塞程度息息相关。</p>\n<p>在正常情况下，一条网线的延时小于1ns，在发生拥塞的区域，网线的延时可能达到若干ns，导致布线延时显著增加。为了解决布线延迟大，需要从降低资源利用率和降低拥塞程度下手，比如某个模块使用了大量的寄存器堆，占用了大量的资源，此时应该考虑使用Block RAM代替这些寄存器堆；某个模块使用了大量的数据选择器，此时应该考虑如何优化这些数据选择器；某个模块的控制信号扇出比较大，与其他模块的互联很重，此时应该考虑如何降低这些信号的扇出；某条时序路径的起点或终点是Block，由于Block的位置比较固定，所以Block的布线延迟会大一些。最后需要强调的是，一定要额外关注高扇出的网线也会对布线延时产生影响。</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/TimeQuest%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90Setup1.png\" alt=\"img\"></p>\n<p>TimeQuest时序分析（Setup）</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/TimeQuest%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90Setup2.png\" alt=\"img\"></p>\n</li>\n</ol>\n<h3 id=\"Holdup-检查\"><a href=\"#Holdup-检查\" class=\"headerlink\" title=\"Holdup 检查\"></a>Holdup 检查</h3><h4 id=\"时序引擎如何进行Holdup检查\"><a href=\"#时序引擎如何进行Holdup检查\" class=\"headerlink\" title=\"时序引擎如何进行Holdup检查\"></a>时序引擎如何进行Holdup检查</h4><ol>\n<li><p>确定保持时间要求（确定发起时钟沿和捕获时钟沿）</p>\n<p><strong>保持时间要求是以建立时间要求为基础的</strong>，保持时间要求有两种：</p>\n<ul>\n<li><p>当前建立时间的发起沿产生的数据不能被当前建立时间的捕获沿的前一个有效沿捕获</p>\n</li>\n<li><p>当前建立时间的发起沿的下一个有效沿产生的数据不能被当前建立时间的捕获沿捕获</p>\n</li>\n</ul>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/holdTimeRequirement.png\" alt=\"img\"></p>\n<p>根据所有的建立时间需求找到所有的保持时间需求，并从保持时间需求（可正可负）中找到最大的保持时间需求。!</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/HoldPathRequirement.png\" alt=\"img\"></p>\n</li>\n</ol>\n<p>   <img src=\"/2024/01/shi-xu-yue-shu-zheng-li/DataPathRequirementCalculation.png\" alt=\"img\"></p>\n<ol start=\"2\">\n<li><p>计算数据的需求时间</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/dataRequiredTimeHold.png\" alt=\"img\"></p>\n</li>\n<li><p>计算数据的到达时间</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/DataArrivalTimeHold.png\" alt=\"img\"></p>\n</li>\n<li><p>计算Hold up的裕量(Slack)</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/SlackHold.png\" alt=\"img\"></p>\n</li>\n</ol>\n<h4 id=\"Holdup分析实例\"><a href=\"#Holdup分析实例\" class=\"headerlink\" title=\"Holdup分析实例\"></a>Holdup分析实例</h4><ul>\n<li>Data Arrival Time (new data) = Launch Edge + Tclka + Tco + Tdata(Tlogic + Tnet)</li>\n<li>Data Require Time = Capture Edge + Tclkb + Th</li>\n<li>Hold up Slack = Data Arrival Time - Data Require Time</li>\n</ul>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/HoldupExample.png\" alt=\"img\"></p>\n<h4 id=\"Holdup-Slack为负的因素\"><a href=\"#Holdup-Slack为负的因素\" class=\"headerlink\" title=\"Holdup Slack为负的因素\"></a>Holdup Slack为负的因素</h4><ul>\n<li>Holdup Slack = (Launch Edge - Capture Edge) + (Tclka - Tclkb) + Tco + Tdata(Tlogic + Tnet) - Th</li>\n<li>Holdup Slack = Tco + Tdata(Tlogic + Tnet) - Th - Holdup Requirement - Clk skew</li>\n</ul>\n<p>Hold up Slack为负的情况比较少见，当Setup Slack有较大裕量时，通常工具会自动插入延时来增加Hold up Slack。</p>\n<ol>\n<li>保持时间需求大于0（通常由时序引擎选择错误的捕获沿导致）</li>\n<li>时钟歪斜大于300ps（通常由时钟路径上的组合逻辑导致）</li>\n<li>Th过大（通常由时钟路径上的组合逻辑导致）</li>\n</ol>\n<p>TimeQuest时序分析（Holdup）</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/TimeQuestHoldupSlack.png\" alt=\"img\"></p>\n<h3 id=\"Recovery-检查\"><a href=\"#Recovery-检查\" class=\"headerlink\" title=\"Recovery 检查\"></a>Recovery 检查</h3><p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/%E5%A4%8D%E4%BD%8D%E7%BB%93%E6%9E%84.png\" alt=\"image-20200806204803965\"></p>\n<h4 id=\"时序引擎如何进行Recovery检查\"><a href=\"#时序引擎如何进行Recovery检查\" class=\"headerlink\" title=\"时序引擎如何进行Recovery检查\"></a>时序引擎如何进行Recovery检查</h4><p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/RequireTimeRecovery.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/TimeQuestRecovery.png\" alt=\"img\"></p>\n<h3 id=\"Removal-检查\"><a href=\"#Removal-检查\" class=\"headerlink\" title=\"Removal 检查\"></a>Removal 检查</h3><h4 id=\"时序引擎如何进行Removal检查\"><a href=\"#时序引擎如何进行Removal检查\" class=\"headerlink\" title=\"时序引擎如何进行Removal检查\"></a>时序引擎如何进行Removal检查</h4><p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/RequireTimeRemoval.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/TimeQuestRemoval.png\" alt=\"img\"></p>\n<h2 id=\"时序约束\"><a href=\"#时序约束\" class=\"headerlink\" title=\"时序约束\"></a>时序约束</h2><p>时序引擎能够正确分析4钟时序路径的前提是，用户已经进行了正确的时序约束。时序约束本质上就是告知时序引擎一些进行时序分析所必要的信息，这些信息只能由用户主动告知，时序引擎对有些信息可以自动推断，但是推断得到的信息不一定正确。</p>\n<ul>\n<li><p>第一种路径需要约束Input_delay</p>\n</li>\n<li><p>第二种路径需要约束时钟</p>\n</li>\n<li><p>第三种路径需要约束Output_delay</p>\n</li>\n<li><p>第四种路径需要约束Max_delay/Min_delay</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/FourPathConstraints.png\" alt=\"img\"></p>\n</li>\n</ul>\n<h3 id=\"时钟约束\"><a href=\"#时钟约束\" class=\"headerlink\" title=\"时钟约束\"></a>时钟约束</h3><h4 id=\"时序约束类型\"><a href=\"#时序约束类型\" class=\"headerlink\" title=\"时序约束类型\"></a>时序约束类型</h4><p>首先用户必须要正确的约束时钟，时序引擎才能根据时钟信息进行各种时序检查。</p>\n<p>用户约束时钟时，一般有两种类型的时钟需要约束。</p>\n<ul>\n<li><p>主时钟（Primary Clock）</p>\n<p>主时钟（Primary Clock）有两种类型：第一种是从FPGA的全局时钟输入引脚输入的时钟；第二种是从高速收发器输出给用户的恢复时钟</p>\n</li>\n<li><p>生成时钟（Generated Clock）</p>\n<p>生成时钟（Generated Clock）有两种类型：第一种是由FPGA的专用时钟管理模块（PLL/MMCM）产生的时钟（这种时钟可以由时序引擎自动推断出来）；第二种是由用户通过LUT或寄存器产生的时钟（这种时钟必须由用户手动约束）</p>\n</li>\n</ul>\n<ol>\n<li><p>主时钟（Primary Clock）约束</p>\n<p>使用<code>Create_clock</code>进行约束</p>\n<ul>\n<li><p>第一种是从FPGA的全局时钟输入引脚输入的时钟：</p>\n<p>全局时钟输入引脚是sysclk，时钟周期10ns，占空比50%，相移0度。</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/PrimaryClockPath.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/PrimaryClockConstraints.png\" alt=\"img\"></p>\n<p>全局时钟输入引脚是ClkIn，时钟周期10ns，占空比25%，相移90度</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/PrimaryClockPath2.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/PrimaryClockConstraints2.png\" alt=\"img\"></p>\n</li>\n<li><p>第二种是从高速收发器输出给用户的恢复时钟 全局时钟输入引脚是sysclk，时钟周期3.3ns，占空比50%，相移0度</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/PrimaryClockPathFromSerdes.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/PrimaryClockConstraintsFromSerdes.png\" alt=\"img\"></p>\n</li>\n</ul>\n</li>\n<li><p>生成时钟（Generated Clock）约束</p>\n<p>用<code>Create_generated_clock</code>进行时序约束</p>\n<p>每个生成时钟都会对应一个时钟源（Master_clk），这个时钟源可以是Primary Clock或者另一个Generated Clock。</p>\n<p>在约束生成时钟时，用户不需要描述生成时钟的周期和波形，只需要描述由Master_clk经过了怎样的变化而产生的生成时钟即可。比如经过分频（-devide_by），倍频（-multiply_by），反相（-invert），相移（-edge_shift）等等操作。</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/GeneratedClockSourceClock.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/GeneratedClcokPath.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/GeneratedClcokConstraints.png\" alt=\"img\"></p>\n<p>当生成时钟需要进行相移时，使用-edge_shift选项。</p>\n<p>-edge_shift不能与-divide_by/-multiple_by/-invert同时使用。</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/GeneratedClockEdgeShiftPath.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/GeneratedClockEdgeShiftConstraints.png\" alt=\"img\"></p>\n</li>\n</ol>\n<h4 id=\"时钟分组\"><a href=\"#时钟分组\" class=\"headerlink\" title=\"时钟分组\"></a>时钟分组</h4><p>时序引擎默认情况下会分析所有时钟之间的时序路径，用户可以通过时钟分组<code>set_clock_group</code>命令或伪路径<code>set_false_path</code>命令来关闭一部分路径的时序分析。</p>\n<ul>\n<li>使用<code>set_clock_group</code>命令，时序引擎会将不同分组的时钟之间的路径分析关闭，相同分组的时钟之间的路径仍然存在。</li>\n<li>使用<code>set_false_path</code>命令，时序引擎会忽略两个时钟的双向路径，被忽略的路径不一定能够正常工作，需要用户确保该路径使用了两级触发器同步或者按照异步数据传输方式传输数据。用户负责保证这些被忽略的路径可以正常工作。</li>\n</ul>\n<p><strong>两个时钟的关系</strong></p>\n<ol>\n<li><p>同步时钟（synchronous clock）</p>\n<p>两个时钟之间的相对相位关系是固定的（两个时钟来源于同一个Primary Clock），并且这两个时钟的频率的最小公共周期是个整数。</p>\n<p>比如一个生成时钟（200M）和该生成时钟的Master_clk（100M）之间就属于同步时钟关系，因为这两个时钟的相位关系是确定的，并且可以找到两个时钟的最小公共周期。通常情况下，一个Primary Clock和它产生的生成时钟之间都属于同步时钟关系，除非找不到最小公共周期。<strong>属于同步时钟关系的两个时钟之间的路径是可以进行时序分析的。</strong></p>\n</li>\n<li><p>异步时钟（asynchronous clock）</p>\n<p>两个时钟之间的相对相位关系不确定。</p>\n<p>比如FPGA上两个晶振分别产生两个Primary clock（相对相位关系不固定），这两个Primary clock分别从FPGA的两个全局时钟引脚输入给两个MMCM，由两个MMCM分别产生的生成时钟之间属于异步时钟。一般情况下，不同的Primary clock之间都属于异步时钟，这些Primary clock分别产生的生成时钟之间也属于异步时钟关系。</p>\n<p><strong>属于异步时钟关系的两个时钟之间的路径无法进行正确的时序分析。</strong></p>\n<p>一般情况下，如果用户不通过时钟分组对时钟之间的关系进行约束，时序引擎会默认所有的时钟之间都属于同步时钟关系</p>\n</li>\n<li><p>不可扩宽的时钟（unexpandable clock）</p>\n<p>对于这类时钟，时序引擎无法在1000个时钟周期内找到两个时钟的公共周期，时序引擎就会从这1000个时钟中找到建立时间需求最差的情况，并进行时序分析，然而它不一定是FPGA实际运行过程中建立时钟需求最差的情况，因为在1000个时钟周期外可能还会有建立时钟需求更差的情况，这样一来，时序引擎的分析结果就无法保证该路径一定不会出现问题，所以时序引擎的分析结果也就变的毫无意义。</p>\n<p>比如说由同一个Primary Clock驱动的两个MMCM的生成时钟分别是clk0（5.125ns）和clk1（6.666ns），虽然他们的相对相位关系是固定的，但是时序引擎无法保证对两个时钟之间的路径的分析属于最差情况，这种情况和异步时钟之间的时序分析类似，时序分析的结果都看起来正常，但是这个结果是不可信的。所以对这种时钟的处理方式与处理异步时钟是相同的，用户都需要进行跨时钟域的操作。</p>\n</li>\n</ol>\n<p><strong>总结：异步时钟和不可扩展的时钟之间的路径都无法进行正确的时序分析，所以在时序分析之前，需要使用<code>set_clock_group</code>对时钟进行分组，从而将这些无法进行正确时序分析的路径忽略掉。</strong></p>\n<p><strong>时钟分组实例</strong></p>\n<ul>\n<li><p>第一个Primary clock clk0从FPGA的全局时钟引脚进入了一个MMCM，MMCM生成了两个生成时钟 userclk, itfclk</p>\n</li>\n<li><p>第二个Primary clock clk1是一个高速收发器输出的恢复时钟，将该恢复时钟输入进一个MMCM，MMCM生成了两个生成时钟gtxclk, gtxclktx</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_clock_group_command.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_clock_group_command2.png\" alt=\"img\"></p>\n</li>\n</ul>\n<h3 id=\"Input-Output-延时约束\"><a href=\"#Input-Output-延时约束\" class=\"headerlink\" title=\"Input/Output 延时约束\"></a>Input/Output 延时约束</h3><h4 id=\"什么是Input-delay-如何计算它？如何约束它？\"><a href=\"#什么是Input-delay-如何计算它？如何约束它？\" class=\"headerlink\" title=\"什么是Input delay? 如何计算它？如何约束它？\"></a>什么是Input delay? 如何计算它？如何约束它？</h4><p><strong>Input delay概念</strong></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/input_delay.png\" alt=\"img\"></p>\n<p><strong>Input delay计算</strong></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/input_delay_path1.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/input_delay_path2.png\" alt=\"img\"></p>\n<p><strong>Max Input Delay = Tco(Max) + Tpcb(Max) - Clk skew(Min)</strong></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/max_input_delay.png\" alt=\"img\"></p>\n<p><strong>Min Input Delay = Tco(Min) + Tpcb(Min) - Clk skew(Max)</strong></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/Min_Input_Delay.png\" alt=\"img\"></p>\n<p><strong>Input delay约束</strong></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/input_delay_constraints1.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/input_delay_constraints2.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/input_delay_constraints3.png\" alt=\"img\"></p>\n<h4 id=\"什么是Output-delay？如何计算它？如何约束它？\"><a href=\"#什么是Output-delay？如何计算它？如何约束它？\" class=\"headerlink\" title=\"什么是Output delay？如何计算它？如何约束它？\"></a>什么是Output delay？如何计算它？如何约束它？</h4><p><strong>Output delay概念</strong></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/output_delay.png\" alt=\"img\"></p>\n<p><strong>Output delay计算</strong></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/output_delay_path1.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/output_delay_path2.png\" alt=\"img\"></p>\n<p><strong>Max Output Delay = Tpcb(Max) + Tsu - Clk skew(Min)</strong></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/max_output_delay.png\" alt=\"img\"></p>\n<p><strong>Min Output Delay = Tpcb(Min) - Th - Clk skew(Max)</strong></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/min_output_delay.png\" alt=\"img\"></p>\n<p><strong>Output delay约束</strong></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/output_delay_constraints1.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/output_delay_constraints2.png\" alt=\"img\"></p>\n<h3 id=\"Multicycle-约束\"><a href=\"#Multicycle-约束\" class=\"headerlink\" title=\"Multicycle 约束\"></a>Multicycle 约束</h3><h4 id=\"为什么要进行Multicycle约束？\"><a href=\"#为什么要进行Multicycle约束？\" class=\"headerlink\" title=\"为什么要进行Multicycle约束？\"></a>为什么要进行Multicycle约束？</h4><ul>\n<li>时序引擎默认情况下会在建立时间需求/保持时间需求最差的情况下进行时序分析，而时序引擎选择的这种需求不一定是用户真正希望的，而且时序引擎默认选择的这种需求是非常严苛的，甚至是根本无法满足的。此时就需要用户进行Multicycle约束，手动修改建立时间需求/保持时间需求。</li>\n<li>用户希望放松某些路径的约束力度，就可以通过Multicycle约束调整建立时间需求/保持时间需求。 </li>\n</ul>\n<p>使用<code>set_multicycle_path</code>命令进行约束</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_start_end.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_source_destination_clock.png\" alt=\"img\"></p>\n<h4 id=\"如何进行正确Multicycle约束？\"><a href=\"#如何进行正确Multicycle约束？\" class=\"headerlink\" title=\"如何进行正确Multicycle约束？\"></a>如何进行正确Multicycle约束？</h4><p>注：使用<code>set_multicycle_path</code>命令</p>\n<ol>\n<li><p>在源时钟和目的时钟相同的情况下进行Multicycle约束</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/multicycle_path_same_clock.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/multicycle_path_same_clock_timing.png\" alt=\"img\"></p>\n<ul>\n<li><p>每两个时钟发起一次数据，每两个时钟捕获一次数据</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/multicycle_path_rtl_diagram.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicyclye_path_same_clk_command.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_same_clk_timing.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicyclye_path_same_clk_command2.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_same_clk_timing2.png\" alt=\"img\"></p>\n</li>\n<li><p>每四个时钟发起一次数据，每四个时钟捕获一次数据</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_4_timing.png\" alt=\"img\"></p>\n</li>\n<li><p>只调整setup需求，Holdup需求会发生相应的变化，但是变化结果是错误的</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_just_setup.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_just_setup_timing.png\" alt=\"img\"></p>\n</li>\n<li><p>进一步调整Holdup需求（-start）</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_holdup_adjust.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_holdup_timing.png\" alt=\"img\"></p>\n</li>\n<li><p>Set_multicycle_path 4 –hold –end –from [get_pins data0_reg/C] – to [get_pins data1_reg/C]</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_hold_4.png\" alt=\"img\"></p>\n</li>\n</ul>\n</li>\n<li><p>在源时钟和目的时钟频率相同且有正向偏移的情况下（正向偏移0.3ns）</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_timeshift0.3.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_timeshift0.3_timing.png\" alt=\"img\"></p>\n<p>先调整setup需求，holdup需求发生相应的变化，但变化的结果是正确的</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_setup_timeshift.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_setup_timeshift_timing.png\" alt=\"img\"></p>\n</li>\n<li><p>在源时钟的目的时钟频率相同且有负向偏移的情况下（负向偏移0.3ns）发生负向偏移时，通常不需要进行Multicycle的约束，除非负向偏移过大</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_minus_shift.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_minus_shift_timing.png\" alt=\"img\"></p>\n</li>\n<li><p>在源时钟和目的时钟频率不同的情况下（源时钟慢，目的时钟快）</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_slow2fast.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_slow2fast_timing.png\" alt=\"img\"></p>\n<p>调整setup需求（只能用-end，不能用-start），Holdup需求发生相应的变化，变化的结果是错误的。</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_slow2fast_just_setup_command.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_slow2fast_just_setup_timing.png\" alt=\"img\"></p>\n<p>进一步调整Holdup需求（只能用-end，不能用-start）</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_slow2fast_holdup_command.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_slow2fast_holdup_timing.png\" alt=\"img\"></p>\n</li>\n<li><p>在源时钟和目的时钟频率不同的情况下（源时钟快，目的时钟慢）</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_fast2slow.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_fast2slow_timing.png\" alt=\"img\"></p>\n<p>同时调整setup需求（只能用-start，不能用-end）和Holdup需求（只能用-start，不能用-end）</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_fast2slow_setup_hold_command.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_fast2slow_setup_hold_timing.png\" alt=\"img\"></p>\n</li>\n</ol>\n<h3 id=\"Falsepath-约束\"><a href=\"#Falsepath-约束\" class=\"headerlink\" title=\"Falsepath 约束\"></a>Falsepath 约束</h3><h4 id=\"什么样的路径属于FalsePath\"><a href=\"#什么样的路径属于FalsePath\" class=\"headerlink\" title=\"什么样的路径属于FalsePath?\"></a>什么样的路径属于FalsePath?</h4><p>注：使用<code>set_false_path</code>命令</p>\n<p>FalsePath路径是指该路径在拓扑结构中的确存在，但是满足以下任一条件的路径：</p>\n<ul>\n<li>在实际运行过程中，该路径不工作</li>\n<li>该路径不需要进行时序分析</li>\n</ul>\n<p>比如：已经做了两级触发器同步的跨时钟域路径</p>\n<p>只在上电时工作一次的寄存器</p>\n<p>异步复位路径或用于测试的路径</p>\n<p><strong>注意</strong>：如果用户的目的只是放松某条路径的时序约束，可以用<code>set_multicycle_path</code>命令进行约束，不要使用<code>set_false_path</code></p>\n<p><strong>设置FalsePath的好处</strong></p>\n<ol>\n<li>减小综合、实现、时序分析的时间</li>\n<li>极大的提升工具对设计的综合、实现、优化的结果</li>\n</ol>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_false_path_command.png\" alt=\"img\"></p>\n<p>-from/-to的node_list必须是有效的时序路径的起点和终点，或是时钟。-through的node_list可以是ports/pins。</p>\n<h4 id=\"FalsePath约束举例\"><a href=\"#FalsePath约束举例\" class=\"headerlink\" title=\"FalsePath约束举例\"></a>FalsePath约束举例</h4><ol>\n<li><p>将异步复位信号设置为伪路径</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_false_path_reset.png\" alt=\"img\"></p>\n</li>\n<li><p>将CLKA到CLKB的单向路径设置为伪路径</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_false_path_a2b_single.png\" alt=\"img\"></p>\n</li>\n<li><p>将CLKA到CLKB以及CLKB到CLKA的双向路径设置为伪路径</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_false_path_a2b_dual.png\" alt=\"img\"></p>\n</li>\n</ol>\n<p><strong>注</strong>：当有多个异步时钟之间的路径需要设置为伪路径时，推荐使用<code>set_clock_group</code>命令。</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_false_path_through_diagram.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_false_path_through_command.png\" alt=\"img\"></p>\n<p>凡是经过MUX1/a0，到MUX2/a1的时序路径都会被忽略，采用-through的好处是不需要具体指定时序路径的起点和终点，-through的顺序需要注意，上述命令描述的是先经过MUX1/a0，然后再经过MUX2/a1。</p>\n<h3 id=\"Maxdelay约束\"><a href=\"#Maxdelay约束\" class=\"headerlink\" title=\"Maxdelay约束\"></a>Maxdelay约束</h3><h4 id=\"什么情况下使用Maxdelay约束？\"><a href=\"#什么情况下使用Maxdelay约束？\" class=\"headerlink\" title=\"什么情况下使用Maxdelay约束？\"></a>什么情况下使用Maxdelay约束？</h4><ol>\n<li>它可以代替Multicycle约束，调整建立时间需求，而且<code>set_max_delay</code>约束的优先级比Multicycle约束要高</li>\n<li>对于两个异步时钟域之间的异步信号不需要进行时序分析，但是用户对路径延迟有一定的要求时，可以使用<code>set_max_delay -datapath only</code>进行约束。<code>-datapath only</code>用于忽略时钟歪斜，只考虑数据路径的延时。</li>\n</ol>\n<p><strong>注</strong>：当用户需要对两个异步时钟域之间的部分/所有路径指定路径的最大延时，用户需要使用<code>set_max_delay -datapath only</code>对这些路径的延时进行约束，同时用户不能使用<code>set_clock_group</code>约束，因为<code>set_clock_group</code>的优先级比<code>set_maxdelay</code>高。<strong>两个时钟域之间的剩余路径可以使用<code>set_false_path</code>进行约束。</strong></p>\n<p>对于通过set_false_path/set_clock_group命令进行约束的路径，综合器不会对该路径进行优化，很可能导致两个寄存器的位置很远。</p>\n<ol>\n<li><p>单bit信号跨时钟域（两级触发器同步）</p>\n<p>此时只需要使用<code>set_false_path/set_clock_group</code>对异步信号的路径约束即可，因为此时两个寄存器之间的延迟不会影响功能，只会影响性能，此时不需要使用Maxdelay约束。</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/single_bit_cdc_diagram.png\" alt=\"image-20200801212024545\"></p>\n</li>\n<li><p>多bit信号跨时钟域（格雷码）</p>\n<p>此时若只使用<code>set_false_path/set_clock_group</code>对异步信号的路径约束，可能会影响格雷码功能的正确性。所以需要Maxdelay对数据路径的延迟进行约束。</p>\n<p>设计中也常用一种带有格雷码控制的FIFO来实现异步时钟域的隔离。计数器和读写指针等需要用BRAM外部的逻辑搭建，这样的结构就不能简单约束<code>set_clock_groups</code>，还要考虑这些外部逻辑如何约束。</p>\n<p>在存储器外部有一些用FPGA逻辑搭建的写指针和读指针控制，分属不同的时钟域，存在跨时钟域的时序路径。</p>\n<p>此时如果仅将读写时钟用<code>set_clock_goups</code>约束为异步时钟，想当于设置从A到B和从B到A的路径全部为false path。false path的优先级最高，很显然这么做会导致所有跨读写时钟域的路径全部不做时序分析，读写指针和相关控制逻辑也就失去了存在的意义。</p>\n</li>\n</ol>\n<h4 id=\"如何进行Maxdelay约束\"><a href=\"#如何进行Maxdelay约束\" class=\"headerlink\" title=\"如何进行Maxdelay约束\"></a>如何进行Maxdelay约束</h4><p><code>set_max_delay -from [get_cells GCB0[*]] -to [get_cells GCB1a[*]] -datapath_only 5</code>（具体延迟大小一般不超过目的时钟的时钟周期）</p>\n<p><code>set_false_path -from [get_cells rega] -to [get_cells regb]</code></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_max_delay_diagram.png\" alt=\"image-20200801214136797\"></p>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<h1 id=\"时序约束整理\"><a href=\"#时序约束整理\" class=\"headerlink\" title=\"时序约束整理\"></a><center>时序约束整理</center></h1><ul>\n<li><a href=\"#时序分析基础知识\">时序分析基础知识</a></li>\n<li><a href=\"#时序检查\">时序检查</a><ul>\n<li><a href=\"#setup-检查\">Setup 检查</a></li>\n<li><a href=\"#holdup-检查\">Holdup 检查</a></li>\n<li><a href=\"#recovery-检查\">Recovery 检查</a></li>\n<li><a href=\"#removal-检查\">Removal 检查</a></li>\n</ul>\n</li>\n<li><a href=\"#时序约束\">时序约束</a><ul>\n<li><a href=\"#时钟约束\">时钟约束</a></li>\n<li><a href=\"#inputoutput-延时约束\">Input/Output 延时约束</a></li>\n<li><a href=\"#multicycle-约束\">Multicycle 约束</a></li>\n<li><a href=\"#falsepath-约束\">Falsepath 约束</a></li>\n<li><a href=\"#maxdelay约束\">Maxdelay约束</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"1-时序分析基础知识\"><a href=\"#1-时序分析基础知识\" class=\"headerlink\" title=\"1.时序分析基础知识\"></a>1.时序分析基础知识</h2><h4 id=\"什么是时序分析\"><a href=\"#什么是时序分析\" class=\"headerlink\" title=\"什么是时序分析\"></a>什么是时序分析</h4><p>时序分析本质上就是一种时序检查，目的是检查设计中所有的D触发器是否能够正常工作，也就是检查D触发器的同步端口（数据输入端口）的变化是否满足建立时间要求（Setup）和保持时间要求（Hold）；检查D触发器的异步端口（异步复位端口）的变化是否满足恢复时间要求（Recovery）和移除时间要求（Removal）。</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90.png\" alt=\"时序分析\"></p>\n<h4 id=\"时序分析有哪些类型\"><a href=\"#时序分析有哪些类型\" class=\"headerlink\" title=\"时序分析有哪些类型\"></a>时序分析有哪些类型</h4><p>时序分析包括静态时序分析（STA）和动态时序分析。</p>\n<ul>\n<li>动态时序分析：将布局布线生成的布线延迟信息反标注到门级网表中进行仿真，检查是否存在时序违例。此时的仿真包括门延迟和布线延迟信息，能够较好反应芯片的实际工作情况。因为不可能产生完备的测试向量，覆盖门级网表中的每一条路径。因此在动态时序分析中，无法暴露一些路径上可能存在的时序问题。</li>\n<li>静态时序分析：采用穷尽分析方法来提取出整个电路存在的所有时序路径，计算信号在这些路径上的传播延时，检查信号的建立和保持时间是否满足时序要求，通过对最大路径延时和最小路径延时的分析，找出违背时序约束的错误。它不需要输入向量就能穷尽所有的路径，且运行速度很快、占用内存较少，不仅可以对芯片设计进行全面的时序功能检查，而且还可利用时序分析的结果来优化设计，因此静态时序分析已经越来越多地被用到数字集成电路设计的验证中。</li>\n</ul>\n<h4 id=\"时序分析使用的工具有哪些\"><a href=\"#时序分析使用的工具有哪些\" class=\"headerlink\" title=\"时序分析使用的工具有哪些\"></a>时序分析使用的工具有哪些</h4><ul>\n<li>静态时序分析使用的工具<ul>\n<li>Xilinx Vivado Integrated Design Environment Time Engine</li>\n<li>Altera Quartus II Timequest</li>\n<li>DC等</li>\n</ul>\n</li>\n<li>动态时序分析使用的工具<ul>\n<li>Mentor Modelsim</li>\n<li>Cadence NC-Verilog</li>\n<li>Sysnopsys VCS</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"静态时序分析之前的准备工作\"><a href=\"#静态时序分析之前的准备工作\" class=\"headerlink\" title=\"静态时序分析之前的准备工作\"></a>静态时序分析之前的准备工作</h4><p>撰写基本的时序约束文件，告知时序引擎一些必要的信息（比如时钟，输入输出延时等）。若没有正确的时序约束，那么时序分析的结果是没有意义的。</p>\n<p>D触发器中Tsetup, Thold, Tco的由来<br><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/TsetupThold%E7%9A%84%E7%94%B1%E6%9D%A5.png\" alt=\"D触发器原理图\"><br><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/Th%E7%9A%84%E7%94%B1%E6%9D%A5.png\" alt=\"Th的由来\"></p>\n<h4 id=\"序分析中的常用术语\"><a href=\"#序分析中的常用术语\" class=\"headerlink\" title=\"序分析中的常用术语\"></a>序分析中的常用术语</h4><ul>\n<li>源时钟（Source Clock/Launch Clock，也称发起时钟）</li>\n<li>目的时钟（Destination Clock/ Capture Clock, 也称捕获时钟）</li>\n<li>发起沿（Launch Edge，源时钟产生数据的有效时钟沿）</li>\n<li>捕获沿（Capture Edge，目的时钟捕获数据的有效时钟沿）</li>\n</ul>\n<p>发起沿通常在0ns，捕获沿通常在下一个发起沿，发起沿和捕获沿通常相差一个时钟周期。</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/LaunchEdgeCaptureEdge.png\" alt=\"img\"></p>\n<h4 id=\"一条普通时序路径的三要素\"><a href=\"#一条普通时序路径的三要素\" class=\"headerlink\" title=\"一条普通时序路径的三要素\"></a>一条普通时序路径的三要素</h4><ul>\n<li>源时钟路径：从源时钟的源节点（通常是FPGA的时钟输入引脚）到源寄存器的时钟端口的路径。当时序路径的起点是FPGA输入端口时，该时序路径是没有源时钟路径的。</li>\n<li>数据路径：从时序路径的起点到时序路径的终点之间的数据传播路径。时序路径的起点可以是源寄存器的时钟端口或FPGA的输入端口，时序路径的终点可以是目的寄存器的输入端口或FPGA的输出端口。</li>\n<li>目的时钟路径：从目的时钟的源节点（通常是FPGA的时钟输入引脚）到目的寄存器的时钟端口的路径。当时序路径的终点是FPGA的输出端口时，该时序路径是没有目的时钟路径的。</li>\n</ul>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/%E4%B8%89%E8%A6%81%E7%B4%A0.png\" alt=\"img\"></p>\n<h4 id=\"FPGA中常见的四种时序路径\"><a href=\"#FPGA中常见的四种时序路径\" class=\"headerlink\" title=\"FPGA中常见的四种时序路径\"></a>FPGA中常见的四种时序路径</h4><ol>\n<li><p>从FPGA的输入端口到目的寄存器的数据输入端口</p>\n<ul>\n<li>数据由Board Clock发起并在FPGA外部产生</li>\n<li>数据经过Input Delay的延迟后到达FPGA的输入端口</li>\n<li>数据经过FPGA的Internal Delay后到达由目的时钟驱动的目的寄存器</li>\n</ul>\n<p>这种路径是没有源时钟路径的，用户需要约束Input Delay和时钟来告知时序引擎必要信息，时序引擎才能正确的分析这种路径</p>\n</li>\n<li><p>从源寄存器的时钟端口到目的寄存器的数据输入端口</p>\n<ul>\n<li>数据由源时钟发起并在FPGA内部产生</li>\n<li>数据经过Data Path Delay后到达由目的时钟驱动的目的寄存器</li>\n</ul>\n<p>这种时序路径是最常见的，用户需要约束源时钟和目的时钟告知时序引擎必要的信息，时序引擎才能正确的分析这种时序路径。</p>\n</li>\n<li><p>从源寄存器的时钟端口到FPGA的输出端口</p>\n<ul>\n<li>数据有源时钟发起并在FPGA内部产生</li>\n<li>数据经过Internal Delay后到达输出端口</li>\n<li>数据经过Output Delay后被Board Clock捕获到</li>\n</ul>\n<p>这种路径是没有目的时钟路径的，用户需要约束Output Delay和时钟来告知时序引擎必要信息，时序引擎才能正确的分析这种路径。</p>\n</li>\n<li><p>从FPGA的输入端口到FPGA的输出端口</p>\n<ul>\n<li>数据横穿FPGA，没有经过任何触发器，这种路径也叫in-to-out path，约束输入和输出延时的参考时钟可以使用虚拟时钟</li>\n</ul>\n<p>这种路径中只有数据路径，用户需要约束Input Delay和Output Delay，告知时序引擎必要的信息，时序引擎才能正确的分析这种时序路径。</p>\n</li>\n</ol>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/%E5%9B%9B%E7%A7%8D%E8%B7%AF%E5%BE%84.png\" alt=\"img\"></p>\n<h2 id=\"时序检查\"><a href=\"#时序检查\" class=\"headerlink\" title=\"时序检查\"></a>时序检查</h2><h3 id=\"Setup-检查\"><a href=\"#Setup-检查\" class=\"headerlink\" title=\"Setup 检查\"></a>Setup 检查</h3><h4 id=\"时序引擎如何进行Setup检查\"><a href=\"#时序引擎如何进行Setup检查\" class=\"headerlink\" title=\"时序引擎如何进行Setup检查\"></a>时序引擎如何进行Setup检查</h4><ol>\n<li><p>确定建立时间要求（建立时间的捕获沿-建立时间的发起沿）</p>\n<p>确定建立时间的捕获沿和建立时间的发起沿。</p>\n<p>时序引擎会找出发起时钟和捕获时钟的最小公共周期，然后在最小公共周期内找到所有发起时钟沿和捕获时钟沿的所有可能情况，并在所有可能的情况中挑选出<strong>最小的建立时间需求</strong>（大于0），从而确定Launch Edge和 Capture Edge。</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/%E7%A1%AE%E5%AE%9A%E5%BB%BA%E7%AB%8B%E6%97%B6%E9%97%B4%E8%A6%81%E6%B1%82.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/%E7%A1%AE%E5%AE%9A%E5%BB%BA%E7%AB%8B%E6%97%B6%E9%97%B4%E8%A6%81%E6%B1%82%E8%AE%A1%E7%AE%97.png\" alt=\"img\"></p>\n</li>\n<li><p>计算数据的需求时间</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/%E5%BB%BA%E7%AB%8B%E6%97%B6%E9%97%B4%E8%AE%A1%E7%AE%97%E6%95%B0%E6%8D%AE%E7%9A%84%E9%9C%80%E6%B1%82%E6%97%B6%E9%97%B4.png\" alt=\"img\"></p>\n</li>\n<li><p>计算数据的到达时间</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/%E5%BB%BA%E7%AB%8B%E6%97%B6%E9%97%B4%E8%AE%A1%E7%AE%97%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%B0%E8%BE%BE%E6%97%B6%E9%97%B4.png\" alt=\"img\"></p>\n</li>\n<li><p>计算Setup的裕量（Slack）</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/%E5%BB%BA%E7%AB%8B%E6%97%B6%E9%97%B4%E8%AE%A1%E7%AE%97Setup%E7%9A%84%E8%A3%95%E9%87%8F.png\" alt=\"img\"></p>\n</li>\n</ol>\n<h4 id=\"Setup分析实例\"><a href=\"#Setup分析实例\" class=\"headerlink\" title=\"Setup分析实例\"></a>Setup分析实例</h4><ul>\n<li><p>Data Arrival Time = Launch Edge + Tclka + Tco + Tdata(Tlogic + Tnet)</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/setup%E5%88%86%E6%9E%90data_arrival_time.png\" alt=\"img\"></p>\n</li>\n<li><p>Data Require Time = Capture Edge + Tclkb - Tsu</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/setup%E5%88%86%E6%9E%90data_require_time.png\" alt=\"img\"></p>\n</li>\n<li><p>Setup Slack = Data Require Time - Data Arrival Time</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/setup%E5%88%86%E6%9E%90setup_slack.png\" alt=\"img\"></p>\n</li>\n</ul>\n<h4 id=\"Setup-Slack为负的因素\"><a href=\"#Setup-Slack为负的因素\" class=\"headerlink\" title=\"Setup Slack为负的因素\"></a>Setup Slack为负的因素</h4><ul>\n<li>Setup Slack = (Capture  Edge - Launch Edge) + (Destination clk delay - source clk delay) - Setup Time - Clk uncertainty - datapath delay</li>\n<li>Setup Slack = Setup Requirement (一定大于0) + clk skew - Tsu - Tclk uncertainty - Tlogic - Tnet - Tco</li>\n</ul>\n<ol>\n<li><p>Setup Requirement与实际情况不符</p>\n<p>建立时间需求过小，这种情况通常会在同步跨时钟域路径中出现，在同步跨时钟域路径中的源时钟频率与目的时钟频率的相位关系虽然是已知的，但是时序引擎默认选择的捕获沿通常都是错误的，需要用户通过多周期路径约束的方式手动修正建立时间需求。比如下图中，两个同频不同相的同步时钟，时序引擎默认选择的捕获沿是目的时钟第二个上升沿，导致建立时间需求非常小，最终肯定会导致时序违例。</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/SetupRequirement%E4%B8%8E%E5%AE%9E%E9%99%85%E4%B8%8D%E7%AC%A6.png\" alt=\"img\"></p>\n</li>\n<li><p>Clk Skew为负值，且很大</p>\n<p>通常情况下，同一个时钟下的时钟歪斜不应该超过300ps，同步跨时钟域路径的时钟歪斜不应该超过500ps，异步跨时钟域路径的时钟歪斜一般比较大，因为它们的时钟源不同。</p>\n<p>当出现时钟歪斜大的情况时:</p>\n<ul>\n<li>检查源时钟路径和目的时钟路径上是否干净，时钟路径上是否引入了组合逻辑，时钟路径是否使用了过多的BUFGCE，时钟路径上是否级联了多个BUFGCE导致时钟延时变大。</li>\n<li>检查源时钟路径和目的时钟路径所经过的模块是否相同，比如源时钟路径上经过全局缓冲，PMMCM，但是目的时钟路径上只经过了全局缓冲。如下图所示，第一条路径的源时钟路径上有BUFGCE/MMCM/BUFGCE，而目的时钟路径上只有BUFGCE，所以源时钟路径和目的时钟路径的延时不同，导致时钟歪斜较大，应该尽量避免此类路径。第二条路径的源时钟和目的时钟都是来源于MMCM的不同的时钟，所以时钟歪斜较小。</li>\n</ul>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/clk_skew%E5%BE%88%E5%A4%A7.png\" alt=\"img\"></p>\n</li>\n<li><p>Tsu/Tco很大</p>\n<p>当设计中使用Block（DSP/Block RAM等）时，应该要注意以下问题。对于以这些Block为时序路径的起点或终点的时序路径，这些<strong>Block的Tsu/Th/Tco都比普通的寄存器大</strong>，而且这些Block的布线延时和时钟歪斜比较大。所以当使用这些Block作为时序路径的终点时，它的起点一定要是触发器，比如说一个Block RAM的写数据信号，输入进Block前最好打一拍。当使用这些Block作为时序路径的起点时，应该使用Block 内部的输出寄存器，比如使用由Block RAM组成的FIFO时，尽量不要使用首字置出的，而使用打一拍后输出的，使用后者可以显著降低Tco。当时序路径为从一个Block到另一个Block时，中间需要进行打拍操作。当使用这些Block的控制端口时，应该保证这些控制信号的低扇出，如使用由Block RAM组成的FIFO时，应该尽量降低读/写能信/地址信号的扇出。</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/Tco_Th%E5%BE%88%E5%A4%A7.png\" alt=\"img\"></p>\n</li>\n<li><p>Tlogic大</p>\n<p>一般情况下，逻辑延时与时序路径的逻辑层级数息息相关，逻辑层级是指时序路径的起点和终点之间组合逻辑单元（LUT）的个数，而逻辑层级多一级意味着多1个LUT的延时加1条连接LUT的网线延时。通常一级逻辑层级的延时标准是1个LUT加1根网线的总延迟为0.5ns，如果某条路径的逻辑级数大于时钟周期/0.5ns，那么这条路径就被称为长路径。</p>\n<p>常用的处理长路径的方案有两种：</p>\n<ul>\n<li>修改rtl代码，在长路径的逻辑中插入流水线，将长路径打破分为多条短路径；</li>\n<li>使用综合工具的retiming优化方式，retiming实际上是寄存器重定向，原理是当某条长路径的相邻路径的建立时间裕量较大，那么它可以调整中间寄存器的位置，来调整布线延迟，通过适当增加相邻路径的布线延迟而减少长路径的布线延迟，使得那些时序违例较小的长路径通过这种微调实现时序收敛。需要强调的是，<strong>这种方式优化的力度非常有限</strong>，它只适合时序违例较小的长路径，对于一些延时特别大的长路径而言，也是无力回天。</li>\n</ul>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/Tlogic%E5%BE%88%E5%A4%A7.png\" alt=\"img\"></p>\n</li>\n<li><p>Tnet大</p>\n<p>一般情况下，布线延迟与设计整体或局部模块的资源利用率以及拥塞程度息息相关。</p>\n<p>在正常情况下，一条网线的延时小于1ns，在发生拥塞的区域，网线的延时可能达到若干ns，导致布线延时显著增加。为了解决布线延迟大，需要从降低资源利用率和降低拥塞程度下手，比如某个模块使用了大量的寄存器堆，占用了大量的资源，此时应该考虑使用Block RAM代替这些寄存器堆；某个模块使用了大量的数据选择器，此时应该考虑如何优化这些数据选择器；某个模块的控制信号扇出比较大，与其他模块的互联很重，此时应该考虑如何降低这些信号的扇出；某条时序路径的起点或终点是Block，由于Block的位置比较固定，所以Block的布线延迟会大一些。最后需要强调的是，一定要额外关注高扇出的网线也会对布线延时产生影响。</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/TimeQuest%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90Setup1.png\" alt=\"img\"></p>\n<p>TimeQuest时序分析（Setup）</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/TimeQuest%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90Setup2.png\" alt=\"img\"></p>\n</li>\n</ol>\n<h3 id=\"Holdup-检查\"><a href=\"#Holdup-检查\" class=\"headerlink\" title=\"Holdup 检查\"></a>Holdup 检查</h3><h4 id=\"时序引擎如何进行Holdup检查\"><a href=\"#时序引擎如何进行Holdup检查\" class=\"headerlink\" title=\"时序引擎如何进行Holdup检查\"></a>时序引擎如何进行Holdup检查</h4><ol>\n<li><p>确定保持时间要求（确定发起时钟沿和捕获时钟沿）</p>\n<p><strong>保持时间要求是以建立时间要求为基础的</strong>，保持时间要求有两种：</p>\n<ul>\n<li><p>当前建立时间的发起沿产生的数据不能被当前建立时间的捕获沿的前一个有效沿捕获</p>\n</li>\n<li><p>当前建立时间的发起沿的下一个有效沿产生的数据不能被当前建立时间的捕获沿捕获</p>\n</li>\n</ul>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/holdTimeRequirement.png\" alt=\"img\"></p>\n<p>根据所有的建立时间需求找到所有的保持时间需求，并从保持时间需求（可正可负）中找到最大的保持时间需求。!</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/HoldPathRequirement.png\" alt=\"img\"></p>\n</li>\n</ol>\n<p>   <img src=\"/2024/01/shi-xu-yue-shu-zheng-li/DataPathRequirementCalculation.png\" alt=\"img\"></p>\n<ol start=\"2\">\n<li><p>计算数据的需求时间</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/dataRequiredTimeHold.png\" alt=\"img\"></p>\n</li>\n<li><p>计算数据的到达时间</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/DataArrivalTimeHold.png\" alt=\"img\"></p>\n</li>\n<li><p>计算Hold up的裕量(Slack)</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/SlackHold.png\" alt=\"img\"></p>\n</li>\n</ol>\n<h4 id=\"Holdup分析实例\"><a href=\"#Holdup分析实例\" class=\"headerlink\" title=\"Holdup分析实例\"></a>Holdup分析实例</h4><ul>\n<li>Data Arrival Time (new data) = Launch Edge + Tclka + Tco + Tdata(Tlogic + Tnet)</li>\n<li>Data Require Time = Capture Edge + Tclkb + Th</li>\n<li>Hold up Slack = Data Arrival Time - Data Require Time</li>\n</ul>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/HoldupExample.png\" alt=\"img\"></p>\n<h4 id=\"Holdup-Slack为负的因素\"><a href=\"#Holdup-Slack为负的因素\" class=\"headerlink\" title=\"Holdup Slack为负的因素\"></a>Holdup Slack为负的因素</h4><ul>\n<li>Holdup Slack = (Launch Edge - Capture Edge) + (Tclka - Tclkb) + Tco + Tdata(Tlogic + Tnet) - Th</li>\n<li>Holdup Slack = Tco + Tdata(Tlogic + Tnet) - Th - Holdup Requirement - Clk skew</li>\n</ul>\n<p>Hold up Slack为负的情况比较少见，当Setup Slack有较大裕量时，通常工具会自动插入延时来增加Hold up Slack。</p>\n<ol>\n<li>保持时间需求大于0（通常由时序引擎选择错误的捕获沿导致）</li>\n<li>时钟歪斜大于300ps（通常由时钟路径上的组合逻辑导致）</li>\n<li>Th过大（通常由时钟路径上的组合逻辑导致）</li>\n</ol>\n<p>TimeQuest时序分析（Holdup）</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/TimeQuestHoldupSlack.png\" alt=\"img\"></p>\n<h3 id=\"Recovery-检查\"><a href=\"#Recovery-检查\" class=\"headerlink\" title=\"Recovery 检查\"></a>Recovery 检查</h3><p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/%E5%A4%8D%E4%BD%8D%E7%BB%93%E6%9E%84.png\" alt=\"image-20200806204803965\"></p>\n<h4 id=\"时序引擎如何进行Recovery检查\"><a href=\"#时序引擎如何进行Recovery检查\" class=\"headerlink\" title=\"时序引擎如何进行Recovery检查\"></a>时序引擎如何进行Recovery检查</h4><p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/RequireTimeRecovery.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/TimeQuestRecovery.png\" alt=\"img\"></p>\n<h3 id=\"Removal-检查\"><a href=\"#Removal-检查\" class=\"headerlink\" title=\"Removal 检查\"></a>Removal 检查</h3><h4 id=\"时序引擎如何进行Removal检查\"><a href=\"#时序引擎如何进行Removal检查\" class=\"headerlink\" title=\"时序引擎如何进行Removal检查\"></a>时序引擎如何进行Removal检查</h4><p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/RequireTimeRemoval.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/TimeQuestRemoval.png\" alt=\"img\"></p>\n<h2 id=\"时序约束\"><a href=\"#时序约束\" class=\"headerlink\" title=\"时序约束\"></a>时序约束</h2><p>时序引擎能够正确分析4钟时序路径的前提是，用户已经进行了正确的时序约束。时序约束本质上就是告知时序引擎一些进行时序分析所必要的信息，这些信息只能由用户主动告知，时序引擎对有些信息可以自动推断，但是推断得到的信息不一定正确。</p>\n<ul>\n<li><p>第一种路径需要约束Input_delay</p>\n</li>\n<li><p>第二种路径需要约束时钟</p>\n</li>\n<li><p>第三种路径需要约束Output_delay</p>\n</li>\n<li><p>第四种路径需要约束Max_delay/Min_delay</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/FourPathConstraints.png\" alt=\"img\"></p>\n</li>\n</ul>\n<h3 id=\"时钟约束\"><a href=\"#时钟约束\" class=\"headerlink\" title=\"时钟约束\"></a>时钟约束</h3><h4 id=\"时序约束类型\"><a href=\"#时序约束类型\" class=\"headerlink\" title=\"时序约束类型\"></a>时序约束类型</h4><p>首先用户必须要正确的约束时钟，时序引擎才能根据时钟信息进行各种时序检查。</p>\n<p>用户约束时钟时，一般有两种类型的时钟需要约束。</p>\n<ul>\n<li><p>主时钟（Primary Clock）</p>\n<p>主时钟（Primary Clock）有两种类型：第一种是从FPGA的全局时钟输入引脚输入的时钟；第二种是从高速收发器输出给用户的恢复时钟</p>\n</li>\n<li><p>生成时钟（Generated Clock）</p>\n<p>生成时钟（Generated Clock）有两种类型：第一种是由FPGA的专用时钟管理模块（PLL/MMCM）产生的时钟（这种时钟可以由时序引擎自动推断出来）；第二种是由用户通过LUT或寄存器产生的时钟（这种时钟必须由用户手动约束）</p>\n</li>\n</ul>\n<ol>\n<li><p>主时钟（Primary Clock）约束</p>\n<p>使用<code>Create_clock</code>进行约束</p>\n<ul>\n<li><p>第一种是从FPGA的全局时钟输入引脚输入的时钟：</p>\n<p>全局时钟输入引脚是sysclk，时钟周期10ns，占空比50%，相移0度。</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/PrimaryClockPath.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/PrimaryClockConstraints.png\" alt=\"img\"></p>\n<p>全局时钟输入引脚是ClkIn，时钟周期10ns，占空比25%，相移90度</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/PrimaryClockPath2.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/PrimaryClockConstraints2.png\" alt=\"img\"></p>\n</li>\n<li><p>第二种是从高速收发器输出给用户的恢复时钟 全局时钟输入引脚是sysclk，时钟周期3.3ns，占空比50%，相移0度</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/PrimaryClockPathFromSerdes.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/PrimaryClockConstraintsFromSerdes.png\" alt=\"img\"></p>\n</li>\n</ul>\n</li>\n<li><p>生成时钟（Generated Clock）约束</p>\n<p>用<code>Create_generated_clock</code>进行时序约束</p>\n<p>每个生成时钟都会对应一个时钟源（Master_clk），这个时钟源可以是Primary Clock或者另一个Generated Clock。</p>\n<p>在约束生成时钟时，用户不需要描述生成时钟的周期和波形，只需要描述由Master_clk经过了怎样的变化而产生的生成时钟即可。比如经过分频（-devide_by），倍频（-multiply_by），反相（-invert），相移（-edge_shift）等等操作。</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/GeneratedClockSourceClock.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/GeneratedClcokPath.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/GeneratedClcokConstraints.png\" alt=\"img\"></p>\n<p>当生成时钟需要进行相移时，使用-edge_shift选项。</p>\n<p>-edge_shift不能与-divide_by/-multiple_by/-invert同时使用。</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/GeneratedClockEdgeShiftPath.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/GeneratedClockEdgeShiftConstraints.png\" alt=\"img\"></p>\n</li>\n</ol>\n<h4 id=\"时钟分组\"><a href=\"#时钟分组\" class=\"headerlink\" title=\"时钟分组\"></a>时钟分组</h4><p>时序引擎默认情况下会分析所有时钟之间的时序路径，用户可以通过时钟分组<code>set_clock_group</code>命令或伪路径<code>set_false_path</code>命令来关闭一部分路径的时序分析。</p>\n<ul>\n<li>使用<code>set_clock_group</code>命令，时序引擎会将不同分组的时钟之间的路径分析关闭，相同分组的时钟之间的路径仍然存在。</li>\n<li>使用<code>set_false_path</code>命令，时序引擎会忽略两个时钟的双向路径，被忽略的路径不一定能够正常工作，需要用户确保该路径使用了两级触发器同步或者按照异步数据传输方式传输数据。用户负责保证这些被忽略的路径可以正常工作。</li>\n</ul>\n<p><strong>两个时钟的关系</strong></p>\n<ol>\n<li><p>同步时钟（synchronous clock）</p>\n<p>两个时钟之间的相对相位关系是固定的（两个时钟来源于同一个Primary Clock），并且这两个时钟的频率的最小公共周期是个整数。</p>\n<p>比如一个生成时钟（200M）和该生成时钟的Master_clk（100M）之间就属于同步时钟关系，因为这两个时钟的相位关系是确定的，并且可以找到两个时钟的最小公共周期。通常情况下，一个Primary Clock和它产生的生成时钟之间都属于同步时钟关系，除非找不到最小公共周期。<strong>属于同步时钟关系的两个时钟之间的路径是可以进行时序分析的。</strong></p>\n</li>\n<li><p>异步时钟（asynchronous clock）</p>\n<p>两个时钟之间的相对相位关系不确定。</p>\n<p>比如FPGA上两个晶振分别产生两个Primary clock（相对相位关系不固定），这两个Primary clock分别从FPGA的两个全局时钟引脚输入给两个MMCM，由两个MMCM分别产生的生成时钟之间属于异步时钟。一般情况下，不同的Primary clock之间都属于异步时钟，这些Primary clock分别产生的生成时钟之间也属于异步时钟关系。</p>\n<p><strong>属于异步时钟关系的两个时钟之间的路径无法进行正确的时序分析。</strong></p>\n<p>一般情况下，如果用户不通过时钟分组对时钟之间的关系进行约束，时序引擎会默认所有的时钟之间都属于同步时钟关系</p>\n</li>\n<li><p>不可扩宽的时钟（unexpandable clock）</p>\n<p>对于这类时钟，时序引擎无法在1000个时钟周期内找到两个时钟的公共周期，时序引擎就会从这1000个时钟中找到建立时间需求最差的情况，并进行时序分析，然而它不一定是FPGA实际运行过程中建立时钟需求最差的情况，因为在1000个时钟周期外可能还会有建立时钟需求更差的情况，这样一来，时序引擎的分析结果就无法保证该路径一定不会出现问题，所以时序引擎的分析结果也就变的毫无意义。</p>\n<p>比如说由同一个Primary Clock驱动的两个MMCM的生成时钟分别是clk0（5.125ns）和clk1（6.666ns），虽然他们的相对相位关系是固定的，但是时序引擎无法保证对两个时钟之间的路径的分析属于最差情况，这种情况和异步时钟之间的时序分析类似，时序分析的结果都看起来正常，但是这个结果是不可信的。所以对这种时钟的处理方式与处理异步时钟是相同的，用户都需要进行跨时钟域的操作。</p>\n</li>\n</ol>\n<p><strong>总结：异步时钟和不可扩展的时钟之间的路径都无法进行正确的时序分析，所以在时序分析之前，需要使用<code>set_clock_group</code>对时钟进行分组，从而将这些无法进行正确时序分析的路径忽略掉。</strong></p>\n<p><strong>时钟分组实例</strong></p>\n<ul>\n<li><p>第一个Primary clock clk0从FPGA的全局时钟引脚进入了一个MMCM，MMCM生成了两个生成时钟 userclk, itfclk</p>\n</li>\n<li><p>第二个Primary clock clk1是一个高速收发器输出的恢复时钟，将该恢复时钟输入进一个MMCM，MMCM生成了两个生成时钟gtxclk, gtxclktx</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_clock_group_command.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_clock_group_command2.png\" alt=\"img\"></p>\n</li>\n</ul>\n<h3 id=\"Input-Output-延时约束\"><a href=\"#Input-Output-延时约束\" class=\"headerlink\" title=\"Input/Output 延时约束\"></a>Input/Output 延时约束</h3><h4 id=\"什么是Input-delay-如何计算它？如何约束它？\"><a href=\"#什么是Input-delay-如何计算它？如何约束它？\" class=\"headerlink\" title=\"什么是Input delay? 如何计算它？如何约束它？\"></a>什么是Input delay? 如何计算它？如何约束它？</h4><p><strong>Input delay概念</strong></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/input_delay.png\" alt=\"img\"></p>\n<p><strong>Input delay计算</strong></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/input_delay_path1.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/input_delay_path2.png\" alt=\"img\"></p>\n<p><strong>Max Input Delay = Tco(Max) + Tpcb(Max) - Clk skew(Min)</strong></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/max_input_delay.png\" alt=\"img\"></p>\n<p><strong>Min Input Delay = Tco(Min) + Tpcb(Min) - Clk skew(Max)</strong></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/Min_Input_Delay.png\" alt=\"img\"></p>\n<p><strong>Input delay约束</strong></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/input_delay_constraints1.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/input_delay_constraints2.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/input_delay_constraints3.png\" alt=\"img\"></p>\n<h4 id=\"什么是Output-delay？如何计算它？如何约束它？\"><a href=\"#什么是Output-delay？如何计算它？如何约束它？\" class=\"headerlink\" title=\"什么是Output delay？如何计算它？如何约束它？\"></a>什么是Output delay？如何计算它？如何约束它？</h4><p><strong>Output delay概念</strong></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/output_delay.png\" alt=\"img\"></p>\n<p><strong>Output delay计算</strong></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/output_delay_path1.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/output_delay_path2.png\" alt=\"img\"></p>\n<p><strong>Max Output Delay = Tpcb(Max) + Tsu - Clk skew(Min)</strong></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/max_output_delay.png\" alt=\"img\"></p>\n<p><strong>Min Output Delay = Tpcb(Min) - Th - Clk skew(Max)</strong></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/min_output_delay.png\" alt=\"img\"></p>\n<p><strong>Output delay约束</strong></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/output_delay_constraints1.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/output_delay_constraints2.png\" alt=\"img\"></p>\n<h3 id=\"Multicycle-约束\"><a href=\"#Multicycle-约束\" class=\"headerlink\" title=\"Multicycle 约束\"></a>Multicycle 约束</h3><h4 id=\"为什么要进行Multicycle约束？\"><a href=\"#为什么要进行Multicycle约束？\" class=\"headerlink\" title=\"为什么要进行Multicycle约束？\"></a>为什么要进行Multicycle约束？</h4><ul>\n<li>时序引擎默认情况下会在建立时间需求/保持时间需求最差的情况下进行时序分析，而时序引擎选择的这种需求不一定是用户真正希望的，而且时序引擎默认选择的这种需求是非常严苛的，甚至是根本无法满足的。此时就需要用户进行Multicycle约束，手动修改建立时间需求/保持时间需求。</li>\n<li>用户希望放松某些路径的约束力度，就可以通过Multicycle约束调整建立时间需求/保持时间需求。 </li>\n</ul>\n<p>使用<code>set_multicycle_path</code>命令进行约束</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_start_end.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_source_destination_clock.png\" alt=\"img\"></p>\n<h4 id=\"如何进行正确Multicycle约束？\"><a href=\"#如何进行正确Multicycle约束？\" class=\"headerlink\" title=\"如何进行正确Multicycle约束？\"></a>如何进行正确Multicycle约束？</h4><p>注：使用<code>set_multicycle_path</code>命令</p>\n<ol>\n<li><p>在源时钟和目的时钟相同的情况下进行Multicycle约束</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/multicycle_path_same_clock.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/multicycle_path_same_clock_timing.png\" alt=\"img\"></p>\n<ul>\n<li><p>每两个时钟发起一次数据，每两个时钟捕获一次数据</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/multicycle_path_rtl_diagram.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicyclye_path_same_clk_command.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_same_clk_timing.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicyclye_path_same_clk_command2.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_same_clk_timing2.png\" alt=\"img\"></p>\n</li>\n<li><p>每四个时钟发起一次数据，每四个时钟捕获一次数据</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_4_timing.png\" alt=\"img\"></p>\n</li>\n<li><p>只调整setup需求，Holdup需求会发生相应的变化，但是变化结果是错误的</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_just_setup.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_just_setup_timing.png\" alt=\"img\"></p>\n</li>\n<li><p>进一步调整Holdup需求（-start）</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_holdup_adjust.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_holdup_timing.png\" alt=\"img\"></p>\n</li>\n<li><p>Set_multicycle_path 4 –hold –end –from [get_pins data0_reg/C] – to [get_pins data1_reg/C]</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_hold_4.png\" alt=\"img\"></p>\n</li>\n</ul>\n</li>\n<li><p>在源时钟和目的时钟频率相同且有正向偏移的情况下（正向偏移0.3ns）</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_timeshift0.3.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_timeshift0.3_timing.png\" alt=\"img\"></p>\n<p>先调整setup需求，holdup需求发生相应的变化，但变化的结果是正确的</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_setup_timeshift.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_setup_timeshift_timing.png\" alt=\"img\"></p>\n</li>\n<li><p>在源时钟的目的时钟频率相同且有负向偏移的情况下（负向偏移0.3ns）发生负向偏移时，通常不需要进行Multicycle的约束，除非负向偏移过大</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_minus_shift.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_minus_shift_timing.png\" alt=\"img\"></p>\n</li>\n<li><p>在源时钟和目的时钟频率不同的情况下（源时钟慢，目的时钟快）</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_slow2fast.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_slow2fast_timing.png\" alt=\"img\"></p>\n<p>调整setup需求（只能用-end，不能用-start），Holdup需求发生相应的变化，变化的结果是错误的。</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_slow2fast_just_setup_command.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_slow2fast_just_setup_timing.png\" alt=\"img\"></p>\n<p>进一步调整Holdup需求（只能用-end，不能用-start）</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_slow2fast_holdup_command.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_slow2fast_holdup_timing.png\" alt=\"img\"></p>\n</li>\n<li><p>在源时钟和目的时钟频率不同的情况下（源时钟快，目的时钟慢）</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_fast2slow.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_fast2slow_timing.png\" alt=\"img\"></p>\n<p>同时调整setup需求（只能用-start，不能用-end）和Holdup需求（只能用-start，不能用-end）</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_fast2slow_setup_hold_command.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_multicycle_path_fast2slow_setup_hold_timing.png\" alt=\"img\"></p>\n</li>\n</ol>\n<h3 id=\"Falsepath-约束\"><a href=\"#Falsepath-约束\" class=\"headerlink\" title=\"Falsepath 约束\"></a>Falsepath 约束</h3><h4 id=\"什么样的路径属于FalsePath\"><a href=\"#什么样的路径属于FalsePath\" class=\"headerlink\" title=\"什么样的路径属于FalsePath?\"></a>什么样的路径属于FalsePath?</h4><p>注：使用<code>set_false_path</code>命令</p>\n<p>FalsePath路径是指该路径在拓扑结构中的确存在，但是满足以下任一条件的路径：</p>\n<ul>\n<li>在实际运行过程中，该路径不工作</li>\n<li>该路径不需要进行时序分析</li>\n</ul>\n<p>比如：已经做了两级触发器同步的跨时钟域路径</p>\n<p>只在上电时工作一次的寄存器</p>\n<p>异步复位路径或用于测试的路径</p>\n<p><strong>注意</strong>：如果用户的目的只是放松某条路径的时序约束，可以用<code>set_multicycle_path</code>命令进行约束，不要使用<code>set_false_path</code></p>\n<p><strong>设置FalsePath的好处</strong></p>\n<ol>\n<li>减小综合、实现、时序分析的时间</li>\n<li>极大的提升工具对设计的综合、实现、优化的结果</li>\n</ol>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_false_path_command.png\" alt=\"img\"></p>\n<p>-from/-to的node_list必须是有效的时序路径的起点和终点，或是时钟。-through的node_list可以是ports/pins。</p>\n<h4 id=\"FalsePath约束举例\"><a href=\"#FalsePath约束举例\" class=\"headerlink\" title=\"FalsePath约束举例\"></a>FalsePath约束举例</h4><ol>\n<li><p>将异步复位信号设置为伪路径</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_false_path_reset.png\" alt=\"img\"></p>\n</li>\n<li><p>将CLKA到CLKB的单向路径设置为伪路径</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_false_path_a2b_single.png\" alt=\"img\"></p>\n</li>\n<li><p>将CLKA到CLKB以及CLKB到CLKA的双向路径设置为伪路径</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_false_path_a2b_dual.png\" alt=\"img\"></p>\n</li>\n</ol>\n<p><strong>注</strong>：当有多个异步时钟之间的路径需要设置为伪路径时，推荐使用<code>set_clock_group</code>命令。</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_false_path_through_diagram.png\" alt=\"img\"></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_false_path_through_command.png\" alt=\"img\"></p>\n<p>凡是经过MUX1/a0，到MUX2/a1的时序路径都会被忽略，采用-through的好处是不需要具体指定时序路径的起点和终点，-through的顺序需要注意，上述命令描述的是先经过MUX1/a0，然后再经过MUX2/a1。</p>\n<h3 id=\"Maxdelay约束\"><a href=\"#Maxdelay约束\" class=\"headerlink\" title=\"Maxdelay约束\"></a>Maxdelay约束</h3><h4 id=\"什么情况下使用Maxdelay约束？\"><a href=\"#什么情况下使用Maxdelay约束？\" class=\"headerlink\" title=\"什么情况下使用Maxdelay约束？\"></a>什么情况下使用Maxdelay约束？</h4><ol>\n<li>它可以代替Multicycle约束，调整建立时间需求，而且<code>set_max_delay</code>约束的优先级比Multicycle约束要高</li>\n<li>对于两个异步时钟域之间的异步信号不需要进行时序分析，但是用户对路径延迟有一定的要求时，可以使用<code>set_max_delay -datapath only</code>进行约束。<code>-datapath only</code>用于忽略时钟歪斜，只考虑数据路径的延时。</li>\n</ol>\n<p><strong>注</strong>：当用户需要对两个异步时钟域之间的部分/所有路径指定路径的最大延时，用户需要使用<code>set_max_delay -datapath only</code>对这些路径的延时进行约束，同时用户不能使用<code>set_clock_group</code>约束，因为<code>set_clock_group</code>的优先级比<code>set_maxdelay</code>高。<strong>两个时钟域之间的剩余路径可以使用<code>set_false_path</code>进行约束。</strong></p>\n<p>对于通过set_false_path/set_clock_group命令进行约束的路径，综合器不会对该路径进行优化，很可能导致两个寄存器的位置很远。</p>\n<ol>\n<li><p>单bit信号跨时钟域（两级触发器同步）</p>\n<p>此时只需要使用<code>set_false_path/set_clock_group</code>对异步信号的路径约束即可，因为此时两个寄存器之间的延迟不会影响功能，只会影响性能，此时不需要使用Maxdelay约束。</p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/single_bit_cdc_diagram.png\" alt=\"image-20200801212024545\"></p>\n</li>\n<li><p>多bit信号跨时钟域（格雷码）</p>\n<p>此时若只使用<code>set_false_path/set_clock_group</code>对异步信号的路径约束，可能会影响格雷码功能的正确性。所以需要Maxdelay对数据路径的延迟进行约束。</p>\n<p>设计中也常用一种带有格雷码控制的FIFO来实现异步时钟域的隔离。计数器和读写指针等需要用BRAM外部的逻辑搭建，这样的结构就不能简单约束<code>set_clock_groups</code>，还要考虑这些外部逻辑如何约束。</p>\n<p>在存储器外部有一些用FPGA逻辑搭建的写指针和读指针控制，分属不同的时钟域，存在跨时钟域的时序路径。</p>\n<p>此时如果仅将读写时钟用<code>set_clock_goups</code>约束为异步时钟，想当于设置从A到B和从B到A的路径全部为false path。false path的优先级最高，很显然这么做会导致所有跨读写时钟域的路径全部不做时序分析，读写指针和相关控制逻辑也就失去了存在的意义。</p>\n</li>\n</ol>\n<h4 id=\"如何进行Maxdelay约束\"><a href=\"#如何进行Maxdelay约束\" class=\"headerlink\" title=\"如何进行Maxdelay约束\"></a>如何进行Maxdelay约束</h4><p><code>set_max_delay -from [get_cells GCB0[*]] -to [get_cells GCB1a[*]] -datapath_only 5</code>（具体延迟大小一般不超过目的时钟的时钟周期）</p>\n<p><code>set_false_path -from [get_cells rega] -to [get_cells regb]</code></p>\n<p><img src=\"/2024/01/shi-xu-yue-shu-zheng-li/set_max_delay_diagram.png\" alt=\"image-20200801214136797\"></p>\n"},{"title":"FPGA基本单元","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2024-01-25T06:44:59.000Z","password":null,"summary":null,"keywords":null,"description":null,"_content":"\n原文地址 [Logic Elements and Logic Array Blocks in Cyclone IV Devices](https://cdrdv2-public.intel.com/653677/cyiv-51002.pdf)\n\n# Logic Elements and Logic Array Blocks in Cyclone IV Devices （LCyclone IV器件中的逻辑元件和逻辑阵列块）\nThis chapter contains feature definitions for logic elements (LEs) and logic array blocks (LABs). Details are provided on how LEs work, how LABs contain groups of LEs, and how LABs interface with the other blocks in Cyclone® IV devices.\n>这一章包含了Cyclone® IV器件中逻辑元件（LEs）和逻辑阵列块（LABs）的特性定义。详细介绍了LEs的工作原理、LABs如何包含LEs的组群，以及LABs如何与Cyclone® IV器件中的其他模块进行接口。\n\n## Logic Elements (逻辑元件)\nLogic elements (LEs) are the smallest units of logic in the Cyclone IV device\narchitecture. LEs are compact and provide advanced features with efficient logic\nusage. Each LE has the following features:\n>逻辑元件（LEs）是Cyclone IV器件架构中最小的逻辑单元。LEs紧凑而且提供高效的逻辑使用，具有先进的功能。每个LE具有以下特性：\n\n■ A four-input look-up table (LUT), which can implement any function of four\nvariables\n■ A programmable register\n■ A carry chain connection\n■ A register chain connection\n■ The ability to drive the following interconnects:\n■ ■ Local\n■ ■ Row\n■ ■ Column\n■ ■ Register chain\n■ ■ Direct link\n■ Register packing support\n■ Register feedback support\n\n>- 一个四输入查找表（LUT），可以实现四个变量的任何函数\n>- 一个可编程寄存器\n>- 一个进位链连接\n>- 一个寄存器链连接\n>- 能够驱动以下互连方式：\n>  -- 本地\n>  -- 行\n>  -- 列\n>  -- 寄存器链\n>  -- 直接链接\n>  - 寄存器打包支持\n>  - 寄存器反馈支持\n\n![img](FPGA基本单元/Cyclone_IV_dEVICES_LEs.png)\n\n### LE Features(LE特性)\nYou can configure the programmable register of each LE for D, T, JK, or SR flipflop\noperation. Each register has data, clock, clock enable, and clear inputs. Signals that use the global clock network, general-purpose I/O pins, or any internal logic can drive the clock and clear control signals of the register. Either general-purpose I/O pins or the internal logic can drive the clock enable. For combinational functions, the LUT output bypasses the register and drives directly to the LE outputs. \nEach LE has three outputs that drive the local, row, and column routing resources. The LUT or register output independently drives these three outputs. Two LE outputs drive the column or row and direct link routing connections, while one LE drives the local interconnect resources. This allows the LUT to drive one output while the register drives another output. This feature, called register packing, improves device utilization because the device can use the register and the LUT for unrelated functions. The LAB-wide synchronous load control signal is not available when using register packing. For more information about the synchronous load control signal, refer to “LAB Control Signals” on page 2–6. \nThe register feedback mode allows the register output to feed back into the LUT of the same LE to ensure that the register is packed with its own fan-out LUT, providing another mechanism for improved fitting. The LE can also drive out registered and unregistered versions of the LUT output. \nIn addition to the three general routing outputs, LEs in an LAB have register chain outputs, which allows registers in the same LAB to cascade together. The register chain output allows the LUTs to be used for combinational functions and the registers to be used for an unrelated shift register implementation. These resources speed up connections between LABs while saving local interconnect resources.\n\n>每个LE的可编程寄存器可以配置为D、T、JK或SR触发器操作。每个寄存器都有数据、时钟、时钟使能和清除输入。使用全局时钟网络、通用I/O引脚或任何内部逻辑的信号都可以驱动寄存器的时钟和清除控制信号。通用I/O引脚或内部逻辑都可以驱动时钟使能。对于组合功能，查找表（LUT）输出会绕过寄存器，直接驱动LE的输出。每个LE有三个输出，分别驱动本地、行和列的路由资源。LUT或寄存器输出可以独立地驱动这三个输出。两个LE输出驱动列或行以及直接链接的路由连接，而一个LE驱动本地互连资源。这允许LUT驱动一个输出，而寄存器驱动另一个输出。这个特性被称为**寄存器打包**，它提高了器件的利用率，因为器件可以同时使用寄存器和LUT来执行不相关的功能。当使用寄存器打包时，整个LAB范围的同步加载控制信号不可用。有关同步加载控制信号的更多信息，请参阅第2-6页上的“LAB控制信号”。**寄存器反馈模式**允许寄存器输出反馈到同一LE的LUT中，以确保寄存器与其自身的扇出LUT一起打包，提供了另一种改善适配的机制。LE还可以驱动经过寄存器和未经过寄存器的LUT输出。\n除了三个通用的路由输出之外，同一个LAB中的LE还具有寄存器链输出，这使得同一个LAB中的寄存器可以级联在一起。寄存器链输出允许LUT用于组合功能，而寄存器用于不相关的移位寄存器实现。这些资源加速了LAB之间的连接，同时节省了本地互连资源。\n\n## LE Operating Modes（LE操作模式）\nCyclone IV LEs operate in the following modes:\n>Cyclone IV中的LE有以下操作模式：\n\n■ Normal mode\n■ Arithmetic mode\n>普通模式\n算术模式\n\nThe Quartus® II software automatically chooses the appropriate mode for common\nfunctions, such as counters, adders, subtractors, and arithmetic functions, in\nconjunction with parameterized functions such as the library of parameterized\nmodules (LPM) functions. You can also create special-purpose functions that specify\nwhich LE operating mode to use for optimal performance, if required\n>Quartus® II软件会自动选择适用于常见功能（如计数器、加法器、减法器和算术函数）的适当模式，与参数化功能（如参数化模块库（LPM）函数）结合使用。如果需要，您还可以创建特殊用途的功能，明确指定LE操作模式以实现最佳性能\n\n### Normal Mode(普通模式)\nNormal mode is suitable for general logic applications and combinational functions.\nIn normal mode, four data inputs from the LAB local interconnect are inputs to a\nfour-input LUT (Figure 2–2). The Quartus II Compiler automatically selects the\ncarry-in (cin) or the data3 signal as one of the inputs to the LUT. LEs in normal mode support packed registers and register feedback.\n>普通模式适用于一般逻辑应用和组合功能。在普通模式下，来自LAB本地互连的四个数据输入是四输入查找表（LUT）的输入（图2–2）。Quartus II编译器会自动选择进位输入（cin）或data3信号作为LUT的输入之一。普通模式下的LE支持寄存器打包和寄存器反馈\n\n![img](FPGA基本单元/shows_LEs_in_normal_mode.png)\n\n### Arithmetic Mode(算术模式)\nArithmetic mode is ideal for implementing adders, counters, accumulators, and comparators. An LE in arithmetic mode implements a 2-bit full adder and basic carry\nchain (Figure 2–3). LEs in arithmetic mode can drive out registered and unregistered versions of the LUT output. Register feedback and register packing are supported when LEs are used in arithmetic mode.\n>算术模式非常适合实现加法器、计数器、累加器和比较器。在算术模式下，LE实现一个2位全加器和基本的进位链（图2–3）。在算术模式下的LE可以输出经过寄存器和未经寄存器的LUT输出版本。当LE在算术模式下使用时，支持寄存器反馈和寄存器打包。\n\n![img](FPGA基本单元/LEs_in_arithmetic_mode.png)\n\nThe Quartus II Compiler automatically creates carry chain logic during design\nprocessing. You can also manually create the carry chain logic during design entry.\nParameterized functions, such as LPM functions, automatically take advantage of\ncarry chains for the appropriate functions.\n>Quartus II编译器在设计处理过程中会自动创建进位链逻辑。您也可以在设计输入期间手动创建进位链逻辑。参数化函数，如LPM函数，会自动利用适当的功能的进位链。\n\nThe Quartus II Compiler creates carry chains longer than 16 LEs by automatically linking LABs in the same column. For enhanced fitting, a long carry chain runsvertically, which allows fast horizontal connections to M9K memory blocks orembedded multipliers through direct link interconnects. For example, if a design has a long carry chain in an LAB column next to a column of M9K memory blocks, any LE output can feed an adjacent M9K memory block through the direct link interconnect. If the carry chains run horizontally, any LAB which is not next to the column of M9K memory blocks uses other row or column interconnects to drive a M9K memory block. A carry chain continues as far as a full column.\n>Quartus II编译器通过自动连接同一列中的LAB来创建长度超过16个LE的进位链。为了增强适配性，一个长的进位链垂直运行，允许通过直接链接互连快速水平连接到M9K存储器块或嵌入式乘法器。例如，如果设计在与M9K存储器块相邻的LAB列中有一个长的进位链，任何LE输出都可以通过直接链接互连馈送到相邻的M9K存储器块。如果进位链水平运行，不与M9K存储器块列相邻的任何LAB都会使用其他行或列互连来驱动M9K存储器块。进位链会一直延伸到整个列。\n\n## Logic Array Blocks(逻辑阵列块)\nLogic array blocks (LABs) contain groups of LEs.\n>逻辑阵列块（LABs）包含LE的组群\n### Topology(拓扑结构)\nEach LAB consists of the following features:\n■ 16 LEs\n■ LAB control signals\n■ LE carry chains\n■ Register chains\n■ Local interconnect\nThe local interconnect transfers signals between LEs in the same LAB. Register chain connections transfer the output of one LE register to the adjacent LE register in an LAB. The Quartus II Compiler places associated logic in an LAB or adjacent LABs, allowing the use of local and register chain connections for performance and area efficiency.\n>每个LAB包括以下特性：\n--16个LE\n--LAB控制信号\n--LE进位链\n--寄存器链\n--本地互连\n本地互连在同一LAB中的LE之间传递信号。寄存器链连接将一个LE寄存器的输出传递到相邻LAB中的另一个LE寄存器。Quartus II编译器将相关逻辑放置在一个LAB或相邻的LAB中，从而允许使用本地和寄存器链连接以提高性能和节省面积。\n![img](FPGA基本单元/LAB_structure_for_Cyclone_IV_devices.png)\n\n### LAB Interconnects(LAB互连)\nThe LAB local interconnect is driven by column and row interconnects and LE\noutputs in the same LAB. Neighboring LABs, phase-locked loops (PLLs), M9K RAM\nblocks, and embedded multipliers from the left and right can also drive the local\ninterconnect of a LAB through the direct link connection. The direct link connection feature minimizes the use of row and column interconnects, providing higher performance and flexibility. Each LE can drive up to 48 LEs through fast local and direct link interconnects.\n>LAB本地互连由同一LAB中的列和行互连以及LE输出驱动。相邻的LAB、锁相环（PLL）、M9K RAM块和来自左侧和右侧的嵌入式乘法器也可以通过直接链接连接驱动LAB的本地互连。直接链接连接功能最小化了行和列互连的使用，提供更高的性能和灵活性。每个LE可以通过快速的本地和直接链接互连驱动最多48个LE。\n\n![img](FPGA基本单元/direct_link_connection.png)\n### LAB Control Signals(LAB控制信号)\nEach LAB contains dedicated logic for driving control signals to its LEs. The control signals include:\n>每个LAB都包含专用逻辑，用于向其LE驱动控制信号。这些控制信号包括：\n\n■ Two clocks\n■ Two clock enables\n■ Two asynchronous clears\n■ One synchronous clear\n■ One synchronous load\n>两个时钟\n两个时钟使能\n两个异步清除\n一个同步清除\n一个同步加载\n\nYou can use up to eight control signals at a time. Register packing and synchronous\nload cannot be used simultaneously.\n>您可以同时使用最多八个控制信号。寄存器打包和同步加载不能同时使用。\n\nEach LAB can have up to four non-global control signals. You can use additional LAB\ncontrol signals as long as they are global signals.\n>每个LAB最多可以有四个非全局控制信号。只要它们是全局信号，您可以使用额外的LAB控制信号。\n\nSynchronous clear and load signals are useful for implementing counters and other\nfunctions. The synchronous clear and synchronous load signals are LAB-wide signals\nthat affect all registers in the LAB.\n>同步清除和同步加载信号对于实现计数器和其他功能非常有用。同步清除和同步加载信号是LAB范围的信号，影响LAB中的所有寄存器。\n\nEach LAB can use two clocks and two clock enable signals. The clock and clock enable signals of each LAB are linked. For example, any LE in a particular LAB using the labclk1 signal also uses the labclkena1. If the LAB uses both the rising and falling edges of a clock, it also uses both LAB-wide clock signals. Deasserting the clock enable signal turns off the LAB-wide clock.\n>每个LAB可以使用两个时钟和两个时钟使能信号。每个LAB的时钟和时钟使能信号是关联的。例如，使用labclk1信号的特定LAB中的任何LE也使用labclkena1。如果LAB同时使用上升沿和下降沿的时钟，它还会使用两个LAB范围的时钟信号。取消时钟使能信号将关闭LAB范围的时钟。\n\nThe LAB row clocks [5..0] and LAB local interconnect generate the LAB-wide\ncontrol signals. The MultiTrack interconnect inherent low skew allows clock and\ncontrol signal distribution in addition to data distribution.\n>LAB行时钟[5..0]和LAB本地互连生成LAB范围的控制信号。MultiTrack互连固有的低斜率允许时钟和控制信号的分发，除了数据分发。\n\n![img](FPGA基本单元/LAB_control_signal_generation_circuit.png)\nLAB-wide signals control the logic for the clear signal of the register. The LE directly supports an asynchronous clear function. Each LAB supports up to two asynchronous clear signals (labclr1 and labclr2).\n>LAB范围的信号控制寄存器的清除信号逻辑。LE直接支持异步清除功能。每个LAB支持最多两个异步清除信号（labclr1和labclr2）。\n\nA LAB-wide asynchronous load signal to control the logic for the preset signal of the register is not available. The register preset is achieved with a NOT gate push-back technique. Cyclone IV devices only support either a preset or asynchronous clear signal.\n>LAB范围的异步加载信号，用于控制寄存器的预设信号逻辑，是不可用的。寄存器的预设是通过NOT门推迟技术实现的。Cyclone IV器件仅支持预设或异步清除信号的一种。\n\nIn addition to the clear port, Cyclone IV devices provide a chip-wide reset pin\n(DEV_CLRn) that resets all registers in the device. An option set before compilation in the Quartus II software controls this pin. This chip-wide reset overrides all other control signals.\n>除了清除端口，Cyclone IV器件提供一个芯片范围的复位引脚（DEV_CLRn），用于复位设备中的所有寄存器。在Quartus II软件中编译之前设置的选项控制此引脚。这个芯片范围的复位会覆盖所有其他控制信号。\n\n","source":"_posts/2024/01/FPGA基本单元.md","raw":"---\ntitle: FPGA基本单元\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2024-01-25 14:44:59\npassword:\nsummary:\ntags:\n- FPGA\ncategories:\n- FPGA\nkeywords:\ndescription:\n---\n\n原文地址 [Logic Elements and Logic Array Blocks in Cyclone IV Devices](https://cdrdv2-public.intel.com/653677/cyiv-51002.pdf)\n\n# Logic Elements and Logic Array Blocks in Cyclone IV Devices （LCyclone IV器件中的逻辑元件和逻辑阵列块）\nThis chapter contains feature definitions for logic elements (LEs) and logic array blocks (LABs). Details are provided on how LEs work, how LABs contain groups of LEs, and how LABs interface with the other blocks in Cyclone® IV devices.\n>这一章包含了Cyclone® IV器件中逻辑元件（LEs）和逻辑阵列块（LABs）的特性定义。详细介绍了LEs的工作原理、LABs如何包含LEs的组群，以及LABs如何与Cyclone® IV器件中的其他模块进行接口。\n\n## Logic Elements (逻辑元件)\nLogic elements (LEs) are the smallest units of logic in the Cyclone IV device\narchitecture. LEs are compact and provide advanced features with efficient logic\nusage. Each LE has the following features:\n>逻辑元件（LEs）是Cyclone IV器件架构中最小的逻辑单元。LEs紧凑而且提供高效的逻辑使用，具有先进的功能。每个LE具有以下特性：\n\n■ A four-input look-up table (LUT), which can implement any function of four\nvariables\n■ A programmable register\n■ A carry chain connection\n■ A register chain connection\n■ The ability to drive the following interconnects:\n■ ■ Local\n■ ■ Row\n■ ■ Column\n■ ■ Register chain\n■ ■ Direct link\n■ Register packing support\n■ Register feedback support\n\n>- 一个四输入查找表（LUT），可以实现四个变量的任何函数\n>- 一个可编程寄存器\n>- 一个进位链连接\n>- 一个寄存器链连接\n>- 能够驱动以下互连方式：\n>  -- 本地\n>  -- 行\n>  -- 列\n>  -- 寄存器链\n>  -- 直接链接\n>  - 寄存器打包支持\n>  - 寄存器反馈支持\n\n![img](FPGA基本单元/Cyclone_IV_dEVICES_LEs.png)\n\n### LE Features(LE特性)\nYou can configure the programmable register of each LE for D, T, JK, or SR flipflop\noperation. Each register has data, clock, clock enable, and clear inputs. Signals that use the global clock network, general-purpose I/O pins, or any internal logic can drive the clock and clear control signals of the register. Either general-purpose I/O pins or the internal logic can drive the clock enable. For combinational functions, the LUT output bypasses the register and drives directly to the LE outputs. \nEach LE has three outputs that drive the local, row, and column routing resources. The LUT or register output independently drives these three outputs. Two LE outputs drive the column or row and direct link routing connections, while one LE drives the local interconnect resources. This allows the LUT to drive one output while the register drives another output. This feature, called register packing, improves device utilization because the device can use the register and the LUT for unrelated functions. The LAB-wide synchronous load control signal is not available when using register packing. For more information about the synchronous load control signal, refer to “LAB Control Signals” on page 2–6. \nThe register feedback mode allows the register output to feed back into the LUT of the same LE to ensure that the register is packed with its own fan-out LUT, providing another mechanism for improved fitting. The LE can also drive out registered and unregistered versions of the LUT output. \nIn addition to the three general routing outputs, LEs in an LAB have register chain outputs, which allows registers in the same LAB to cascade together. The register chain output allows the LUTs to be used for combinational functions and the registers to be used for an unrelated shift register implementation. These resources speed up connections between LABs while saving local interconnect resources.\n\n>每个LE的可编程寄存器可以配置为D、T、JK或SR触发器操作。每个寄存器都有数据、时钟、时钟使能和清除输入。使用全局时钟网络、通用I/O引脚或任何内部逻辑的信号都可以驱动寄存器的时钟和清除控制信号。通用I/O引脚或内部逻辑都可以驱动时钟使能。对于组合功能，查找表（LUT）输出会绕过寄存器，直接驱动LE的输出。每个LE有三个输出，分别驱动本地、行和列的路由资源。LUT或寄存器输出可以独立地驱动这三个输出。两个LE输出驱动列或行以及直接链接的路由连接，而一个LE驱动本地互连资源。这允许LUT驱动一个输出，而寄存器驱动另一个输出。这个特性被称为**寄存器打包**，它提高了器件的利用率，因为器件可以同时使用寄存器和LUT来执行不相关的功能。当使用寄存器打包时，整个LAB范围的同步加载控制信号不可用。有关同步加载控制信号的更多信息，请参阅第2-6页上的“LAB控制信号”。**寄存器反馈模式**允许寄存器输出反馈到同一LE的LUT中，以确保寄存器与其自身的扇出LUT一起打包，提供了另一种改善适配的机制。LE还可以驱动经过寄存器和未经过寄存器的LUT输出。\n除了三个通用的路由输出之外，同一个LAB中的LE还具有寄存器链输出，这使得同一个LAB中的寄存器可以级联在一起。寄存器链输出允许LUT用于组合功能，而寄存器用于不相关的移位寄存器实现。这些资源加速了LAB之间的连接，同时节省了本地互连资源。\n\n## LE Operating Modes（LE操作模式）\nCyclone IV LEs operate in the following modes:\n>Cyclone IV中的LE有以下操作模式：\n\n■ Normal mode\n■ Arithmetic mode\n>普通模式\n算术模式\n\nThe Quartus® II software automatically chooses the appropriate mode for common\nfunctions, such as counters, adders, subtractors, and arithmetic functions, in\nconjunction with parameterized functions such as the library of parameterized\nmodules (LPM) functions. You can also create special-purpose functions that specify\nwhich LE operating mode to use for optimal performance, if required\n>Quartus® II软件会自动选择适用于常见功能（如计数器、加法器、减法器和算术函数）的适当模式，与参数化功能（如参数化模块库（LPM）函数）结合使用。如果需要，您还可以创建特殊用途的功能，明确指定LE操作模式以实现最佳性能\n\n### Normal Mode(普通模式)\nNormal mode is suitable for general logic applications and combinational functions.\nIn normal mode, four data inputs from the LAB local interconnect are inputs to a\nfour-input LUT (Figure 2–2). The Quartus II Compiler automatically selects the\ncarry-in (cin) or the data3 signal as one of the inputs to the LUT. LEs in normal mode support packed registers and register feedback.\n>普通模式适用于一般逻辑应用和组合功能。在普通模式下，来自LAB本地互连的四个数据输入是四输入查找表（LUT）的输入（图2–2）。Quartus II编译器会自动选择进位输入（cin）或data3信号作为LUT的输入之一。普通模式下的LE支持寄存器打包和寄存器反馈\n\n![img](FPGA基本单元/shows_LEs_in_normal_mode.png)\n\n### Arithmetic Mode(算术模式)\nArithmetic mode is ideal for implementing adders, counters, accumulators, and comparators. An LE in arithmetic mode implements a 2-bit full adder and basic carry\nchain (Figure 2–3). LEs in arithmetic mode can drive out registered and unregistered versions of the LUT output. Register feedback and register packing are supported when LEs are used in arithmetic mode.\n>算术模式非常适合实现加法器、计数器、累加器和比较器。在算术模式下，LE实现一个2位全加器和基本的进位链（图2–3）。在算术模式下的LE可以输出经过寄存器和未经寄存器的LUT输出版本。当LE在算术模式下使用时，支持寄存器反馈和寄存器打包。\n\n![img](FPGA基本单元/LEs_in_arithmetic_mode.png)\n\nThe Quartus II Compiler automatically creates carry chain logic during design\nprocessing. You can also manually create the carry chain logic during design entry.\nParameterized functions, such as LPM functions, automatically take advantage of\ncarry chains for the appropriate functions.\n>Quartus II编译器在设计处理过程中会自动创建进位链逻辑。您也可以在设计输入期间手动创建进位链逻辑。参数化函数，如LPM函数，会自动利用适当的功能的进位链。\n\nThe Quartus II Compiler creates carry chains longer than 16 LEs by automatically linking LABs in the same column. For enhanced fitting, a long carry chain runsvertically, which allows fast horizontal connections to M9K memory blocks orembedded multipliers through direct link interconnects. For example, if a design has a long carry chain in an LAB column next to a column of M9K memory blocks, any LE output can feed an adjacent M9K memory block through the direct link interconnect. If the carry chains run horizontally, any LAB which is not next to the column of M9K memory blocks uses other row or column interconnects to drive a M9K memory block. A carry chain continues as far as a full column.\n>Quartus II编译器通过自动连接同一列中的LAB来创建长度超过16个LE的进位链。为了增强适配性，一个长的进位链垂直运行，允许通过直接链接互连快速水平连接到M9K存储器块或嵌入式乘法器。例如，如果设计在与M9K存储器块相邻的LAB列中有一个长的进位链，任何LE输出都可以通过直接链接互连馈送到相邻的M9K存储器块。如果进位链水平运行，不与M9K存储器块列相邻的任何LAB都会使用其他行或列互连来驱动M9K存储器块。进位链会一直延伸到整个列。\n\n## Logic Array Blocks(逻辑阵列块)\nLogic array blocks (LABs) contain groups of LEs.\n>逻辑阵列块（LABs）包含LE的组群\n### Topology(拓扑结构)\nEach LAB consists of the following features:\n■ 16 LEs\n■ LAB control signals\n■ LE carry chains\n■ Register chains\n■ Local interconnect\nThe local interconnect transfers signals between LEs in the same LAB. Register chain connections transfer the output of one LE register to the adjacent LE register in an LAB. The Quartus II Compiler places associated logic in an LAB or adjacent LABs, allowing the use of local and register chain connections for performance and area efficiency.\n>每个LAB包括以下特性：\n--16个LE\n--LAB控制信号\n--LE进位链\n--寄存器链\n--本地互连\n本地互连在同一LAB中的LE之间传递信号。寄存器链连接将一个LE寄存器的输出传递到相邻LAB中的另一个LE寄存器。Quartus II编译器将相关逻辑放置在一个LAB或相邻的LAB中，从而允许使用本地和寄存器链连接以提高性能和节省面积。\n![img](FPGA基本单元/LAB_structure_for_Cyclone_IV_devices.png)\n\n### LAB Interconnects(LAB互连)\nThe LAB local interconnect is driven by column and row interconnects and LE\noutputs in the same LAB. Neighboring LABs, phase-locked loops (PLLs), M9K RAM\nblocks, and embedded multipliers from the left and right can also drive the local\ninterconnect of a LAB through the direct link connection. The direct link connection feature minimizes the use of row and column interconnects, providing higher performance and flexibility. Each LE can drive up to 48 LEs through fast local and direct link interconnects.\n>LAB本地互连由同一LAB中的列和行互连以及LE输出驱动。相邻的LAB、锁相环（PLL）、M9K RAM块和来自左侧和右侧的嵌入式乘法器也可以通过直接链接连接驱动LAB的本地互连。直接链接连接功能最小化了行和列互连的使用，提供更高的性能和灵活性。每个LE可以通过快速的本地和直接链接互连驱动最多48个LE。\n\n![img](FPGA基本单元/direct_link_connection.png)\n### LAB Control Signals(LAB控制信号)\nEach LAB contains dedicated logic for driving control signals to its LEs. The control signals include:\n>每个LAB都包含专用逻辑，用于向其LE驱动控制信号。这些控制信号包括：\n\n■ Two clocks\n■ Two clock enables\n■ Two asynchronous clears\n■ One synchronous clear\n■ One synchronous load\n>两个时钟\n两个时钟使能\n两个异步清除\n一个同步清除\n一个同步加载\n\nYou can use up to eight control signals at a time. Register packing and synchronous\nload cannot be used simultaneously.\n>您可以同时使用最多八个控制信号。寄存器打包和同步加载不能同时使用。\n\nEach LAB can have up to four non-global control signals. You can use additional LAB\ncontrol signals as long as they are global signals.\n>每个LAB最多可以有四个非全局控制信号。只要它们是全局信号，您可以使用额外的LAB控制信号。\n\nSynchronous clear and load signals are useful for implementing counters and other\nfunctions. The synchronous clear and synchronous load signals are LAB-wide signals\nthat affect all registers in the LAB.\n>同步清除和同步加载信号对于实现计数器和其他功能非常有用。同步清除和同步加载信号是LAB范围的信号，影响LAB中的所有寄存器。\n\nEach LAB can use two clocks and two clock enable signals. The clock and clock enable signals of each LAB are linked. For example, any LE in a particular LAB using the labclk1 signal also uses the labclkena1. If the LAB uses both the rising and falling edges of a clock, it also uses both LAB-wide clock signals. Deasserting the clock enable signal turns off the LAB-wide clock.\n>每个LAB可以使用两个时钟和两个时钟使能信号。每个LAB的时钟和时钟使能信号是关联的。例如，使用labclk1信号的特定LAB中的任何LE也使用labclkena1。如果LAB同时使用上升沿和下降沿的时钟，它还会使用两个LAB范围的时钟信号。取消时钟使能信号将关闭LAB范围的时钟。\n\nThe LAB row clocks [5..0] and LAB local interconnect generate the LAB-wide\ncontrol signals. The MultiTrack interconnect inherent low skew allows clock and\ncontrol signal distribution in addition to data distribution.\n>LAB行时钟[5..0]和LAB本地互连生成LAB范围的控制信号。MultiTrack互连固有的低斜率允许时钟和控制信号的分发，除了数据分发。\n\n![img](FPGA基本单元/LAB_control_signal_generation_circuit.png)\nLAB-wide signals control the logic for the clear signal of the register. The LE directly supports an asynchronous clear function. Each LAB supports up to two asynchronous clear signals (labclr1 and labclr2).\n>LAB范围的信号控制寄存器的清除信号逻辑。LE直接支持异步清除功能。每个LAB支持最多两个异步清除信号（labclr1和labclr2）。\n\nA LAB-wide asynchronous load signal to control the logic for the preset signal of the register is not available. The register preset is achieved with a NOT gate push-back technique. Cyclone IV devices only support either a preset or asynchronous clear signal.\n>LAB范围的异步加载信号，用于控制寄存器的预设信号逻辑，是不可用的。寄存器的预设是通过NOT门推迟技术实现的。Cyclone IV器件仅支持预设或异步清除信号的一种。\n\nIn addition to the clear port, Cyclone IV devices provide a chip-wide reset pin\n(DEV_CLRn) that resets all registers in the device. An option set before compilation in the Quartus II software controls this pin. This chip-wide reset overrides all other control signals.\n>除了清除端口，Cyclone IV器件提供一个芯片范围的复位引脚（DEV_CLRn），用于复位设备中的所有寄存器。在Quartus II软件中编译之前设置的选项控制此引脚。这个芯片范围的复位会覆盖所有其他控制信号。\n\n","slug":"FPGA基本单元","published":1,"updated":"2024-01-26T02:42:32.548Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clru1g22h003ts4fu1adr4utt","content":"<p>原文地址 <a href=\"https://cdrdv2-public.intel.com/653677/cyiv-51002.pdf\" target=\"_blank\" rel=\"noopener\">Logic Elements and Logic Array Blocks in Cyclone IV Devices</a></p>\n<h1 id=\"Logic-Elements-and-Logic-Array-Blocks-in-Cyclone-IV-Devices-（LCyclone-IV器件中的逻辑元件和逻辑阵列块）\"><a href=\"#Logic-Elements-and-Logic-Array-Blocks-in-Cyclone-IV-Devices-（LCyclone-IV器件中的逻辑元件和逻辑阵列块）\" class=\"headerlink\" title=\"Logic Elements and Logic Array Blocks in Cyclone IV Devices （LCyclone IV器件中的逻辑元件和逻辑阵列块）\"></a>Logic Elements and Logic Array Blocks in Cyclone IV Devices （LCyclone IV器件中的逻辑元件和逻辑阵列块）</h1><p>This chapter contains feature definitions for logic elements (LEs) and logic array blocks (LABs). Details are provided on how LEs work, how LABs contain groups of LEs, and how LABs interface with the other blocks in Cyclone® IV devices.</p>\n<blockquote>\n<p>这一章包含了Cyclone® IV器件中逻辑元件（LEs）和逻辑阵列块（LABs）的特性定义。详细介绍了LEs的工作原理、LABs如何包含LEs的组群，以及LABs如何与Cyclone® IV器件中的其他模块进行接口。</p>\n</blockquote>\n<h2 id=\"Logic-Elements-逻辑元件\"><a href=\"#Logic-Elements-逻辑元件\" class=\"headerlink\" title=\"Logic Elements (逻辑元件)\"></a>Logic Elements (逻辑元件)</h2><p>Logic elements (LEs) are the smallest units of logic in the Cyclone IV device<br>architecture. LEs are compact and provide advanced features with efficient logic<br>usage. Each LE has the following features:</p>\n<blockquote>\n<p>逻辑元件（LEs）是Cyclone IV器件架构中最小的逻辑单元。LEs紧凑而且提供高效的逻辑使用，具有先进的功能。每个LE具有以下特性：</p>\n</blockquote>\n<p>■ A four-input look-up table (LUT), which can implement any function of four<br>variables<br>■ A programmable register<br>■ A carry chain connection<br>■ A register chain connection<br>■ The ability to drive the following interconnects:<br>■ ■ Local<br>■ ■ Row<br>■ ■ Column<br>■ ■ Register chain<br>■ ■ Direct link<br>■ Register packing support<br>■ Register feedback support</p>\n<blockquote>\n<ul>\n<li>一个四输入查找表（LUT），可以实现四个变量的任何函数</li>\n<li>一个可编程寄存器</li>\n<li>一个进位链连接</li>\n<li>一个寄存器链连接</li>\n<li>能够驱动以下互连方式：<br>– 本地<br>– 行<br>– 列<br>– 寄存器链<br>– 直接链接<ul>\n<li>寄存器打包支持</li>\n<li>寄存器反馈支持</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p><img src=\"/2024/01/fpga-ji-ben-dan-yuan/Cyclone_IV_dEVICES_LEs.png\" alt=\"img\"></p>\n<h3 id=\"LE-Features-LE特性\"><a href=\"#LE-Features-LE特性\" class=\"headerlink\" title=\"LE Features(LE特性)\"></a>LE Features(LE特性)</h3><p>You can configure the programmable register of each LE for D, T, JK, or SR flipflop<br>operation. Each register has data, clock, clock enable, and clear inputs. Signals that use the global clock network, general-purpose I/O pins, or any internal logic can drive the clock and clear control signals of the register. Either general-purpose I/O pins or the internal logic can drive the clock enable. For combinational functions, the LUT output bypasses the register and drives directly to the LE outputs.<br>Each LE has three outputs that drive the local, row, and column routing resources. The LUT or register output independently drives these three outputs. Two LE outputs drive the column or row and direct link routing connections, while one LE drives the local interconnect resources. This allows the LUT to drive one output while the register drives another output. This feature, called register packing, improves device utilization because the device can use the register and the LUT for unrelated functions. The LAB-wide synchronous load control signal is not available when using register packing. For more information about the synchronous load control signal, refer to “LAB Control Signals” on page 2–6.<br>The register feedback mode allows the register output to feed back into the LUT of the same LE to ensure that the register is packed with its own fan-out LUT, providing another mechanism for improved fitting. The LE can also drive out registered and unregistered versions of the LUT output.<br>In addition to the three general routing outputs, LEs in an LAB have register chain outputs, which allows registers in the same LAB to cascade together. The register chain output allows the LUTs to be used for combinational functions and the registers to be used for an unrelated shift register implementation. These resources speed up connections between LABs while saving local interconnect resources.</p>\n<blockquote>\n<p>每个LE的可编程寄存器可以配置为D、T、JK或SR触发器操作。每个寄存器都有数据、时钟、时钟使能和清除输入。使用全局时钟网络、通用I/O引脚或任何内部逻辑的信号都可以驱动寄存器的时钟和清除控制信号。通用I/O引脚或内部逻辑都可以驱动时钟使能。对于组合功能，查找表（LUT）输出会绕过寄存器，直接驱动LE的输出。每个LE有三个输出，分别驱动本地、行和列的路由资源。LUT或寄存器输出可以独立地驱动这三个输出。两个LE输出驱动列或行以及直接链接的路由连接，而一个LE驱动本地互连资源。这允许LUT驱动一个输出，而寄存器驱动另一个输出。这个特性被称为<strong>寄存器打包</strong>，它提高了器件的利用率，因为器件可以同时使用寄存器和LUT来执行不相关的功能。当使用寄存器打包时，整个LAB范围的同步加载控制信号不可用。有关同步加载控制信号的更多信息，请参阅第2-6页上的“LAB控制信号”。<strong>寄存器反馈模式</strong>允许寄存器输出反馈到同一LE的LUT中，以确保寄存器与其自身的扇出LUT一起打包，提供了另一种改善适配的机制。LE还可以驱动经过寄存器和未经过寄存器的LUT输出。<br>除了三个通用的路由输出之外，同一个LAB中的LE还具有寄存器链输出，这使得同一个LAB中的寄存器可以级联在一起。寄存器链输出允许LUT用于组合功能，而寄存器用于不相关的移位寄存器实现。这些资源加速了LAB之间的连接，同时节省了本地互连资源。</p>\n</blockquote>\n<h2 id=\"LE-Operating-Modes（LE操作模式）\"><a href=\"#LE-Operating-Modes（LE操作模式）\" class=\"headerlink\" title=\"LE Operating Modes（LE操作模式）\"></a>LE Operating Modes（LE操作模式）</h2><p>Cyclone IV LEs operate in the following modes:</p>\n<blockquote>\n<p>Cyclone IV中的LE有以下操作模式：</p>\n</blockquote>\n<p>■ Normal mode<br>■ Arithmetic mode</p>\n<blockquote>\n<p>普通模式<br>算术模式</p>\n</blockquote>\n<p>The Quartus® II software automatically chooses the appropriate mode for common<br>functions, such as counters, adders, subtractors, and arithmetic functions, in<br>conjunction with parameterized functions such as the library of parameterized<br>modules (LPM) functions. You can also create special-purpose functions that specify<br>which LE operating mode to use for optimal performance, if required</p>\n<blockquote>\n<p>Quartus® II软件会自动选择适用于常见功能（如计数器、加法器、减法器和算术函数）的适当模式，与参数化功能（如参数化模块库（LPM）函数）结合使用。如果需要，您还可以创建特殊用途的功能，明确指定LE操作模式以实现最佳性能</p>\n</blockquote>\n<h3 id=\"Normal-Mode-普通模式\"><a href=\"#Normal-Mode-普通模式\" class=\"headerlink\" title=\"Normal Mode(普通模式)\"></a>Normal Mode(普通模式)</h3><p>Normal mode is suitable for general logic applications and combinational functions.<br>In normal mode, four data inputs from the LAB local interconnect are inputs to a<br>four-input LUT (Figure 2–2). The Quartus II Compiler automatically selects the<br>carry-in (cin) or the data3 signal as one of the inputs to the LUT. LEs in normal mode support packed registers and register feedback.</p>\n<blockquote>\n<p>普通模式适用于一般逻辑应用和组合功能。在普通模式下，来自LAB本地互连的四个数据输入是四输入查找表（LUT）的输入（图2–2）。Quartus II编译器会自动选择进位输入（cin）或data3信号作为LUT的输入之一。普通模式下的LE支持寄存器打包和寄存器反馈</p>\n</blockquote>\n<p><img src=\"/2024/01/fpga-ji-ben-dan-yuan/shows_LEs_in_normal_mode.png\" alt=\"img\"></p>\n<h3 id=\"Arithmetic-Mode-算术模式\"><a href=\"#Arithmetic-Mode-算术模式\" class=\"headerlink\" title=\"Arithmetic Mode(算术模式)\"></a>Arithmetic Mode(算术模式)</h3><p>Arithmetic mode is ideal for implementing adders, counters, accumulators, and comparators. An LE in arithmetic mode implements a 2-bit full adder and basic carry<br>chain (Figure 2–3). LEs in arithmetic mode can drive out registered and unregistered versions of the LUT output. Register feedback and register packing are supported when LEs are used in arithmetic mode.</p>\n<blockquote>\n<p>算术模式非常适合实现加法器、计数器、累加器和比较器。在算术模式下，LE实现一个2位全加器和基本的进位链（图2–3）。在算术模式下的LE可以输出经过寄存器和未经寄存器的LUT输出版本。当LE在算术模式下使用时，支持寄存器反馈和寄存器打包。</p>\n</blockquote>\n<p><img src=\"/2024/01/fpga-ji-ben-dan-yuan/LEs_in_arithmetic_mode.png\" alt=\"img\"></p>\n<p>The Quartus II Compiler automatically creates carry chain logic during design<br>processing. You can also manually create the carry chain logic during design entry.<br>Parameterized functions, such as LPM functions, automatically take advantage of<br>carry chains for the appropriate functions.</p>\n<blockquote>\n<p>Quartus II编译器在设计处理过程中会自动创建进位链逻辑。您也可以在设计输入期间手动创建进位链逻辑。参数化函数，如LPM函数，会自动利用适当的功能的进位链。</p>\n</blockquote>\n<p>The Quartus II Compiler creates carry chains longer than 16 LEs by automatically linking LABs in the same column. For enhanced fitting, a long carry chain runsvertically, which allows fast horizontal connections to M9K memory blocks orembedded multipliers through direct link interconnects. For example, if a design has a long carry chain in an LAB column next to a column of M9K memory blocks, any LE output can feed an adjacent M9K memory block through the direct link interconnect. If the carry chains run horizontally, any LAB which is not next to the column of M9K memory blocks uses other row or column interconnects to drive a M9K memory block. A carry chain continues as far as a full column.</p>\n<blockquote>\n<p>Quartus II编译器通过自动连接同一列中的LAB来创建长度超过16个LE的进位链。为了增强适配性，一个长的进位链垂直运行，允许通过直接链接互连快速水平连接到M9K存储器块或嵌入式乘法器。例如，如果设计在与M9K存储器块相邻的LAB列中有一个长的进位链，任何LE输出都可以通过直接链接互连馈送到相邻的M9K存储器块。如果进位链水平运行，不与M9K存储器块列相邻的任何LAB都会使用其他行或列互连来驱动M9K存储器块。进位链会一直延伸到整个列。</p>\n</blockquote>\n<h2 id=\"Logic-Array-Blocks-逻辑阵列块\"><a href=\"#Logic-Array-Blocks-逻辑阵列块\" class=\"headerlink\" title=\"Logic Array Blocks(逻辑阵列块)\"></a>Logic Array Blocks(逻辑阵列块)</h2><p>Logic array blocks (LABs) contain groups of LEs.</p>\n<blockquote>\n<p>逻辑阵列块（LABs）包含LE的组群</p>\n</blockquote>\n<h3 id=\"Topology-拓扑结构\"><a href=\"#Topology-拓扑结构\" class=\"headerlink\" title=\"Topology(拓扑结构)\"></a>Topology(拓扑结构)</h3><p>Each LAB consists of the following features:<br>■ 16 LEs<br>■ LAB control signals<br>■ LE carry chains<br>■ Register chains<br>■ Local interconnect<br>The local interconnect transfers signals between LEs in the same LAB. Register chain connections transfer the output of one LE register to the adjacent LE register in an LAB. The Quartus II Compiler places associated logic in an LAB or adjacent LABs, allowing the use of local and register chain connections for performance and area efficiency.</p>\n<blockquote>\n<p>每个LAB包括以下特性：<br>–16个LE<br>–LAB控制信号<br>–LE进位链<br>–寄存器链<br>–本地互连<br>本地互连在同一LAB中的LE之间传递信号。寄存器链连接将一个LE寄存器的输出传递到相邻LAB中的另一个LE寄存器。Quartus II编译器将相关逻辑放置在一个LAB或相邻的LAB中，从而允许使用本地和寄存器链连接以提高性能和节省面积。<br><img src=\"/2024/01/fpga-ji-ben-dan-yuan/LAB_structure_for_Cyclone_IV_devices.png\" alt=\"img\"></p>\n</blockquote>\n<h3 id=\"LAB-Interconnects-LAB互连\"><a href=\"#LAB-Interconnects-LAB互连\" class=\"headerlink\" title=\"LAB Interconnects(LAB互连)\"></a>LAB Interconnects(LAB互连)</h3><p>The LAB local interconnect is driven by column and row interconnects and LE<br>outputs in the same LAB. Neighboring LABs, phase-locked loops (PLLs), M9K RAM<br>blocks, and embedded multipliers from the left and right can also drive the local<br>interconnect of a LAB through the direct link connection. The direct link connection feature minimizes the use of row and column interconnects, providing higher performance and flexibility. Each LE can drive up to 48 LEs through fast local and direct link interconnects.</p>\n<blockquote>\n<p>LAB本地互连由同一LAB中的列和行互连以及LE输出驱动。相邻的LAB、锁相环（PLL）、M9K RAM块和来自左侧和右侧的嵌入式乘法器也可以通过直接链接连接驱动LAB的本地互连。直接链接连接功能最小化了行和列互连的使用，提供更高的性能和灵活性。每个LE可以通过快速的本地和直接链接互连驱动最多48个LE。</p>\n</blockquote>\n<p><img src=\"/2024/01/fpga-ji-ben-dan-yuan/direct_link_connection.png\" alt=\"img\"></p>\n<h3 id=\"LAB-Control-Signals-LAB控制信号\"><a href=\"#LAB-Control-Signals-LAB控制信号\" class=\"headerlink\" title=\"LAB Control Signals(LAB控制信号)\"></a>LAB Control Signals(LAB控制信号)</h3><p>Each LAB contains dedicated logic for driving control signals to its LEs. The control signals include:</p>\n<blockquote>\n<p>每个LAB都包含专用逻辑，用于向其LE驱动控制信号。这些控制信号包括：</p>\n</blockquote>\n<p>■ Two clocks<br>■ Two clock enables<br>■ Two asynchronous clears<br>■ One synchronous clear<br>■ One synchronous load</p>\n<blockquote>\n<p>两个时钟<br>两个时钟使能<br>两个异步清除<br>一个同步清除<br>一个同步加载</p>\n</blockquote>\n<p>You can use up to eight control signals at a time. Register packing and synchronous<br>load cannot be used simultaneously.</p>\n<blockquote>\n<p>您可以同时使用最多八个控制信号。寄存器打包和同步加载不能同时使用。</p>\n</blockquote>\n<p>Each LAB can have up to four non-global control signals. You can use additional LAB<br>control signals as long as they are global signals.</p>\n<blockquote>\n<p>每个LAB最多可以有四个非全局控制信号。只要它们是全局信号，您可以使用额外的LAB控制信号。</p>\n</blockquote>\n<p>Synchronous clear and load signals are useful for implementing counters and other<br>functions. The synchronous clear and synchronous load signals are LAB-wide signals<br>that affect all registers in the LAB.</p>\n<blockquote>\n<p>同步清除和同步加载信号对于实现计数器和其他功能非常有用。同步清除和同步加载信号是LAB范围的信号，影响LAB中的所有寄存器。</p>\n</blockquote>\n<p>Each LAB can use two clocks and two clock enable signals. The clock and clock enable signals of each LAB are linked. For example, any LE in a particular LAB using the labclk1 signal also uses the labclkena1. If the LAB uses both the rising and falling edges of a clock, it also uses both LAB-wide clock signals. Deasserting the clock enable signal turns off the LAB-wide clock.</p>\n<blockquote>\n<p>每个LAB可以使用两个时钟和两个时钟使能信号。每个LAB的时钟和时钟使能信号是关联的。例如，使用labclk1信号的特定LAB中的任何LE也使用labclkena1。如果LAB同时使用上升沿和下降沿的时钟，它还会使用两个LAB范围的时钟信号。取消时钟使能信号将关闭LAB范围的时钟。</p>\n</blockquote>\n<p>The LAB row clocks [5..0] and LAB local interconnect generate the LAB-wide<br>control signals. The MultiTrack interconnect inherent low skew allows clock and<br>control signal distribution in addition to data distribution.</p>\n<blockquote>\n<p>LAB行时钟[5..0]和LAB本地互连生成LAB范围的控制信号。MultiTrack互连固有的低斜率允许时钟和控制信号的分发，除了数据分发。</p>\n</blockquote>\n<p><img src=\"/2024/01/fpga-ji-ben-dan-yuan/LAB_control_signal_generation_circuit.png\" alt=\"img\"><br>LAB-wide signals control the logic for the clear signal of the register. The LE directly supports an asynchronous clear function. Each LAB supports up to two asynchronous clear signals (labclr1 and labclr2).</p>\n<blockquote>\n<p>LAB范围的信号控制寄存器的清除信号逻辑。LE直接支持异步清除功能。每个LAB支持最多两个异步清除信号（labclr1和labclr2）。</p>\n</blockquote>\n<p>A LAB-wide asynchronous load signal to control the logic for the preset signal of the register is not available. The register preset is achieved with a NOT gate push-back technique. Cyclone IV devices only support either a preset or asynchronous clear signal.</p>\n<blockquote>\n<p>LAB范围的异步加载信号，用于控制寄存器的预设信号逻辑，是不可用的。寄存器的预设是通过NOT门推迟技术实现的。Cyclone IV器件仅支持预设或异步清除信号的一种。</p>\n</blockquote>\n<p>In addition to the clear port, Cyclone IV devices provide a chip-wide reset pin<br>(DEV_CLRn) that resets all registers in the device. An option set before compilation in the Quartus II software controls this pin. This chip-wide reset overrides all other control signals.</p>\n<blockquote>\n<p>除了清除端口，Cyclone IV器件提供一个芯片范围的复位引脚（DEV_CLRn），用于复位设备中的所有寄存器。在Quartus II软件中编译之前设置的选项控制此引脚。这个芯片范围的复位会覆盖所有其他控制信号。</p>\n</blockquote>\n","site":{"data":{"musics":[{"name":"每天爱你多一些","artist":"张学友","url":"/medias/music/每天爱你多一些-张学友.mp3","cover":"/medias/music/avatars/每天爱你多一些.jpg"},{"name":"不见就散","artist":"周深","url":"/medias/music/不见就散-周深.mp3","cover":"/medias/music/avatars/不见就散-周深.jpg"},{"name":"平凡之路","artist":"朴树","url":"/medias/music/平凡之路-朴树.mp3","cover":"/medias/music/avatars/平凡之路-朴树.jpg"}]}},"excerpt":"","more":"<p>原文地址 <a href=\"https://cdrdv2-public.intel.com/653677/cyiv-51002.pdf\" target=\"_blank\" rel=\"noopener\">Logic Elements and Logic Array Blocks in Cyclone IV Devices</a></p>\n<h1 id=\"Logic-Elements-and-Logic-Array-Blocks-in-Cyclone-IV-Devices-（LCyclone-IV器件中的逻辑元件和逻辑阵列块）\"><a href=\"#Logic-Elements-and-Logic-Array-Blocks-in-Cyclone-IV-Devices-（LCyclone-IV器件中的逻辑元件和逻辑阵列块）\" class=\"headerlink\" title=\"Logic Elements and Logic Array Blocks in Cyclone IV Devices （LCyclone IV器件中的逻辑元件和逻辑阵列块）\"></a>Logic Elements and Logic Array Blocks in Cyclone IV Devices （LCyclone IV器件中的逻辑元件和逻辑阵列块）</h1><p>This chapter contains feature definitions for logic elements (LEs) and logic array blocks (LABs). Details are provided on how LEs work, how LABs contain groups of LEs, and how LABs interface with the other blocks in Cyclone® IV devices.</p>\n<blockquote>\n<p>这一章包含了Cyclone® IV器件中逻辑元件（LEs）和逻辑阵列块（LABs）的特性定义。详细介绍了LEs的工作原理、LABs如何包含LEs的组群，以及LABs如何与Cyclone® IV器件中的其他模块进行接口。</p>\n</blockquote>\n<h2 id=\"Logic-Elements-逻辑元件\"><a href=\"#Logic-Elements-逻辑元件\" class=\"headerlink\" title=\"Logic Elements (逻辑元件)\"></a>Logic Elements (逻辑元件)</h2><p>Logic elements (LEs) are the smallest units of logic in the Cyclone IV device<br>architecture. LEs are compact and provide advanced features with efficient logic<br>usage. Each LE has the following features:</p>\n<blockquote>\n<p>逻辑元件（LEs）是Cyclone IV器件架构中最小的逻辑单元。LEs紧凑而且提供高效的逻辑使用，具有先进的功能。每个LE具有以下特性：</p>\n</blockquote>\n<p>■ A four-input look-up table (LUT), which can implement any function of four<br>variables<br>■ A programmable register<br>■ A carry chain connection<br>■ A register chain connection<br>■ The ability to drive the following interconnects:<br>■ ■ Local<br>■ ■ Row<br>■ ■ Column<br>■ ■ Register chain<br>■ ■ Direct link<br>■ Register packing support<br>■ Register feedback support</p>\n<blockquote>\n<ul>\n<li>一个四输入查找表（LUT），可以实现四个变量的任何函数</li>\n<li>一个可编程寄存器</li>\n<li>一个进位链连接</li>\n<li>一个寄存器链连接</li>\n<li>能够驱动以下互连方式：<br>– 本地<br>– 行<br>– 列<br>– 寄存器链<br>– 直接链接<ul>\n<li>寄存器打包支持</li>\n<li>寄存器反馈支持</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p><img src=\"/2024/01/fpga-ji-ben-dan-yuan/Cyclone_IV_dEVICES_LEs.png\" alt=\"img\"></p>\n<h3 id=\"LE-Features-LE特性\"><a href=\"#LE-Features-LE特性\" class=\"headerlink\" title=\"LE Features(LE特性)\"></a>LE Features(LE特性)</h3><p>You can configure the programmable register of each LE for D, T, JK, or SR flipflop<br>operation. Each register has data, clock, clock enable, and clear inputs. Signals that use the global clock network, general-purpose I/O pins, or any internal logic can drive the clock and clear control signals of the register. Either general-purpose I/O pins or the internal logic can drive the clock enable. For combinational functions, the LUT output bypasses the register and drives directly to the LE outputs.<br>Each LE has three outputs that drive the local, row, and column routing resources. The LUT or register output independently drives these three outputs. Two LE outputs drive the column or row and direct link routing connections, while one LE drives the local interconnect resources. This allows the LUT to drive one output while the register drives another output. This feature, called register packing, improves device utilization because the device can use the register and the LUT for unrelated functions. The LAB-wide synchronous load control signal is not available when using register packing. For more information about the synchronous load control signal, refer to “LAB Control Signals” on page 2–6.<br>The register feedback mode allows the register output to feed back into the LUT of the same LE to ensure that the register is packed with its own fan-out LUT, providing another mechanism for improved fitting. The LE can also drive out registered and unregistered versions of the LUT output.<br>In addition to the three general routing outputs, LEs in an LAB have register chain outputs, which allows registers in the same LAB to cascade together. The register chain output allows the LUTs to be used for combinational functions and the registers to be used for an unrelated shift register implementation. These resources speed up connections between LABs while saving local interconnect resources.</p>\n<blockquote>\n<p>每个LE的可编程寄存器可以配置为D、T、JK或SR触发器操作。每个寄存器都有数据、时钟、时钟使能和清除输入。使用全局时钟网络、通用I/O引脚或任何内部逻辑的信号都可以驱动寄存器的时钟和清除控制信号。通用I/O引脚或内部逻辑都可以驱动时钟使能。对于组合功能，查找表（LUT）输出会绕过寄存器，直接驱动LE的输出。每个LE有三个输出，分别驱动本地、行和列的路由资源。LUT或寄存器输出可以独立地驱动这三个输出。两个LE输出驱动列或行以及直接链接的路由连接，而一个LE驱动本地互连资源。这允许LUT驱动一个输出，而寄存器驱动另一个输出。这个特性被称为<strong>寄存器打包</strong>，它提高了器件的利用率，因为器件可以同时使用寄存器和LUT来执行不相关的功能。当使用寄存器打包时，整个LAB范围的同步加载控制信号不可用。有关同步加载控制信号的更多信息，请参阅第2-6页上的“LAB控制信号”。<strong>寄存器反馈模式</strong>允许寄存器输出反馈到同一LE的LUT中，以确保寄存器与其自身的扇出LUT一起打包，提供了另一种改善适配的机制。LE还可以驱动经过寄存器和未经过寄存器的LUT输出。<br>除了三个通用的路由输出之外，同一个LAB中的LE还具有寄存器链输出，这使得同一个LAB中的寄存器可以级联在一起。寄存器链输出允许LUT用于组合功能，而寄存器用于不相关的移位寄存器实现。这些资源加速了LAB之间的连接，同时节省了本地互连资源。</p>\n</blockquote>\n<h2 id=\"LE-Operating-Modes（LE操作模式）\"><a href=\"#LE-Operating-Modes（LE操作模式）\" class=\"headerlink\" title=\"LE Operating Modes（LE操作模式）\"></a>LE Operating Modes（LE操作模式）</h2><p>Cyclone IV LEs operate in the following modes:</p>\n<blockquote>\n<p>Cyclone IV中的LE有以下操作模式：</p>\n</blockquote>\n<p>■ Normal mode<br>■ Arithmetic mode</p>\n<blockquote>\n<p>普通模式<br>算术模式</p>\n</blockquote>\n<p>The Quartus® II software automatically chooses the appropriate mode for common<br>functions, such as counters, adders, subtractors, and arithmetic functions, in<br>conjunction with parameterized functions such as the library of parameterized<br>modules (LPM) functions. You can also create special-purpose functions that specify<br>which LE operating mode to use for optimal performance, if required</p>\n<blockquote>\n<p>Quartus® II软件会自动选择适用于常见功能（如计数器、加法器、减法器和算术函数）的适当模式，与参数化功能（如参数化模块库（LPM）函数）结合使用。如果需要，您还可以创建特殊用途的功能，明确指定LE操作模式以实现最佳性能</p>\n</blockquote>\n<h3 id=\"Normal-Mode-普通模式\"><a href=\"#Normal-Mode-普通模式\" class=\"headerlink\" title=\"Normal Mode(普通模式)\"></a>Normal Mode(普通模式)</h3><p>Normal mode is suitable for general logic applications and combinational functions.<br>In normal mode, four data inputs from the LAB local interconnect are inputs to a<br>four-input LUT (Figure 2–2). The Quartus II Compiler automatically selects the<br>carry-in (cin) or the data3 signal as one of the inputs to the LUT. LEs in normal mode support packed registers and register feedback.</p>\n<blockquote>\n<p>普通模式适用于一般逻辑应用和组合功能。在普通模式下，来自LAB本地互连的四个数据输入是四输入查找表（LUT）的输入（图2–2）。Quartus II编译器会自动选择进位输入（cin）或data3信号作为LUT的输入之一。普通模式下的LE支持寄存器打包和寄存器反馈</p>\n</blockquote>\n<p><img src=\"/2024/01/fpga-ji-ben-dan-yuan/shows_LEs_in_normal_mode.png\" alt=\"img\"></p>\n<h3 id=\"Arithmetic-Mode-算术模式\"><a href=\"#Arithmetic-Mode-算术模式\" class=\"headerlink\" title=\"Arithmetic Mode(算术模式)\"></a>Arithmetic Mode(算术模式)</h3><p>Arithmetic mode is ideal for implementing adders, counters, accumulators, and comparators. An LE in arithmetic mode implements a 2-bit full adder and basic carry<br>chain (Figure 2–3). LEs in arithmetic mode can drive out registered and unregistered versions of the LUT output. Register feedback and register packing are supported when LEs are used in arithmetic mode.</p>\n<blockquote>\n<p>算术模式非常适合实现加法器、计数器、累加器和比较器。在算术模式下，LE实现一个2位全加器和基本的进位链（图2–3）。在算术模式下的LE可以输出经过寄存器和未经寄存器的LUT输出版本。当LE在算术模式下使用时，支持寄存器反馈和寄存器打包。</p>\n</blockquote>\n<p><img src=\"/2024/01/fpga-ji-ben-dan-yuan/LEs_in_arithmetic_mode.png\" alt=\"img\"></p>\n<p>The Quartus II Compiler automatically creates carry chain logic during design<br>processing. You can also manually create the carry chain logic during design entry.<br>Parameterized functions, such as LPM functions, automatically take advantage of<br>carry chains for the appropriate functions.</p>\n<blockquote>\n<p>Quartus II编译器在设计处理过程中会自动创建进位链逻辑。您也可以在设计输入期间手动创建进位链逻辑。参数化函数，如LPM函数，会自动利用适当的功能的进位链。</p>\n</blockquote>\n<p>The Quartus II Compiler creates carry chains longer than 16 LEs by automatically linking LABs in the same column. For enhanced fitting, a long carry chain runsvertically, which allows fast horizontal connections to M9K memory blocks orembedded multipliers through direct link interconnects. For example, if a design has a long carry chain in an LAB column next to a column of M9K memory blocks, any LE output can feed an adjacent M9K memory block through the direct link interconnect. If the carry chains run horizontally, any LAB which is not next to the column of M9K memory blocks uses other row or column interconnects to drive a M9K memory block. A carry chain continues as far as a full column.</p>\n<blockquote>\n<p>Quartus II编译器通过自动连接同一列中的LAB来创建长度超过16个LE的进位链。为了增强适配性，一个长的进位链垂直运行，允许通过直接链接互连快速水平连接到M9K存储器块或嵌入式乘法器。例如，如果设计在与M9K存储器块相邻的LAB列中有一个长的进位链，任何LE输出都可以通过直接链接互连馈送到相邻的M9K存储器块。如果进位链水平运行，不与M9K存储器块列相邻的任何LAB都会使用其他行或列互连来驱动M9K存储器块。进位链会一直延伸到整个列。</p>\n</blockquote>\n<h2 id=\"Logic-Array-Blocks-逻辑阵列块\"><a href=\"#Logic-Array-Blocks-逻辑阵列块\" class=\"headerlink\" title=\"Logic Array Blocks(逻辑阵列块)\"></a>Logic Array Blocks(逻辑阵列块)</h2><p>Logic array blocks (LABs) contain groups of LEs.</p>\n<blockquote>\n<p>逻辑阵列块（LABs）包含LE的组群</p>\n</blockquote>\n<h3 id=\"Topology-拓扑结构\"><a href=\"#Topology-拓扑结构\" class=\"headerlink\" title=\"Topology(拓扑结构)\"></a>Topology(拓扑结构)</h3><p>Each LAB consists of the following features:<br>■ 16 LEs<br>■ LAB control signals<br>■ LE carry chains<br>■ Register chains<br>■ Local interconnect<br>The local interconnect transfers signals between LEs in the same LAB. Register chain connections transfer the output of one LE register to the adjacent LE register in an LAB. The Quartus II Compiler places associated logic in an LAB or adjacent LABs, allowing the use of local and register chain connections for performance and area efficiency.</p>\n<blockquote>\n<p>每个LAB包括以下特性：<br>–16个LE<br>–LAB控制信号<br>–LE进位链<br>–寄存器链<br>–本地互连<br>本地互连在同一LAB中的LE之间传递信号。寄存器链连接将一个LE寄存器的输出传递到相邻LAB中的另一个LE寄存器。Quartus II编译器将相关逻辑放置在一个LAB或相邻的LAB中，从而允许使用本地和寄存器链连接以提高性能和节省面积。<br><img src=\"/2024/01/fpga-ji-ben-dan-yuan/LAB_structure_for_Cyclone_IV_devices.png\" alt=\"img\"></p>\n</blockquote>\n<h3 id=\"LAB-Interconnects-LAB互连\"><a href=\"#LAB-Interconnects-LAB互连\" class=\"headerlink\" title=\"LAB Interconnects(LAB互连)\"></a>LAB Interconnects(LAB互连)</h3><p>The LAB local interconnect is driven by column and row interconnects and LE<br>outputs in the same LAB. Neighboring LABs, phase-locked loops (PLLs), M9K RAM<br>blocks, and embedded multipliers from the left and right can also drive the local<br>interconnect of a LAB through the direct link connection. The direct link connection feature minimizes the use of row and column interconnects, providing higher performance and flexibility. Each LE can drive up to 48 LEs through fast local and direct link interconnects.</p>\n<blockquote>\n<p>LAB本地互连由同一LAB中的列和行互连以及LE输出驱动。相邻的LAB、锁相环（PLL）、M9K RAM块和来自左侧和右侧的嵌入式乘法器也可以通过直接链接连接驱动LAB的本地互连。直接链接连接功能最小化了行和列互连的使用，提供更高的性能和灵活性。每个LE可以通过快速的本地和直接链接互连驱动最多48个LE。</p>\n</blockquote>\n<p><img src=\"/2024/01/fpga-ji-ben-dan-yuan/direct_link_connection.png\" alt=\"img\"></p>\n<h3 id=\"LAB-Control-Signals-LAB控制信号\"><a href=\"#LAB-Control-Signals-LAB控制信号\" class=\"headerlink\" title=\"LAB Control Signals(LAB控制信号)\"></a>LAB Control Signals(LAB控制信号)</h3><p>Each LAB contains dedicated logic for driving control signals to its LEs. The control signals include:</p>\n<blockquote>\n<p>每个LAB都包含专用逻辑，用于向其LE驱动控制信号。这些控制信号包括：</p>\n</blockquote>\n<p>■ Two clocks<br>■ Two clock enables<br>■ Two asynchronous clears<br>■ One synchronous clear<br>■ One synchronous load</p>\n<blockquote>\n<p>两个时钟<br>两个时钟使能<br>两个异步清除<br>一个同步清除<br>一个同步加载</p>\n</blockquote>\n<p>You can use up to eight control signals at a time. Register packing and synchronous<br>load cannot be used simultaneously.</p>\n<blockquote>\n<p>您可以同时使用最多八个控制信号。寄存器打包和同步加载不能同时使用。</p>\n</blockquote>\n<p>Each LAB can have up to four non-global control signals. You can use additional LAB<br>control signals as long as they are global signals.</p>\n<blockquote>\n<p>每个LAB最多可以有四个非全局控制信号。只要它们是全局信号，您可以使用额外的LAB控制信号。</p>\n</blockquote>\n<p>Synchronous clear and load signals are useful for implementing counters and other<br>functions. The synchronous clear and synchronous load signals are LAB-wide signals<br>that affect all registers in the LAB.</p>\n<blockquote>\n<p>同步清除和同步加载信号对于实现计数器和其他功能非常有用。同步清除和同步加载信号是LAB范围的信号，影响LAB中的所有寄存器。</p>\n</blockquote>\n<p>Each LAB can use two clocks and two clock enable signals. The clock and clock enable signals of each LAB are linked. For example, any LE in a particular LAB using the labclk1 signal also uses the labclkena1. If the LAB uses both the rising and falling edges of a clock, it also uses both LAB-wide clock signals. Deasserting the clock enable signal turns off the LAB-wide clock.</p>\n<blockquote>\n<p>每个LAB可以使用两个时钟和两个时钟使能信号。每个LAB的时钟和时钟使能信号是关联的。例如，使用labclk1信号的特定LAB中的任何LE也使用labclkena1。如果LAB同时使用上升沿和下降沿的时钟，它还会使用两个LAB范围的时钟信号。取消时钟使能信号将关闭LAB范围的时钟。</p>\n</blockquote>\n<p>The LAB row clocks [5..0] and LAB local interconnect generate the LAB-wide<br>control signals. The MultiTrack interconnect inherent low skew allows clock and<br>control signal distribution in addition to data distribution.</p>\n<blockquote>\n<p>LAB行时钟[5..0]和LAB本地互连生成LAB范围的控制信号。MultiTrack互连固有的低斜率允许时钟和控制信号的分发，除了数据分发。</p>\n</blockquote>\n<p><img src=\"/2024/01/fpga-ji-ben-dan-yuan/LAB_control_signal_generation_circuit.png\" alt=\"img\"><br>LAB-wide signals control the logic for the clear signal of the register. The LE directly supports an asynchronous clear function. Each LAB supports up to two asynchronous clear signals (labclr1 and labclr2).</p>\n<blockquote>\n<p>LAB范围的信号控制寄存器的清除信号逻辑。LE直接支持异步清除功能。每个LAB支持最多两个异步清除信号（labclr1和labclr2）。</p>\n</blockquote>\n<p>A LAB-wide asynchronous load signal to control the logic for the preset signal of the register is not available. The register preset is achieved with a NOT gate push-back technique. Cyclone IV devices only support either a preset or asynchronous clear signal.</p>\n<blockquote>\n<p>LAB范围的异步加载信号，用于控制寄存器的预设信号逻辑，是不可用的。寄存器的预设是通过NOT门推迟技术实现的。Cyclone IV器件仅支持预设或异步清除信号的一种。</p>\n</blockquote>\n<p>In addition to the clear port, Cyclone IV devices provide a chip-wide reset pin<br>(DEV_CLRn) that resets all registers in the device. An option set before compilation in the Quartus II software controls this pin. This chip-wide reset overrides all other control signals.</p>\n<blockquote>\n<p>除了清除端口，Cyclone IV器件提供一个芯片范围的复位引脚（DEV_CLRn），用于复位设备中的所有寄存器。在Quartus II软件中编译之前设置的选项控制此引脚。这个芯片范围的复位会覆盖所有其他控制信号。</p>\n</blockquote>\n"}],"PostAsset":[{"_id":"source/_posts/2022/01/Linux-input子系统/2909691-20220819093409715-1604400596.png","slug":"2909691-20220819093409715-1604400596.png","post":"clru1g1zz0008s4futq2z4rl1","modified":0,"renderable":0},{"_id":"source/_posts/2022/01/IMX6ull-移植-lVGL总结/2909691-20220928153305849-1048335725.png","slug":"2909691-20220928153305849-1048335725.png","post":"clru1g20a000gs4fukjgw8gmn","modified":0,"renderable":0},{"_id":"source/_posts/2022/01/中华通史-上古史-夏/20210703111602157.png","slug":"20210703111602157.png","post":"clru1g205000cs4fuq737vg42","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/业务功能-业务流程-业务规则分析/业务规则.png","slug":"业务规则.png","post":"clru1g2140016s4fueh5sbcf2","modified":0,"renderable":0},{"_id":"source/_posts/2023/08/process-dbus-daemon/2.png","slug":"2.png","post":"clru1g21q0026s4fuedrkdte0","modified":0,"renderable":0},{"_id":"source/_posts/2023/09/日落/微信图片_20230912150536.jpg","slug":"微信图片_20230912150536.jpg","post":"clru1g229003bs4fuf1z176lp","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/I2C半高电平/picture1.jpg","slug":"picture1.jpg","post":"clru1g22b003fs4fux04bf8tb","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/set_max_delay_diagram.png","slug":"set_max_delay_diagram.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2022/01/IMX6ull-移植-lVGL总结/2909691-20220928152922659-1842915282.png","slug":"2909691-20220928152922659-1842915282.png","post":"clru1g20a000gs4fukjgw8gmn","modified":0,"renderable":0},{"_id":"source/_posts/2022/01/python使用百度翻译的API/20200302112847600.png","slug":"20200302112847600.png","post":"clru1g204000bs4futt6zjx5x","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/EMC-EMI/2023-04-04_19-30-08.png","slug":"2023-04-04_19-30-08.png","post":"clru1g20j000ls4fuaql2kexw","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/EMC-EMI/2023-04-04_19-32-59.png","slug":"2023-04-04_19-32-59.png","post":"clru1g20j000ls4fuaql2kexw","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/业务功能-业务流程-业务规则分析/穷尽分支.png","slug":"穷尽分支.png","post":"clru1g2140016s4fueh5sbcf2","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/新疆/5d0b74a8910a3abba7e860149b9d40e12.JPG","slug":"5d0b74a8910a3abba7e860149b9d40e12.JPG","post":"clru1g211000ys4fuin3pfiq8","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/衡山/20230403161440.jpg","slug":"20230403161440.jpg","post":"clru1g2120011s4fuickg00wo","modified":0,"renderable":0},{"_id":"source/_posts/2023/05/PIN-GPIO/pinctrl struct.png","slug":"pinctrl struct.png","post":"clru1g219001as4fu1zngclnp","modified":0,"renderable":0},{"_id":"source/_posts/2023/09/Medical-device-registration-standards/2023-09-14_10-00-13.png","slug":"2023-09-14_10-00-13.png","post":"clru1g2270039s4fulr5c5f3a","modified":0,"renderable":0},{"_id":"source/_posts/2022/01/超详细解析python爬取外网图片/20200302110709393.png","slug":"20200302110709393.png","post":"clru1g20m000ns4fu53hv0diq","modified":0,"renderable":0},{"_id":"source/_posts/2022/01/超详细解析python爬取外网图片/20200302111109517.png","slug":"20200302111109517.png","post":"clru1g20m000ns4fu53hv0diq","modified":0,"renderable":0},{"_id":"source/_posts/2023/06/linux内核-tool目录/menuconfig.png","slug":"menuconfig.png","post":"clru1g21f001es4fucozngc0z","modified":0,"renderable":0},{"_id":"source/_posts/2023/06/linux内核-tool目录/tool目录.png","slug":"tool目录.png","post":"clru1g21f001es4fucozngc0z","modified":0,"renderable":0},{"_id":"source/_posts/2023/07/linux-platform/device-driver.png","slug":"device-driver.png","post":"clru1g21l001us4fuc513tgh7","modified":0,"renderable":0},{"_id":"source/_posts/2023/07/linux-platform/platform.png","slug":"platform.png","post":"clru1g21l001us4fuc513tgh7","modified":0,"renderable":0},{"_id":"source/_posts/2023/08/process-dbus-daemon/1.png","slug":"1.png","post":"clru1g21q0026s4fuedrkdte0","modified":0,"renderable":0},{"_id":"source/_posts/2022/01/linux线程/2909691-20221018201940242-320806714.png","slug":"2909691-20221018201940242-320806714.png","post":"clru1g1zt0007s4fuilzb4ji1","modified":0,"renderable":0},{"_id":"source/_posts/2022/01/linux线程/2909691-20221018202536805-171723429.png","slug":"2909691-20221018202536805-171723429.png","post":"clru1g1zt0007s4fuilzb4ji1","modified":0,"renderable":0},{"_id":"source/_posts/2022/01/linux线程/2909691-20221018204634847-2097816257.png","slug":"2909691-20221018204634847-2097816257.png","post":"clru1g1zt0007s4fuilzb4ji1","modified":0,"renderable":0},{"_id":"source/_posts/2022/01/Linux-input子系统/2909691-20220819094250974-180404869.webp","slug":"2909691-20220819094250974-180404869.webp","post":"clru1g1zz0008s4futq2z4rl1","modified":0,"renderable":0},{"_id":"source/_posts/2022/01/Linux-input子系统/2909691-20220819102740731-2036281828.png","slug":"2909691-20220819102740731-2036281828.png","post":"clru1g1zz0008s4futq2z4rl1","modified":0,"renderable":0},{"_id":"source/_posts/2022/01/Linux-input子系统/input_logical.png","slug":"input_logical.png","post":"clru1g1zz0008s4futq2z4rl1","modified":0,"renderable":0},{"_id":"source/_posts/2022/01/中华通史-上古史-夏/20210703105815619.png","slug":"20210703105815619.png","post":"clru1g205000cs4fuq737vg42","modified":0,"renderable":0},{"_id":"source/_posts/2022/01/中华通史-上古史-夏/20210703105831609.png","slug":"20210703105831609.png","post":"clru1g205000cs4fuq737vg42","modified":0,"renderable":0},{"_id":"source/_posts/2022/01/中华通史-上古史-夏/20210703105920999.png","slug":"20210703105920999.png","post":"clru1g205000cs4fuq737vg42","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/上海/20230403160752.jpg","slug":"20230403160752.jpg","post":"clru1g20q000ss4fup0eq2s1f","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/上海/20230403160809.jpg","slug":"20230403160809.jpg","post":"clru1g20q000ss4fup0eq2s1f","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/上海/20230403160815.jpg","slug":"20230403160815.jpg","post":"clru1g20q000ss4fup0eq2s1f","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/上海/20230403160820.jpg","slug":"20230403160820.jpg","post":"clru1g20q000ss4fup0eq2s1f","modified":0,"renderable":0},{"_id":"source/_posts/2023/06/ttymxx-UART/cat-proc-devices.png","slug":"cat-proc-devices.png","post":"clru1g21j001ns4fumvse5sfz","modified":0,"renderable":0},{"_id":"source/_posts/2023/06/ttymxx-UART/cat-ttymxc2.png","slug":"cat-ttymxc2.png","post":"clru1g21j001ns4fumvse5sfz","modified":0,"renderable":0},{"_id":"source/_posts/2023/06/ttymxx-UART/ls-dev.png","slug":"ls-dev.png","post":"clru1g21j001ns4fumvse5sfz","modified":0,"renderable":0},{"_id":"source/_posts/2023/06/ttymxx-UART/ttymxc.png","slug":"ttymxc.png","post":"clru1g21j001ns4fumvse5sfz","modified":0,"renderable":0},{"_id":"source/_posts/2023/08/语法指导翻译器/文法定义.png","slug":"文法定义.png","post":"clru1g2240032s4ful7gth935","modified":0,"renderable":0},{"_id":"source/_posts/2023/08/语法指导翻译器/简单语法制导定义.png","slug":"简单语法制导定义.png","post":"clru1g2240032s4ful7gth935","modified":0,"renderable":0},{"_id":"source/_posts/2023/08/语法指导翻译器/语法分析树.png","slug":"语法分析树.png","post":"clru1g2240032s4ful7gth935","modified":0,"renderable":0},{"_id":"source/_posts/2023/08/语法指导翻译器/语法制导翻译.png","slug":"语法制导翻译.png","post":"clru1g2240032s4ful7gth935","modified":0,"renderable":0},{"_id":"source/_posts/2023/08/语法指导翻译器/语法定义.png","slug":"语法定义.png","post":"clru1g2240032s4ful7gth935","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/I2C半高电平/picture2.jpg","slug":"picture2.jpg","post":"clru1g22b003fs4fux04bf8tb","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/I2C半高电平/picture3.jpg","slug":"picture3.jpg","post":"clru1g22b003fs4fux04bf8tb","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/I2C半高电平/picture4.jpg","slug":"picture4.jpg","post":"clru1g22b003fs4fux04bf8tb","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/I2C半高电平/picture5.jpg","slug":"picture5.jpg","post":"clru1g22b003fs4fux04bf8tb","modified":0,"renderable":0},{"_id":"source/_posts/2023/09/Design-Inputs-Outputs-for-Medical-Device/2023-09-13_17-08-45.png","slug":"2023-09-13_17-08-45.png","post":"clru1g22d003hs4fu2vfcxvib","modified":0,"renderable":0},{"_id":"source/_posts/2023/09/Design-Inputs-Outputs-for-Medical-Device/2023-09-13_17-14-12.png","slug":"2023-09-13_17-14-12.png","post":"clru1g22d003hs4fu2vfcxvib","modified":0,"renderable":0},{"_id":"source/_posts/2023/09/Design-Inputs-Outputs-for-Medical-Device/2023-09-14_09-16-16.png","slug":"2023-09-14_09-16-16.png","post":"clru1g22d003hs4fu2vfcxvib","modified":0,"renderable":0},{"_id":"source/_posts/2023/09/Design-Inputs-Outputs-for-Medical-Device/2023-09-14_09-19-28.png","slug":"2023-09-14_09-19-28.png","post":"clru1g22d003hs4fu2vfcxvib","modified":0,"renderable":0},{"_id":"source/_posts/2023/09/Design-Inputs-Outputs-for-Medical-Device/2023-09-14_9-14-12.png","slug":"2023-09-14_9-14-12.png","post":"clru1g22d003hs4fu2vfcxvib","modified":0,"renderable":0},{"_id":"source/_posts/2022/01/python使用百度翻译的API/20200302112753932.png","slug":"20200302112753932.png","post":"clru1g204000bs4futt6zjx5x","modified":0,"renderable":0},{"_id":"source/_posts/2022/01/python使用百度翻译的API/20200302113313981.png","slug":"20200302113313981.png","post":"clru1g204000bs4futt6zjx5x","modified":0,"renderable":0},{"_id":"source/_posts/2022/01/python使用百度翻译的API/20200302113654396.png","slug":"20200302113654396.png","post":"clru1g204000bs4futt6zjx5x","modified":0,"renderable":0},{"_id":"source/_posts/2022/01/python使用百度翻译的API/20200302115943813.png","slug":"20200302115943813.png","post":"clru1g204000bs4futt6zjx5x","modified":0,"renderable":0},{"_id":"source/_posts/2022/01/python使用百度翻译的API/20200302120105912.png","slug":"20200302120105912.png","post":"clru1g204000bs4futt6zjx5x","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/深圳梧桐山-毛棉杜鹃/0a32e20ee914cca207bd5e0446eca332.JPG","slug":"0a32e20ee914cca207bd5e0446eca332.JPG","post":"clru1g2160018s4fuh2gi8y1v","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/深圳梧桐山-毛棉杜鹃/2b135a37c965e856f04d4a5faf8d2f2b2.JPG","slug":"2b135a37c965e856f04d4a5faf8d2f2b2.JPG","post":"clru1g2160018s4fuh2gi8y1v","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/深圳梧桐山-毛棉杜鹃/6f19a8a8bff80c030eeba535032db0f6.JPG","slug":"6f19a8a8bff80c030eeba535032db0f6.JPG","post":"clru1g2160018s4fuh2gi8y1v","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/深圳梧桐山-毛棉杜鹃/7d011510a39a8f6e23429fa828448a7c2.JPG","slug":"7d011510a39a8f6e23429fa828448a7c2.JPG","post":"clru1g2160018s4fuh2gi8y1v","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/深圳梧桐山-毛棉杜鹃/d2a7004a2e039c3f37d5fef10c7cc28a2.JPG","slug":"d2a7004a2e039c3f37d5fef10c7cc28a2.JPG","post":"clru1g2160018s4fuh2gi8y1v","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/深圳梧桐山-毛棉杜鹃/f4e3370968454b29062472df853b648e.JPG","slug":"f4e3370968454b29062472df853b648e.JPG","post":"clru1g2160018s4fuh2gi8y1v","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/FPGA基本单元/Cyclone_IV_dEVICES_LEs.png","slug":"Cyclone_IV_dEVICES_LEs.png","post":"clru1g22h003ts4fu1adr4utt","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/FPGA基本单元/LAB_control_signal_generation_circuit.png","slug":"LAB_control_signal_generation_circuit.png","post":"clru1g22h003ts4fu1adr4utt","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/FPGA基本单元/LAB_structure_for_Cyclone_IV_devices.png","slug":"LAB_structure_for_Cyclone_IV_devices.png","post":"clru1g22h003ts4fu1adr4utt","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/FPGA基本单元/LEs_in_arithmetic_mode.png","slug":"LEs_in_arithmetic_mode.png","post":"clru1g22h003ts4fu1adr4utt","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/FPGA基本单元/direct_link_connection.png","slug":"direct_link_connection.png","post":"clru1g22h003ts4fu1adr4utt","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/FPGA基本单元/shows_LEs_in_normal_mode.png","slug":"shows_LEs_in_normal_mode.png","post":"clru1g22h003ts4fu1adr4utt","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/衡山/20230403161331.jpg","slug":"20230403161331.jpg","post":"clru1g2120011s4fuickg00wo","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/衡山/20230403161404.jpg","slug":"20230403161404.jpg","post":"clru1g2120011s4fuickg00wo","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/衡山/20230403161412.jpg","slug":"20230403161412.jpg","post":"clru1g2120011s4fuickg00wo","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/衡山/20230403161419.jpg","slug":"20230403161419.jpg","post":"clru1g2120011s4fuickg00wo","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/衡山/20230403161427.jpg","slug":"20230403161427.jpg","post":"clru1g2120011s4fuickg00wo","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/衡山/20230403161434.jpg","slug":"20230403161434.jpg","post":"clru1g2120011s4fuickg00wo","modified":0,"renderable":0},{"_id":"source/_posts/2023/05/PIN-GPIO/Pinctrl.png","slug":"Pinctrl.png","post":"clru1g219001as4fu1zngclnp","modified":0,"renderable":0},{"_id":"source/_posts/2023/05/PIN-GPIO/gpio.png","slug":"gpio.png","post":"clru1g219001as4fu1zngclnp","modified":0,"renderable":0},{"_id":"source/_posts/2023/05/PIN-GPIO/imx6ull pinctrl.png","slug":"imx6ull pinctrl.png","post":"clru1g219001as4fu1zngclnp","modified":0,"renderable":0},{"_id":"source/_posts/2023/05/PIN-GPIO/iomuxc.png","slug":"iomuxc.png","post":"clru1g219001as4fu1zngclnp","modified":0,"renderable":0},{"_id":"source/_posts/2023/05/PIN-GPIO/pinctrl_system.png","slug":"pinctrl_system.png","post":"clru1g219001as4fu1zngclnp","modified":0,"renderable":0},{"_id":"source/_posts/2023/05/PIN-GPIO/probe.png","slug":"probe.png","post":"clru1g219001as4fu1zngclnp","modified":0,"renderable":0},{"_id":"source/_posts/2022/01/IMX6ull-移植-lVGL总结/2909691-20220928151916481-1456634923.png","slug":"2909691-20220928151916481-1456634923.png","post":"clru1g20a000gs4fukjgw8gmn","modified":0,"renderable":0},{"_id":"source/_posts/2022/01/IMX6ull-移植-lVGL总结/2909691-20220928152209724-1097250473.png","slug":"2909691-20220928152209724-1097250473.png","post":"clru1g20a000gs4fukjgw8gmn","modified":0,"renderable":0},{"_id":"source/_posts/2022/01/IMX6ull-移植-lVGL总结/2909691-20220928152945955-899676295.png","slug":"2909691-20220928152945955-899676295.png","post":"clru1g20a000gs4fukjgw8gmn","modified":0,"renderable":0},{"_id":"source/_posts/2022/01/IMX6ull-移植-lVGL总结/2909691-20220928152957065-501054685.png","slug":"2909691-20220928152957065-501054685.png","post":"clru1g20a000gs4fukjgw8gmn","modified":0,"renderable":0},{"_id":"source/_posts/2022/01/IMX6ull-移植-lVGL总结/2909691-20220928153140065-1807119912.png","slug":"2909691-20220928153140065-1807119912.png","post":"clru1g20a000gs4fukjgw8gmn","modified":0,"renderable":0},{"_id":"source/_posts/2022/01/IMX6ull-移植-lVGL总结/2909691-20220928153451220-1274979267.png","slug":"2909691-20220928153451220-1274979267.png","post":"clru1g20a000gs4fukjgw8gmn","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/业务功能-业务流程-业务规则分析/业务规则上.png","slug":"业务规则上.png","post":"clru1g2140016s4fueh5sbcf2","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/业务功能-业务流程-业务规则分析/业务规则下.png","slug":"业务规则下.png","post":"clru1g2140016s4fueh5sbcf2","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/业务功能-业务流程-业务规则分析/主干流程.png","slug":"主干流程.png","post":"clru1g2140016s4fueh5sbcf2","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/业务功能-业务流程-业务规则分析/分析起步.png","slug":"分析起步.png","post":"clru1g2140016s4fueh5sbcf2","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/业务功能-业务流程-业务规则分析/探索分支.png","slug":"探索分支.png","post":"clru1g2140016s4fueh5sbcf2","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/业务功能-业务流程-业务规则分析/模板.png","slug":"模板.png","post":"clru1g2140016s4fueh5sbcf2","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/ten-ge-li/1.jpg","slug":"1.jpg","post":"clru1g20d000hs4fu1jtgir76","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/ten-ge-li/2.jpg","slug":"2.jpg","post":"clru1g20d000hs4fu1jtgir76","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/ten-ge-li/3.jpg","slug":"3.jpg","post":"clru1g20d000hs4fu1jtgir76","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/ten-ge-li/4.jpg","slug":"4.jpg","post":"clru1g20d000hs4fu1jtgir76","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/ten-ge-li/5.jpg","slug":"5.jpg","post":"clru1g20d000hs4fu1jtgir76","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/ten-ge-li/6.jpg","slug":"6.jpg","post":"clru1g20d000hs4fu1jtgir76","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/ten-ge-li/IMG_6899.JPG","slug":"IMG_6899.JPG","post":"clru1g20d000hs4fu1jtgir76","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/ten-ge-li/IMG_6912.JPG","slug":"IMG_6912.JPG","post":"clru1g20d000hs4fu1jtgir76","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/ten-ge-li/IMG_7069.JPG","slug":"IMG_7069.JPG","post":"clru1g20d000hs4fu1jtgir76","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/EMC-EMI/2023-04-04_19-28-04.png","slug":"2023-04-04_19-28-04.png","post":"clru1g20j000ls4fuaql2kexw","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/EMC-EMI/2023-04-04_19-31-27.png","slug":"2023-04-04_19-31-27.png","post":"clru1g20j000ls4fuaql2kexw","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/EMC-EMI/2023-04-04_19-32-29.png","slug":"2023-04-04_19-32-29.png","post":"clru1g20j000ls4fuaql2kexw","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/EMC-EMI/2023-04-04_19-33-05.png","slug":"2023-04-04_19-33-05.png","post":"clru1g20j000ls4fuaql2kexw","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/EMC-EMI/2023-04-04_19-33-48.png","slug":"2023-04-04_19-33-48.png","post":"clru1g20j000ls4fuaql2kexw","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/EMC-EMI/2023-04-04_19-34-25.png","slug":"2023-04-04_19-34-25.png","post":"clru1g20j000ls4fuaql2kexw","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/EMC-EMI/2023-04-04_19-35-03.png","slug":"2023-04-04_19-35-03.png","post":"clru1g20j000ls4fuaql2kexw","modified":0,"renderable":0},{"_id":"source/_posts/2022/01/菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329193127889.jpg","slug":"20210329193127889.jpg","post":"clru1g206000ds4furzkxg6pl","modified":0,"renderable":0},{"_id":"source/_posts/2022/01/菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329195920218.jpg","slug":"20210329195920218.jpg","post":"clru1g206000ds4furzkxg6pl","modified":0,"renderable":0},{"_id":"source/_posts/2022/01/菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329200632579.png","slug":"20210329200632579.png","post":"clru1g206000ds4furzkxg6pl","modified":0,"renderable":0},{"_id":"source/_posts/2022/01/菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329201443609.png","slug":"20210329201443609.png","post":"clru1g206000ds4furzkxg6pl","modified":0,"renderable":0},{"_id":"source/_posts/2022/01/菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329201646615.png","slug":"20210329201646615.png","post":"clru1g206000ds4furzkxg6pl","modified":0,"renderable":0},{"_id":"source/_posts/2022/01/菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329202358795.png","slug":"20210329202358795.png","post":"clru1g206000ds4furzkxg6pl","modified":0,"renderable":0},{"_id":"source/_posts/2022/01/菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329202548677.png","slug":"20210329202548677.png","post":"clru1g206000ds4furzkxg6pl","modified":0,"renderable":0},{"_id":"source/_posts/2022/01/菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329203021908.png","slug":"20210329203021908.png","post":"clru1g206000ds4furzkxg6pl","modified":0,"renderable":0},{"_id":"source/_posts/2022/01/菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329203335481.png","slug":"20210329203335481.png","post":"clru1g206000ds4furzkxg6pl","modified":0,"renderable":0},{"_id":"source/_posts/2022/01/菜鸟应该如何开始设计一个项目的嵌入式软件架构/20210329203626594.png","slug":"20210329203626594.png","post":"clru1g206000ds4furzkxg6pl","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/北京/DSC01645.JPG","slug":"DSC01645.JPG","post":"clru1g20u000us4fup0iw7xda","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/北京/DSC01687.JPG","slug":"DSC01687.JPG","post":"clru1g20u000us4fup0iw7xda","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/北京/DSC01697.JPG","slug":"DSC01697.JPG","post":"clru1g20u000us4fup0iw7xda","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/北京/DSC01699.JPG","slug":"DSC01699.JPG","post":"clru1g20u000us4fup0iw7xda","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/北京/DSC01722.JPG","slug":"DSC01722.JPG","post":"clru1g20u000us4fup0iw7xda","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/北京/DSC01755.JPG","slug":"DSC01755.JPG","post":"clru1g20u000us4fup0iw7xda","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/北京/DSC01821.JPG","slug":"DSC01821.JPG","post":"clru1g20u000us4fup0iw7xda","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/北京/DSC01827.JPG","slug":"DSC01827.JPG","post":"clru1g20u000us4fup0iw7xda","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/北京/IMG_6716.JPG","slug":"IMG_6716.JPG","post":"clru1g20u000us4fup0iw7xda","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/北京/IMG_6717.JPG","slug":"IMG_6717.JPG","post":"clru1g20u000us4fup0iw7xda","modified":0,"renderable":0},{"_id":"source/_posts/2023/07/嵌入式软件框架方案/22c7469876239933b38a12a32e9c6f16.png","slug":"22c7469876239933b38a12a32e9c6f16.png","post":"clru1g21o0022s4fugc4vhpx2","modified":0,"renderable":0},{"_id":"source/_posts/2023/07/嵌入式软件框架方案/2dd308b3411c41658cce041f8c230853.png","slug":"2dd308b3411c41658cce041f8c230853.png","post":"clru1g21o0022s4fugc4vhpx2","modified":0,"renderable":0},{"_id":"source/_posts/2023/07/嵌入式软件框架方案/32643a6fbe010dcc95af301416619164.png","slug":"32643a6fbe010dcc95af301416619164.png","post":"clru1g21o0022s4fugc4vhpx2","modified":0,"renderable":0},{"_id":"source/_posts/2023/07/嵌入式软件框架方案/60a0b6815e87242adbc049d64b96e01b.png","slug":"60a0b6815e87242adbc049d64b96e01b.png","post":"clru1g21o0022s4fugc4vhpx2","modified":0,"renderable":0},{"_id":"source/_posts/2023/07/嵌入式软件框架方案/6aadad4da134377249d84bab5dbdfa8d.png","slug":"6aadad4da134377249d84bab5dbdfa8d.png","post":"clru1g21o0022s4fugc4vhpx2","modified":0,"renderable":0},{"_id":"source/_posts/2023/07/嵌入式软件框架方案/780552b6b4ceacfe274a8c687b74a569.png","slug":"780552b6b4ceacfe274a8c687b74a569.png","post":"clru1g21o0022s4fugc4vhpx2","modified":0,"renderable":0},{"_id":"source/_posts/2023/07/嵌入式软件框架方案/c7546c50623e8a8aa6ab33ead8fac6cb.png","slug":"c7546c50623e8a8aa6ab33ead8fac6cb.png","post":"clru1g21o0022s4fugc4vhpx2","modified":0,"renderable":0},{"_id":"source/_posts/2023/07/嵌入式软件框架方案/dc4e3ddfdab5a0456af40df7d0a9238b.png","slug":"dc4e3ddfdab5a0456af40df7d0a9238b.png","post":"clru1g21o0022s4fugc4vhpx2","modified":0,"renderable":0},{"_id":"source/_posts/2023/07/嵌入式软件框架方案/e7176066eab77c0cf6e147aed0046ea7.png","slug":"e7176066eab77c0cf6e147aed0046ea7.png","post":"clru1g21o0022s4fugc4vhpx2","modified":0,"renderable":0},{"_id":"source/_posts/2023/07/嵌入式软件框架方案/e852708ffd1c78efd87949efa7b31592.png","slug":"e852708ffd1c78efd87949efa7b31592.png","post":"clru1g21o0022s4fugc4vhpx2","modified":0,"renderable":0},{"_id":"source/_posts/2023/09/日落/微信图片_20230912090924.png","slug":"微信图片_20230912090924.png","post":"clru1g229003bs4fuf1z176lp","modified":0,"renderable":0},{"_id":"source/_posts/2023/09/日落/微信图片_20230912150554.jpg","slug":"微信图片_20230912150554.jpg","post":"clru1g229003bs4fuf1z176lp","modified":0,"renderable":0},{"_id":"source/_posts/2023/09/日落/微信图片_20230912150558.jpg","slug":"微信图片_20230912150558.jpg","post":"clru1g229003bs4fuf1z176lp","modified":0,"renderable":0},{"_id":"source/_posts/2023/09/日落/微信图片_20230912150602.jpg","slug":"微信图片_20230912150602.jpg","post":"clru1g229003bs4fuf1z176lp","modified":0,"renderable":0},{"_id":"source/_posts/2023/09/日落/微信图片_20230912150606.jpg","slug":"微信图片_20230912150606.jpg","post":"clru1g229003bs4fuf1z176lp","modified":0,"renderable":0},{"_id":"source/_posts/2023/09/日落/微信图片_20230912150610.jpg","slug":"微信图片_20230912150610.jpg","post":"clru1g229003bs4fuf1z176lp","modified":0,"renderable":0},{"_id":"source/_posts/2023/09/日落/微信图片_20230912150614.jpg","slug":"微信图片_20230912150614.jpg","post":"clru1g229003bs4fuf1z176lp","modified":0,"renderable":0},{"_id":"source/_posts/2023/09/日落/微信图片_20230912150619.jpg","slug":"微信图片_20230912150619.jpg","post":"clru1g229003bs4fuf1z176lp","modified":0,"renderable":0},{"_id":"source/_posts/2023/09/日落/微信图片_20230912150622.jpg","slug":"微信图片_20230912150622.jpg","post":"clru1g229003bs4fuf1z176lp","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/新疆/1b706b934fc955412e3ed163fd0b7cbc2.JPG","slug":"1b706b934fc955412e3ed163fd0b7cbc2.JPG","post":"clru1g211000ys4fuin3pfiq8","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/新疆/254bc46a6128338402204fa78f54b3e12.PNG","slug":"254bc46a6128338402204fa78f54b3e12.PNG","post":"clru1g211000ys4fuin3pfiq8","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/新疆/2d25bdf0ce35910c874badcedff928002.JPG","slug":"2d25bdf0ce35910c874badcedff928002.JPG","post":"clru1g211000ys4fuin3pfiq8","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/新疆/50f3a54d039eb642be22bc25607e11ca2.PNG","slug":"50f3a54d039eb642be22bc25607e11ca2.PNG","post":"clru1g211000ys4fuin3pfiq8","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/新疆/6d0c92b575f36108df2062fda3b1e4ba2.PNG","slug":"6d0c92b575f36108df2062fda3b1e4ba2.PNG","post":"clru1g211000ys4fuin3pfiq8","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/新疆/76d386e1b8eeeb85abab758cefc855e0.JPG","slug":"76d386e1b8eeeb85abab758cefc855e0.JPG","post":"clru1g211000ys4fuin3pfiq8","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/新疆/88a98ae85a4705294439aca39ae07d672.JPG","slug":"88a98ae85a4705294439aca39ae07d672.JPG","post":"clru1g211000ys4fuin3pfiq8","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/新疆/89c05a76a9273811c585c395890c9f522.JPG","slug":"89c05a76a9273811c585c395890c9f522.JPG","post":"clru1g211000ys4fuin3pfiq8","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/新疆/95d557eb4ef2235d74a45743be1b05842.JPG","slug":"95d557eb4ef2235d74a45743be1b05842.JPG","post":"clru1g211000ys4fuin3pfiq8","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/新疆/ANKG1449.JPG","slug":"ANKG1449.JPG","post":"clru1g211000ys4fuin3pfiq8","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/新疆/AQSR2937.JPG","slug":"AQSR2937.JPG","post":"clru1g211000ys4fuin3pfiq8","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/新疆/AZQE3071.JPG","slug":"AZQE3071.JPG","post":"clru1g211000ys4fuin3pfiq8","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/新疆/BBND3773.PNG","slug":"BBND3773.PNG","post":"clru1g211000ys4fuin3pfiq8","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/新疆/BBOD4958.JPG","slug":"BBOD4958.JPG","post":"clru1g211000ys4fuin3pfiq8","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/新疆/IGAX1811.JPG","slug":"IGAX1811.JPG","post":"clru1g211000ys4fuin3pfiq8","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/新疆/KNLN1045.PNG","slug":"KNLN1045.PNG","post":"clru1g211000ys4fuin3pfiq8","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/新疆/MOVG5083.JPG","slug":"MOVG5083.JPG","post":"clru1g211000ys4fuin3pfiq8","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/新疆/XRBQ0574.JPG","slug":"XRBQ0574.JPG","post":"clru1g211000ys4fuin3pfiq8","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/新疆/YJUM1401.JPG","slug":"YJUM1401.JPG","post":"clru1g211000ys4fuin3pfiq8","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/新疆/a2a9265c2707c16b5a1ca704a4d0856d.JPG","slug":"a2a9265c2707c16b5a1ca704a4d0856d.JPG","post":"clru1g211000ys4fuin3pfiq8","modified":0,"renderable":0},{"_id":"source/_posts/2023/04/新疆/a51d80549e7edc0d1ba69a885aa946ff2.JPG","slug":"a51d80549e7edc0d1ba69a885aa946ff2.JPG","post":"clru1g211000ys4fuin3pfiq8","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/DataArrivalTimeHold.png","slug":"DataArrivalTimeHold.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/DataPathRequirementCalculation.png","slug":"DataPathRequirementCalculation.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/FourPathConstraints.png","slug":"FourPathConstraints.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/GeneratedClcokConstraints.png","slug":"GeneratedClcokConstraints.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/GeneratedClcokPath.png","slug":"GeneratedClcokPath.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/GeneratedClockEdgeShiftConstraints.png","slug":"GeneratedClockEdgeShiftConstraints.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/GeneratedClockEdgeShiftPath.png","slug":"GeneratedClockEdgeShiftPath.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/GeneratedClockSourceClock.png","slug":"GeneratedClockSourceClock.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/HoldPathRequirement.png","slug":"HoldPathRequirement.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/HoldupExample.png","slug":"HoldupExample.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/LaunchEdgeCaptureEdge.png","slug":"LaunchEdgeCaptureEdge.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/Min_Input_Delay.png","slug":"Min_Input_Delay.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/PrimaryClockConstraints.png","slug":"PrimaryClockConstraints.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/PrimaryClockConstraints2.png","slug":"PrimaryClockConstraints2.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/PrimaryClockConstraintsFromSerdes.png","slug":"PrimaryClockConstraintsFromSerdes.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/PrimaryClockPath.png","slug":"PrimaryClockPath.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/PrimaryClockPath2.png","slug":"PrimaryClockPath2.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/PrimaryClockPathFromSerdes.png","slug":"PrimaryClockPathFromSerdes.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/RequireTimeRecovery.png","slug":"RequireTimeRecovery.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/RequireTimeRemoval.png","slug":"RequireTimeRemoval.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/SetupRequirement与实际不符.png","slug":"SetupRequirement与实际不符.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/SlackHold.png","slug":"SlackHold.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/Tco_Th很大.png","slug":"Tco_Th很大.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/Tco的由来.png","slug":"Tco的由来.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/Th的由来.png","slug":"Th的由来.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/TimeQuestHoldupSlack.png","slug":"TimeQuestHoldupSlack.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/TimeQuestRecovery.png","slug":"TimeQuestRecovery.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/TimeQuestRemoval.png","slug":"TimeQuestRemoval.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/TimeQuest时序分析Setup1.png","slug":"TimeQuest时序分析Setup1.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/TimeQuest时序分析Setup2.png","slug":"TimeQuest时序分析Setup2.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/Tlogic很大.png","slug":"Tlogic很大.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/TsetupThold的由来.png","slug":"TsetupThold的由来.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/clk_skew很大.png","slug":"clk_skew很大.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/dataRequiredTimeHold.png","slug":"dataRequiredTimeHold.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/holdTimeRequirement.png","slug":"holdTimeRequirement.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/input_delay.png","slug":"input_delay.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/input_delay_constraints1.png","slug":"input_delay_constraints1.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/input_delay_constraints2.png","slug":"input_delay_constraints2.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/input_delay_constraints3.png","slug":"input_delay_constraints3.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/input_delay_path1.png","slug":"input_delay_path1.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/input_delay_path2.png","slug":"input_delay_path2.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/max_input_delay.png","slug":"max_input_delay.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/max_output_delay.png","slug":"max_output_delay.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/min_output_delay.png","slug":"min_output_delay.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/multicycle_path_rtl_diagram.png","slug":"multicycle_path_rtl_diagram.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/multicycle_path_same_clock.png","slug":"multicycle_path_same_clock.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/multicycle_path_same_clock_timing.png","slug":"multicycle_path_same_clock_timing.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/output_delay.png","slug":"output_delay.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/output_delay_constraints1.png","slug":"output_delay_constraints1.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/output_delay_constraints2.png","slug":"output_delay_constraints2.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/output_delay_path1.png","slug":"output_delay_path1.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/output_delay_path2.png","slug":"output_delay_path2.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/set_clock_group_command.png","slug":"set_clock_group_command.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/set_clock_group_command2.png","slug":"set_clock_group_command2.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/set_clock_group_path.png","slug":"set_clock_group_path.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/set_false_path_a2b_dual.png","slug":"set_false_path_a2b_dual.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/set_false_path_a2b_single.png","slug":"set_false_path_a2b_single.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/set_false_path_command.png","slug":"set_false_path_command.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/set_false_path_reset.png","slug":"set_false_path_reset.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/set_false_path_through_command.png","slug":"set_false_path_through_command.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/set_false_path_through_diagram.png","slug":"set_false_path_through_diagram.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_hold_4.png","slug":"set_multicycle_hold_4.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path.png","slug":"set_multicycle_path.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path_4_timing.png","slug":"set_multicycle_path_4_timing.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path_fast2slow.png","slug":"set_multicycle_path_fast2slow.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path_fast2slow_setup_hold_command.png","slug":"set_multicycle_path_fast2slow_setup_hold_command.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path_fast2slow_setup_hold_timing.png","slug":"set_multicycle_path_fast2slow_setup_hold_timing.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path_fast2slow_timing.png","slug":"set_multicycle_path_fast2slow_timing.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path_holdup_adjust.png","slug":"set_multicycle_path_holdup_adjust.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path_holdup_timing.png","slug":"set_multicycle_path_holdup_timing.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path_just_setup.png","slug":"set_multicycle_path_just_setup.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path_just_setup_timing.png","slug":"set_multicycle_path_just_setup_timing.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path_minus_shift.png","slug":"set_multicycle_path_minus_shift.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path_minus_shift_timing.png","slug":"set_multicycle_path_minus_shift_timing.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path_same_clk_timing.png","slug":"set_multicycle_path_same_clk_timing.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path_same_clk_timing2.png","slug":"set_multicycle_path_same_clk_timing2.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path_slow2fast.png","slug":"set_multicycle_path_slow2fast.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path_slow2fast_holdup_command.png","slug":"set_multicycle_path_slow2fast_holdup_command.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path_slow2fast_holdup_timing.png","slug":"set_multicycle_path_slow2fast_holdup_timing.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path_slow2fast_just_setup_command.png","slug":"set_multicycle_path_slow2fast_just_setup_command.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path_slow2fast_just_setup_timing.png","slug":"set_multicycle_path_slow2fast_just_setup_timing.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path_slow2fast_timing.png","slug":"set_multicycle_path_slow2fast_timing.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path_source_destination_clock.png","slug":"set_multicycle_path_source_destination_clock.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path_start_end.png","slug":"set_multicycle_path_start_end.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path_timeshift0.3.png","slug":"set_multicycle_path_timeshift0.3.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_path_timeshift0.3_timing.png","slug":"set_multicycle_path_timeshift0.3_timing.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_setup_timeshift.png","slug":"set_multicycle_setup_timeshift.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/set_multicycle_setup_timeshift_timing.png","slug":"set_multicycle_setup_timeshift_timing.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/set_multicyclye_path_same_clk_command.png","slug":"set_multicyclye_path_same_clk_command.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/set_multicyclye_path_same_clk_command2.png","slug":"set_multicyclye_path_same_clk_command2.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/setup_time.png","slug":"setup_time.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/setup分析data_arrival_time.png","slug":"setup分析data_arrival_time.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/setup分析data_require_time.png","slug":"setup分析data_require_time.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/setup分析setup_slack.png","slug":"setup分析setup_slack.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/single_bit_cdc_diagram.png","slug":"single_bit_cdc_diagram.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/三要素.png","slug":"三要素.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/四种路径.png","slug":"四种路径.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/复位结构.png","slug":"复位结构.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/建立时间计算Setup的裕量.png","slug":"建立时间计算Setup的裕量.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/建立时间计算数据的到达时间.png","slug":"建立时间计算数据的到达时间.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/建立时间计算数据的需求时间.png","slug":"建立时间计算数据的需求时间.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/时序分析.png","slug":"时序分析.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/确定建立时间要求.png","slug":"确定建立时间要求.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0},{"_id":"source/_posts/2024/01/时序约束整理/确定建立时间要求计算.png","slug":"确定建立时间要求计算.png","post":"clru1g22f003ps4fuk3inxtki","modified":0,"renderable":0}],"PostCategory":[{"post_id":"clru1g1zt0007s4fuilzb4ji1","category_id":"clru1g2020009s4fusskta275","_id":"clru1g20f000js4fuj1wdk86j"},{"post_id":"clru1g20a000gs4fukjgw8gmn","category_id":"clru1g2020009s4fusskta275","_id":"clru1g20n000os4fu772bpo3k"},{"post_id":"clru1g1zz0008s4futq2z4rl1","category_id":"clru1g2020009s4fusskta275","_id":"clru1g20r000ts4furck6xr0p"},{"post_id":"clru1g204000bs4futt6zjx5x","category_id":"clru1g20e000is4fu8m7w6byr","_id":"clru1g20v000vs4ful2r75a4r"},{"post_id":"clru1g20m000ns4fu53hv0diq","category_id":"clru1g20e000is4fu8m7w6byr","_id":"clru1g212000zs4fu5xyr8cub"},{"post_id":"clru1g205000cs4fuq737vg42","category_id":"clru1g20o000qs4fubbcbssh7","_id":"clru1g2130013s4fua90w8m3s"},{"post_id":"clru1g206000ds4furzkxg6pl","category_id":"clru1g20w000ws4fun9y4rod1","_id":"clru1g2190019s4fuurwt7tjw"},{"post_id":"clru1g2140016s4fueh5sbcf2","category_id":"clru1g20w000ws4fun9y4rod1","_id":"clru1g21g001fs4fucnpgsacx"},{"post_id":"clru1g2160018s4fuh2gi8y1v","category_id":"clru1g2130014s4fuc3w84hjm","_id":"clru1g21h001hs4fumklh6lwn"},{"post_id":"clru1g20d000hs4fu1jtgir76","category_id":"clru1g2130014s4fuc3w84hjm","_id":"clru1g21i001ls4fu55vg9s8w"},{"post_id":"clru1g219001as4fu1zngclnp","category_id":"clru1g2020009s4fusskta275","_id":"clru1g21j001os4fu1xt5nomt"},{"post_id":"clru1g21f001es4fucozngc0z","category_id":"clru1g2020009s4fusskta275","_id":"clru1g21l001ss4fuq5sgk2qd"},{"post_id":"clru1g20j000ls4fuaql2kexw","category_id":"clru1g21d001bs4fuhd91vark","_id":"clru1g21m001vs4fukp440qas"},{"post_id":"clru1g21g001gs4fubg5x35bg","category_id":"clru1g20w000ws4fun9y4rod1","_id":"clru1g21o0020s4fug3y7km1m"},{"post_id":"clru1g21i001ks4fuecq8g83h","category_id":"clru1g20w000ws4fun9y4rod1","_id":"clru1g21p0023s4fuimya563n"},{"post_id":"clru1g20q000ss4fup0eq2s1f","category_id":"clru1g2130014s4fuc3w84hjm","_id":"clru1g21r0027s4fu4a6rl9h9"},{"post_id":"clru1g21j001ns4fumvse5sfz","category_id":"clru1g2020009s4fusskta275","_id":"clru1g21u002bs4fuauildgjf"},{"post_id":"clru1g20u000us4fup0iw7xda","category_id":"clru1g2130014s4fuc3w84hjm","_id":"clru1g21v002fs4fubfqwt32b"},{"post_id":"clru1g21l001us4fuc513tgh7","category_id":"clru1g2020009s4fusskta275","_id":"clru1g21x002js4fuga1utd2j"},{"post_id":"clru1g21n001zs4fu9pug0u4i","category_id":"clru1g2020009s4fusskta275","_id":"clru1g21y002ns4fuet341h15"},{"post_id":"clru1g211000ys4fuin3pfiq8","category_id":"clru1g2130014s4fuc3w84hjm","_id":"clru1g220002rs4fuhfpsn5cc"},{"post_id":"clru1g21o0022s4fugc4vhpx2","category_id":"clru1g20w000ws4fun9y4rod1","_id":"clru1g221002vs4fuhw5y0m6j"},{"post_id":"clru1g2120011s4fuickg00wo","category_id":"clru1g2130014s4fuc3w84hjm","_id":"clru1g223002zs4fuzjbecv6l"},{"post_id":"clru1g21k001rs4fupgmvlkq6","category_id":"clru1g21u002cs4fu8qnm3d0x","_id":"clru1g2240033s4fusjyi66aj"},{"post_id":"clru1g2270039s4fulr5c5f3a","category_id":"clru1g20w000ws4fun9y4rod1","_id":"clru1g22d003is4fuqjzm8g9s"},{"post_id":"clru1g229003bs4fuf1z176lp","category_id":"clru1g2130014s4fuc3w84hjm","_id":"clru1g22f003ms4furdz7uq2o"},{"post_id":"clru1g22b003fs4fux04bf8tb","category_id":"clru1g20w000ws4fun9y4rod1","_id":"clru1g22g003qs4fuvjk3zvyc"},{"post_id":"clru1g22d003hs4fu2vfcxvib","category_id":"clru1g20w000ws4fun9y4rod1","_id":"clru1g22i003us4fu0zu5cebo"},{"post_id":"clru1g21y002ms4fucr22ff2f","category_id":"clru1g21x002ls4furih9pp87","_id":"clru1g22j003xs4fuph1hf55g"},{"post_id":"clru1g21y002ms4fucr22ff2f","category_id":"clru1g22b003es4fuo8v9rtyu","_id":"clru1g22j0040s4fuk1g4srvh"},{"post_id":"clru1g21q0026s4fuedrkdte0","category_id":"clru1g21x002ls4furih9pp87","_id":"clru1g22k0043s4fup3d9jf82"},{"post_id":"clru1g21q0026s4fuedrkdte0","category_id":"clru1g22b003es4fuo8v9rtyu","_id":"clru1g22l0046s4fu0sub6t2k"},{"post_id":"clru1g21z002qs4fuajeqh8sg","category_id":"clru1g21x002ls4furih9pp87","_id":"clru1g22m0049s4fuzq2dr2o3"},{"post_id":"clru1g21z002qs4fuajeqh8sg","category_id":"clru1g22b003es4fuo8v9rtyu","_id":"clru1g22m004bs4futug07er2"},{"post_id":"clru1g220002us4fu627r0x4y","category_id":"clru1g21x002ls4furih9pp87","_id":"clru1g22o004fs4fudwn8bz6m"},{"post_id":"clru1g220002us4fu627r0x4y","category_id":"clru1g22b003es4fuo8v9rtyu","_id":"clru1g22o004hs4fu5m3vejs5"},{"post_id":"clru1g21t002as4fu67141sob","category_id":"clru1g21x002ls4furih9pp87","_id":"clru1g22q004ls4fuqm5o9093"},{"post_id":"clru1g21t002as4fu67141sob","category_id":"clru1g22b003es4fuo8v9rtyu","_id":"clru1g22q004ns4fuo9e905o0"},{"post_id":"clru1g222002ys4fu67ptqf4d","category_id":"clru1g21x002ls4furih9pp87","_id":"clru1g22s004rs4fuzq2itaeh"},{"post_id":"clru1g222002ys4fu67ptqf4d","category_id":"clru1g22b003es4fuo8v9rtyu","_id":"clru1g22s004ts4fusob8cvv9"},{"post_id":"clru1g2240032s4ful7gth935","category_id":"clru1g22p004is4fumdau8ai0","_id":"clru1g22t004xs4fufvcs0j8l"},{"post_id":"clru1g21u002es4fuvy9zlc3p","category_id":"clru1g21x002ls4furih9pp87","_id":"clru1g22u0050s4fujjacysik"},{"post_id":"clru1g21u002es4fuvy9zlc3p","category_id":"clru1g22b003es4fuo8v9rtyu","_id":"clru1g22v0053s4fupg7a4jgn"},{"post_id":"clru1g2250036s4fuukfseg7s","category_id":"clru1g21x002ls4furih9pp87","_id":"clru1g22v0056s4fu4kunk2r5"},{"post_id":"clru1g2250036s4fuukfseg7s","category_id":"clru1g22b003es4fuo8v9rtyu","_id":"clru1g22w0059s4fujzjgiak7"},{"post_id":"clru1g21w002is4fufa8aksmk","category_id":"clru1g21x002ls4furih9pp87","_id":"clru1g22w005bs4fu84gz1a5s"},{"post_id":"clru1g21w002is4fufa8aksmk","category_id":"clru1g22b003es4fuo8v9rtyu","_id":"clru1g22w005es4fuum87hyns"},{"post_id":"clru1g22e003ls4fuhswam8de","category_id":"clru1g22v0055s4fur29a95rc","_id":"clru1g22y005js4fukfk1m071"},{"post_id":"clru1g22f003ps4fuk3inxtki","category_id":"clru1g22v0055s4fur29a95rc","_id":"clru1g22z005ns4fuc418gdnw"},{"post_id":"clru1g22h003ts4fu1adr4utt","category_id":"clru1g22v0055s4fur29a95rc","_id":"clru1g231005rs4fu4kn796l4"}],"PostTag":[{"post_id":"clru1g1zt0007s4fuilzb4ji1","tag_id":"clru1g204000as4fulrvsq3nn","_id":"clru1g20k000ms4fuc61ly8ei"},{"post_id":"clru1g1zt0007s4fuilzb4ji1","tag_id":"clru1g208000fs4fu2uy1muir","_id":"clru1g20n000ps4fuudyscrlo"},{"post_id":"clru1g1zz0008s4futq2z4rl1","tag_id":"clru1g204000as4fulrvsq3nn","_id":"clru1g2120010s4fu2x9itkux"},{"post_id":"clru1g1zz0008s4futq2z4rl1","tag_id":"clru1g20o000rs4fum5cgj2xd","_id":"clru1g2130012s4fu0844hd9z"},{"post_id":"clru1g204000bs4futt6zjx5x","tag_id":"clru1g20w000xs4fuiygmfmv0","_id":"clru1g2160017s4fu4obl15c7"},{"post_id":"clru1g205000cs4fuq737vg42","tag_id":"clru1g2130015s4fub6d8g3z8","_id":"clru1g21e001ds4fuomay198p"},{"post_id":"clru1g206000ds4furzkxg6pl","tag_id":"clru1g21d001cs4fu9h2y06fj","_id":"clru1g21i001ms4fu5gqv2yl5"},{"post_id":"clru1g20a000gs4fukjgw8gmn","tag_id":"clru1g204000as4fulrvsq3nn","_id":"clru1g21l001ts4fulmvs90w8"},{"post_id":"clru1g20a000gs4fukjgw8gmn","tag_id":"clru1g21h001js4fuhywk71sv","_id":"clru1g21m001xs4fuyj2y9tdx"},{"post_id":"clru1g21j001ns4fumvse5sfz","tag_id":"clru1g204000as4fulrvsq3nn","_id":"clru1g21o0021s4fujpkg0tb1"},{"post_id":"clru1g20d000hs4fu1jtgir76","tag_id":"clru1g21k001qs4fu9fgm6gyw","_id":"clru1g21p0025s4fulr6jkxya"},{"post_id":"clru1g21n001zs4fu9pug0u4i","tag_id":"clru1g204000as4fulrvsq3nn","_id":"clru1g21s0029s4fuw6ozb5tf"},{"post_id":"clru1g21o0022s4fugc4vhpx2","tag_id":"clru1g21d001cs4fu9h2y06fj","_id":"clru1g21u002ds4fu95hz30rb"},{"post_id":"clru1g20j000ls4fuaql2kexw","tag_id":"clru1g21n001ys4fuk4rsg8m4","_id":"clru1g21w002hs4fu4zejsjj7"},{"post_id":"clru1g21q0026s4fuedrkdte0","tag_id":"clru1g204000as4fulrvsq3nn","_id":"clru1g21x002ks4fumvo9sk7s"},{"post_id":"clru1g21q0026s4fuedrkdte0","tag_id":"clru1g208000fs4fu2uy1muir","_id":"clru1g21z002ps4fuf33f7hi1"},{"post_id":"clru1g21t002as4fu67141sob","tag_id":"clru1g204000as4fulrvsq3nn","_id":"clru1g220002ss4fu09er32vz"},{"post_id":"clru1g21t002as4fu67141sob","tag_id":"clru1g208000fs4fu2uy1muir","_id":"clru1g222002ws4fukzfzoat4"},{"post_id":"clru1g20m000ns4fu53hv0diq","tag_id":"clru1g20w000xs4fuiygmfmv0","_id":"clru1g2230030s4ful7x1el1w"},{"post_id":"clru1g21u002es4fuvy9zlc3p","tag_id":"clru1g204000as4fulrvsq3nn","_id":"clru1g2250034s4fu30mdoqyx"},{"post_id":"clru1g21u002es4fuvy9zlc3p","tag_id":"clru1g208000fs4fu2uy1muir","_id":"clru1g2260037s4funltxdapx"},{"post_id":"clru1g21w002is4fufa8aksmk","tag_id":"clru1g204000as4fulrvsq3nn","_id":"clru1g229003as4fu6otyw1us"},{"post_id":"clru1g21w002is4fufa8aksmk","tag_id":"clru1g208000fs4fu2uy1muir","_id":"clru1g22b003ds4fuy6zjl2c9"},{"post_id":"clru1g20q000ss4fup0eq2s1f","tag_id":"clru1g21v002gs4futi6zaopw","_id":"clru1g22c003gs4fueb18zs8q"},{"post_id":"clru1g21y002ms4fucr22ff2f","tag_id":"clru1g204000as4fulrvsq3nn","_id":"clru1g22e003ks4fufohbodcd"},{"post_id":"clru1g21y002ms4fucr22ff2f","tag_id":"clru1g208000fs4fu2uy1muir","_id":"clru1g22f003os4funo6hetx7"},{"post_id":"clru1g21z002qs4fuajeqh8sg","tag_id":"clru1g204000as4fulrvsq3nn","_id":"clru1g22h003ss4fu1kglsuas"},{"post_id":"clru1g21z002qs4fuajeqh8sg","tag_id":"clru1g208000fs4fu2uy1muir","_id":"clru1g22i003ws4fujivwb8xi"},{"post_id":"clru1g20u000us4fup0iw7xda","tag_id":"clru1g21z002os4fu3nn9rpeo","_id":"clru1g22j003ys4fueazwdsw9"},{"post_id":"clru1g220002us4fu627r0x4y","tag_id":"clru1g204000as4fulrvsq3nn","_id":"clru1g22k0042s4fu5mrqsudi"},{"post_id":"clru1g220002us4fu627r0x4y","tag_id":"clru1g208000fs4fu2uy1muir","_id":"clru1g22k0044s4fu7muxi9m8"},{"post_id":"clru1g222002ys4fu67ptqf4d","tag_id":"clru1g204000as4fulrvsq3nn","_id":"clru1g22m0048s4fueazh3r6k"},{"post_id":"clru1g222002ys4fu67ptqf4d","tag_id":"clru1g208000fs4fu2uy1muir","_id":"clru1g22m004as4fuxuhp63ou"},{"post_id":"clru1g211000ys4fuin3pfiq8","tag_id":"clru1g222002xs4fuitw7wnay","_id":"clru1g22n004es4fu5ddkn0we"},{"post_id":"clru1g2250036s4fuukfseg7s","tag_id":"clru1g204000as4fulrvsq3nn","_id":"clru1g22o004gs4fuej4mhn4y"},{"post_id":"clru1g2250036s4fuukfseg7s","tag_id":"clru1g208000fs4fu2uy1muir","_id":"clru1g22q004ks4fup7nvpfkf"},{"post_id":"clru1g2120011s4fuickg00wo","tag_id":"clru1g2250035s4ful4ay9sv0","_id":"clru1g22q004ms4fuvt6voags"},{"post_id":"clru1g22b003fs4fux04bf8tb","tag_id":"clru1g21d001cs4fu9h2y06fj","_id":"clru1g22r004qs4fujtuo980l"},{"post_id":"clru1g2140016s4fueh5sbcf2","tag_id":"clru1g21d001cs4fu9h2y06fj","_id":"clru1g22s004ss4fua7muskzz"},{"post_id":"clru1g2160018s4fuh2gi8y1v","tag_id":"clru1g22d003js4fuz8gqraj2","_id":"clru1g22s004vs4fux6buq0c0"},{"post_id":"clru1g219001as4fu1zngclnp","tag_id":"clru1g22g003rs4fusufpsuih","_id":"clru1g22t004ys4fu6ahonnxu"},{"post_id":"clru1g219001as4fu1zngclnp","tag_id":"clru1g204000as4fulrvsq3nn","_id":"clru1g22u0051s4fu3nyfli6e"},{"post_id":"clru1g21f001es4fucozngc0z","tag_id":"clru1g22j003zs4fupspdovop","_id":"clru1g22v0054s4fuqvamt56b"},{"post_id":"clru1g21f001es4fucozngc0z","tag_id":"clru1g204000as4fulrvsq3nn","_id":"clru1g22v0057s4fusovi0uh1"},{"post_id":"clru1g21g001gs4fubg5x35bg","tag_id":"clru1g22k0045s4fuxtxy7nul","_id":"clru1g22w005as4fujttwzzyb"},{"post_id":"clru1g21i001ks4fuecq8g83h","tag_id":"clru1g21n001ys4fuk4rsg8m4","_id":"clru1g22w005cs4fu9p0t08pd"},{"post_id":"clru1g21k001rs4fupgmvlkq6","tag_id":"clru1g22p004js4fu3xde0wc2","_id":"clru1g22x005gs4fu1mkino85"},{"post_id":"clru1g21l001us4fuc513tgh7","tag_id":"clru1g22r004ps4fuoumpumps","_id":"clru1g22x005hs4fugkqynhin"},{"post_id":"clru1g21l001us4fuc513tgh7","tag_id":"clru1g204000as4fulrvsq3nn","_id":"clru1g22y005ls4furdm3jtgj"},{"post_id":"clru1g2240032s4ful7gth935","tag_id":"clru1g22t004ws4fuu9fgxp7l","_id":"clru1g22z005ms4fu1c7r4n6v"},{"post_id":"clru1g2270039s4fulr5c5f3a","tag_id":"clru1g22u0052s4fuqt0i9g22","_id":"clru1g22z005os4fu1x6lymf4"},{"post_id":"clru1g229003bs4fuf1z176lp","tag_id":"clru1g22v0058s4ful2nmwiny","_id":"clru1g230005qs4fu8gf6ivnd"},{"post_id":"clru1g22d003hs4fu2vfcxvib","tag_id":"clru1g22u0052s4fuqt0i9g22","_id":"clru1g231005ss4fudkbpinoa"},{"post_id":"clru1g22e003ls4fuhswam8de","tag_id":"clru1g22y005ks4fudbxnet19","_id":"clru1g232005us4fu7ab7of88"},{"post_id":"clru1g22f003ps4fuk3inxtki","tag_id":"clru1g22y005ks4fudbxnet19","_id":"clru1g232005vs4fugnifb8gv"},{"post_id":"clru1g22h003ts4fu1adr4utt","tag_id":"clru1g22y005ks4fudbxnet19","_id":"clru1g232005ws4fuaoh3tbus"}],"Tag":[{"name":"linux","_id":"clru1g204000as4fulrvsq3nn"},{"name":"process","_id":"clru1g208000fs4fu2uy1muir"},{"name":"input","_id":"clru1g20o000rs4fum5cgj2xd"},{"name":"python","_id":"clru1g20w000xs4fuiygmfmv0"},{"name":"history","_id":"clru1g2130015s4fub6d8g3z8"},{"name":"Embedded system","_id":"clru1g21d001cs4fu9h2y06fj"},{"name":"imx6ull","_id":"clru1g21h001js4fuhywk71sv"},{"name":"gallery-腾格里","_id":"clru1g21k001qs4fu9fgm6gyw"},{"name":"EMC-EMI","_id":"clru1g21n001ys4fuk4rsg8m4"},{"name":"gallery-上海","_id":"clru1g21v002gs4futi6zaopw"},{"name":"gallery-北京","_id":"clru1g21z002os4fu3nn9rpeo"},{"name":"gallery-新疆","_id":"clru1g222002xs4fuitw7wnay"},{"name":"gallery-衡山","_id":"clru1g2250035s4ful4ay9sv0"},{"name":"gallery-深圳梧桐山-毛棉杜鹃","_id":"clru1g22d003js4fuz8gqraj2"},{"name":"PIN GPIO","_id":"clru1g22g003rs4fusufpsuih"},{"name":"tool目录","_id":"clru1g22j003zs4fupspdovop"},{"name":"模块","_id":"clru1g22k0045s4fuxtxy7nul"},{"name":"study","_id":"clru1g22p004js4fu3xde0wc2"},{"name":"platform","_id":"clru1g22r004ps4fuoumpumps"},{"name":"编译原理","_id":"clru1g22t004ws4fuu9fgxp7l"},{"name":"医疗器械软件","_id":"clru1g22u0052s4fuqt0i9g22"},{"name":"gallery-日落","_id":"clru1g22v0058s4ful2nmwiny"},{"name":"FPGA","_id":"clru1g22y005ks4fudbxnet19"}]}}